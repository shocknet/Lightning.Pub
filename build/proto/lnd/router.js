"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = exports.UpdateChanStatusResponse = exports.UpdateChanStatusRequest = exports.ForwardHtlcInterceptResponse = exports.ForwardHtlcInterceptRequest = exports.CircuitKey = exports.PaymentStatus = exports.LinkFailEvent = exports.SettleEvent = exports.ForwardFailEvent = exports.ForwardEvent = exports.HtlcInfo = exports.HtlcEvent = exports.SubscribeHtlcEventsRequest = exports.BuildRouteResponse = exports.BuildRouteRequest = exports.QueryProbabilityResponse = exports.QueryProbabilityRequest = exports.MissionControlConfig = exports.SetMissionControlConfigResponse = exports.SetMissionControlConfigRequest = exports.GetMissionControlConfigResponse = exports.GetMissionControlConfigRequest = exports.PairData = exports.PairHistory = exports.XImportMissionControlResponse = exports.XImportMissionControlRequest = exports.QueryMissionControlResponse = exports.QueryMissionControlRequest = exports.ResetMissionControlResponse = exports.ResetMissionControlRequest = exports.SendToRouteResponse = exports.SendToRouteRequest = exports.RouteFeeResponse = exports.RouteFeeRequest = exports.TrackPaymentRequest = exports.SendPaymentRequest = exports.ChanStatusAction = exports.ResolveHoldForwardAction = exports.PaymentState = exports.FailureDetail = exports.HtlcEvent_EventType = void 0;
// @generated by protobuf-ts 2.5.0 with parameter long_type_string
// @generated from protobuf file "router.proto" (package "routerrpc", syntax proto3)
// tslint:disable
const rpc_1 = require("./rpc");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const rpc_2 = require("./rpc");
const rpc_3 = require("./rpc");
const rpc_4 = require("./rpc");
const rpc_5 = require("./rpc");
const rpc_6 = require("./rpc");
const rpc_7 = require("./rpc");
const rpc_8 = require("./rpc");
/**
 * @generated from protobuf enum routerrpc.HtlcEvent.EventType
 */
var HtlcEvent_EventType;
(function (HtlcEvent_EventType) {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * @generated from protobuf enum value: SEND = 1;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["SEND"] = 1] = "SEND";
    /**
     * @generated from protobuf enum value: RECEIVE = 2;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["RECEIVE"] = 2] = "RECEIVE";
    /**
     * @generated from protobuf enum value: FORWARD = 3;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["FORWARD"] = 3] = "FORWARD";
})(HtlcEvent_EventType = exports.HtlcEvent_EventType || (exports.HtlcEvent_EventType = {}));
/**
 * @generated from protobuf enum routerrpc.FailureDetail
 */
var FailureDetail;
(function (FailureDetail) {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    FailureDetail[FailureDetail["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * @generated from protobuf enum value: NO_DETAIL = 1;
     */
    FailureDetail[FailureDetail["NO_DETAIL"] = 1] = "NO_DETAIL";
    /**
     * @generated from protobuf enum value: ONION_DECODE = 2;
     */
    FailureDetail[FailureDetail["ONION_DECODE"] = 2] = "ONION_DECODE";
    /**
     * @generated from protobuf enum value: LINK_NOT_ELIGIBLE = 3;
     */
    FailureDetail[FailureDetail["LINK_NOT_ELIGIBLE"] = 3] = "LINK_NOT_ELIGIBLE";
    /**
     * @generated from protobuf enum value: ON_CHAIN_TIMEOUT = 4;
     */
    FailureDetail[FailureDetail["ON_CHAIN_TIMEOUT"] = 4] = "ON_CHAIN_TIMEOUT";
    /**
     * @generated from protobuf enum value: HTLC_EXCEEDS_MAX = 5;
     */
    FailureDetail[FailureDetail["HTLC_EXCEEDS_MAX"] = 5] = "HTLC_EXCEEDS_MAX";
    /**
     * @generated from protobuf enum value: INSUFFICIENT_BALANCE = 6;
     */
    FailureDetail[FailureDetail["INSUFFICIENT_BALANCE"] = 6] = "INSUFFICIENT_BALANCE";
    /**
     * @generated from protobuf enum value: INCOMPLETE_FORWARD = 7;
     */
    FailureDetail[FailureDetail["INCOMPLETE_FORWARD"] = 7] = "INCOMPLETE_FORWARD";
    /**
     * @generated from protobuf enum value: HTLC_ADD_FAILED = 8;
     */
    FailureDetail[FailureDetail["HTLC_ADD_FAILED"] = 8] = "HTLC_ADD_FAILED";
    /**
     * @generated from protobuf enum value: FORWARDS_DISABLED = 9;
     */
    FailureDetail[FailureDetail["FORWARDS_DISABLED"] = 9] = "FORWARDS_DISABLED";
    /**
     * @generated from protobuf enum value: INVOICE_CANCELED = 10;
     */
    FailureDetail[FailureDetail["INVOICE_CANCELED"] = 10] = "INVOICE_CANCELED";
    /**
     * @generated from protobuf enum value: INVOICE_UNDERPAID = 11;
     */
    FailureDetail[FailureDetail["INVOICE_UNDERPAID"] = 11] = "INVOICE_UNDERPAID";
    /**
     * @generated from protobuf enum value: INVOICE_EXPIRY_TOO_SOON = 12;
     */
    FailureDetail[FailureDetail["INVOICE_EXPIRY_TOO_SOON"] = 12] = "INVOICE_EXPIRY_TOO_SOON";
    /**
     * @generated from protobuf enum value: INVOICE_NOT_OPEN = 13;
     */
    FailureDetail[FailureDetail["INVOICE_NOT_OPEN"] = 13] = "INVOICE_NOT_OPEN";
    /**
     * @generated from protobuf enum value: MPP_INVOICE_TIMEOUT = 14;
     */
    FailureDetail[FailureDetail["MPP_INVOICE_TIMEOUT"] = 14] = "MPP_INVOICE_TIMEOUT";
    /**
     * @generated from protobuf enum value: ADDRESS_MISMATCH = 15;
     */
    FailureDetail[FailureDetail["ADDRESS_MISMATCH"] = 15] = "ADDRESS_MISMATCH";
    /**
     * @generated from protobuf enum value: SET_TOTAL_MISMATCH = 16;
     */
    FailureDetail[FailureDetail["SET_TOTAL_MISMATCH"] = 16] = "SET_TOTAL_MISMATCH";
    /**
     * @generated from protobuf enum value: SET_TOTAL_TOO_LOW = 17;
     */
    FailureDetail[FailureDetail["SET_TOTAL_TOO_LOW"] = 17] = "SET_TOTAL_TOO_LOW";
    /**
     * @generated from protobuf enum value: SET_OVERPAID = 18;
     */
    FailureDetail[FailureDetail["SET_OVERPAID"] = 18] = "SET_OVERPAID";
    /**
     * @generated from protobuf enum value: UNKNOWN_INVOICE = 19;
     */
    FailureDetail[FailureDetail["UNKNOWN_INVOICE"] = 19] = "UNKNOWN_INVOICE";
    /**
     * @generated from protobuf enum value: INVALID_KEYSEND = 20;
     */
    FailureDetail[FailureDetail["INVALID_KEYSEND"] = 20] = "INVALID_KEYSEND";
    /**
     * @generated from protobuf enum value: MPP_IN_PROGRESS = 21;
     */
    FailureDetail[FailureDetail["MPP_IN_PROGRESS"] = 21] = "MPP_IN_PROGRESS";
    /**
     * @generated from protobuf enum value: CIRCULAR_ROUTE = 22;
     */
    FailureDetail[FailureDetail["CIRCULAR_ROUTE"] = 22] = "CIRCULAR_ROUTE";
})(FailureDetail = exports.FailureDetail || (exports.FailureDetail = {}));
/**
 * @generated from protobuf enum routerrpc.PaymentState
 */
var PaymentState;
(function (PaymentState) {
    /**
     *
     * Payment is still in flight.
     *
     * @generated from protobuf enum value: IN_FLIGHT = 0;
     */
    PaymentState[PaymentState["IN_FLIGHT"] = 0] = "IN_FLIGHT";
    /**
     *
     * Payment completed successfully.
     *
     * @generated from protobuf enum value: SUCCEEDED = 1;
     */
    PaymentState[PaymentState["SUCCEEDED"] = 1] = "SUCCEEDED";
    /**
     *
     * There are more routes to try, but the payment timeout was exceeded.
     *
     * @generated from protobuf enum value: FAILED_TIMEOUT = 2;
     */
    PaymentState[PaymentState["FAILED_TIMEOUT"] = 2] = "FAILED_TIMEOUT";
    /**
     *
     * All possible routes were tried and failed permanently. Or were no
     * routes to the destination at all.
     *
     * @generated from protobuf enum value: FAILED_NO_ROUTE = 3;
     */
    PaymentState[PaymentState["FAILED_NO_ROUTE"] = 3] = "FAILED_NO_ROUTE";
    /**
     *
     * A non-recoverable error has occured.
     *
     * @generated from protobuf enum value: FAILED_ERROR = 4;
     */
    PaymentState[PaymentState["FAILED_ERROR"] = 4] = "FAILED_ERROR";
    /**
     *
     * Payment details incorrect (unknown hash, invalid amt or
     * invalid final cltv delta)
     *
     * @generated from protobuf enum value: FAILED_INCORRECT_PAYMENT_DETAILS = 5;
     */
    PaymentState[PaymentState["FAILED_INCORRECT_PAYMENT_DETAILS"] = 5] = "FAILED_INCORRECT_PAYMENT_DETAILS";
    /**
     *
     * Insufficient local balance.
     *
     * @generated from protobuf enum value: FAILED_INSUFFICIENT_BALANCE = 6;
     */
    PaymentState[PaymentState["FAILED_INSUFFICIENT_BALANCE"] = 6] = "FAILED_INSUFFICIENT_BALANCE";
})(PaymentState = exports.PaymentState || (exports.PaymentState = {}));
/**
 * @generated from protobuf enum routerrpc.ResolveHoldForwardAction
 */
var ResolveHoldForwardAction;
(function (ResolveHoldForwardAction) {
    /**
     * @generated from protobuf enum value: SETTLE = 0;
     */
    ResolveHoldForwardAction[ResolveHoldForwardAction["SETTLE"] = 0] = "SETTLE";
    /**
     * @generated from protobuf enum value: FAIL = 1;
     */
    ResolveHoldForwardAction[ResolveHoldForwardAction["FAIL"] = 1] = "FAIL";
    /**
     * @generated from protobuf enum value: RESUME = 2;
     */
    ResolveHoldForwardAction[ResolveHoldForwardAction["RESUME"] = 2] = "RESUME";
})(ResolveHoldForwardAction = exports.ResolveHoldForwardAction || (exports.ResolveHoldForwardAction = {}));
/**
 * @generated from protobuf enum routerrpc.ChanStatusAction
 */
var ChanStatusAction;
(function (ChanStatusAction) {
    /**
     * @generated from protobuf enum value: ENABLE = 0;
     */
    ChanStatusAction[ChanStatusAction["ENABLE"] = 0] = "ENABLE";
    /**
     * @generated from protobuf enum value: DISABLE = 1;
     */
    ChanStatusAction[ChanStatusAction["DISABLE"] = 1] = "DISABLE";
    /**
     * @generated from protobuf enum value: AUTO = 2;
     */
    ChanStatusAction[ChanStatusAction["AUTO"] = 2] = "AUTO";
})(ChanStatusAction = exports.ChanStatusAction || (exports.ChanStatusAction = {}));
// @generated message type with reflection information, may provide speed optimized methods
class SendPaymentRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SendPaymentRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "amt", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 12, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "timeout_seconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "fee_limit_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 13, name: "fee_limit_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 19, name: "outgoing_chan_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ },
            { no: 14, name: "last_hop_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "cltv_limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "route_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => rpc_8.RouteHint },
            { no: 11, name: "dest_custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 15, name: "allow_self_payment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "dest_features", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["lnrpc.FeatureBit", rpc_7.FeatureBit] },
            { no: 17, name: "max_parts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "max_shard_size_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 22, name: "amp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { dest: new Uint8Array(0), amt: "0", amtMsat: "0", paymentHash: new Uint8Array(0), finalCltvDelta: 0, paymentAddr: new Uint8Array(0), paymentRequest: "", timeoutSeconds: 0, feeLimitSat: "0", feeLimitMsat: "0", outgoingChanId: "0", outgoingChanIds: [], lastHopPubkey: new Uint8Array(0), cltvLimit: 0, routeHints: [], destCustomRecords: {}, allowSelfPayment: false, destFeatures: [], maxParts: 0, noInflightUpdates: false, maxShardSizeMsat: "0", amp: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* int64 amt */ 2:
                    message.amt = reader.int64().toString();
                    break;
                case /* int64 amt_msat */ 12:
                    message.amtMsat = reader.int64().toString();
                    break;
                case /* bytes payment_hash */ 3:
                    message.paymentHash = reader.bytes();
                    break;
                case /* int32 final_cltv_delta */ 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* bytes payment_addr */ 20:
                    message.paymentAddr = reader.bytes();
                    break;
                case /* string payment_request */ 5:
                    message.paymentRequest = reader.string();
                    break;
                case /* int32 timeout_seconds */ 6:
                    message.timeoutSeconds = reader.int32();
                    break;
                case /* int64 fee_limit_sat */ 7:
                    message.feeLimitSat = reader.int64().toString();
                    break;
                case /* int64 fee_limit_msat */ 13:
                    message.feeLimitMsat = reader.int64().toString();
                    break;
                case /* uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING];*/ 8:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* repeated uint64 outgoing_chan_ids */ 19:
                    if (wireType === runtime_2.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.outgoingChanIds.push(reader.uint64().toString());
                    else
                        message.outgoingChanIds.push(reader.uint64().toString());
                    break;
                case /* bytes last_hop_pubkey */ 14:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case /* int32 cltv_limit */ 9:
                    message.cltvLimit = reader.int32();
                    break;
                case /* repeated lnrpc.RouteHint route_hints */ 10:
                    message.routeHints.push(rpc_8.RouteHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint64, bytes> dest_custom_records */ 11:
                    this.binaryReadMap11(message.destCustomRecords, reader, options);
                    break;
                case /* bool allow_self_payment */ 15:
                    message.allowSelfPayment = reader.bool();
                    break;
                case /* repeated lnrpc.FeatureBit dest_features */ 16:
                    if (wireType === runtime_2.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.destFeatures.push(reader.int32());
                    else
                        message.destFeatures.push(reader.int32());
                    break;
                case /* uint32 max_parts */ 17:
                    message.maxParts = reader.uint32();
                    break;
                case /* bool no_inflight_updates */ 18:
                    message.noInflightUpdates = reader.bool();
                    break;
                case /* uint64 max_shard_size_msat */ 21:
                    message.maxShardSizeMsat = reader.uint64().toString();
                    break;
                case /* bool amp */ 22:
                    message.amp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap11(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field routerrpc.SendPaymentRequest.dest_custom_records");
            }
        }
        map[key !== null && key !== void 0 ? key : "0"] = val !== null && val !== void 0 ? val : new Uint8Array(0);
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.dest);
        /* int64 amt = 2; */
        if (message.amt !== "0")
            writer.tag(2, runtime_2.WireType.Varint).int64(message.amt);
        /* int64 amt_msat = 12; */
        if (message.amtMsat !== "0")
            writer.tag(12, runtime_2.WireType.Varint).int64(message.amtMsat);
        /* bytes payment_hash = 3; */
        if (message.paymentHash.length)
            writer.tag(3, runtime_2.WireType.LengthDelimited).bytes(message.paymentHash);
        /* int32 final_cltv_delta = 4; */
        if (message.finalCltvDelta !== 0)
            writer.tag(4, runtime_2.WireType.Varint).int32(message.finalCltvDelta);
        /* bytes payment_addr = 20; */
        if (message.paymentAddr.length)
            writer.tag(20, runtime_2.WireType.LengthDelimited).bytes(message.paymentAddr);
        /* string payment_request = 5; */
        if (message.paymentRequest !== "")
            writer.tag(5, runtime_2.WireType.LengthDelimited).string(message.paymentRequest);
        /* int32 timeout_seconds = 6; */
        if (message.timeoutSeconds !== 0)
            writer.tag(6, runtime_2.WireType.Varint).int32(message.timeoutSeconds);
        /* int64 fee_limit_sat = 7; */
        if (message.feeLimitSat !== "0")
            writer.tag(7, runtime_2.WireType.Varint).int64(message.feeLimitSat);
        /* int64 fee_limit_msat = 13; */
        if (message.feeLimitMsat !== "0")
            writer.tag(13, runtime_2.WireType.Varint).int64(message.feeLimitMsat);
        /* uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(8, runtime_2.WireType.Varint).uint64(message.outgoingChanId);
        /* repeated uint64 outgoing_chan_ids = 19; */
        if (message.outgoingChanIds.length) {
            writer.tag(19, runtime_2.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.outgoingChanIds.length; i++)
                writer.uint64(message.outgoingChanIds[i]);
            writer.join();
        }
        /* bytes last_hop_pubkey = 14; */
        if (message.lastHopPubkey.length)
            writer.tag(14, runtime_2.WireType.LengthDelimited).bytes(message.lastHopPubkey);
        /* int32 cltv_limit = 9; */
        if (message.cltvLimit !== 0)
            writer.tag(9, runtime_2.WireType.Varint).int32(message.cltvLimit);
        /* repeated lnrpc.RouteHint route_hints = 10; */
        for (let i = 0; i < message.routeHints.length; i++)
            rpc_8.RouteHint.internalBinaryWrite(message.routeHints[i], writer.tag(10, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* map<uint64, bytes> dest_custom_records = 11; */
        for (let k of Object.keys(message.destCustomRecords))
            writer.tag(11, runtime_2.WireType.LengthDelimited).fork().tag(1, runtime_2.WireType.Varint).uint64(k).tag(2, runtime_2.WireType.LengthDelimited).bytes(message.destCustomRecords[k]).join();
        /* bool allow_self_payment = 15; */
        if (message.allowSelfPayment !== false)
            writer.tag(15, runtime_2.WireType.Varint).bool(message.allowSelfPayment);
        /* repeated lnrpc.FeatureBit dest_features = 16; */
        if (message.destFeatures.length) {
            writer.tag(16, runtime_2.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.destFeatures.length; i++)
                writer.int32(message.destFeatures[i]);
            writer.join();
        }
        /* uint32 max_parts = 17; */
        if (message.maxParts !== 0)
            writer.tag(17, runtime_2.WireType.Varint).uint32(message.maxParts);
        /* bool no_inflight_updates = 18; */
        if (message.noInflightUpdates !== false)
            writer.tag(18, runtime_2.WireType.Varint).bool(message.noInflightUpdates);
        /* uint64 max_shard_size_msat = 21; */
        if (message.maxShardSizeMsat !== "0")
            writer.tag(21, runtime_2.WireType.Varint).uint64(message.maxShardSizeMsat);
        /* bool amp = 22; */
        if (message.amp !== false)
            writer.tag(22, runtime_2.WireType.Varint).bool(message.amp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendPaymentRequest
 */
exports.SendPaymentRequest = new SendPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPaymentRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.TrackPaymentRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { paymentHash: new Uint8Array(0), noInflightUpdates: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* bool no_inflight_updates */ 2:
                    message.noInflightUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.paymentHash);
        /* bool no_inflight_updates = 2; */
        if (message.noInflightUpdates !== false)
            writer.tag(2, runtime_2.WireType.Varint).bool(message.noInflightUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentRequest
 */
exports.TrackPaymentRequest = new TrackPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteFeeRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.RouteFeeRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = { dest: new Uint8Array(0), amtSat: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* int64 amt_sat */ 2:
                    message.amtSat = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.dest);
        /* int64 amt_sat = 2; */
        if (message.amtSat !== "0")
            writer.tag(2, runtime_2.WireType.Varint).int64(message.amtSat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeRequest
 */
exports.RouteFeeRequest = new RouteFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteFeeResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.RouteFeeResponse", [
            { no: 1, name: "routing_fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "time_lock_delay", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = { routingFeeMsat: "0", timeLockDelay: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 routing_fee_msat */ 1:
                    message.routingFeeMsat = reader.int64().toString();
                    break;
                case /* int64 time_lock_delay */ 2:
                    message.timeLockDelay = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 routing_fee_msat = 1; */
        if (message.routingFeeMsat !== "0")
            writer.tag(1, runtime_2.WireType.Varint).int64(message.routingFeeMsat);
        /* int64 time_lock_delay = 2; */
        if (message.timeLockDelay !== "0")
            writer.tag(2, runtime_2.WireType.Varint).int64(message.timeLockDelay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeResponse
 */
exports.RouteFeeResponse = new RouteFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SendToRouteRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "route", kind: "message", T: () => rpc_6.Route }
        ]);
    }
    create(value) {
        const message = { paymentHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* lnrpc.Route route */ 2:
                    message.route = rpc_6.Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.paymentHash);
        /* lnrpc.Route route = 2; */
        if (message.route)
            rpc_6.Route.internalBinaryWrite(message.route, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteRequest
 */
exports.SendToRouteRequest = new SendToRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SendToRouteResponse", [
            { no: 1, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "failure", kind: "message", T: () => rpc_5.Failure }
        ]);
    }
    create(value) {
        const message = { preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes preimage */ 1:
                    message.preimage = reader.bytes();
                    break;
                case /* lnrpc.Failure failure */ 2:
                    message.failure = rpc_5.Failure.internalBinaryRead(reader, reader.uint32(), options, message.failure);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes preimage = 1; */
        if (message.preimage.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.preimage);
        /* lnrpc.Failure failure = 2; */
        if (message.failure)
            rpc_5.Failure.internalBinaryWrite(message.failure, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteResponse
 */
exports.SendToRouteResponse = new SendToRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetMissionControlRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.ResetMissionControlRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlRequest
 */
exports.ResetMissionControlRequest = new ResetMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetMissionControlResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.ResetMissionControlResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlResponse
 */
exports.ResetMissionControlResponse = new ResetMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMissionControlRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.QueryMissionControlRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlRequest
 */
exports.QueryMissionControlRequest = new QueryMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMissionControlResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.QueryMissionControlResponse", [
            { no: 2, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.PairHistory }
        ]);
    }
    create(value) {
        const message = { pairs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routerrpc.PairHistory pairs */ 2:
                    message.pairs.push(exports.PairHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated routerrpc.PairHistory pairs = 2; */
        for (let i = 0; i < message.pairs.length; i++)
            exports.PairHistory.internalBinaryWrite(message.pairs[i], writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlResponse
 */
exports.QueryMissionControlResponse = new QueryMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XImportMissionControlRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.XImportMissionControlRequest", [
            { no: 1, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.PairHistory }
        ]);
    }
    create(value) {
        const message = { pairs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routerrpc.PairHistory pairs */ 1:
                    message.pairs.push(exports.PairHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated routerrpc.PairHistory pairs = 1; */
        for (let i = 0; i < message.pairs.length; i++)
            exports.PairHistory.internalBinaryWrite(message.pairs[i], writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlRequest
 */
exports.XImportMissionControlRequest = new XImportMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XImportMissionControlResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.XImportMissionControlResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlResponse
 */
exports.XImportMissionControlResponse = new XImportMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PairHistory$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.PairHistory", [
            { no: 1, name: "node_from", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "node_to", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "history", kind: "message", T: () => exports.PairData }
        ]);
    }
    create(value) {
        const message = { nodeFrom: new Uint8Array(0), nodeTo: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes node_from */ 1:
                    message.nodeFrom = reader.bytes();
                    break;
                case /* bytes node_to */ 2:
                    message.nodeTo = reader.bytes();
                    break;
                case /* routerrpc.PairData history */ 7:
                    message.history = exports.PairData.internalBinaryRead(reader, reader.uint32(), options, message.history);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes node_from = 1; */
        if (message.nodeFrom.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.nodeFrom);
        /* bytes node_to = 2; */
        if (message.nodeTo.length)
            writer.tag(2, runtime_2.WireType.LengthDelimited).bytes(message.nodeTo);
        /* routerrpc.PairData history = 7; */
        if (message.history)
            exports.PairData.internalBinaryWrite(message.history, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PairHistory
 */
exports.PairHistory = new PairHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PairData$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.PairData", [
            { no: 1, name: "fail_time", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "fail_amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "fail_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "success_time", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "success_amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "success_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = { failTime: "0", failAmtSat: "0", failAmtMsat: "0", successTime: "0", successAmtSat: "0", successAmtMsat: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 fail_time */ 1:
                    message.failTime = reader.int64().toString();
                    break;
                case /* int64 fail_amt_sat */ 2:
                    message.failAmtSat = reader.int64().toString();
                    break;
                case /* int64 fail_amt_msat */ 4:
                    message.failAmtMsat = reader.int64().toString();
                    break;
                case /* int64 success_time */ 5:
                    message.successTime = reader.int64().toString();
                    break;
                case /* int64 success_amt_sat */ 6:
                    message.successAmtSat = reader.int64().toString();
                    break;
                case /* int64 success_amt_msat */ 7:
                    message.successAmtMsat = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 fail_time = 1; */
        if (message.failTime !== "0")
            writer.tag(1, runtime_2.WireType.Varint).int64(message.failTime);
        /* int64 fail_amt_sat = 2; */
        if (message.failAmtSat !== "0")
            writer.tag(2, runtime_2.WireType.Varint).int64(message.failAmtSat);
        /* int64 fail_amt_msat = 4; */
        if (message.failAmtMsat !== "0")
            writer.tag(4, runtime_2.WireType.Varint).int64(message.failAmtMsat);
        /* int64 success_time = 5; */
        if (message.successTime !== "0")
            writer.tag(5, runtime_2.WireType.Varint).int64(message.successTime);
        /* int64 success_amt_sat = 6; */
        if (message.successAmtSat !== "0")
            writer.tag(6, runtime_2.WireType.Varint).int64(message.successAmtSat);
        /* int64 success_amt_msat = 7; */
        if (message.successAmtMsat !== "0")
            writer.tag(7, runtime_2.WireType.Varint).int64(message.successAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PairData
 */
exports.PairData = new PairData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMissionControlConfigRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.GetMissionControlConfigRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigRequest
 */
exports.GetMissionControlConfigRequest = new GetMissionControlConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMissionControlConfigResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.GetMissionControlConfigResponse", [
            { no: 1, name: "config", kind: "message", T: () => exports.MissionControlConfig }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.MissionControlConfig config */ 1:
                    message.config = exports.MissionControlConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.MissionControlConfig config = 1; */
        if (message.config)
            exports.MissionControlConfig.internalBinaryWrite(message.config, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigResponse
 */
exports.GetMissionControlConfigResponse = new GetMissionControlConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMissionControlConfigRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SetMissionControlConfigRequest", [
            { no: 1, name: "config", kind: "message", T: () => exports.MissionControlConfig }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.MissionControlConfig config */ 1:
                    message.config = exports.MissionControlConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.MissionControlConfig config = 1; */
        if (message.config)
            exports.MissionControlConfig.internalBinaryWrite(message.config, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigRequest
 */
exports.SetMissionControlConfigRequest = new SetMissionControlConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMissionControlConfigResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SetMissionControlConfigResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigResponse
 */
exports.SetMissionControlConfigResponse = new SetMissionControlConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionControlConfig$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.MissionControlConfig", [
            { no: 1, name: "half_life_seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "hop_probability", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "maximum_payment_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "minimum_failure_relax_interval", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value) {
        const message = { halfLifeSeconds: "0", hopProbability: 0, weight: 0, maximumPaymentResults: 0, minimumFailureRelaxInterval: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 half_life_seconds */ 1:
                    message.halfLifeSeconds = reader.uint64().toString();
                    break;
                case /* float hop_probability */ 2:
                    message.hopProbability = reader.float();
                    break;
                case /* float weight */ 3:
                    message.weight = reader.float();
                    break;
                case /* uint32 maximum_payment_results */ 4:
                    message.maximumPaymentResults = reader.uint32();
                    break;
                case /* uint64 minimum_failure_relax_interval */ 5:
                    message.minimumFailureRelaxInterval = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 half_life_seconds = 1; */
        if (message.halfLifeSeconds !== "0")
            writer.tag(1, runtime_2.WireType.Varint).uint64(message.halfLifeSeconds);
        /* float hop_probability = 2; */
        if (message.hopProbability !== 0)
            writer.tag(2, runtime_2.WireType.Bit32).float(message.hopProbability);
        /* float weight = 3; */
        if (message.weight !== 0)
            writer.tag(3, runtime_2.WireType.Bit32).float(message.weight);
        /* uint32 maximum_payment_results = 4; */
        if (message.maximumPaymentResults !== 0)
            writer.tag(4, runtime_2.WireType.Varint).uint32(message.maximumPaymentResults);
        /* uint64 minimum_failure_relax_interval = 5; */
        if (message.minimumFailureRelaxInterval !== "0")
            writer.tag(5, runtime_2.WireType.Varint).uint64(message.minimumFailureRelaxInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.MissionControlConfig
 */
exports.MissionControlConfig = new MissionControlConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryProbabilityRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.QueryProbabilityRequest", [
            { no: 1, name: "from_node", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "to_node", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = { fromNode: new Uint8Array(0), toNode: new Uint8Array(0), amtMsat: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes from_node */ 1:
                    message.fromNode = reader.bytes();
                    break;
                case /* bytes to_node */ 2:
                    message.toNode = reader.bytes();
                    break;
                case /* int64 amt_msat */ 3:
                    message.amtMsat = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes from_node = 1; */
        if (message.fromNode.length)
            writer.tag(1, runtime_2.WireType.LengthDelimited).bytes(message.fromNode);
        /* bytes to_node = 2; */
        if (message.toNode.length)
            writer.tag(2, runtime_2.WireType.LengthDelimited).bytes(message.toNode);
        /* int64 amt_msat = 3; */
        if (message.amtMsat !== "0")
            writer.tag(3, runtime_2.WireType.Varint).int64(message.amtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityRequest
 */
exports.QueryProbabilityRequest = new QueryProbabilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryProbabilityResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.QueryProbabilityResponse", [
            { no: 1, name: "probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "history", kind: "message", T: () => exports.PairData }
        ]);
    }
    create(value) {
        const message = { probability: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double probability */ 1:
                    message.probability = reader.double();
                    break;
                case /* routerrpc.PairData history */ 2:
                    message.history = exports.PairData.internalBinaryRead(reader, reader.uint32(), options, message.history);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double probability = 1; */
        if (message.probability !== 0)
            writer.tag(1, runtime_2.WireType.Bit64).double(message.probability);
        /* routerrpc.PairData history = 2; */
        if (message.history)
            exports.PairData.internalBinaryWrite(message.history, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityResponse
 */
exports.QueryProbabilityResponse = new QueryProbabilityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildRouteRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.BuildRouteRequest", [
            { no: 1, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "hop_pubkeys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { amtMsat: "0", finalCltvDelta: 0, outgoingChanId: "0", hopPubkeys: [], paymentAddr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 amt_msat */ 1:
                    message.amtMsat = reader.int64().toString();
                    break;
                case /* int32 final_cltv_delta */ 2:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* uint64 outgoing_chan_id = 3 [jstype = JS_STRING];*/ 3:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* repeated bytes hop_pubkeys */ 4:
                    message.hopPubkeys.push(reader.bytes());
                    break;
                case /* bytes payment_addr */ 5:
                    message.paymentAddr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 amt_msat = 1; */
        if (message.amtMsat !== "0")
            writer.tag(1, runtime_2.WireType.Varint).int64(message.amtMsat);
        /* int32 final_cltv_delta = 2; */
        if (message.finalCltvDelta !== 0)
            writer.tag(2, runtime_2.WireType.Varint).int32(message.finalCltvDelta);
        /* uint64 outgoing_chan_id = 3 [jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(3, runtime_2.WireType.Varint).uint64(message.outgoingChanId);
        /* repeated bytes hop_pubkeys = 4; */
        for (let i = 0; i < message.hopPubkeys.length; i++)
            writer.tag(4, runtime_2.WireType.LengthDelimited).bytes(message.hopPubkeys[i]);
        /* bytes payment_addr = 5; */
        if (message.paymentAddr.length)
            writer.tag(5, runtime_2.WireType.LengthDelimited).bytes(message.paymentAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteRequest
 */
exports.BuildRouteRequest = new BuildRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildRouteResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.BuildRouteResponse", [
            { no: 1, name: "route", kind: "message", T: () => rpc_6.Route }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.Route route */ 1:
                    message.route = rpc_6.Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* lnrpc.Route route = 1; */
        if (message.route)
            rpc_6.Route.internalBinaryWrite(message.route, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteResponse
 */
exports.BuildRouteResponse = new BuildRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHtlcEventsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SubscribeHtlcEventsRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribeHtlcEventsRequest
 */
exports.SubscribeHtlcEventsRequest = new SubscribeHtlcEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HtlcEvent$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.HtlcEvent", [
            { no: 1, name: "incoming_channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "outgoing_channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "incoming_htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "outgoing_htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 6, name: "event_type", kind: "enum", T: () => ["routerrpc.HtlcEvent.EventType", HtlcEvent_EventType] },
            { no: 7, name: "forward_event", kind: "message", oneof: "event", T: () => exports.ForwardEvent },
            { no: 8, name: "forward_fail_event", kind: "message", oneof: "event", T: () => exports.ForwardFailEvent },
            { no: 9, name: "settle_event", kind: "message", oneof: "event", T: () => exports.SettleEvent },
            { no: 10, name: "link_fail_event", kind: "message", oneof: "event", T: () => exports.LinkFailEvent }
        ]);
    }
    create(value) {
        const message = { incomingChannelId: "0", outgoingChannelId: "0", incomingHtlcId: "0", outgoingHtlcId: "0", timestampNs: "0", eventType: 0, event: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 incoming_channel_id */ 1:
                    message.incomingChannelId = reader.uint64().toString();
                    break;
                case /* uint64 outgoing_channel_id */ 2:
                    message.outgoingChannelId = reader.uint64().toString();
                    break;
                case /* uint64 incoming_htlc_id */ 3:
                    message.incomingHtlcId = reader.uint64().toString();
                    break;
                case /* uint64 outgoing_htlc_id */ 4:
                    message.outgoingHtlcId = reader.uint64().toString();
                    break;
                case /* uint64 timestamp_ns */ 5:
                    message.timestampNs = reader.uint64().toString();
                    break;
                case /* routerrpc.HtlcEvent.EventType event_type */ 6:
                    message.eventType = reader.int32();
                    break;
                case /* routerrpc.ForwardEvent forward_event */ 7:
                    message.event = {
                        oneofKind: "forwardEvent",
                        forwardEvent: exports.ForwardEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.forwardEvent)
                    };
                    break;
                case /* routerrpc.ForwardFailEvent forward_fail_event */ 8:
                    message.event = {
                        oneofKind: "forwardFailEvent",
                        forwardFailEvent: exports.ForwardFailEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.forwardFailEvent)
                    };
                    break;
                case /* routerrpc.SettleEvent settle_event */ 9:
                    message.event = {
                        oneofKind: "settleEvent",
                        settleEvent: exports.SettleEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.settleEvent)
                    };
                    break;
                case /* routerrpc.LinkFailEvent link_fail_event */ 10:
                    message.event = {
                        oneofKind: "linkFailEvent",
                        linkFailEvent: exports.LinkFailEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.linkFailEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 incoming_channel_id = 1; */
        if (message.incomingChannelId !== "0")
            writer.tag(1, runtime_2.WireType.Varint).uint64(message.incomingChannelId);
        /* uint64 outgoing_channel_id = 2; */
        if (message.outgoingChannelId !== "0")
            writer.tag(2, runtime_2.WireType.Varint).uint64(message.outgoingChannelId);
        /* uint64 incoming_htlc_id = 3; */
        if (message.incomingHtlcId !== "0")
            writer.tag(3, runtime_2.WireType.Varint).uint64(message.incomingHtlcId);
        /* uint64 outgoing_htlc_id = 4; */
        if (message.outgoingHtlcId !== "0")
            writer.tag(4, runtime_2.WireType.Varint).uint64(message.outgoingHtlcId);
        /* uint64 timestamp_ns = 5; */
        if (message.timestampNs !== "0")
            writer.tag(5, runtime_2.WireType.Varint).uint64(message.timestampNs);
        /* routerrpc.HtlcEvent.EventType event_type = 6; */
        if (message.eventType !== 0)
            writer.tag(6, runtime_2.WireType.Varint).int32(message.eventType);
        /* routerrpc.ForwardEvent forward_event = 7; */
        if (message.event.oneofKind === "forwardEvent")
            exports.ForwardEvent.internalBinaryWrite(message.event.forwardEvent, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ForwardFailEvent forward_fail_event = 8; */
        if (message.event.oneofKind === "forwardFailEvent")
            exports.ForwardFailEvent.internalBinaryWrite(message.event.forwardFailEvent, writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.SettleEvent settle_event = 9; */
        if (message.event.oneofKind === "settleEvent")
            exports.SettleEvent.internalBinaryWrite(message.event.settleEvent, writer.tag(9, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.LinkFailEvent link_fail_event = 10; */
        if (message.event.oneofKind === "linkFailEvent")
            exports.LinkFailEvent.internalBinaryWrite(message.event.linkFailEvent, writer.tag(10, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcEvent
 */
exports.HtlcEvent = new HtlcEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HtlcInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.HtlcInfo", [
            { no: 1, name: "incoming_timelock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "outgoing_timelock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "incoming_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "outgoing_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value) {
        const message = { incomingTimelock: 0, outgoingTimelock: 0, incomingAmtMsat: "0", outgoingAmtMsat: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 incoming_timelock */ 1:
                    message.incomingTimelock = reader.uint32();
                    break;
                case /* uint32 outgoing_timelock */ 2:
                    message.outgoingTimelock = reader.uint32();
                    break;
                case /* uint64 incoming_amt_msat */ 3:
                    message.incomingAmtMsat = reader.uint64().toString();
                    break;
                case /* uint64 outgoing_amt_msat */ 4:
                    message.outgoingAmtMsat = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 incoming_timelock = 1; */
        if (message.incomingTimelock !== 0)
            writer.tag(1, runtime_2.WireType.Varint).uint32(message.incomingTimelock);
        /* uint32 outgoing_timelock = 2; */
        if (message.outgoingTimelock !== 0)
            writer.tag(2, runtime_2.WireType.Varint).uint32(message.outgoingTimelock);
        /* uint64 incoming_amt_msat = 3; */
        if (message.incomingAmtMsat !== "0")
            writer.tag(3, runtime_2.WireType.Varint).uint64(message.incomingAmtMsat);
        /* uint64 outgoing_amt_msat = 4; */
        if (message.outgoingAmtMsat !== "0")
            writer.tag(4, runtime_2.WireType.Varint).uint64(message.outgoingAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcInfo
 */
exports.HtlcInfo = new HtlcInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardEvent$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.ForwardEvent", [
            { no: 1, name: "info", kind: "message", T: () => exports.HtlcInfo }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.HtlcInfo info */ 1:
                    message.info = exports.HtlcInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.HtlcInfo info = 1; */
        if (message.info)
            exports.HtlcInfo.internalBinaryWrite(message.info, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardEvent
 */
exports.ForwardEvent = new ForwardEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardFailEvent$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.ForwardFailEvent", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardFailEvent
 */
exports.ForwardFailEvent = new ForwardFailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettleEvent$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.SettleEvent", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SettleEvent
 */
exports.SettleEvent = new SettleEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkFailEvent$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.LinkFailEvent", [
            { no: 1, name: "info", kind: "message", T: () => exports.HtlcInfo },
            { no: 2, name: "wire_failure", kind: "enum", T: () => ["lnrpc.Failure.FailureCode", rpc_4.Failure_FailureCode] },
            { no: 3, name: "failure_detail", kind: "enum", T: () => ["routerrpc.FailureDetail", FailureDetail] },
            { no: 4, name: "failure_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { wireFailure: 0, failureDetail: 0, failureString: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.HtlcInfo info */ 1:
                    message.info = exports.HtlcInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* lnrpc.Failure.FailureCode wire_failure */ 2:
                    message.wireFailure = reader.int32();
                    break;
                case /* routerrpc.FailureDetail failure_detail */ 3:
                    message.failureDetail = reader.int32();
                    break;
                case /* string failure_string */ 4:
                    message.failureString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.HtlcInfo info = 1; */
        if (message.info)
            exports.HtlcInfo.internalBinaryWrite(message.info, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Failure.FailureCode wire_failure = 2; */
        if (message.wireFailure !== 0)
            writer.tag(2, runtime_2.WireType.Varint).int32(message.wireFailure);
        /* routerrpc.FailureDetail failure_detail = 3; */
        if (message.failureDetail !== 0)
            writer.tag(3, runtime_2.WireType.Varint).int32(message.failureDetail);
        /* string failure_string = 4; */
        if (message.failureString !== "")
            writer.tag(4, runtime_2.WireType.LengthDelimited).string(message.failureString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.LinkFailEvent
 */
exports.LinkFailEvent = new LinkFailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaymentStatus$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.PaymentStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["routerrpc.PaymentState", PaymentState] },
            { no: 2, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => rpc_3.HTLCAttempt }
        ]);
    }
    create(value) {
        const message = { state: 0, preimage: new Uint8Array(0), htlcs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.PaymentState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* bytes preimage */ 2:
                    message.preimage = reader.bytes();
                    break;
                case /* repeated lnrpc.HTLCAttempt htlcs */ 4:
                    message.htlcs.push(rpc_3.HTLCAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.PaymentState state = 1; */
        if (message.state !== 0)
            writer.tag(1, runtime_2.WireType.Varint).int32(message.state);
        /* bytes preimage = 2; */
        if (message.preimage.length)
            writer.tag(2, runtime_2.WireType.LengthDelimited).bytes(message.preimage);
        /* repeated lnrpc.HTLCAttempt htlcs = 4; */
        for (let i = 0; i < message.htlcs.length; i++)
            rpc_3.HTLCAttempt.internalBinaryWrite(message.htlcs[i], writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PaymentStatus
 */
exports.PaymentStatus = new PaymentStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CircuitKey$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.CircuitKey", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value) {
        const message = { chanId: "0", htlcId: "0" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id */ 1:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* uint64 htlc_id */ 2:
                    message.htlcId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 chan_id = 1; */
        if (message.chanId !== "0")
            writer.tag(1, runtime_2.WireType.Varint).uint64(message.chanId);
        /* uint64 htlc_id = 2; */
        if (message.htlcId !== "0")
            writer.tag(2, runtime_2.WireType.Varint).uint64(message.htlcId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.CircuitKey
 */
exports.CircuitKey = new CircuitKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardHtlcInterceptRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.ForwardHtlcInterceptRequest", [
            { no: 1, name: "incoming_circuit_key", kind: "message", T: () => exports.CircuitKey },
            { no: 5, name: "incoming_amount_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 6, name: "incoming_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "outgoing_requested_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "outgoing_amount_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "outgoing_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 9, name: "onion_blob", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { incomingAmountMsat: "0", incomingExpiry: 0, paymentHash: new Uint8Array(0), outgoingRequestedChanId: "0", outgoingAmountMsat: "0", outgoingExpiry: 0, customRecords: {}, onionBlob: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.CircuitKey incoming_circuit_key */ 1:
                    message.incomingCircuitKey = exports.CircuitKey.internalBinaryRead(reader, reader.uint32(), options, message.incomingCircuitKey);
                    break;
                case /* uint64 incoming_amount_msat */ 5:
                    message.incomingAmountMsat = reader.uint64().toString();
                    break;
                case /* uint32 incoming_expiry */ 6:
                    message.incomingExpiry = reader.uint32();
                    break;
                case /* bytes payment_hash */ 2:
                    message.paymentHash = reader.bytes();
                    break;
                case /* uint64 outgoing_requested_chan_id */ 7:
                    message.outgoingRequestedChanId = reader.uint64().toString();
                    break;
                case /* uint64 outgoing_amount_msat */ 3:
                    message.outgoingAmountMsat = reader.uint64().toString();
                    break;
                case /* uint32 outgoing_expiry */ 4:
                    message.outgoingExpiry = reader.uint32();
                    break;
                case /* map<uint64, bytes> custom_records */ 8:
                    this.binaryReadMap8(message.customRecords, reader, options);
                    break;
                case /* bytes onion_blob */ 9:
                    message.onionBlob = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap8(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field routerrpc.ForwardHtlcInterceptRequest.custom_records");
            }
        }
        map[key !== null && key !== void 0 ? key : "0"] = val !== null && val !== void 0 ? val : new Uint8Array(0);
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.CircuitKey incoming_circuit_key = 1; */
        if (message.incomingCircuitKey)
            exports.CircuitKey.internalBinaryWrite(message.incomingCircuitKey, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* uint64 incoming_amount_msat = 5; */
        if (message.incomingAmountMsat !== "0")
            writer.tag(5, runtime_2.WireType.Varint).uint64(message.incomingAmountMsat);
        /* uint32 incoming_expiry = 6; */
        if (message.incomingExpiry !== 0)
            writer.tag(6, runtime_2.WireType.Varint).uint32(message.incomingExpiry);
        /* bytes payment_hash = 2; */
        if (message.paymentHash.length)
            writer.tag(2, runtime_2.WireType.LengthDelimited).bytes(message.paymentHash);
        /* uint64 outgoing_requested_chan_id = 7; */
        if (message.outgoingRequestedChanId !== "0")
            writer.tag(7, runtime_2.WireType.Varint).uint64(message.outgoingRequestedChanId);
        /* uint64 outgoing_amount_msat = 3; */
        if (message.outgoingAmountMsat !== "0")
            writer.tag(3, runtime_2.WireType.Varint).uint64(message.outgoingAmountMsat);
        /* uint32 outgoing_expiry = 4; */
        if (message.outgoingExpiry !== 0)
            writer.tag(4, runtime_2.WireType.Varint).uint32(message.outgoingExpiry);
        /* map<uint64, bytes> custom_records = 8; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(8, runtime_2.WireType.LengthDelimited).fork().tag(1, runtime_2.WireType.Varint).uint64(k).tag(2, runtime_2.WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        /* bytes onion_blob = 9; */
        if (message.onionBlob.length)
            writer.tag(9, runtime_2.WireType.LengthDelimited).bytes(message.onionBlob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptRequest
 */
exports.ForwardHtlcInterceptRequest = new ForwardHtlcInterceptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardHtlcInterceptResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.ForwardHtlcInterceptResponse", [
            { no: 1, name: "incoming_circuit_key", kind: "message", T: () => exports.CircuitKey },
            { no: 2, name: "action", kind: "enum", T: () => ["routerrpc.ResolveHoldForwardAction", ResolveHoldForwardAction] },
            { no: 3, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { action: 0, preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.CircuitKey incoming_circuit_key */ 1:
                    message.incomingCircuitKey = exports.CircuitKey.internalBinaryRead(reader, reader.uint32(), options, message.incomingCircuitKey);
                    break;
                case /* routerrpc.ResolveHoldForwardAction action */ 2:
                    message.action = reader.int32();
                    break;
                case /* bytes preimage */ 3:
                    message.preimage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.CircuitKey incoming_circuit_key = 1; */
        if (message.incomingCircuitKey)
            exports.CircuitKey.internalBinaryWrite(message.incomingCircuitKey, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ResolveHoldForwardAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, runtime_2.WireType.Varint).int32(message.action);
        /* bytes preimage = 3; */
        if (message.preimage.length)
            writer.tag(3, runtime_2.WireType.LengthDelimited).bytes(message.preimage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptResponse
 */
exports.ForwardHtlcInterceptResponse = new ForwardHtlcInterceptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateChanStatusRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.UpdateChanStatusRequest", [
            { no: 1, name: "chan_point", kind: "message", T: () => rpc_2.ChannelPoint },
            { no: 2, name: "action", kind: "enum", T: () => ["routerrpc.ChanStatusAction", ChanStatusAction] }
        ]);
    }
    create(value) {
        const message = { action: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint chan_point */ 1:
                    message.chanPoint = rpc_2.ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* routerrpc.ChanStatusAction action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* lnrpc.ChannelPoint chan_point = 1; */
        if (message.chanPoint)
            rpc_2.ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ChanStatusAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, runtime_2.WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusRequest
 */
exports.UpdateChanStatusRequest = new UpdateChanStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateChanStatusResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("routerrpc.UpdateChanStatusResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusResponse
 */
exports.UpdateChanStatusResponse = new UpdateChanStatusResponse$Type();
/**
 * @generated ServiceType for protobuf service routerrpc.Router
 */
exports.Router = new runtime_rpc_1.ServiceType("routerrpc.Router", [
    { name: "SendPaymentV2", serverStreaming: true, options: {}, I: exports.SendPaymentRequest, O: rpc_1.Payment },
    { name: "TrackPaymentV2", serverStreaming: true, options: {}, I: exports.TrackPaymentRequest, O: rpc_1.Payment },
    { name: "EstimateRouteFee", options: {}, I: exports.RouteFeeRequest, O: exports.RouteFeeResponse },
    { name: "SendToRoute", options: {}, I: exports.SendToRouteRequest, O: exports.SendToRouteResponse },
    { name: "SendToRouteV2", options: {}, I: exports.SendToRouteRequest, O: rpc_3.HTLCAttempt },
    { name: "ResetMissionControl", options: {}, I: exports.ResetMissionControlRequest, O: exports.ResetMissionControlResponse },
    { name: "QueryMissionControl", options: {}, I: exports.QueryMissionControlRequest, O: exports.QueryMissionControlResponse },
    { name: "XImportMissionControl", options: {}, I: exports.XImportMissionControlRequest, O: exports.XImportMissionControlResponse },
    { name: "GetMissionControlConfig", options: {}, I: exports.GetMissionControlConfigRequest, O: exports.GetMissionControlConfigResponse },
    { name: "SetMissionControlConfig", options: {}, I: exports.SetMissionControlConfigRequest, O: exports.SetMissionControlConfigResponse },
    { name: "QueryProbability", options: {}, I: exports.QueryProbabilityRequest, O: exports.QueryProbabilityResponse },
    { name: "BuildRoute", options: {}, I: exports.BuildRouteRequest, O: exports.BuildRouteResponse },
    { name: "SubscribeHtlcEvents", serverStreaming: true, options: {}, I: exports.SubscribeHtlcEventsRequest, O: exports.HtlcEvent },
    { name: "SendPayment", serverStreaming: true, options: {}, I: exports.SendPaymentRequest, O: exports.PaymentStatus },
    { name: "TrackPayment", serverStreaming: true, options: {}, I: exports.TrackPaymentRequest, O: exports.PaymentStatus },
    { name: "HtlcInterceptor", serverStreaming: true, clientStreaming: true, options: {}, I: exports.ForwardHtlcInterceptResponse, O: exports.ForwardHtlcInterceptRequest },
    { name: "UpdateChanStatus", options: {}, I: exports.UpdateChanStatusRequest, O: exports.UpdateChanStatusResponse }
]);
//# sourceMappingURL=router.js.map