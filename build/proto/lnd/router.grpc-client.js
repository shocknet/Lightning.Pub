"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterClient = void 0;
// @generated by protobuf-ts 2.5.0 with parameter long_type_string,client_grpc1
// @generated from protobuf file "router.proto" (package "routerrpc", syntax proto3)
// tslint:disable
const router_1 = require("./router");
const grpc = __importStar(require("@grpc/grpc-js"));
/**
 * Router is a service that offers advanced interaction with the router
 * subsystem of the daemon.
 *
 * @generated from protobuf service routerrpc.Router
 */
class RouterClient extends grpc.Client {
    constructor(address, credentials, options = {}, binaryOptions = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     *
     * SendPaymentV2 attempts to route a payment described by the passed
     * PaymentRequest to the final destination. The call returns a stream of
     * payment updates.
     *
     * @generated from protobuf rpc: SendPaymentV2(routerrpc.SendPaymentRequest) returns (stream lnrpc.Payment);
     */
    sendPaymentV2(input, metadata, options) {
        const method = router_1.Router.methods[0];
        return this.makeServerStreamRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options);
    }
    /**
     *
     * TrackPaymentV2 returns an update stream for the payment identified by the
     * payment hash.
     *
     * @generated from protobuf rpc: TrackPaymentV2(routerrpc.TrackPaymentRequest) returns (stream lnrpc.Payment);
     */
    trackPaymentV2(input, metadata, options) {
        const method = router_1.Router.methods[1];
        return this.makeServerStreamRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options);
    }
    /**
     *
     * EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
     * may cost to send an HTLC to the target end destination.
     *
     * @generated from protobuf rpc: EstimateRouteFee(routerrpc.RouteFeeRequest) returns (routerrpc.RouteFeeResponse);
     */
    estimateRouteFee(input, metadata, options, callback) {
        const method = router_1.Router.methods[2];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * Deprecated, use SendToRouteV2. SendToRoute attempts to make a payment via
     * the specified route. This method differs from SendPayment in that it
     * allows users to specify a full route manually. This can be used for
     * things like rebalancing, and atomic swaps. It differs from the newer
     * SendToRouteV2 in that it doesn't return the full HTLC information.
     *
     * @deprecated
     * @generated from protobuf rpc: SendToRoute(routerrpc.SendToRouteRequest) returns (routerrpc.SendToRouteResponse);
     */
    sendToRoute(input, metadata, options, callback) {
        const method = router_1.Router.methods[3];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * SendToRouteV2 attempts to make a payment via the specified route. This
     * method differs from SendPayment in that it allows users to specify a full
     * route manually. This can be used for things like rebalancing, and atomic
     * swaps.
     *
     * @generated from protobuf rpc: SendToRouteV2(routerrpc.SendToRouteRequest) returns (lnrpc.HTLCAttempt);
     */
    sendToRouteV2(input, metadata, options, callback) {
        const method = router_1.Router.methods[4];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * ResetMissionControl clears all mission control state and starts with a clean
     * slate.
     *
     * @generated from protobuf rpc: ResetMissionControl(routerrpc.ResetMissionControlRequest) returns (routerrpc.ResetMissionControlResponse);
     */
    resetMissionControl(input, metadata, options, callback) {
        const method = router_1.Router.methods[5];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * QueryMissionControl exposes the internal mission control state to callers.
     * It is a development feature.
     *
     * @generated from protobuf rpc: QueryMissionControl(routerrpc.QueryMissionControlRequest) returns (routerrpc.QueryMissionControlResponse);
     */
    queryMissionControl(input, metadata, options, callback) {
        const method = router_1.Router.methods[6];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * XImportMissionControl is an experimental API that imports the state provided
     * to the internal mission control's state, using all results which are more
     * recent than our existing values. These values will only be imported
     * in-memory, and will not be persisted across restarts.
     *
     * @generated from protobuf rpc: XImportMissionControl(routerrpc.XImportMissionControlRequest) returns (routerrpc.XImportMissionControlResponse);
     */
    xImportMissionControl(input, metadata, options, callback) {
        const method = router_1.Router.methods[7];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * GetMissionControlConfig returns mission control's current config.
     *
     * @generated from protobuf rpc: GetMissionControlConfig(routerrpc.GetMissionControlConfigRequest) returns (routerrpc.GetMissionControlConfigResponse);
     */
    getMissionControlConfig(input, metadata, options, callback) {
        const method = router_1.Router.methods[8];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * SetMissionControlConfig will set mission control's config, if the config
     * provided is valid.
     *
     * @generated from protobuf rpc: SetMissionControlConfig(routerrpc.SetMissionControlConfigRequest) returns (routerrpc.SetMissionControlConfigResponse);
     */
    setMissionControlConfig(input, metadata, options, callback) {
        const method = router_1.Router.methods[9];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * QueryProbability returns the current success probability estimate for a
     * given node pair and amount.
     *
     * @generated from protobuf rpc: QueryProbability(routerrpc.QueryProbabilityRequest) returns (routerrpc.QueryProbabilityResponse);
     */
    queryProbability(input, metadata, options, callback) {
        const method = router_1.Router.methods[10];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * BuildRoute builds a fully specified route based on a list of hop public
     * keys. It retrieves the relevant channel policies from the graph in order to
     * calculate the correct fees and time locks.
     *
     * @generated from protobuf rpc: BuildRoute(routerrpc.BuildRouteRequest) returns (routerrpc.BuildRouteResponse);
     */
    buildRoute(input, metadata, options, callback) {
        const method = router_1.Router.methods[11];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
    /**
     *
     * SubscribeHtlcEvents creates a uni-directional stream from the server to
     * the client which delivers a stream of htlc events.
     *
     * @generated from protobuf rpc: SubscribeHtlcEvents(routerrpc.SubscribeHtlcEventsRequest) returns (stream routerrpc.HtlcEvent);
     */
    subscribeHtlcEvents(input, metadata, options) {
        const method = router_1.Router.methods[12];
        return this.makeServerStreamRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options);
    }
    /**
     *
     * Deprecated, use SendPaymentV2. SendPayment attempts to route a payment
     * described by the passed PaymentRequest to the final destination. The call
     * returns a stream of payment status updates.
     *
     * @deprecated
     * @generated from protobuf rpc: SendPayment(routerrpc.SendPaymentRequest) returns (stream routerrpc.PaymentStatus);
     */
    sendPayment(input, metadata, options) {
        const method = router_1.Router.methods[13];
        return this.makeServerStreamRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options);
    }
    /**
     *
     * Deprecated, use TrackPaymentV2. TrackPayment returns an update stream for
     * the payment identified by the payment hash.
     *
     * @deprecated
     * @generated from protobuf rpc: TrackPayment(routerrpc.TrackPaymentRequest) returns (stream routerrpc.PaymentStatus);
     */
    trackPayment(input, metadata, options) {
        const method = router_1.Router.methods[14];
        return this.makeServerStreamRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options);
    }
    /**
     * *
     * HtlcInterceptor dispatches a bi-directional streaming RPC in which
     * Forwarded HTLC requests are sent to the client and the client responds with
     * a boolean that tells LND if this htlc should be intercepted.
     * In case of interception, the htlc can be either settled, cancelled or
     * resumed later by using the ResolveHoldForward endpoint.
     *
     * @generated from protobuf rpc: HtlcInterceptor(stream routerrpc.ForwardHtlcInterceptResponse) returns (stream routerrpc.ForwardHtlcInterceptRequest);
     */
    htlcInterceptor(metadata, options) {
        const method = router_1.Router.methods[15];
        return this.makeBidiStreamRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), metadata, options);
    }
    /**
     *
     * UpdateChanStatus attempts to manually set the state of a channel
     * (enabled, disabled, or auto). A manual "disable" request will cause the
     * channel to stay disabled until a subsequent manual request of either
     * "enable" or "auto".
     *
     * @generated from protobuf rpc: UpdateChanStatus(routerrpc.UpdateChanStatusRequest) returns (routerrpc.UpdateChanStatusResponse);
     */
    updateChanStatus(input, metadata, options, callback) {
        const method = router_1.Router.methods[16];
        return this.makeUnaryRequest(`/${router_1.Router.typeName}/${method.name}`, (value) => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value) => method.O.fromBinary(value, this._binaryOptions), input, metadata, options, callback);
    }
}
exports.RouterClient = RouterClient;
//# sourceMappingURL=router.grpc-client.js.map