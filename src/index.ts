import 'dotenv/config'
import NewServer from '../proto/autogenerated/ts/express_server.js'
import GetServerMethods from './services/serverMethods/index.js'
import serverOptions from './auth.js';
import nostrMiddleware from './nostrMiddleware.js'
import { getLogger } from './services/helpers/logger.js';
import { initMainHandler, initSettings } from './services/main/init.js';
import { nip19 } from 'nostr-tools'
import { LoadStorageSettingsFromEnv } from './services/storage/index.js';
import Main from './services/main/index.js';
import * as Types from '../proto/autogenerated/ts/types.js';
import { networks } from 'bitcoinjs-lib';
//@ts-ignore
const { nprofileEncode } = nip19


const start = async () => {
    const log = getLogger({})
    //const mainSettings = LoadMainSettingsFromEnv()
    const storageSettings = LoadStorageSettingsFromEnv()
    const settingsManager = await initSettings(log, storageSettings)
    const keepOn = await initMainHandler(log, settingsManager)
    if (!keepOn) {
        log("manual process ended")
        return
    }

    const { apps, mainHandler, liquidityProviderInfo, wizard, adminManager } = keepOn
    const serverMethods = GetServerMethods(mainHandler)
    log("initializing nostr middleware")
    const relays = mainHandler.settings.getSettings().nostrRelaySettings.relays
    const maxEventContentLength = mainHandler.settings.getSettings().nostrRelaySettings.maxEventContentLength
    const { Send, Stop, Ping, Reset } = nostrMiddleware(serverMethods, mainHandler,
        { relays, maxEventContentLength, apps, clients: [liquidityProviderInfo] },
        (e, p) => mainHandler.liquidityProvider.onEvent(e, p)
    )
    exitHandler(() => { Stop(); mainHandler.Stop() })
    log("starting server")
    mainHandler.attachNostrSend(Send)
    mainHandler.attachNostrProcessPing(Ping)
    mainHandler.attachNostrReset(Reset)
    mainHandler.StartBeacons()
    const appNprofile = nprofileEncode({ pubkey: liquidityProviderInfo.publicKey, relays })
    if (wizard) {
        wizard.AddConnectInfo(appNprofile, relays)
    }
    adminManager.setAppNprofile(appNprofile)
    const Server = NewServer(serverMethods, serverOptions(mainHandler))
    Server.Listen(mainHandler.settings.getSettings().serviceSettings.servicePort)
    await TMP_swapTest_TMP(mainHandler) // TMP -- remove this
}
start()

const exitHandler = async (kill: () => void) => {
    // catch ctrl+c event and exit normally
    process.on('SIGINT', () => {
        console.log('Ctrl-C detected, exiting safely...');
        process.exit(2);
    });

    //catch uncaught exceptions, trace, then exit normally
    process.on('uncaughtException', (e) => {
        console.log('Uncaught Exception detected, exiting safely, and killing all child processes...');
        console.log(e.stack);
        kill();
        process.exit(99);
    });
}

const TMP_swapTest_TMP = async (mainHandler: Main) => {
    await new Promise(resolve => setTimeout(resolve, 10000))
    /*    const i = await mainHandler.lnd.NewInvoice(25000, 'test', 3600, { useProvider: true, from: 'user' })
        console.log('Invoice created with provider destination', i.providerDst)
        const decoded = await mainHandler.lnd.DecodeInvoice(i.payRequest)
        await mainHandler.paymentManager.swaps.SwapInvoice(i.payRequest, decoded.paymentHash) */
    const a = await mainHandler.lnd.NewAddress(Types.AddressType.WITNESS_PUBKEY_HASH, { useProvider: false, from: 'user' })
    console.log('Address created', a.address)
    await mainHandler.paymentManager.swaps.SwapTransaction(a.address, 25000, networks.bitcoin)

}