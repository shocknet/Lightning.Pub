import { ECPairFactory } from 'ecpair';
import * as ecc from 'tiny-secp256k1';
import { getLogger } from '../../helpers/logger.js';
import SettingsManager from '../../main/settingsManager.js';
import * as Types from '../../../../proto/autogenerated/ts/types.js';
import Storage from '../../storage/index.js';
import LND from '../lnd.js';
import { UserInvoicePayment } from '../../storage/entity/UserInvoicePayment.js';
import { ReverseSwaps, TransactionSwapData } from './reverseSwaps.js';
import { SubmarineSwaps, InvoiceSwapData } from './submarineSwaps.js';
import { InvoiceSwap } from '../../storage/entity/InvoiceSwap.js';


export class Swaps {
    settings: SettingsManager
    revSwappers: Record<string, ReverseSwaps>
    subSwappers: Record<string, SubmarineSwaps>
    storage: Storage
    lnd: LND
    waitingSwaps: Record<string, boolean> = {}
    log = getLogger({ component: 'swaps' })
    constructor(settings: SettingsManager, storage: Storage) {
        this.settings = settings
        this.revSwappers = {}
        this.subSwappers = {}
        const network = settings.getSettings().lndSettings.network
        const { boltzHttpUrl, boltzWebSocketUrl, boltsHttpUrlAlt, boltsWebSocketUrlAlt } = settings.getSettings().swapsSettings
        if (boltzHttpUrl && boltzWebSocketUrl) {
            this.revSwappers[boltzHttpUrl] = new ReverseSwaps({ httpUrl: boltzHttpUrl, wsUrl: boltzWebSocketUrl, network })
            this.subSwappers[boltzHttpUrl] = new SubmarineSwaps({ httpUrl: boltzHttpUrl, wsUrl: boltzWebSocketUrl, network })
        }
        if (boltsHttpUrlAlt && boltsWebSocketUrlAlt) {
            this.revSwappers[boltsHttpUrlAlt] = new ReverseSwaps({ httpUrl: boltsHttpUrlAlt, wsUrl: boltsWebSocketUrlAlt, network })
            this.subSwappers[boltsHttpUrlAlt] = new SubmarineSwaps({ httpUrl: boltsHttpUrlAlt, wsUrl: boltsWebSocketUrlAlt, network })
        }
        this.storage = storage
    }

    SetLnd = (lnd: LND) => {
        this.lnd = lnd
    }

    Stop = () => { }

    GetKeys = (privateKey: string) => {
        const keys = ECPairFactory(ecc).fromPrivateKey(Buffer.from(privateKey, 'hex'))
        return keys
    }

    GetInvoiceSwapQuotes = async (appUserId: string, invoice: string): Promise<Types.InvoiceSwapQuote[]> => {
        if (!this.settings.getSettings().swapsSettings.enableSwaps) {
            throw new Error("Swaps are not enabled")
        }
        const swappers = Object.values(this.subSwappers)
        if (swappers.length === 0) {
            throw new Error("No swap services available")
        }
        const res = await Promise.allSettled(swappers.map(sw => this.getInvoiceSwapQuote(sw, appUserId, invoice)))
        const failures: string[] = []
        const success: Types.InvoiceSwapQuote[] = []
        for (const r of res) {
            if (r.status === 'fulfilled') {
                success.push(r.value)
            } else {
                failures.push(r.reason.message ? r.reason.message : r.reason.toString())
            }
        }
        if (success.length === 0) {
            throw new Error(failures.join("\n"))
        }
        return success
    }

    private mapInvoiceSwapQuote = (s: InvoiceSwap): Types.InvoiceSwapQuote => {
        return {
            swap_operation_id: s.swap_operation_id,
            invoice: s.invoice,
            invoice_amount_sats: s.invoice_amount,
            address: s.address,
            transaction_amount_sats: s.transaction_amount,
            chain_fee_sats: s.chain_fee_sats,
            service_fee_sats: 0,
            service_url: s.service_url,
            swap_fee_sats: s.swap_fee_sats,
            tx_id: s.tx_id,
            paid_at_unix: s.paid_at_unix || (s.tx_id ? 1 : 0),
            expires_at_block_height: s.timeout_block_height,
        }
    }

    ListInvoiceSwaps = async (appUserId: string): Promise<Types.InvoiceSwapsList> => {
        const info = await this.lnd.GetInfo()
        const currentBlockHeight = info.blockHeight
        const completedSwaps = await this.storage.paymentStorage.ListCompletedInvoiceSwaps(appUserId)
        const pendingSwaps = await this.storage.paymentStorage.ListPendingInvoiceSwaps(appUserId)
        const quotes: Types.InvoiceSwapOperation[] = pendingSwaps.map(s => ({ quote: this.mapInvoiceSwapQuote(s) }))
        const operations: Types.InvoiceSwapOperation[] = completedSwaps.map(s => ({
            quote: this.mapInvoiceSwapQuote(s),
            failure_reason: s.failure_reason,
            completed_at_unix: s.completed_at_unix || 1,
        }))
        return {
            current_block_height: currentBlockHeight,
            swaps: operations.concat(quotes),
        }
    }

    RefundInvoiceSwap = async (swapOperationId: string, satPerVByte: number, refundAddress: string, currentHeight: number): Promise<{ published: false, txHex: string, txId: string } | { published: true, txId: string }> => {
        this.log("refunding invoice swap", { swapOperationId, satPerVByte, refundAddress, currentHeight })
        const swap = await this.storage.paymentStorage.GetRefundableInvoiceSwap(swapOperationId)
        if (!swap) {
            throw new Error("Swap not found or already used")
        }
        const swapper = this.subSwappers[swap.service_url]
        if (!swapper) {
            throw new Error("swapper service not found")
        }
        const result = await swapper.RefundSwap({
            swapId: swap.swap_quote_id,
            claimPublicKey: swap.claim_public_key,
            currentHeight,
            privateKeyHex: swap.ephemeral_private_key,
            refundAddress,
            swapTree: swap.swap_tree,
            timeoutBlockHeight: swap.timeout_block_height,
            feePerVbyte: satPerVByte,
            lockupTxHex: swap.lockup_tx_hex,
        })
        if (!result.ok) {
            throw new Error(result.error)
        }
        if (result.publish.done) {
            return { published: true, txId: result.publish.txId }
        }
        return { published: false, txHex: result.publish.txHex, txId: result.publish.txId }

    }

    PayInvoiceSwap = async (appUserId: string, swapOpId: string, satPerVByte: number, payAddress: (address: string, amt: number) => Promise<{ txId: string }>): Promise<void> => {
        this.log("paying invoice swap", { appUserId, swapOpId, satPerVByte })
        if (!this.settings.getSettings().swapsSettings.enableSwaps) {
            throw new Error("Swaps are not enabled")
        }
        if (!swapOpId) {
            throw new Error("swap operation id is required")
        }
        if (!satPerVByte) {
            throw new Error("sat per v byte is required")
        }
        const swap = await this.storage.paymentStorage.GetInvoiceSwap(swapOpId, appUserId)
        if (!swap) {
            throw new Error("swap not found")
        }
        const swapper = this.subSwappers[swap.service_url]
        if (!swapper) {
            throw new Error("swapper service not found")
        }
        if (this.waitingSwaps[swapOpId]) {
            throw new Error("swap already in progress")
        }
        this.waitingSwaps[swapOpId] = true
        const data = this.getInvoiceSwapData(swap)
        let txId = ""
        const close = swapper.SubscribeToInvoiceSwap(data, async (result) => {
            if (result.ok) {
                await this.storage.paymentStorage.FinalizeInvoiceSwap(swapOpId)
                this.log("invoice swap completed", { swapOpId, txId })
            } else {
                await this.storage.paymentStorage.FailInvoiceSwap(swapOpId, result.error, txId)
                this.log("invoice swap failed", { swapOpId, error: result.error })
            }
        }, () => payAddress(swap.address, swap.transaction_amount)
            .then(res => { txId = res.txId })
            .catch(err => { close(); this.log("error paying address", err.message || err) }))
    }

    ResumeInvoiceSwaps = async () => {
        this.log("resuming invoice swaps")
        const swaps = await this.storage.paymentStorage.ListUnfinishedInvoiceSwaps()
        this.log("resuming", swaps.length, "invoice swaps")
        for (const swap of swaps) {
            try {
                this.resumeInvoiceSwap(swap)
            } catch (err: any) {
                this.log("error resuming invoice swap", err.message || err)
            }
        }
    }


    private resumeInvoiceSwap = (swap: InvoiceSwap) => {
        // const swap = await this.storage.paymentStorage.GetInvoiceSwap(swapOpId, appUserId)
        if (!swap || !swap.tx_id || swap.used) {
            throw new Error("swap to resume not found, or does not have a tx id")
        }
        const swapper = this.subSwappers[swap.service_url]
        if (!swapper) {
            throw new Error("swapper service not found")
        }
        const data = this.getInvoiceSwapData(swap)
        swapper.SubscribeToInvoiceSwap(data, async (result) => {
            if (result.ok) {
                await this.storage.paymentStorage.FinalizeInvoiceSwap(swap.swap_operation_id)
                this.log("invoice swap completed", { swapOpId: swap.swap_operation_id, txId: swap.tx_id })
            } else {
                await this.storage.paymentStorage.FailInvoiceSwap(swap.swap_operation_id, result.error)
                this.log("invoice swap failed", { swapOpId: swap.swap_operation_id, error: result.error })
            }
        }, () => { throw new Error("swap tx already paid") })
    }

    private getInvoiceSwapData = (swap: InvoiceSwap) => {
        return {
            createdResponse: {
                address: swap.address,
                claimPublicKey: swap.claim_public_key,
                id: swap.swap_quote_id,
                swapTree: swap.swap_tree,
                timeoutBlockHeight: swap.timeout_block_height,
                expectedAmount: swap.transaction_amount,
            },
            info: {
                keys: this.GetKeys(swap.ephemeral_private_key),
                paymentHash: swap.payment_hash,
            }
        }
    }

    private async getInvoiceSwapQuote(swapper: SubmarineSwaps, appUserId: string, invoice: string): Promise<Types.InvoiceSwapQuote> {
        const feesRes = await swapper.GetFees()
        if (!feesRes.ok) {
            throw new Error(feesRes.error)
        }
        const decoded = await this.lnd.DecodeInvoice(invoice)
        const amt = decoded.numSatoshis
        const fee = Math.ceil((feesRes.fees.percentage / 100) * amt) + feesRes.fees.minerFees
        const res = await swapper.SwapInvoice(invoice)
        if (!res.ok) {
            throw new Error(res.error)
        }
        const newSwap = await this.storage.paymentStorage.AddInvoiceSwap({
            app_user_id: appUserId,
            swap_quote_id: res.createdResponse.id,
            swap_tree: JSON.stringify(res.createdResponse.swapTree),
            timeout_block_height: res.createdResponse.timeoutBlockHeight,
            ephemeral_public_key: res.pubkey,
            ephemeral_private_key: res.privKey,
            invoice: invoice,
            invoice_amount: amt,
            transaction_amount: res.createdResponse.expectedAmount,
            swap_fee_sats: fee,
            chain_fee_sats: 0,
            service_url: swapper.getHttpUrl(),
            address: res.createdResponse.address,
            claim_public_key: res.createdResponse.claimPublicKey,
            payment_hash: decoded.paymentHash,
        })
        return {
            swap_operation_id: newSwap.swap_operation_id,
            invoice: invoice,
            invoice_amount_sats: amt,
            address: res.createdResponse.address,
            transaction_amount_sats: res.createdResponse.expectedAmount,
            chain_fee_sats: 0,
            service_fee_sats: 0,
            service_url: swapper.getHttpUrl(),
            swap_fee_sats: fee,
            tx_id: newSwap.tx_id,
            paid_at_unix: newSwap.paid_at_unix,
            expires_at_block_height: newSwap.timeout_block_height,
        }
    }

    ListTxSwaps = async (appUserId: string, payments: UserInvoicePayment[], newOp: (p: UserInvoicePayment) => Types.UserOperation | undefined, getServiceFee: (amt: number) => number): Promise<Types.TxSwapsList> => {
        const completedSwaps = await this.storage.paymentStorage.ListCompletedTxSwaps(appUserId, payments)
        const pendingSwaps = await this.storage.paymentStorage.ListPendingTransactionSwaps(appUserId)
        return {
            swaps: completedSwaps.map(s => {
                const p = s.payment
                const op = p ? newOp(p) : undefined
                return {
                    operation_payment: op,
                    swap_operation_id: s.swap.swap_operation_id,
                    address_paid: s.swap.address_paid,
                    failure_reason: s.swap.failure_reason,
                }
            }),
            quotes: pendingSwaps.map(s => {
                const serviceFee = getServiceFee(s.invoice_amount)
                return {
                    swap_operation_id: s.swap_operation_id,
                    invoice_amount_sats: s.invoice_amount,
                    transaction_amount_sats: s.transaction_amount,
                    chain_fee_sats: s.chain_fee_sats,
                    service_fee_sats: serviceFee,
                    swap_fee_sats: s.swap_fee_sats,
                    service_url: s.service_url,
                }
            })
        }
    }
    GetTxSwapQuotes = async (appUserId: string, amt: number, getServiceFee: (decodedAmt: number) => number): Promise<Types.TransactionSwapQuote[]> => {
        if (!this.settings.getSettings().swapsSettings.enableSwaps) {
            throw new Error("Swaps are not enabled")
        }
        const swappers = Object.values(this.revSwappers)
        if (swappers.length === 0) {
            throw new Error("No swap services available")
        }
        const res = await Promise.allSettled(swappers.map(sw => this.getTxSwapQuote(sw, appUserId, amt, getServiceFee)))
        const failures: string[] = []
        const success: Types.TransactionSwapQuote[] = []
        for (const r of res) {
            if (r.status === 'fulfilled') {
                success.push(r.value)
            } else {
                failures.push(r.reason.message ? r.reason.message : r.reason.toString())
            }
        }
        if (success.length === 0) {
            throw new Error(failures.join("\n"))
        }
        return success
    }

    private async getTxSwapQuote(swapper: ReverseSwaps, appUserId: string, amt: number, getServiceFee: (decodedAmt: number) => number): Promise<Types.TransactionSwapQuote> {
        this.log("getting transaction swap quote")
        const feesRes = await swapper.GetFees()
        if (!feesRes.ok) {
            throw new Error(feesRes.error)
        }
        const { claim, lockup } = feesRes.fees.minerFees
        const minerFee = claim + lockup
        const chainTotal = amt + minerFee
        const res = await swapper.SwapTransaction(chainTotal)
        if (!res.ok) {
            throw new Error(res.error)
        }
        const decoded = await this.lnd.DecodeInvoice(res.createdResponse.invoice)
        const swapFee = decoded.numSatoshis - chainTotal
        const serviceFee = getServiceFee(decoded.numSatoshis)
        const newSwap = await this.storage.paymentStorage.AddTransactionSwap({
            app_user_id: appUserId,
            swap_quote_id: res.createdResponse.id,
            swap_tree: JSON.stringify(res.createdResponse.swapTree),
            lockup_address: res.createdResponse.lockupAddress,
            refund_public_key: res.createdResponse.refundPublicKey,
            timeout_block_height: res.createdResponse.timeoutBlockHeight,
            invoice: res.createdResponse.invoice,
            invoice_amount: decoded.numSatoshis,
            transaction_amount: chainTotal,
            swap_fee_sats: swapFee,
            chain_fee_sats: minerFee,
            preimage: res.preimage,
            ephemeral_private_key: res.privKey,
            ephemeral_public_key: res.pubkey,
            service_url: swapper.getHttpUrl(),
        })
        return {
            swap_operation_id: newSwap.swap_operation_id,
            swap_fee_sats: swapFee,
            invoice_amount_sats: decoded.numSatoshis,
            transaction_amount_sats: amt,
            chain_fee_sats: minerFee,
            service_fee_sats: serviceFee,
            service_url: swapper.getHttpUrl(),
        }
    }

    async PayAddrWithSwap(appUserId: string, swapOpId: string, address: string, payInvoice: (invoice: string, amt: number) => Promise<void>) {
        if (!this.settings.getSettings().swapsSettings.enableSwaps) {
            throw new Error("Swaps are not enabled")
        }
        this.log("paying address with swap", { appUserId, swapOpId, address })
        if (!swapOpId) {
            throw new Error("request a swap quote before paying an external address")
        }
        const txSwap = await this.storage.paymentStorage.GetTransactionSwap(swapOpId, appUserId)
        if (!txSwap) {
            throw new Error("swap quote not found")
        }
        const info = await this.lnd.GetInfo()
        if (info.blockHeight >= txSwap.timeout_block_height) {
            throw new Error("swap timeout")
        }
        const swapper = this.revSwappers[txSwap.service_url]
        if (!swapper) {
            throw new Error("swapper service not found")
        }
        const keys = this.GetKeys(txSwap.ephemeral_private_key)
        const data: TransactionSwapData = {
            createdResponse: {
                id: txSwap.swap_quote_id,
                invoice: txSwap.invoice,
                lockupAddress: txSwap.lockup_address,
                refundPublicKey: txSwap.refund_public_key,
                swapTree: txSwap.swap_tree,
                timeoutBlockHeight: txSwap.timeout_block_height,
                onchainAmount: txSwap.transaction_amount,
            },
            info: {
                destinationAddress: address,
                keys,
                chainFee: txSwap.chain_fee_sats,
                preimage: Buffer.from(txSwap.preimage, 'hex'),
            }
        }
        // the swap and the invoice payment are linked, swap will not start until the invoice payment is started, and will not complete once the invoice payment is completed
        let swapResult = { ok: false, error: "swap never completed" } as { ok: true, txId: string } | { ok: false, error: string }
        swapper.SubscribeToTransactionSwap(data, result => {
            swapResult = result
        })
        try {
            await payInvoice(txSwap.invoice, txSwap.invoice_amount)
            if (!swapResult.ok) {
                this.log("invoice payment successful, but swap failed")
                await this.storage.paymentStorage.FailTransactionSwap(swapOpId, address, swapResult.error)
                throw new Error(swapResult.error)
            }
            this.log("swap completed successfully")
            await this.storage.paymentStorage.FinalizeTransactionSwap(swapOpId, address, swapResult.txId)
        } catch (err: any) {
            if (swapResult.ok) {
                this.log("failed to pay swap invoice, but swap completed successfully", swapResult.txId)
                await this.storage.paymentStorage.FailTransactionSwap(swapOpId, address, err.message)
            } else {
                this.log("failed to pay swap invoice and swap failed", swapResult.error)
                await this.storage.paymentStorage.FailTransactionSwap(swapOpId, address, swapResult.error)
            }
            throw err
        }
        const networkFeesTotal = txSwap.chain_fee_sats + txSwap.swap_fee_sats
        return {
            txId: swapResult.txId,
            network_fee: networkFeesTotal
        }
    }
}