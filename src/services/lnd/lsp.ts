import fetch from "node-fetch"
import { LiquidityProvider } from "../main/liquidityProvider.js"
import { getLogger, PubLogger } from '../helpers/logger.js'
import LND from "./lnd.js"
import { AddressType } from "../../../proto/autogenerated/ts/types.js"
import { EnvCanBeInteger } from "../helpers/envParser.js"
export type LSPSettings = {
    olympusServiceUrl: string
    voltageServiceUrl: string
    flashsatsServiceUrl: string
    channelThreshold: number
    maxRelativeFee: number
}

export const LoadLSPSettingsFromEnv = (): LSPSettings => {
    const olympusServiceUrl = process.env.OLYMPUS_LSP_URL || "https://lsps1.lnolymp.us/api/v1"
    const voltageServiceUrl = process.env.VOLTAGE_LSP_URL || "https://lsp.voltageapi.com/api/v1"
    const flashsatsServiceUrl = process.env.FLASHSATS_LSP_URL || "https://lsp.flashsats.xyz/lsp/channel"
    const channelThreshold = EnvCanBeInteger("LSP_CHANNEL_THRESHOLD", 1000000)
    const maxRelativeFee = EnvCanBeInteger("LSP_MAX_FEE_BPS", 100) / 10000
    return { olympusServiceUrl, voltageServiceUrl, channelThreshold, maxRelativeFee, flashsatsServiceUrl }

}
type OlympusOrder = {
    "lsp_balance_sat": string,
    "client_balance_sat": string,
    "required_channel_confirmations": number,
    "funding_confirms_within_blocks": number,
    "channel_expiry_blocks": number,
    "refund_onchain_address": string,
    "announce_channel": boolean,
    "public_key": string

}
type FlashsatsOrder = {
    "node_connection_info": string,
    "lsp_balance_sat": number,
    "client_balance_sat": number,
    "confirms_within_blocks": number,
    "channel_expiry_blocks": number,
    "announce_channel": boolean,
    "token": string
}

type OrderResponse = {
    orderId: string
    invoice: string
    totalSats: number
    fees: number
}

class LSP {
    settings: LSPSettings
    liquidityProvider: LiquidityProvider
    lnd: LND
    log: PubLogger
    constructor(serviceName: string, settings: LSPSettings, lnd: LND, liquidityProvider: LiquidityProvider) {
        this.settings = settings
        this.lnd = lnd
        this.liquidityProvider = liquidityProvider
        this.log = getLogger({ component: serviceName })
    }

    addPeer = async (pubKey: string, host: string) => {
        const { peers } = await this.lnd.ListPeers()
        if (!peers.find(p => p.pubKey === pubKey)) {
            await this.lnd.ConnectPeer({ host, pubkey: pubKey })
        }

    }
}

export class FlashsatsLSP extends LSP {
    constructor(settings: LSPSettings, lnd: LND, liquidityProvider: LiquidityProvider) {
        super("FlashsatsLSP", settings, lnd, liquidityProvider)
    }

    requestChannel = async (maxSpendable: number): Promise<OrderResponse | null> => {
        if (!this.settings.flashsatsServiceUrl) {
            this.log("no flashsats service url provided")
            return null
        }
        const serviceInfo = await this.getInfo()
        if (+serviceInfo.options.min_initial_client_balance_sat > maxSpendable) {
            this.log("balance of", maxSpendable, "is lower than service minimum of", serviceInfo.options.min_initial_client_balance_sat)
            return null
        }
        const lndInfo = await this.lnd.GetInfo()
        const myUri = lndInfo.uris.length > 0 ? lndInfo.uris[0] : ""
        if (!myUri) {
            this.log("no uri found for this node,uri is required to use flashsats")
            return null
        }
        const channelSize = Math.floor(maxSpendable * (1 - this.settings.maxRelativeFee)) * 2
        const lspBalance = channelSize.toString()
        const chanExpiryBlocks = serviceInfo.options.max_channel_expiry_blocks
        const order = await this.createOrder({ nodeUri: myUri, lspBalance, clientBalance: "0", chanExpiryBlocks })
        if (order.payment.state !== 'EXPECT_PAYMENT') {
            this.log("order not in expect payment state")
            return null
        }
        const decoded = await this.lnd.DecodeInvoice(order.payment.bolt11_invoice)
        if (decoded.numSatoshis !== +order.payment.order_total_sat) {
            this.log("invoice of amount", decoded.numSatoshis, "does not match order total of", order.payment.order_total_sat)
            return null
        }
        if (decoded.numSatoshis > maxSpendable) {
            this.log("invoice of amount", decoded.numSatoshis, "exceeds user balance of", maxSpendable)
            return null
        }
        const relativeFee = +order.payment.fee_total_sat / channelSize
        if (relativeFee > this.settings.maxRelativeFee) {
            this.log("invoice relative fee of", relativeFee, "exceeds max relative fee of", this.settings.maxRelativeFee)
            return null
        }
        const res = await this.liquidityProvider.PayInvoice(order.payment.bolt11_invoice, decoded.numSatoshis, 'system')
        const fees = +order.payment.fee_total_sat + res.network_fee + res.service_fee
        this.log("paid", res.amount_paid, "to open channel, and a fee of", fees)
        return { orderId: order.order_id, invoice: order.payment.bolt11_invoice, totalSats: +order.payment.order_total_sat, fees }

    }
    getInfo = async () => {
        const res = await fetch(`${this.settings.flashsatsServiceUrl}/info`)
        const json = await res.json() as { options: { min_initial_client_balance_sat: string, max_channel_expiry_blocks: number } }
        return json
    }
    createOrder = async (orderInfo: { nodeUri: string, lspBalance: string, clientBalance: string, chanExpiryBlocks: number }) => {
        const req: FlashsatsOrder = {
            node_connection_info: orderInfo.nodeUri,
            announce_channel: true,
            channel_expiry_blocks: orderInfo.chanExpiryBlocks,
            client_balance_sat: +orderInfo.clientBalance,
            lsp_balance_sat: +orderInfo.lspBalance,
            confirms_within_blocks: 6,
            token: "flashsats"
        }
        const res = await fetch(`${this.settings.flashsatsServiceUrl}/channel`, {
            method: "POST",
            body: JSON.stringify(req),
            headers: { "Content-Type": "application/json" }
        })
        const json = await res.json() as { order_id: string, payment: { state: 'EXPECT_PAYMENT', bolt11_invoice: string, fee_total_sat: string, order_total_sat: string } }
        return json
    }
}

export class OlympusLSP extends LSP {
    constructor(settings: LSPSettings, lnd: LND, liquidityProvider: LiquidityProvider) {
        super("OlympusLSP", settings, lnd, liquidityProvider)
    }

    requestChannel = async (maxSpendable: number): Promise<OrderResponse | null> => {
        if (!this.settings.olympusServiceUrl) {
            this.log("no olympus service url provided")
            return null
        }
        const serviceInfo = await this.getInfo()
        if (+serviceInfo.min_initial_client_balance_sat > maxSpendable) {
            this.log("balance of", maxSpendable, "is lower than service minimum of", serviceInfo.min_initial_client_balance_sat)
            return null
        }
        const [servicePub, host] = serviceInfo.uris[0].split('@')
        await this.addPeer(servicePub, host)
        const lndInfo = await this.lnd.GetInfo()
        const myPub = lndInfo.identityPubkey
        const refundAddr = await this.lnd.NewAddress(AddressType.WITNESS_PUBKEY_HASH, { useProvider: false, from: 'system' })
        const channelSize = Math.floor(maxSpendable * (1 - this.settings.maxRelativeFee)) * 2
        const lspBalance = channelSize.toString()
        const chanExpiryBlocks = serviceInfo.max_channel_expiry_blocks
        const order = await this.createOrder({ pubKey: myPub, refundAddr: refundAddr.address, lspBalance, clientBalance: "0", chanExpiryBlocks })
        if (order.payment.bolt11.state !== 'EXPECT_PAYMENT') {
            this.log("order not in expect payment state")
            return null
        }
        const decoded = await this.lnd.DecodeInvoice(order.payment.bolt11.invoice)
        if (decoded.numSatoshis !== +order.payment.bolt11.order_total_sat) {
            this.log("invoice of amount", decoded.numSatoshis, "does not match order total of", order.payment.bolt11.order_total_sat)
            return null
        }
        if (decoded.numSatoshis > maxSpendable) {
            this.log("invoice of amount", decoded.numSatoshis, "exceeds user balance of", maxSpendable)
            return null
        }
        const relativeFee = +order.payment.bolt11.fee_total_sat / channelSize
        if (relativeFee > this.settings.maxRelativeFee) {
            this.log("invoice relative fee of", relativeFee, "exceeds max relative fee of", this.settings.maxRelativeFee)
            return null
        }
        const res = await this.liquidityProvider.PayInvoice(order.payment.bolt11.invoice, decoded.numSatoshis, 'system')
        const fees = +order.payment.bolt11.fee_total_sat + res.network_fee + res.service_fee
        this.log("paid", res.amount_paid, "to open channel, and a fee of", fees)
        return { orderId: order.order_id, invoice: order.payment.bolt11.invoice, totalSats: +order.payment.bolt11.order_total_sat, fees }
    }

    getInfo = async () => {
        const res = await fetch(`${this.settings.olympusServiceUrl}/get_info`)
        const json = await res.json() as { min_initial_client_balance_sat: string, max_channel_expiry_blocks: number, uris: string[] }
        return json
    }

    createOrder = async (orderInfo: { pubKey: string, refundAddr: string, lspBalance: string, clientBalance: string, chanExpiryBlocks: number }) => {
        const req: OlympusOrder = {
            public_key: orderInfo.pubKey,
            announce_channel: true,
            refund_onchain_address: orderInfo.refundAddr,
            lsp_balance_sat: orderInfo.lspBalance,
            client_balance_sat: orderInfo.clientBalance,
            channel_expiry_blocks: orderInfo.chanExpiryBlocks,
            funding_confirms_within_blocks: 6,
            required_channel_confirmations: 0
        }
        const res = await fetch(`${this.settings.olympusServiceUrl}/create_order`, {
            method: "POST",
            body: JSON.stringify(req),
            headers: { "Content-Type": "application/json" }
        })
        const json = await res.json() as { order_id: string, payment: { bolt11: { state: 'EXPECT_PAYMENT', invoice: string, fee_total_sat: string, order_total_sat: string } } }
        return json
    }

    getOrder = async (orderId: string) => {
        const res = await fetch(`${this.settings.olympusServiceUrl}/get_order&order_id=${orderId}`)
        const json = await res.json() as {}
        return json
    }
}

/*
export class VoltageLSP extends LSP {
    constructor(settings: LSPSettings, lnd: LND, liquidityProvider: LiquidityProvider) {
        super("VoltageLSP", settings, lnd, liquidityProvider)
    }

    getInfo = async () => {
        const res = await fetch(`${this.settings.voltageServiceUrl}/info`)
        const json = await res.json() as { connection_methods: { address: string, port: string, type: string }[], pubkey: string }
        return json
    }

    getFees = async (amtMsat: number, pubkey: string) => {
        const res = await fetch(`${this.settings.voltageServiceUrl}/fee`, {
            method: "POST",
            body: JSON.stringify({ amount_msat: amtMsat, pubkey }),
            headers: { "Content-Type": "application/json" }
        })
        const resText = await res.text()
        this.log("fee response", resText)
        const json = JSON.parse(resText) as { fee_amount_msat: number, id: string }
        return json
    }

    requestChannel = async (maxSpendable: number): Promise<OrderResponse | null> => {
        if (!this.settings.voltageServiceUrl) {
            this.log("no voltage service url provided")
            return null
        }

        const lndInfo = await this.lnd.GetInfo()
        const myPub = lndInfo.identityPubkey
        const amtSats = Math.floor(maxSpendable * 0.9)
        const amtMsats = Math.floor(maxSpendable * 0.9) * 1000
        const fee = await this.getFees(amtMsats, myPub)
        const feeSats = fee.fee_amount_msat / 1000
        const relativeFee = feeSats / (amtSats * 1.1)

        if (relativeFee > this.settings.maxRelativeFee) {
            this.log("relative fee of", relativeFee, "exceeds max relative fee of", this.settings.maxRelativeFee)
            return null
        }

        const info = await this.getInfo()
        const ipv4 = info.connection_methods.find(c => c.type === 'ipv4')
        if (!ipv4) {
            this.log("no ipv4 address found")
            return null
        }
        await this.addPeer(info.pubkey, `${ipv4.address}:${ipv4.port}`)

        const invoice = await this.lnd.NewInvoice(amtSats, "open channel", 60 * 60, { from: 'system', useProvider: false })
        const proposalRes = await this.proposal(invoice.payRequest, fee.id)
        this.log("proposal res", proposalRes, fee.id)
        const decoded = await this.lnd.DecodeInvoice(proposalRes.jit_bolt11)
        if (decoded.numSatoshis !== amtSats + feeSats) {
            this.log("invoice of amount", decoded.numSatoshis, "does not match expected amount of", amtSats + feeSats)
            return null
        }
        if (decoded.numSatoshis > maxSpendable) {
            this.log("invoice of amount", decoded.numSatoshis, "exceeds user balance of", maxSpendable)
            return null
        }
        const res = await this.liquidityProvider.PayInvoice(proposalRes.jit_bolt11, decoded.numSatoshis, 'system')
        const fees = feeSats + res.network_fee + res.service_fee
        this.log("paid", res.amount_paid, "to open channel, and a fee of", fees)
        return { orderId: fee.id, invoice: proposalRes.jit_bolt11, totalSats: decoded.numSatoshis, fees }
    }

    proposal = async (bolt11: string, feeId: string) => {
        const res = await fetch(`${this.settings.voltageServiceUrl}/proposal`, {
            method: "POST",
            body: JSON.stringify({ bolt11, fee_id: feeId }),
            headers: { "Content-Type": "application/json" }
        })
        const json = await res.json() as { jit_bolt11: string }
        return json
    }
}
    */