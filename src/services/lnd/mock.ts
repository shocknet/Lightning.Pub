//const grpc = require('@grpc/grpc-js');
import { credentials, Metadata } from '@grpc/grpc-js'
import { GrpcTransport } from "@protobuf-ts/grpc-transport";
import fs from 'fs'
import crypto from 'crypto'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { LightningClient } from '../../../proto/lnd/lightning.client.js'
import { InvoicesClient } from '../../../proto/lnd/invoices.client.js'
import { RouterClient } from '../../../proto/lnd/router.client.js'
import { GetInfoResponse, AddressType, NewAddressResponse, AddInvoiceResponse, Invoice_InvoiceState, PayReq, Payment_PaymentStatus, Payment, PaymentFailureReason, SendCoinsResponse, EstimateFeeResponse } from '../../../proto/lnd/lightning.js'
import { OpenChannelReq } from './openChannelReq.js';
import { AddInvoiceReq } from './addInvoiceReq.js';
import { PayInvoiceReq } from './payInvoiceReq.js';
import { SendCoinsReq } from './sendCoinsReq.js';
import { LndSettings, AddressPaidCb, InvoicePaidCb, NodeInfo, Invoice, DecodedInvoice, PaidInvoice } from './settings.js';

export default class {
    invoicesAwaiting: Record<string /* invoice */, { value: number, memo: string, expiryUnix: number }>
    settings: LndSettings
    abortController = new AbortController()
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    constructor(settings: LndSettings, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb) {
        this.settings = settings
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
    }

    async SetMockInvoiceAsPaid(invoice: string, amount: number): Promise<void> {
        const decoded = await this.DecodeInvoice(invoice)
        if (decoded.numSatoshis && amount) {
            throw new Error("non zero amount provided to pay invoice but invoice has value already")
        }
        this.invoicePaidCb(invoice, decoded.numSatoshis || amount)
        delete this.invoicesAwaiting[invoice]
    }

    Stop() { }
    async Warmup() { }

    async GetInfo(): Promise<NodeInfo> {
        return { alias: "mock", syncedToChain: true, syncedToGraph: true }
    }

    async Health(): Promise<void> { }

    async NewAddress(addressType: Types.AddressType): Promise<NewAddressResponse> {
        throw new Error("NewAddress disabled in mock mode")
    }

    async NewInvoice(value: number, memo: string, expiry: number): Promise<Invoice> {
        const mockInvoice = "lnbcrtmock" + crypto.randomBytes(32).toString('hex')
        this.invoicesAwaiting[mockInvoice] = { value, memo, expiryUnix: expiry + Date.now() / 1000 }
        return { payRequest: mockInvoice }
    }

    async DecodeInvoice(paymentRequest: string): Promise<DecodedInvoice> {
        const i = this.invoicesAwaiting[paymentRequest]
        if (!i) {
            throw new Error("invoice not found")
        }
        return { numSatoshis: i.value }
    }

    GetFeeLimitAmount(amount: number): number {
        return Math.ceil(amount * this.settings.feeRateLimit + this.settings.feeFixedLimit);
    }

    GetMaxWithinLimit(amount: number): number {
        return Math.max(0, Math.floor(amount * (1 - this.settings.feeRateLimit) - this.settings.feeFixedLimit))
    }

    async PayInvoice(invoice: string, amount: number, feeLimit: number): Promise<PaidInvoice> {
        if (!invoice.startsWith('lnbcrtmock')) {
            throw new Error("invalid mock invoice provided for payment")
        }
        const amt = invoice.substring('lnbcrtmock'.length)
        if (isNaN(+amt)) {
            throw new Error("invalid mock invoice provided for payment")
        }
        return { feeSat: 0, paymentPreimage: "all_good", valueSat: +amt || amount }
    }

    async EstimateChainFees(address: string, amount: number, targetConf: number): Promise<EstimateFeeResponse> {
        throw new Error("EstimateChainFees disabled in mock mode")
    }

    async PayAddress(address: string, amount: number, satPerVByte: number, label = ""): Promise<SendCoinsResponse> {
        throw new Error("PayAddress disabled in mock mode")
    }


    async OpenChannel(destination: string, closeAddress: string, fundingAmount: number, pushSats: number): Promise<string> {
        throw new Error("OpenChannel disabled in mock mode")
    }
}


