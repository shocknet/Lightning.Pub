//const grpc = require('@grpc/grpc-js');
import { credentials, Metadata } from '@grpc/grpc-js'
import { GrpcTransport } from "@protobuf-ts/grpc-transport";
import fs from 'fs'
import crypto from 'crypto'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { LightningClient } from '../../../proto/lnd/lightning.client.js'
import { InvoicesClient } from '../../../proto/lnd/invoices.client.js'
import { RouterClient } from '../../../proto/lnd/router.client.js'
import { GetInfoResponse, AddressType, NewAddressResponse, AddInvoiceResponse, Invoice_InvoiceState, PayReq, Payment_PaymentStatus, Payment, PaymentFailureReason, SendCoinsResponse, EstimateFeeResponse, TransactionDetails, ClosedChannelsResponse, ListChannelsResponse, PendingChannelsResponse, ListInvoiceResponse, ListPaymentsResponse } from '../../../proto/lnd/lightning.js'
import { OpenChannelReq } from './openChannelReq.js';
import { AddInvoiceReq } from './addInvoiceReq.js';
import { PayInvoiceReq } from './payInvoiceReq.js';
import { SendCoinsReq } from './sendCoinsReq.js';
import { LndSettings, AddressPaidCb, InvoicePaidCb, NodeInfo, Invoice, DecodedInvoice, PaidInvoice, NewBlockCb, BalanceInfo } from './settings.js';
import { getLogger } from '../helpers/logger.js';

export default class {
    invoicesAwaiting: Record<string /* invoice */, { value: number, memo: string, expiryUnix: number }> = {}
    settings: LndSettings
    abortController = new AbortController()
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    constructor(settings: LndSettings, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb, newBlockCb: NewBlockCb) {
        this.settings = settings
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
    }

    async SetMockInvoiceAsPaid(invoice: string, amount: number): Promise<void> {
        const decoded = await this.DecodeInvoice(invoice)
        if (decoded.numSatoshis && amount) {
            throw new Error("non zero amount provided to pay invoice but invoice has value already")
        }
        this.invoicePaidCb(invoice, decoded.numSatoshis || amount, false)
        delete this.invoicesAwaiting[invoice]
    }

    Stop() { }
    async Warmup() { }

    async ListClosedChannels(): Promise<ClosedChannelsResponse> { throw new Error("ListClosedChannels disabled in mock mode") }
    async ListChannels(): Promise<ListChannelsResponse> { throw new Error("ListChannels disabled in mock mode") }
    async ListPendingChannels(): Promise<PendingChannelsResponse> { throw new Error("ListPendingChannels disabled in mock mode") }
    async GetForwardingHistory(indexOffset: number): Promise<{ fee: number, chanIdIn: string, chanIdOut: string, timestampNs: number, offset: number }[]> { throw new Error("GetForwardingHistory disabled in mock mode") }

    async GetInfo(): Promise<NodeInfo> {
        return { alias: "mock", syncedToChain: true, syncedToGraph: true, blockHeight: 1, blockHash: "" }
    }

    async Health(): Promise<void> { }

    async NewAddress(addressType: Types.AddressType): Promise<NewAddressResponse> {
        throw new Error("NewAddress disabled in mock mode")
    }

    async NewInvoice(value: number, memo: string, expiry: number): Promise<Invoice> {
        const mockInvoice = "lnbcrtmockin" + crypto.randomBytes(32).toString('hex')
        this.invoicesAwaiting[mockInvoice] = { value, memo, expiryUnix: expiry + Date.now() / 1000 }
        return { payRequest: mockInvoice }
    }

    async DecodeInvoice(paymentRequest: string): Promise<DecodedInvoice> {
        if (paymentRequest.startsWith('lnbcrtmockout')) {
            const amt = this.decodeOutboundInvoice(paymentRequest)
            return { numSatoshis: amt, paymentHash: paymentRequest }
        }
        const i = this.invoicesAwaiting[paymentRequest]
        if (!i) {
            throw new Error("invoice not found")
        }
        return { numSatoshis: i.value, paymentHash: paymentRequest }
    }

    GetFeeLimitAmount(amount: number): number {
        return Math.ceil(amount * this.settings.feeRateLimit + this.settings.feeFixedLimit);
    }

    GetMaxWithinLimit(amount: number): number {
        return Math.max(0, Math.floor(amount * (1 - this.settings.feeRateLimit) - this.settings.feeFixedLimit))
    }

    decodeOutboundInvoice(invoice: string): number {
        if (!invoice.startsWith('lnbcrtmockout')) {
            throw new Error("invalid mock invoice provided for payment")
        }
        const amt = invoice.substring('lnbcrtmockout'.length).split("__")[0]
        if (isNaN(+amt)) {
            throw new Error("invalid mock invoice provided for payment")
        }
        return +amt
    }

    async PayInvoice(invoice: string, amount: number, feeLimit: number): Promise<PaidInvoice> {
        const log = getLogger({})
        log('payng', invoice)
        await new Promise(res => setTimeout(res, 200))
        const amt = this.decodeOutboundInvoice(invoice)
        log('paid', invoice)
        return { feeSat: 1, paymentPreimage: "all_good", valueSat: amt || amount }
    }

    async ChannelBalance(): Promise<{ local: number, remote: number }> {
        return { local: 100 * 1000 * 1000, remote: 100 * 1000 * 1000 }
    }

    async EstimateChainFees(address: string, amount: number, targetConf: number): Promise<EstimateFeeResponse> {
        throw new Error("EstimateChainFees disabled in mock mode")
    }

    async PayAddress(address: string, amount: number, satPerVByte: number, label = ""): Promise<SendCoinsResponse> {
        throw new Error("PayAddress disabled in mock mode")
    }


    async OpenChannel(destination: string, closeAddress: string, fundingAmount: number, pushSats: number): Promise<string> {
        throw new Error("OpenChannel disabled in mock mode")
    }

    async GetTransactions(startHeight: number): Promise<TransactionDetails> {
        throw new Error("GetTransactions disabled in mock mode")
    }

    GetBalance(): Promise<BalanceInfo> {
        throw new Error("GetBalance disabled in mock mode")
    }

    async GetAllPaidInvoices(max: number): Promise<ListInvoiceResponse> {
        throw new Error("not implemented")
    }
    async GetAllPayments(max: number): Promise<ListPaymentsResponse> {
        throw new Error("not implemented")
    }
    LockOutgoingOperations() {
        throw new Error("not implemented")
    }
    UnlockOutgoingOperations() {
        throw new Error("not implemented")
    }
}


