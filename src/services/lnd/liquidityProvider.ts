import newNostrClient from '../../../proto/autogenerated/ts/nostr_client.js'
import { NostrRequest } from '../../../proto/autogenerated/ts/nostr_transport.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { decodeNprofile } from '../../custom-nip19.js'
import { getLogger } from '../helpers/logger.js'
import { NostrEvent, NostrSend } from '../nostr/handler.js'
import { relayInit } from '../nostr/tools/relay.js'
import { InvoicePaidCb } from './settings.js'

export type LiquidityRequest = { action: 'spend' | 'receive', amount: number }

export type nostrCallback<T> = { startedAtMillis: number, type: 'single' | 'stream', f: (res: T) => void }
export class LiquidityProvider {
    client: ReturnType<typeof newNostrClient>
    clientCbs: Record<string, nostrCallback<any>> = {}
    clientId: string = ""
    myPub: string = ""
    log = getLogger({ component: 'liquidityProvider' })
    nostrSend: NostrSend | null = null
    ready = false
    pubDestination: string
    latestMaxWithdrawable: number | null = null
    invoicePaidCb: InvoicePaidCb
    connecting = false
    readyInterval: NodeJS.Timeout
    // make the sub process accept client
    constructor(pubDestination: string, invoicePaidCb: InvoicePaidCb) {
        if (!pubDestination) {
            this.log("No pub provider to liquidity provider, will not be initialized")
        }
        this.pubDestination = pubDestination
        this.invoicePaidCb = invoicePaidCb
        this.client = newNostrClient({
            pubDestination: this.pubDestination,
            retrieveNostrUserAuth: async () => this.myPub,
        }, this.clientSend, this.clientSub)

        this.readyInterval = setInterval(() => {
            if (this.ready) {
                clearInterval(this.readyInterval)
                this.Connect()
            }
        }, 1000)
    }

    Stop = () => {
        clearInterval(this.readyInterval)
    }

    Connect = async () => {
        await new Promise(res => setTimeout(res, 2000))
        this.log("ready")
        await this.CheckUserState()
        if (this.latestMaxWithdrawable === null) {
            return
        }
        this.log("subbing to user operations")
        this.client.GetLiveUserOperations(res => {
            console.log("got user operation", res)
            if (res.status === 'ERROR') {
                this.log("error getting user operations", res.reason)
                return
            }
            this.log("got user operation", res.operation)
            if (res.operation.type === Types.UserOperationType.INCOMING_INVOICE) {
                this.log("invoice was paid", res.operation.identifier)
                this.invoicePaidCb(res.operation.identifier, res.operation.amount, false)
            }
        })
    }

    CheckUserState = async () => {
        const res = await this.client.GetUserInfo()
        if (res.status === 'ERROR') {
            this.log("error getting user info", res)
            return
        }
        this.latestMaxWithdrawable = res.max_withdrawable
        this.log("latest provider balance:", res.max_withdrawable)
        return res
    }

    CanProviderHandle = (req: LiquidityRequest) => {
        if (this.latestMaxWithdrawable === null) {
            return false
        }
        if (req.action === 'spend') {
            return this.latestMaxWithdrawable > req.amount
        }
        return true
    }

    AddInvoice = async (amount: number, memo: string) => {
        const res = await this.client.NewInvoice({ amountSats: amount, memo })
        if (res.status === 'ERROR') {
            this.log("error creating invoice", res.reason)
            throw new Error(res.reason)
        }
        this.log("new invoice", res.invoice)
        this.CheckUserState()
        return res.invoice
    }

    PayInvoice = async (invoice: string) => {
        const res = await this.client.PayInvoice({ invoice, amount: 0 })
        if (res.status === 'ERROR') {
            this.log("error paying invoice", res.reason)
            throw new Error(res.reason)
        }
        this.log("paid invoice", res)
        this.CheckUserState()
        return res
    }

    setNostrInfo = ({ clientId, myPub }: { myPub: string, clientId: string }) => {
        this.clientId = clientId
        this.myPub = myPub
        this.setSetIfReady()
    }



    attachNostrSend(f: NostrSend) {
        this.nostrSend = f
        this.setSetIfReady()
    }

    setSetIfReady = () => {
        if (this.nostrSend && !!this.pubDestination && !!this.clientId && !!this.myPub) {
            this.ready = true
            this.log("ready to send to ", this.pubDestination)
        }
    }

    onEvent = async (res: { requestId: string }, fromPub: string) => {
        if (fromPub !== this.pubDestination) {
            this.log("got event from invalid pub", fromPub, this.pubDestination)
            return false
        }
        if (this.clientCbs[res.requestId]) {
            const cb = this.clientCbs[res.requestId]
            cb.f(res)
            if (cb.type === 'single') {
                delete this.clientCbs[res.requestId]
                this.log(this.getSingleSubs(), "single subs left")
            }
            return true
        }
        return false
    }

    clientSend = (to: string, message: NostrRequest): Promise<any> => {
        if (!this.ready || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = makeId(16)
        }
        const reqId = message.requestId
        if (this.clientCbs[reqId]) {
            throw new Error("request was already sent")
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })

        //this.nostrSend(this.relays, to, JSON.stringify(message), this.settings)

        this.log("subbing  to single send", reqId, message.rpcName || 'no rpc name')
        return new Promise(res => {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'single',
                f: (response: any) => { res(response) },
            }
        })
    }

    clientSub = (to: string, message: NostrRequest, cb: (res: any) => void): void => {
        if (!this.ready || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = message.rpcName
        }
        const reqId = message.requestId
        if (!reqId) {
            throw new Error("invalid sub")
        }
        if (this.clientCbs[reqId]) {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'stream',
                f: (response: any) => { cb(response) },
            }
            this.log("sub for", reqId, "was already registered, overriding")
            return
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })
        this.log("subbing  to stream", reqId)
        this.clientCbs[reqId] = {
            startedAtMillis: Date.now(),
            type: 'stream',
            f: (response: any) => { cb(response) }
        }
    }
    getSingleSubs = () => {
        return Object.entries(this.clientCbs).filter(([_, cb]) => cb.type === 'single')
    }
}

export const makeId = (length: number) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}