import newNostrClient from '../../../proto/autogenerated/ts/nostr_client.js'
import { NostrRequest } from '../../../proto/autogenerated/ts/nostr_transport.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { decodeNprofile } from '../../custom-nip19.js'
import { getLogger } from '../helpers/logger.js'
import { NostrEvent, NostrSend } from '../nostr/handler.js'
import { relayInit } from '../nostr/tools/relay.js'


export type nostrCallback<T> = { startedAtMillis: number, type: 'single' | 'stream', f: (res: T) => void }
export class LiquidityProvider {
    client: ReturnType<typeof newNostrClient>
    clientCbs: Record<string, nostrCallback<any>> = {}
    clientId: string = ""
    log = getLogger({ component: 'liquidityProvider' })
    nostrSend: NostrSend | null = null
    ready = false
    pubDestination: string

    // make the sub process accept client
    constructor(pubDestination: string) {
        if (!pubDestination) {
            this.log("No pub provider to liquidity provider, will not be initialized")
        }
        this.client = newNostrClient({
            pubDestination: pubDestination,
            retrieveNostrUserAuth: async () => "",
        }, this.clientSend, this.clientSub)

        const interval = setInterval(() => {
            if (this.ready) {
                this.log("ready")
                clearInterval(interval)
                this.client.GetUserInfo().then(res => {
                    if (res.status === 'ERROR') {
                        this.log("error getting user info", res)
                        return
                    }
                    this.log("got user info", res)
                })
            }
        }, 1000)
    }

    setClientId = (clientId: string) => {
        this.clientId = clientId
        if (this.nostrSend && this.pubDestination !== "") {
            this.ready = true
        }
    }

    attachNostrSend(f: NostrSend) {
        this.nostrSend = f
        if (this.clientId !== "" && this.pubDestination !== "") {
            this.ready = true
        }
    }

    IsReady = () => {
        return this.ready
    }

    onEvent = async (res: { requestId: string }, fromPub: string) => {
        if (fromPub !== this.pubDestination) {
            return false
        }
        if (this.clientCbs[res.requestId]) {
            const cb = this.clientCbs[res.requestId]
            cb.f(res)
            if (cb.type === 'single') {
                const deleteOk = (delete this.clientCbs[res.requestId])
                console.log(this.getSingleSubs(), "single subs left", deleteOk)
            }
            return true
        }
        return false
    }

    clientSend = (to: string, message: NostrRequest): Promise<any> => {
        if (!this.ready || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = makeId(16)
        }
        const reqId = message.requestId
        if (this.clientCbs[reqId]) {
            throw new Error("request was already sent")
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })

        //this.nostrSend(this.relays, to, JSON.stringify(message), this.settings)

        console.log("subbing  to single send", reqId, message.rpcName)
        return new Promise(res => {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'single',
                f: (response: any) => { res(response) },
            }
        })
    }

    clientSub = (to: string, message: NostrRequest, cb: (res: any) => void): void => {
        if (!this.ready || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = message.rpcName
        }
        const reqId = message.requestId
        if (!reqId) {
            throw new Error("invalid sub")
        }
        if (this.clientCbs[reqId]) {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'stream',
                f: (response: any) => { cb(response) },
            }
            console.log("sub for", reqId, "was already registered, overriding")
            return
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })
        console.log("subbing  to stream", reqId)
        this.clientCbs[reqId] = {
            startedAtMillis: Date.now(),
            type: 'stream',
            f: (response: any) => { cb(response) }
        }
    }
    getSingleSubs = () => {
        return Object.entries(this.clientCbs).filter(([_, cb]) => cb.type === 'single')
    }
}

export const makeId = (length: number) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}