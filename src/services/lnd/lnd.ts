//const grpc = require('@grpc/grpc-js');
import crypto from 'crypto'
import { credentials, Metadata } from '@grpc/grpc-js'
import { GrpcTransport } from "@protobuf-ts/grpc-transport";
import fs from 'fs'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { LightningClient } from '../../../proto/lnd/lightning.client.js'
import { InvoicesClient } from '../../../proto/lnd/invoices.client.js'
import { RouterClient } from '../../../proto/lnd/router.client.js'
import { ChainNotifierClient } from '../../../proto/lnd/chainnotifier.client.js'
import { GetInfoResponse, AddressType, NewAddressResponse, AddInvoiceResponse, Invoice_InvoiceState, PayReq, Payment_PaymentStatus, Payment, PaymentFailureReason, SendCoinsResponse, EstimateFeeResponse, ChannelBalanceResponse, TransactionDetails, ListChannelsResponse, ClosedChannelsResponse, PendingChannelsResponse, ForwardingHistoryResponse } from '../../../proto/lnd/lightning.js'
import { OpenChannelReq } from './openChannelReq.js';
import { AddInvoiceReq } from './addInvoiceReq.js';
import { PayInvoiceReq } from './payInvoiceReq.js';
import { SendCoinsReq } from './sendCoinsReq.js';
import { LndSettings, AddressPaidCb, InvoicePaidCb, NodeInfo, Invoice, DecodedInvoice, PaidInvoice, NewBlockCb, HtlcCb, BalanceInfo } from './settings.js';
import { getLogger } from '../helpers/logger.js';
import { HtlcEvent_EventType } from '../../../proto/lnd/router.js';
import { LiquidityProvider, LiquidityRequest } from '../main/liquidityProvider.js';
import { Utils } from '../helpers/utilsWrapper.js';
import { TxPointSettings } from '../storage/stateBundler.js';
const DeadLineMetadata = (deadline = 10 * 1000) => ({ deadline: Date.now() + deadline })
const deadLndRetrySeconds = 5
type TxActionOptions = { useProvider: boolean, from: 'user' | 'system' }
export default class {
    lightning: LightningClient
    invoices: InvoicesClient
    router: RouterClient
    chainNotifier: ChainNotifierClient
    settings: LndSettings
    ready = false
    latestKnownBlockHeigh = 0
    latestKnownSettleIndex = 0
    abortController = new AbortController()
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    newBlockCb: NewBlockCb
    htlcCb: HtlcCb
    log = getLogger({ component: 'lndManager' })
    outgoingOpsLocked = false
    liquidProvider: LiquidityProvider
    utils: Utils
    constructor(settings: LndSettings, liquidProvider: LiquidityProvider, utils: Utils, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb, newBlockCb: NewBlockCb, htlcCb: HtlcCb) {
        this.settings = settings
        this.utils = utils
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
        this.newBlockCb = newBlockCb
        this.htlcCb = htlcCb
        const { lndAddr, lndCertPath, lndMacaroonPath } = this.settings.mainNode
        const lndCert = fs.readFileSync(lndCertPath);
        const macaroon = fs.readFileSync(lndMacaroonPath).toString('hex');
        const sslCreds = credentials.createSsl(lndCert);
        const macaroonCreds = credentials.createFromMetadataGenerator(
            function (args: any, callback: any) {
                let metadata = new Metadata();
                metadata.add('macaroon', macaroon);
                callback(null, metadata);
            },
        );
        const creds = credentials.combineChannelCredentials(
            sslCreds,
            macaroonCreds,
        );
        const transport = new GrpcTransport({ host: lndAddr, channelCredentials: creds })
        this.lightning = new LightningClient(transport)
        this.invoices = new InvoicesClient(transport)
        this.router = new RouterClient(transport)
        this.chainNotifier = new ChainNotifierClient(transport)
        this.liquidProvider = liquidProvider
    }

    LockOutgoingOperations(): void {
        this.outgoingOpsLocked = true
    }
    UnlockOutgoingOperations(): void {
        this.outgoingOpsLocked = false
    }

    SetMockInvoiceAsPaid(invoice: string, amount: number): Promise<void> {
        throw new Error("SetMockInvoiceAsPaid only available in mock mode")
    }
    Stop() {
        this.abortController.abort()
        this.liquidProvider.Stop()
    }

    async Warmup() {
        this.SubscribeAddressPaid()
        this.SubscribeInvoicePaid()
        this.SubscribeNewBlock()
        this.SubscribeHtlcEvents()
        const now = Date.now()
        return new Promise<void>((res, rej) => {
            const interval = setInterval(async () => {
                try {
                    await this.GetInfo()
                    clearInterval(interval)
                    this.ready = true
                    res()
                } catch (err) {
                    this.log("LND is not ready yet, will try again in 1 second")
                    if (Date.now() - now > 1000 * 60) {
                        rej(new Error("LND not ready after 1 minute"))
                    }
                }
            }, 1000)
        })
    }

    async GetInfo(): Promise<NodeInfo> {
        const res = await this.lightning.getInfo({}, DeadLineMetadata())
        return res.response
    }
    async ListPendingChannels(): Promise<PendingChannelsResponse> {
        const res = await this.lightning.pendingChannels({}, DeadLineMetadata())
        return res.response
    }
    async ListChannels(): Promise<ListChannelsResponse> {
        const res = await this.lightning.listChannels({
            activeOnly: false, inactiveOnly: false, privateOnly: false, publicOnly: false, peer: Buffer.alloc(0)
        }, DeadLineMetadata())
        return res.response
    }
    async ListClosedChannels(): Promise<ClosedChannelsResponse> {
        const res = await this.lightning.closedChannels({
            abandoned: true,
            breach: true,
            cooperative: true,
            fundingCanceled: true,
            localForce: true,
            remoteForce: true
        }, DeadLineMetadata())
        return res.response
    }

    async Health(): Promise<void> {
        if (!this.ready) {
            throw new Error("not ready")
        }
        const info = await this.GetInfo()
        if (!info.syncedToChain || !info.syncedToGraph) {
            throw new Error("not synced")
        }
    }

    RestartStreams() {
        if (!this.ready) {
            return
        }
        this.log("LND is dead, will try to reconnect in", deadLndRetrySeconds, "seconds")
        const interval = setInterval(async () => {
            try {
                await this.Health()
                this.log("LND is back online")
                clearInterval(interval)
                this.Warmup()
            } catch (err) {
                this.log("LND still dead, will try again in", deadLndRetrySeconds, "seconds")
            }
        }, deadLndRetrySeconds * 1000)
    }

    async SubscribeHtlcEvents() {
        const stream = this.router.subscribeHtlcEvents({}, { abort: this.abortController.signal })
        stream.responses.onMessage(htlc => {
            this.htlcCb(htlc)
        })
        stream.responses.onError(error => {
            this.log("Error with subscribeHtlcEvents stream")
        })
        stream.responses.onComplete(() => {
            this.log("subscribeHtlcEvents stream closed")
        })
    }

    async SubscribeNewBlock() {
        const { blockHeight } = await this.GetInfo()
        const stream = this.chainNotifier.registerBlockEpochNtfn({ height: blockHeight, hash: Buffer.alloc(0) }, { abort: this.abortController.signal })
        stream.responses.onMessage(block => {
            this.newBlockCb(block.height)
        })
        stream.responses.onError(error => {
            this.log("Error with onchain tx stream")
        })
        stream.responses.onComplete(() => {
            this.log("onchain tx stream closed")
        })
    }

    SubscribeAddressPaid(): void {
        const stream = this.lightning.subscribeTransactions({
            account: "",
            endHeight: 0,
            startHeight: this.latestKnownBlockHeigh,
        }, { abort: this.abortController.signal })
        stream.responses.onMessage(tx => {
            if (tx.blockHeight > this.latestKnownBlockHeigh) {
                this.latestKnownBlockHeigh = tx.blockHeight
            }
            if (tx.numConfirmations === 0) { // only process pending transactions, confirmed transaction are processed by the newBlock CB
                tx.outputDetails.forEach(output => {
                    if (output.isOurAddress) {
                        this.addressPaidCb({ hash: tx.txHash, index: Number(output.outputIndex) }, output.address, Number(output.amount), 'lnd')
                    }
                })
            }
        })
        stream.responses.onError(error => {
            this.log("Error with onchain tx stream")
        })
        stream.responses.onComplete(() => {
            this.log("onchain tx stream closed")
        })
    }

    SubscribeInvoicePaid(): void {
        const stream = this.lightning.subscribeInvoices({
            settleIndex: BigInt(this.latestKnownSettleIndex),
            addIndex: 0n,
        }, { abort: this.abortController.signal })
        stream.responses.onMessage(invoice => {
            if (invoice.state === Invoice_InvoiceState.SETTLED) {
                this.latestKnownSettleIndex = Number(invoice.settleIndex)
                this.invoicePaidCb(invoice.paymentRequest, Number(invoice.amtPaidSat), 'lnd')
            }
        })
        stream.responses.onError(error => {
            this.log("Error with invoice stream")
        })
        stream.responses.onComplete(() => {
            this.log("invoice stream closed")
            this.RestartStreams()
        })
    }

    async NewAddress(addressType: Types.AddressType, { useProvider, from }: TxActionOptions): Promise<NewAddressResponse> {

        await this.Health()
        let lndAddressType: AddressType
        switch (addressType) {
            case Types.AddressType.NESTED_PUBKEY_HASH:
                lndAddressType = AddressType.NESTED_PUBKEY_HASH
                break;
            case Types.AddressType.WITNESS_PUBKEY_HASH:
                lndAddressType = AddressType.WITNESS_PUBKEY_HASH
                break;
            case Types.AddressType.TAPROOT_PUBKEY:
                lndAddressType = AddressType.TAPROOT_PUBKEY
                break;
            default:
                throw new Error("unknown address type " + addressType)
        }
        if (useProvider) {
            throw new Error("provider payments not support chain payments yet")
        }
        try {
            const res = await this.lightning.newAddress({ account: "", type: lndAddressType }, DeadLineMetadata())
            this.utils.stateBundler.AddTxPoint('addedAddress', 1, { from, used: 'lnd' })
            return res.response
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('addedAddress', 1, { from, used: 'lnd' })
            throw err
        }
    }

    async NewInvoice(value: number, memo: string, expiry: number, { useProvider, from }: TxActionOptions): Promise<Invoice> {
        await this.Health()
        if (useProvider) {
            const invoice = await this.liquidProvider.AddInvoice(value, memo, from)
            const providerDst = this.liquidProvider.GetProviderDestination()
            return { payRequest: invoice, providerDst }
        }
        try {
            const res = await this.lightning.addInvoice(AddInvoiceReq(value, expiry, true, memo), DeadLineMetadata())
            this.utils.stateBundler.AddTxPoint('addedInvoice', value, { from, used: 'lnd' })
            return { payRequest: res.response.paymentRequest }
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('addedInvoice', value, { from, used: 'lnd' })
            throw err
        }
    }

    async DecodeInvoice(paymentRequest: string): Promise<DecodedInvoice> {
        const res = await this.lightning.decodePayReq({ payReq: paymentRequest }, DeadLineMetadata())
        return { numSatoshis: Number(res.response.numSatoshis), paymentHash: res.response.paymentHash }
    }

    GetFeeLimitAmount(amount: number): number {
        return Math.ceil(amount * this.settings.feeRateLimit + this.settings.feeFixedLimit);
    }

    GetMaxWithinLimit(amount: number): number {
        return Math.max(0, Math.floor(amount * (1 - this.settings.feeRateLimit) - this.settings.feeFixedLimit))
    }

    async ChannelBalance(): Promise<{ local: number, remote: number }> {
        const res = await this.lightning.channelBalance({})
        const r = res.response
        return { local: r.localBalance ? Number(r.localBalance.sat) : 0, remote: r.remoteBalance ? Number(r.remoteBalance.sat) : 0 }
    }
    async PayInvoice(invoice: string, amount: number, feeLimit: number, decodedAmount: number, { useProvider, from }: TxActionOptions): Promise<PaidInvoice> {
        if (this.outgoingOpsLocked) {
            this.log("outgoing ops locked, rejecting payment request")
            throw new Error("lnd node is currently out of sync")
        }
        await this.Health()
        if (useProvider) {
            const res = await this.liquidProvider.PayInvoice(invoice, decodedAmount, from)
            const providerDst = this.liquidProvider.GetProviderDestination()
            return { feeSat: res.network_fee + res.service_fee, valueSat: res.amount_paid, paymentPreimage: res.preimage, providerDst }
        }
        try {
            const abortController = new AbortController()
            const req = PayInvoiceReq(invoice, amount, feeLimit)
            const stream = this.router.sendPaymentV2(req, { abort: abortController.signal })
            return new Promise((res, rej) => {
                stream.responses.onError(error => {
                    this.log("invoice payment failed", error)
                    rej(error)
                })
                stream.responses.onMessage(payment => {
                    switch (payment.status) {
                        case Payment_PaymentStatus.FAILED:
                            console.log(payment)
                            this.log("invoice payment failed", payment.failureReason)
                            rej(PaymentFailureReason[payment.failureReason])
                            return
                        case Payment_PaymentStatus.SUCCEEDED:
                            this.utils.stateBundler.AddTxPoint('paidAnInvoice', Number(payment.valueSat), { from, used: 'lnd', timeDiscount: true })
                            res({ feeSat: Math.ceil(Number(payment.feeMsat) / 1000), valueSat: Number(payment.valueSat), paymentPreimage: payment.paymentPreimage })
                            return
                    }
                })
            })
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('paidAnInvoice', decodedAmount, { from, used: 'lnd' })
            throw err
        }

    }

    async EstimateChainFees(address: string, amount: number, targetConf: number): Promise<EstimateFeeResponse> {
        await this.Health()
        const res = await this.lightning.estimateFee({
            addrToAmount: { [address]: BigInt(amount) },
            minConfs: 1,
            spendUnconfirmed: false,
            targetConf: targetConf
        })
        return res.response
    }

    async PayAddress(address: string, amount: number, satPerVByte: number, label = "", { useProvider, from }: TxActionOptions): Promise<SendCoinsResponse> {
        if (this.outgoingOpsLocked) {
            this.log("outgoing ops locked, rejecting payment request")
            throw new Error("lnd node is currently out of sync")
        }
        if (useProvider) {
            throw new Error("provider payments not support chain payments yet")
        }
        try {
            await this.Health()
            const res = await this.lightning.sendCoins(SendCoinsReq(address, amount, satPerVByte, label), DeadLineMetadata())
            this.utils.stateBundler.AddTxPoint('paidAnAddress', amount, { from, used: 'lnd', timeDiscount: true })
            return res.response
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('paidAnAddress', amount, { from, used: 'lnd' })
            throw err
        }
    }

    async GetTransactions(startHeight: number): Promise<TransactionDetails> {
        await this.Health()
        const res = await this.lightning.getTransactions({ startHeight, endHeight: 0, account: "" }, DeadLineMetadata())
        return res.response
    }

    async GetChannelBalance() {
        const res = await this.lightning.channelBalance({}, DeadLineMetadata())
        return res.response
    }

    async GetWalletBalance() {
        const res = await this.lightning.walletBalance({}, DeadLineMetadata())
        return res.response
    }

    async GetTotalBalace() {
        const walletBalance = await this.GetWalletBalance()
        const confirmedWalletBalance = Number(walletBalance.confirmedBalance)
        this.utils.stateBundler.AddBalancePoint('walletBalance', confirmedWalletBalance)
        const channelsBalance = await this.GetChannelBalance()
        const totalLightningBalanceMsats = (channelsBalance.localBalance?.msat || 0n) + (channelsBalance.unsettledLocalBalance?.msat || 0n)
        const totalLightningBalance = Math.ceil(Number(totalLightningBalanceMsats) / 1000)
        this.utils.stateBundler.AddBalancePoint('channelBalance', totalLightningBalance)
        const totalLndBalance = confirmedWalletBalance + totalLightningBalance
        this.utils.stateBundler.AddBalancePoint('totalLndBalance', totalLndBalance)
        return totalLndBalance
    }

    async GetBalance(): Promise<BalanceInfo> { // TODO: remove this
        const wRes = await this.lightning.walletBalance({}, DeadLineMetadata())
        const { confirmedBalance, unconfirmedBalance, totalBalance } = wRes.response
        const { response } = await this.lightning.listChannels({
            activeOnly: false, inactiveOnly: false, privateOnly: false, publicOnly: false, peer: Buffer.alloc(0)
        }, DeadLineMetadata())
        const channelsBalance = response.channels.map(c => ({
            channelId: c.chanId,
            localBalanceSats: Number(c.localBalance),
            remoteBalanceSats: Number(c.remoteBalance),
            htlcs: c.pendingHtlcs.map(htlc => ({ incoming: htlc.incoming, amount: Number(htlc.amount), index: Number(htlc.htlcIndex), fwIndex: Number(htlc.forwardingHtlcIndex) }))
        }))
        return { confirmedBalance: Number(confirmedBalance), unconfirmedBalance: Number(unconfirmedBalance), totalBalance: Number(totalBalance), channelsBalance }
    }

    async GetForwardingHistory(indexOffset: number, startTime = 0): Promise<ForwardingHistoryResponse> {
        const { response } = await this.lightning.forwardingHistory({ indexOffset, numMaxEvents: 0, startTime: BigInt(startTime), endTime: 0n, peerAliasLookup: false }, DeadLineMetadata())
        return response
    }

    async GetAllPaidInvoices(max: number) {
        const res = await this.lightning.listInvoices({ indexOffset: 0n, numMaxInvoices: BigInt(max), pendingOnly: false, reversed: true }, DeadLineMetadata())
        return res.response
    }
    async GetAllPayments(max: number) {
        const res = await this.lightning.listPayments({ countTotalPayments: false, includeIncomplete: false, indexOffset: 0n, maxPayments: BigInt(max), reversed: true })
        return res.response
    }

    async ConnectPeer(addr: { pubkey: string, host: string }) {
        const res = await this.lightning.connectPeer({
            addr,
            perm: true,
            timeout: 0n
        }, DeadLineMetadata())
        return res.response
    }

    async ListPeers() {
        const res = await this.lightning.listPeers({ latestError: true }, DeadLineMetadata())
        return res.response
    }

    async OpenChannel(destination: string, closeAddress: string, fundingAmount: number, pushSats: number) {
        const abortController = new AbortController()
        const req = OpenChannelReq(destination, closeAddress, fundingAmount, pushSats)
        const stream = this.lightning.openChannel(req, { abort: abortController.signal })
        return new Promise((res, rej) => {
            stream.responses.onMessage(message => {
                console.log("message", message)
                switch (message.update.oneofKind) {
                    case 'chanPending':
                        res(Buffer.from(message.pendingChanId).toString('base64'))
                        break
                }
            })
            stream.responses.onError(error => {
                console.log("error", error)
                rej(error)
            })
        })
    }
}
