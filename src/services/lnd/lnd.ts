//const grpc = require('@grpc/grpc-js');
import crypto from 'crypto'
import { credentials, Metadata } from '@grpc/grpc-js'
import { GrpcTransport } from "@protobuf-ts/grpc-transport";
import fs from 'fs'
import { decode as decodeBolt11 } from 'light-bolt11-decoder'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { LightningClient } from '../../../proto/lnd/lightning.client.js'
import { InvoicesClient } from '../../../proto/lnd/invoices.client.js'
import { RouterClient } from '../../../proto/lnd/router.client.js'
import { ChainNotifierClient } from '../../../proto/lnd/chainnotifier.client.js'
import { GetInfoResponse, AddressType, NewAddressResponse, AddInvoiceResponse, Invoice_InvoiceState, PayReq, Payment_PaymentStatus, Payment, PaymentFailureReason, SendCoinsResponse, EstimateFeeResponse, ChannelBalanceResponse, TransactionDetails, ListChannelsResponse, ClosedChannelsResponse, PendingChannelsResponse, ForwardingHistoryResponse, CoinSelectionStrategy, OpenStatusUpdate, CloseStatusUpdate, PendingUpdate, ChannelEventUpdate_UpdateType } from '../../../proto/lnd/lightning.js'
import { OpenChannelReq } from './openChannelReq.js';
import { AddInvoiceReq } from './addInvoiceReq.js';
import { PayInvoiceReq } from './payInvoiceReq.js';
import { SendCoinsReq } from './sendCoinsReq.js';
import { AddressPaidCb, InvoicePaidCb, NodeInfo, Invoice, DecodedInvoice, PaidInvoice, NewBlockCb, HtlcCb, BalanceInfo, ChannelEventCb } from './settings.js';
import { ERROR, getLogger } from '../helpers/logger.js';
import { HtlcEvent_EventType } from '../../../proto/lnd/router.js';
import { LiquidityProvider } from '../main/liquidityProvider.js';
import { Utils } from '../helpers/utilsWrapper.js';
import { TxPointSettings } from '../storage/tlv/stateBundler.js';
import { WalletKitClient } from '../../../proto/lnd/walletkit.client.js';
import SettingsManager from '../main/settingsManager.js';
import { LndNodeSettings, LndSettings } from '../main/settings.js';

const DeadLineMetadata = (deadline = 10 * 1000) => ({ deadline: Date.now() + deadline })
const deadLndRetrySeconds = 20
type TxActionOptions = { useProvider: boolean, from: 'user' | 'system' }
type NodeSettingsOverride = {
    lndAddr: string
    lndCertPath: string
    lndMacaroonPath: string
}
export default class {
    lightning: LightningClient
    invoices: InvoicesClient
    router: RouterClient
    chainNotifier: ChainNotifierClient
    walletKit: WalletKitClient
    getSettings: () => { lndSettings: LndSettings, lndNodeSettings: LndNodeSettings }
    ready = false
    latestKnownBlockHeigh = 0
    latestKnownSettleIndex = 0
    abortController = new AbortController()
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    newBlockCb: NewBlockCb
    htlcCb: HtlcCb
    channelEventCb: ChannelEventCb
    log = getLogger({ component: 'lndManager' })
    outgoingOpsLocked = false
    liquidProvider: LiquidityProvider
    utils: Utils
    unlockLnd: () => Promise<void>
    constructor(getSettings: () => { lndSettings: LndSettings, lndNodeSettings: LndNodeSettings }, liquidProvider: LiquidityProvider, unlockLnd: () => Promise<any>, utils: Utils, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb, newBlockCb: NewBlockCb, htlcCb: HtlcCb, channelEventCb: ChannelEventCb) {
        this.getSettings = getSettings
        this.utils = utils
        this.unlockLnd = unlockLnd
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
        this.newBlockCb = newBlockCb
        this.htlcCb = htlcCb
        this.channelEventCb = channelEventCb
        this.liquidProvider = liquidProvider

        // Skip LND client initialization if using only liquidity provider
        if (liquidProvider.getSettings().useOnlyLiquidityProvider) {
            this.log("USE_ONLY_LIQUIDITY_PROVIDER enabled, skipping LND client initialization")
            // Create minimal dummy clients - they won't be used but prevent null reference errors
            // Use insecure credentials directly (can't combine them)
            const { lndAddr } = this.getSettings().lndNodeSettings
            const insecureCreds = credentials.createInsecure()
            const dummyTransport = new GrpcTransport({ host: lndAddr || '127.0.0.1:10009', channelCredentials: insecureCreds })
            this.lightning = new LightningClient(dummyTransport)
            this.invoices = new InvoicesClient(dummyTransport)
            this.router = new RouterClient(dummyTransport)
            this.chainNotifier = new ChainNotifierClient(dummyTransport)
            this.walletKit = new WalletKitClient(dummyTransport)
            return
        }

        const { lndAddr, lndCertPath, lndMacaroonPath } = this.getSettings().lndNodeSettings
        const lndCert = fs.readFileSync(lndCertPath);
        const macaroon = fs.readFileSync(lndMacaroonPath).toString('hex');
        const sslCreds = credentials.createSsl(lndCert);
        const macaroonCreds = credentials.createFromMetadataGenerator(
            function (args: any, callback: any) {
                let metadata = new Metadata();
                metadata.add('macaroon', macaroon);
                callback(null, metadata);
            },
        );
        const creds = credentials.combineChannelCredentials(
            sslCreds,
            macaroonCreds,
        );
        const transport = new GrpcTransport({
            host: lndAddr, channelCredentials: creds, clientOptions: {
                //"grpc.ssl_target_name_override"
            }
        })
        this.lightning = new LightningClient(transport)
        this.invoices = new InvoicesClient(transport)
        this.router = new RouterClient(transport)
        this.chainNotifier = new ChainNotifierClient(transport)
        this.walletKit = new WalletKitClient(transport)
    }

    LockOutgoingOperations(): void {
        this.outgoingOpsLocked = true
    }
    UnlockOutgoingOperations(): void {
        this.outgoingOpsLocked = false
    }

    SetMockInvoiceAsPaid(invoice: string, amount: number): Promise<void> {
        throw new Error("SetMockInvoiceAsPaid only available in mock mode")
    }
    Stop() {
        this.abortController.abort()
        this.liquidProvider.Stop()
    }

    async Warmup() {
        // Skip LND warmup if using only liquidity provider
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            this.log("USE_ONLY_LIQUIDITY_PROVIDER enabled, skipping LND warmup")
            this.ready = true
            return
        }
        // console.log("Warming up LND")
        this.SubscribeAddressPaid()
        this.SubscribeInvoicePaid()
        await this.SubscribeNewBlock()
        this.SubscribeHtlcEvents()
        this.SubscribeChannelEvents()
        const now = Date.now()
        return new Promise<void>((res, rej) => {
            const interval = setInterval(async () => {
                try {
                    await this.GetInfo()
                    clearInterval(interval)
                    this.ready = true
                    res()
                } catch (err) {
                    this.log("LND is not ready yet, will try again in 1 second")
                    if (Date.now() - now > 1000 * 60) {
                        rej(new Error("LND not ready after 1 minute"))
                    }
                }
            }, 1000)
        })
    }

    async GetInfo(): Promise<NodeInfo> {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            // Return dummy info when bypass is enabled
            return {
                identityPubkey: '',
                alias: '',
                syncedToChain: false,
                syncedToGraph: false,
                blockHeight: 0,
                blockHash: '',
                uris: []
            }
        }
        // console.log("Getting info")
        const res = await this.lightning.getInfo({}, DeadLineMetadata())
        return res.response
    }
    async ListPendingChannels(): Promise<PendingChannelsResponse> {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return { pendingOpenChannels: [], pendingClosingChannels: [], pendingForceClosingChannels: [], waitingCloseChannels: [], totalLimboBalance: 0n }
        }
        // console.log("Listing pending channels")
        const res = await this.lightning.pendingChannels({ includeRawTx: false }, DeadLineMetadata())
        return res.response
    }
    async ListChannels(peerLookup = false): Promise<ListChannelsResponse> {
        // console.log("Listing channels")
        const res = await this.lightning.listChannels({
            activeOnly: false, inactiveOnly: false, privateOnly: false, publicOnly: false, peer: Buffer.alloc(0), peerAliasLookup: peerLookup
        }, DeadLineMetadata())
        return res.response
    }
    async ListClosedChannels(): Promise<ClosedChannelsResponse> {
        // console.log("Listing closed channels")
        const res = await this.lightning.closedChannels({
            abandoned: true,
            breach: true,
            cooperative: true,
            fundingCanceled: true,
            localForce: true,
            remoteForce: true
        }, DeadLineMetadata())
        return res.response
    }

    async Health(): Promise<void> {
        // Skip health check when bypass is enabled
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return
        }
        // console.log("Checking health")
        if (!this.ready) {
            throw new Error("not ready")
        }
        const info = await this.GetInfo()
        if (!info.syncedToChain || !info.syncedToGraph) {
            throw new Error("not synced")
        }
    }

    RestartStreams() {
        // console.log("Restarting streams")
        if (!this.ready || this.abortController.signal.aborted) {
            return
        }
        this.log("LND is dead, will try to reconnect in", deadLndRetrySeconds, "seconds")
        const interval = setInterval(async () => {
            try {
                await this.unlockLnd()
                this.log("LND is back online")
                clearInterval(interval)
                await this.Warmup()
            } catch (err) {
                this.log("LND still dead, will try again in", deadLndRetrySeconds, "seconds")
            }
        }, deadLndRetrySeconds * 1000)
    }

    async SubscribeChannelEvents() {
        // console.log("Subscribing to channel events")
        const stream = this.lightning.subscribeChannelEvents({}, { abort: this.abortController.signal })
        stream.responses.onMessage(async channel => {
            const channels = await this.ListChannels()
            this.channelEventCb(channel, channels.channels)
        })
        stream.responses.onError(error => {
            this.log("Error with subscribeChannelEvents stream")
        })
        stream.responses.onComplete(() => {
            this.log("subscribeChannelEvents stream closed")
        })
    }

    async SubscribeHtlcEvents() {
        // console.log("Subscribing to htlc events")
        const stream = this.router.subscribeHtlcEvents({}, { abort: this.abortController.signal })
        stream.responses.onMessage(htlc => {
            this.htlcCb(htlc)
        })
        stream.responses.onError(error => {
            this.log("Error with subscribeHtlcEvents stream")
        })
        stream.responses.onComplete(() => {
            this.log("subscribeHtlcEvents stream closed")
        })
    }

    async SubscribeNewBlock() {
        // console.log("Subscribing to new block")
        const { blockHeight } = await this.GetInfo()
        const stream = this.chainNotifier.registerBlockEpochNtfn({ height: blockHeight, hash: Buffer.alloc(0) }, { abort: this.abortController.signal })
        stream.responses.onMessage(block => {
            this.newBlockCb(block.height)
        })
        stream.responses.onError(error => {
            this.log("Error with new block stream")
        })
        stream.responses.onComplete(() => {
            this.log("new block stream closed")
        })
    }

    SubscribeAddressPaid(): void {
        // console.log("Subscribing to address paid")
        const stream = this.lightning.subscribeTransactions({
            account: "",
            endHeight: 0,
            startHeight: this.latestKnownBlockHeigh,
        }, { abort: this.abortController.signal })
        stream.responses.onMessage(tx => {
            if (tx.blockHeight > this.latestKnownBlockHeigh) {
                this.latestKnownBlockHeigh = tx.blockHeight
            }
            if (tx.numConfirmations === 0) { // only process pending transactions, confirmed transaction are processed by the newBlock CB
                tx.outputDetails.forEach(output => {
                    if (output.isOurAddress) {
                        this.addressPaidCb({ hash: tx.txHash, index: Number(output.outputIndex) }, output.address, Number(output.amount), 'lnd')
                    }
                })
            }
        })
        stream.responses.onError(error => {
            this.log("Error with onchain tx stream")
        })
        stream.responses.onComplete(() => {
            this.log("onchain tx stream closed")
        })
    }

    SubscribeInvoicePaid(): void {
        // console.log("Subscribing to invoice paid")
        const stream = this.lightning.subscribeInvoices({
            settleIndex: BigInt(this.latestKnownSettleIndex),
            addIndex: 0n,
        }, { abort: this.abortController.signal })
        stream.responses.onMessage(invoice => {
            if (invoice.state === Invoice_InvoiceState.SETTLED) {
                this.latestKnownSettleIndex = Number(invoice.settleIndex)
                this.invoicePaidCb(invoice.paymentRequest, Number(invoice.amtPaidSat), 'lnd')
            }
        })
        let restarted = false
        stream.responses.onError(error => {
            this.log("Error with invoice stream")
            if (!restarted) {
                restarted = true
                this.RestartStreams()
            }
        })
        stream.responses.onComplete(() => {
            this.log("invoice stream closed")
            if (!restarted) {
                restarted = true
                this.RestartStreams()
            }
        })
    }

    async NewAddress(addressType: Types.AddressType, { useProvider, from }: TxActionOptions): Promise<NewAddressResponse> {
        // Force use of provider when bypass is enabled (addresses not supported by provider, but we should fail gracefully)
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            throw new Error("Address generation not supported when USE_ONLY_LIQUIDITY_PROVIDER is enabled")
        }
        //  console.log("Creating new address")
        let lndAddressType: AddressType
        switch (addressType) {
            case Types.AddressType.NESTED_PUBKEY_HASH:
                lndAddressType = AddressType.NESTED_PUBKEY_HASH
                break;
            case Types.AddressType.WITNESS_PUBKEY_HASH:
                lndAddressType = AddressType.WITNESS_PUBKEY_HASH
                break;
            case Types.AddressType.TAPROOT_PUBKEY:
                lndAddressType = AddressType.TAPROOT_PUBKEY
                break;
            default:
                throw new Error("unknown address type " + addressType)
        }
        if (useProvider) {
            throw new Error("provider payments not support chain payments yet")
        }
        await this.Health()
        try {
            const res = await this.lightning.newAddress({ account: "", type: lndAddressType }, DeadLineMetadata())
            this.utils.stateBundler.AddTxPoint('addedAddress', 1, { from, used: 'lnd' })
            return res.response
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('addedAddress', 1, { from, used: 'lnd' })
            throw err
        }
    }

    async NewInvoice(value: number, memo: string, expiry: number, { useProvider, from }: TxActionOptions, blind = false): Promise<Invoice> {
        // console.log("Creating new invoice")
        // Force use of provider when bypass is enabled
        const mustUseProvider = this.liquidProvider.getSettings().useOnlyLiquidityProvider || useProvider
        if (mustUseProvider) {
            console.log("using provider")
            const invoice = await this.liquidProvider.AddInvoice(value, memo, from, expiry)
            const providerDst = this.liquidProvider.GetProviderDestination()
            return { payRequest: invoice, providerDst }
        }
        try {
            const res = await this.lightning.addInvoice(AddInvoiceReq(value, expiry, true, memo, blind), DeadLineMetadata())
            this.utils.stateBundler.AddTxPoint('addedInvoice', value, { from, used: 'lnd' })
            return { payRequest: res.response.paymentRequest }
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('addedInvoice', value, { from, used: 'lnd' })
            throw err
        }
    }

    async DecodeInvoice(paymentRequest: string): Promise<DecodedInvoice> {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            // Use light-bolt11-decoder when LND is bypassed
            try {
                const decoded = decodeBolt11(paymentRequest)
                let numSatoshis = 0
                let paymentHash = ''

                for (const section of decoded.sections) {
                    if (section.name === 'amount') {
                        // Amount is in millisatoshis
                        numSatoshis = Math.floor(Number(section.value) / 1000)
                    } else if (section.name === 'payment_hash') {
                        paymentHash = section.value as string
                    }
                }

                if (!paymentHash) {
                    throw new Error("Payment hash not found in invoice")
                }

                return { numSatoshis, paymentHash }
            } catch (err: any) {
                throw new Error(`Failed to decode invoice: ${err.message}`)
            }
        }
        // console.log("Decoding invoice")
        const res = await this.lightning.decodePayReq({ payReq: paymentRequest }, DeadLineMetadata())
        return { numSatoshis: Number(res.response.numSatoshis), paymentHash: res.response.paymentHash }
    }

    async ChannelBalance(): Promise<{ local: number, remote: number }> {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return { local: 0, remote: 0 }
        }
        // console.log("Getting channel balance")
        const res = await this.lightning.channelBalance({})
        const r = res.response
        return { local: r.localBalance ? Number(r.localBalance.sat) : 0, remote: r.remoteBalance ? Number(r.remoteBalance.sat) : 0 }
    }
    async PayInvoice(invoice: string, amount: number, feeLimit: number, decodedAmount: number, { useProvider, from }: TxActionOptions, paymentIndexCb?: (index: number) => void): Promise<PaidInvoice> {
        // console.log("Paying invoice")
        if (this.outgoingOpsLocked) {
            this.log("outgoing ops locked, rejecting payment request")
            throw new Error("lnd node is currently out of sync")
        }
        // Force use of provider when bypass is enabled
        const mustUseProvider = this.liquidProvider.getSettings().useOnlyLiquidityProvider || useProvider
        if (mustUseProvider) {
            const res = await this.liquidProvider.PayInvoice(invoice, decodedAmount, from, feeLimit)
            const providerDst = this.liquidProvider.GetProviderDestination()
            return { feeSat: res.service_fee, valueSat: res.amount_paid, paymentPreimage: res.preimage, providerDst }
        }
        await this.Health()
        try {
            const abortController = new AbortController()
            const req = PayInvoiceReq(invoice, amount, feeLimit)
            const stream = this.router.sendPaymentV2(req, { abort: abortController.signal })
            return new Promise((res, rej) => {
                stream.responses.onError(error => {
                    this.log("invoice payment failed", error)
                    rej(error)
                })
                let indexSent = false
                stream.responses.onMessage(payment => {
                    const indexNum = Number(payment.paymentIndex)
                    if (!indexSent && indexNum > 0) {
                        indexSent = true
                        paymentIndexCb?.(Number(payment.paymentIndex))
                    }
                    switch (payment.status) {
                        case Payment_PaymentStatus.FAILED:
                            this.log("invoice payment failed", payment.failureReason)
                            rej(PaymentFailureReason[payment.failureReason])
                            return
                        case Payment_PaymentStatus.SUCCEEDED:
                            this.utils.stateBundler.AddTxPoint('paidAnInvoice', Number(payment.valueSat), { from, used: 'lnd', timeDiscount: true })
                            res({ feeSat: Math.ceil(Number(payment.feeMsat) / 1000), valueSat: Number(payment.valueSat), paymentPreimage: payment.paymentPreimage })
                            return
                    }
                })
            })
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('paidAnInvoice', decodedAmount, { from, used: 'lnd' })
            throw err
        }

    }

    async EstimateChainFees(address: string, amount: number, targetConf: number): Promise<EstimateFeeResponse> {
        // console.log("Estimating chain fees")
        await this.Health()
        const res = await this.lightning.estimateFee({
            addrToAmount: { [address]: BigInt(amount) },
            minConfs: 1,
            spendUnconfirmed: false,
            targetConf: targetConf,
            coinSelectionStrategy: CoinSelectionStrategy.STRATEGY_LARGEST
        })
        return res.response
    }

    async PayAddress(address: string, amount: number, satPerVByte: number, label = "", { useProvider, from }: TxActionOptions): Promise<SendCoinsResponse> {
        // Address payments not supported when bypass is enabled
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            throw new Error("Address payments not supported when USE_ONLY_LIQUIDITY_PROVIDER is enabled")
        }
        // console.log("Paying address")
        if (this.outgoingOpsLocked) {
            this.log("outgoing ops locked, rejecting payment request")
            throw new Error("lnd node is currently out of sync")
        }
        if (useProvider) {
            throw new Error("provider payments not support chain payments yet")
        }
        await this.Health()
        try {
            const res = await this.lightning.sendCoins(SendCoinsReq(address, amount, satPerVByte, label), DeadLineMetadata())
            this.utils.stateBundler.AddTxPoint('paidAnAddress', amount, { from, used: 'lnd', timeDiscount: true })
            return res.response
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('paidAnAddress', amount, { from, used: 'lnd' })
            throw err
        }
    }

    async GetTransactions(startHeight: number): Promise<TransactionDetails> {
        // console.log("Getting transactions")
        const res = await this.lightning.getTransactions({ startHeight, endHeight: 0, account: "" }, DeadLineMetadata())
        return res.response
    }

    async GetChannelInfo(chanId: string) {
        // console.log("Getting channel info")
        const res = await this.lightning.getChanInfo({ chanId, chanPoint: "" }, DeadLineMetadata())
        return res.response
    }

    async UpdateChannelPolicy(chanPoint: string, policy: Types.ChannelPolicy) {
        // console.log("Updating channel policy")
        const split = chanPoint.split(':')

        const res = await this.lightning.updateChannelPolicy({
            scope: policy ? { oneofKind: 'chanPoint', chanPoint: { fundingTxid: { oneofKind: 'fundingTxidStr', fundingTxidStr: split[0] }, outputIndex: Number(split[1]) } } : { oneofKind: 'global', global: true },
            baseFeeMsat: BigInt(policy.base_fee_msat),
            feeRate: 0,
            maxHtlcMsat: BigInt(policy.max_htlc_msat),
            minHtlcMsat: BigInt(policy.min_htlc_msat),
            timeLockDelta: policy.timelock_delta,
            inboundFee: undefined,
            feeRatePpm: policy.fee_rate_ppm,
            minHtlcMsatSpecified: policy.min_htlc_msat > 0,
        }, DeadLineMetadata())
        return res.response
    }

    async GetChannelBalance() {
        // console.log("Getting channel balance")
        const res = await this.lightning.channelBalance({}, DeadLineMetadata())
        return res.response
    }

    async GetWalletBalance() {
        // console.log("Getting wallet balance")
        const res = await this.lightning.walletBalance({ account: "", minConfs: 1 }, DeadLineMetadata())
        return res.response
    }

    async GetTotalBalace() {
        // console.log("Getting total balance")
        const walletBalance = await this.GetWalletBalance()
        const confirmedWalletBalance = Number(walletBalance.confirmedBalance)
        this.utils.stateBundler.AddBalancePoint('walletBalance', confirmedWalletBalance)
        const channelsBalance = await this.GetChannelBalance()
        const totalLightningBalanceMsats = (channelsBalance.localBalance?.msat || 0n) + (channelsBalance.unsettledLocalBalance?.msat || 0n)
        const totalLightningBalance = Math.ceil(Number(totalLightningBalanceMsats) / 1000)
        this.utils.stateBundler.AddBalancePoint('channelBalance', totalLightningBalance)
        const totalLndBalance = confirmedWalletBalance + totalLightningBalance
        this.utils.stateBundler.AddBalancePoint('totalLndBalance', totalLndBalance)
        const othersFromLnd = { wc: Number(walletBalance.confirmedBalance), wu: Number(walletBalance.unconfirmedBalance), cl: Number(channelsBalance.localBalance?.msat), cul: Number(channelsBalance.unsettledLocalBalance?.msat), cr: Number(channelsBalance.remoteBalance?.msat), cur: Number(channelsBalance.unsettledRemoteBalance?.msat) }
        return { totalLndBalance, othersFromLnd }
    }

    async GetBalance(): Promise<BalanceInfo> { // TODO: remove this
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return { confirmedBalance: 0, unconfirmedBalance: 0, totalBalance: 0, channelsBalance: [] }
        }
        //      console.log("Getting balance")
        const wRes = await this.lightning.walletBalance({ account: "", minConfs: 1 }, DeadLineMetadata())
        const { confirmedBalance, unconfirmedBalance, totalBalance } = wRes.response
        const { response } = await this.lightning.listChannels({
            activeOnly: false, inactiveOnly: false, privateOnly: false, publicOnly: false, peer: Buffer.alloc(0), peerAliasLookup: false
        }, DeadLineMetadata())
        const channelsBalance = response.channels.map(c => ({
            channelId: c.chanId,
            localBalanceSats: Number(c.localBalance),
            remoteBalanceSats: Number(c.remoteBalance),
            htlcs: c.pendingHtlcs.map(htlc => ({ incoming: htlc.incoming, amount: Number(htlc.amount), index: Number(htlc.htlcIndex), fwIndex: Number(htlc.forwardingHtlcIndex) }))
        }))
        return { confirmedBalance: Number(confirmedBalance), unconfirmedBalance: Number(unconfirmedBalance), totalBalance: Number(totalBalance), channelsBalance }
    }

    async GetForwardingHistory(indexOffset: number, startTime = 0, endTime = 0): Promise<ForwardingHistoryResponse> {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return { forwardingEvents: [], lastOffsetIndex: indexOffset }
        }
        // console.log("Getting forwarding history")
        const { response } = await this.lightning.forwardingHistory({ indexOffset, numMaxEvents: 0, startTime: BigInt(startTime), endTime: BigInt(endTime), peerAliasLookup: false }, DeadLineMetadata())
        return response
    }

    async GetAllPaidInvoices(max: number) {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return { invoices: [] }
        }
        // console.log("Getting all paid invoices")
        const res = await this.lightning.listInvoices({ indexOffset: 0n, numMaxInvoices: BigInt(max), pendingOnly: false, reversed: true, creationDateEnd: 0n, creationDateStart: 0n }, DeadLineMetadata())
        return res.response
    }
    async GetAllPayments(max: number) {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return { payments: [] }
        }
        // console.log("Getting all payments")
        const res = await this.lightning.listPayments({ countTotalPayments: false, includeIncomplete: false, indexOffset: 0n, maxPayments: BigInt(max), reversed: true, creationDateEnd: 0n, creationDateStart: 0n })
        return res.response
    }

    async GetPayment(paymentIndex: number) {
        // console.log("Getting payment")
        if (paymentIndex === 0) {
            throw new Error("payment index starts from 1")
        }
        const indexOffset = BigInt(paymentIndex - 1)
        const res = await this.lightning.listPayments({
            countTotalPayments: false, includeIncomplete: true, indexOffset, maxPayments: 1n, reversed: false, creationDateEnd: 0n, creationDateStart: 0n
        }, DeadLineMetadata())
        return res.response
    }

    async GetLatestPaymentIndex(from = 0) {
        if (this.liquidProvider.getSettings().useOnlyLiquidityProvider) {
            return from
        }
        // console.log("Getting latest payment index")
        let indexOffset = BigInt(from)
        while (true) {
            const res = await this.lightning.listPayments({ countTotalPayments: false, includeIncomplete: false, indexOffset, maxPayments: 0n, reversed: false, creationDateEnd: 0n, creationDateStart: 0n }, DeadLineMetadata())
            if (res.response.payments.length === 0) {
                return Number(indexOffset)
            }
            indexOffset = res.response.lastIndexOffset
        }
    }

    async ConnectPeer(addr: { pubkey: string, host: string }) {
        // console.log("Connecting to peer")
        const res = await this.lightning.connectPeer({
            addr,
            perm: true,
            timeout: 0n
        }, DeadLineMetadata())
        return res.response
    }

    async GetPaymentFromHash(paymentHash: string): Promise<Payment | null> {
        // console.log("Getting payment from hash")
        const abortController = new AbortController()
        const stream = this.router.trackPaymentV2({
            paymentHash: Buffer.from(paymentHash, 'hex'),
            noInflightUpdates: false
        }, { abort: abortController.signal })
        return new Promise((res, rej) => {
            stream.responses.onError(error => {
                if (abortController.signal.aborted) {
                    this.log(ERROR, "error with trackPaymentV2", error.message)
                    rej(null)
                }
            })
            stream.responses.onMessage(payment => {
                res(payment)
                abortController.abort()
            })
        })

    }

    async GetTx(txid: string) {
        // console.log("Getting transaction")
        const res = await this.walletKit.getTransaction({ txid }, DeadLineMetadata())
        return res.response
    }

    async AddPeer(pub: string, host: string, port: number) {
        // console.log("Adding peer")
        const res = await this.lightning.connectPeer({
            addr: {
                pubkey: pub,
                host: host + ":" + port,
            },
            perm: true,
            timeout: 0n
        })
        return res.response
    }

    async ListPeers() {
        // console.log("Listing peers")
        const res = await this.lightning.listPeers({ latestError: true }, DeadLineMetadata())
        return res.response
    }

    async OpenChannel(destination: string, closeAddress: string, fundingAmount: number, pushSats: number, satsPerVByte: number): Promise<OpenStatusUpdate> {
        // console.log("Opening channel")
        const abortController = new AbortController()
        const req = OpenChannelReq(destination, closeAddress, fundingAmount, pushSats, satsPerVByte)
        const stream = this.lightning.openChannel(req, { abort: abortController.signal })
        return new Promise((res, rej) => {
            stream.responses.onMessage(message => {
                console.log("message", message)
                switch (message.update.oneofKind) {
                    case 'chanPending':
                        res(message)
                        break
                }
            })
            stream.responses.onError(error => {
                console.log("error", error)
                rej(error)
            })
        })
    }

    async CloseChannel(fundingTx: string, outputIndex: number, force: boolean, satPerVByte: number): Promise<PendingUpdate> {
        // console.log("Closing channel")
        const stream = this.lightning.closeChannel({
            deliveryAddress: "",
            force: force,
            satPerByte: 0n,
            satPerVbyte: BigInt(satPerVByte),
            noWait: false,
            maxFeePerVbyte: 0n,
            targetConf: 0,
            channelPoint: {
                fundingTxid: {
                    fundingTxidStr: fundingTx,
                    oneofKind: "fundingTxidStr"
                },
                outputIndex: outputIndex
            },
        }, DeadLineMetadata())
        return new Promise((res, rej) => {
            stream.responses.onMessage(message => {
                console.log("message", message)
                switch (message.update.oneofKind) {
                    case 'closePending':
                        res(message.update.closePending)
                        break
                }
            })
            stream.responses.onError(error => {
                console.log("error", error)
                rej(error)
            })
        })
    }
}
