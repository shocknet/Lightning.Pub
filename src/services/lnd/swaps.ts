import zkpInit from '@vulpemventures/secp256k1-zkp';
import axios from 'axios';
import { crypto, initEccLib, Transaction, address, Network } from 'bitcoinjs-lib';
// import bolt11 from 'bolt11';
import {
    Musig, SwapTreeSerializer, TaprootUtils, detectSwap,
    constructClaimTransaction, targetFee, OutputType,
    Networks,
} from 'boltz-core';
import { randomBytes, createHash } from 'crypto';
import { ECPairFactory, ECPairInterface } from 'ecpair';
import * as ecc from 'tiny-secp256k1';
import ws from 'ws';
import { getLogger, PubLogger, ERROR } from '../helpers/logger.js';
import SettingsManager from '../main/settingsManager.js';
import * as Types from '../../../proto/autogenerated/ts/types.js';

type InvoiceSwapResponse = { id: string, claimPublicKey: string, swapTree: string }
type InvoiceSwapInfo = { paymentHash: string, keys: ECPairInterface }
type InvoiceSwapData = { createdResponse: InvoiceSwapResponse, info: InvoiceSwapInfo }

type TransactionSwapFees = {
    percentage: number,
    minerFees: {
        claim: number,
        lockup: number,
    }
}

type TransactionSwapFeesRes = {
    BTC?: {
        BTC?: {
            fees: TransactionSwapFees
        }
    }
}


type TransactionSwapResponse = {
    id: string, refundPublicKey: string, swapTree: string,
    timeoutBlockHeight: number, lockupAddress: string, invoice: string,
    onchainAmount?: number
}
type TransactionSwapInfo = { destinationAddress: string, preimage: Buffer, keys: ECPairInterface, chainFee: number }
export type TransactionSwapData = { createdResponse: TransactionSwapResponse, info: TransactionSwapInfo }
const network = Networks.bitcoinMainnet
export class Swaps {
    reverseSwaps: ReverseSwaps
    submarineSwaps: SubmarineSwaps
    constructor(settings: SettingsManager) {
        this.reverseSwaps = new ReverseSwaps(settings)
        this.submarineSwaps = new SubmarineSwaps(settings)
    }

    GetKeys = (privateKey: string) => {
        const keys = ECPairFactory(ecc).fromPrivateKey(Buffer.from(privateKey, 'hex'))
        return keys
    }
}

export class SubmarineSwaps {
    settings: SettingsManager
    log: PubLogger
    constructor(settings: SettingsManager) {
        this.settings = settings
        this.log = getLogger({ component: 'SubmarineSwaps' })
    }

    SwapInvoice = async (invoice: string, paymentHash: string) => {
        if (!this.settings.getSettings().swapsSettings.enableSwaps) {
            this.log(ERROR, 'Swaps are not enabled');
            return;
        }
        const keys = ECPairFactory(ecc).makeRandom()
        const refundPublicKey = Buffer.from(keys.publicKey).toString('hex')
        const req = { invoice, to: 'BTC', from: 'BTC', refundPublicKey }
        const url = `${this.settings.getSettings().swapsSettings.boltzHttpUrl}/v2/swap/submarine`
        this.log('Sending invoice swap request to', url);
        const createdResponseRes = await loggedPost<InvoiceSwapResponse>(this.log, url, req)
        if (!createdResponseRes.ok) {
            return createdResponseRes
        }
        const createdResponse = createdResponseRes.data
        this.log('Created invoice swap');
        this.log(createdResponse);

        const webSocket = new ws(`${this.settings.getSettings().swapsSettings.boltzWebSocketUrl}/v2/ws`)
        const subReq = { op: 'subscribe', channel: 'swap.update', args: [createdResponse.id] }
        webSocket.on('open', () => {
            webSocket.send(JSON.stringify(subReq))
        })

        webSocket.on('message', async (rawMsg) => {
            try {
                await this.handleSwapInvoiceMessage(rawMsg, { createdResponse, info: { paymentHash, keys } }, () => webSocket.close())
            } catch (err: any) {
                this.log(ERROR, 'Error handling invoice WebSocket message', err.message)
                webSocket.close()
                return
            }
        });
    }

    handleSwapInvoiceMessage = async (rawMsg: ws.RawData, data: InvoiceSwapData, closeWebSocket: () => void) => {
        const msg = JSON.parse(rawMsg.toString('utf-8'));
        if (msg.event !== 'update') {
            return;
        }

        this.log('Got invoice WebSocket update');
        this.log(msg);
        switch (msg.args[0].status) {
            // "invoice.set" means Boltz is waiting for an onchain transaction to be sent
            case 'invoice.set':
                this.log('Waiting for onchain transaction');
                return;
            // Create a partial signature to allow Boltz to do a key path spend to claim the mainchain coins
            case 'transaction.claim.pending':
                await this.handleInvoiceClaimPending(data)
                return;

            case 'transaction.claimed':
                this.log('Invoice swap successful');
                closeWebSocket()
                return;
        }

    }

    handleInvoiceClaimPending = async (data: InvoiceSwapData) => {
        this.log('Creating cooperative claim transaction');
        const { createdResponse, info } = data
        const { paymentHash, keys } = info
        const { boltzHttpUrl } = this.settings.getSettings().swapsSettings
        // Get the information request to create a partial signature
        const url = `${boltzHttpUrl}/v2/swap/submarine/${createdResponse.id}/claim`
        const claimTxDetailsRes = await loggedGet<{ preimage: string, transactionHash: string, pubNonce: string }>(this.log, url)
        if (!claimTxDetailsRes.ok) {
            return claimTxDetailsRes
        }
        const claimTxDetails = claimTxDetailsRes.data
        // Verify that Boltz actually paid the invoice by comparing the preimage hash
        // of the invoice to the SHA256 hash of the preimage from the response
        const claimTxPreimageHash = createHash('sha256').update(Buffer.from(claimTxDetails.preimage, 'hex')).digest()
        const invoicePreimageHash = Buffer.from(paymentHash, 'hex')

        if (!claimTxPreimageHash.equals(invoicePreimageHash)) {
            this.log(ERROR, 'Boltz provided invalid preimage');
            return;
        }

        const boltzPublicKey = Buffer.from(createdResponse.claimPublicKey, 'hex')

        // Create a musig signing instance
        const musig = new Musig(await zkpInit(), keys, randomBytes(32), [
            boltzPublicKey,
            Buffer.from(keys.publicKey),
        ]);
        // Tweak that musig with the Taptree of the swap scripts
        TaprootUtils.tweakMusig(
            musig,
            SwapTreeSerializer.deserializeSwapTree(createdResponse.swapTree).tree,
        );

        // Aggregate the nonces
        musig.aggregateNonces([
            [boltzPublicKey, Buffer.from(claimTxDetails.pubNonce, 'hex')],
        ]);
        // Initialize the session to sign the transaction hash from the response
        musig.initializeSession(
            Buffer.from(claimTxDetails.transactionHash, 'hex'),
        );

        // Give our public nonce and the partial signature to Boltz
        const claimUrl = `${boltzHttpUrl}/v2/swap/submarine/${createdResponse.id}/claim`
        const claimReq = {
            pubNonce: Buffer.from(musig.getPublicNonce()).toString('hex'),
            partialSignature: Buffer.from(musig.signPartial()).toString('hex'),
        }
        const claimResponseRes = await loggedPost<{ pubNonce: string, partialSignature: string }>(this.log, claimUrl, claimReq)
        if (!claimResponseRes.ok) {
            return claimResponseRes
        }
        const claimResponse = claimResponseRes.data
        this.log('Claim response', claimResponse)
    }
}
export class ReverseSwaps {
    settings: SettingsManager
    log: PubLogger
    constructor(settings: SettingsManager) {
        this.settings = settings
        this.log = getLogger({ component: 'ReverseSwaps' })
        initEccLib(ecc)
    }

    calculateFees = (fees: TransactionSwapFees, receiveAmount: number) => {
        const pct = fees.percentage / 100
        const minerFee = fees.minerFees.claim + fees.minerFees.lockup

        const preFee = receiveAmount + minerFee
        const fee = Math.ceil(preFee * pct)
        const total = preFee + fee
        return { total, fee, minerFee }
    }

    GetFees = async (): Promise<{ ok: true, fees: TransactionSwapFees, } | { ok: false, error: string }> => {
        const url = `${this.settings.getSettings().swapsSettings.boltzHttpUrl}/v2/swap/reverse`
        const feesRes = await loggedGet<TransactionSwapFeesRes>(this.log, url)
        if (!feesRes.ok) {
            return { ok: false, error: feesRes.error }
        }
        if (!feesRes.data.BTC?.BTC?.fees) {
            return { ok: false, error: 'No fees found for BTC to BTC swap' }
        }

        return { ok: true, fees: feesRes.data.BTC.BTC.fees }
    }

    SwapTransaction = async (txAmount: number): Promise<{ ok: true, createdResponse: TransactionSwapResponse, preimage: string, pubkey: string, privKey: string } | { ok: false, error: string }> => {
        if (!this.settings.getSettings().swapsSettings.enableSwaps) {
            this.log(ERROR, 'Swaps are not enabled');
            return { ok: false, error: 'Swaps are not enabled' }
        }
        const preimage = randomBytes(32);
        const keys = ECPairFactory(ecc).makeRandom()
        if (!keys.privateKey) {
            return { ok: false, error: 'Failed to generate keys' }
        }
        const url = `${this.settings.getSettings().swapsSettings.boltzHttpUrl}/v2/swap/reverse`
        const req: any = {
            onchainAmount: txAmount,
            // invoiceAmount,
            to: 'BTC',
            from: 'BTC',
            claimPublicKey: Buffer.from(keys.publicKey).toString('hex'),
            preimageHash: createHash('sha256').update(preimage).digest('hex'),
        }
        /* if (amount.type === Types.TransactionSwapRequest_amount_type.INVOICE_AMOUNT_SATS) {
            req.invoiceAmount = amount.invoice_amount_sats
        } else if (amount.type === Types.TransactionSwapRequest_amount_type.TRANSACTION_AMOUNT_SATS) {
            req.onchainAmount = amount.transaction_amount_sats
        } */
        const createdResponseRes = await loggedPost<TransactionSwapResponse>(this.log, url, req)
        if (!createdResponseRes.ok) {
            return createdResponseRes
        }
        const createdResponse = createdResponseRes.data
        this.log('Created transaction swap');
        this.log(createdResponse);
        return {
            ok: true, createdResponse,
            preimage: Buffer.from(preimage).toString('hex'),
            pubkey: Buffer.from(keys.publicKey).toString('hex'),
            privKey: Buffer.from(keys.privateKey).toString('hex')
        }
    }

    SubscribeToTransactionSwap = async (data: TransactionSwapData, swapDone: (result: { ok: true, txId: string } | { ok: false, error: string }) => void) => {
        const webSocket = new ws(`${this.settings.getSettings().swapsSettings.boltzWebSocketUrl}/v2/ws`)
        const subReq = { op: 'subscribe', channel: 'swap.update', args: [data.createdResponse.id] }
        webSocket.on('open', () => {
            webSocket.send(JSON.stringify(subReq))
        })
        let txId = ""
        const done = () => {
            webSocket.close()
            swapDone({ ok: true, txId })
        }
        webSocket.on('message', async (rawMsg) => {
            try {
                const result = await this.handleSwapTransactionMessage(rawMsg, data, done)
                if (result) {
                    txId = result
                }
            } catch (err: any) {
                this.log(ERROR, 'Error handling transaction WebSocket message', err.message)
                webSocket.close()
                swapDone({ ok: false, error: err.message })
                return
            }
        })
    }

    handleSwapTransactionMessage = async (rawMsg: ws.RawData, data: TransactionSwapData, done: () => void) => {
        const msg = JSON.parse(rawMsg.toString('utf-8'));
        if (msg.event !== 'update') {
            return;
        }

        this.log('Got WebSocket update');
        this.log(msg);
        switch (msg.args[0].status) {
            // "swap.created" means Boltz is waiting for the invoice to be paid
            case 'swap.created':
                this.log('Waiting invoice to be paid');
                return;

            // "transaction.mempool" means that Boltz sent an onchain transaction
            case 'transaction.mempool':
                const txIdRes = await this.handleTransactionMempool(data, msg.args[0].transaction.hex)
                if (!txIdRes.ok) {
                    throw new Error(txIdRes.error)
                }
                return txIdRes.txId
            case 'invoice.settled':
                this.log('Transaction swap successful');
                done()
                return;
        }
    }

    handleTransactionMempool = async (data: TransactionSwapData, txHex: string): Promise<{ ok: true, txId: string } | { ok: false, error: string }> => {
        this.log('Creating claim transaction');
        const { createdResponse, info } = data
        const { destinationAddress, keys, preimage, chainFee } = info
        const boltzPublicKey = Buffer.from(
            createdResponse.refundPublicKey,
            'hex',
        );

        // Create a musig signing session and tweak it with the Taptree of the swap scripts
        const musig = new Musig(await zkpInit(), keys, randomBytes(32), [
            boltzPublicKey,
            Buffer.from(keys.publicKey),
        ]);
        const tweakedKey = TaprootUtils.tweakMusig(
            musig,
            SwapTreeSerializer.deserializeSwapTree(createdResponse.swapTree).tree,
        );

        // Parse the lockup transaction and find the output relevant for the swap
        const lockupTx = Transaction.fromHex(txHex);
        const swapOutput = detectSwap(tweakedKey, lockupTx);
        if (swapOutput === undefined) {
            this.log(ERROR, 'No swap output found in lockup transaction');
            return { ok: false, error: 'No swap output found in lockup transaction' }
        }

        // Create a claim transaction to be signed cooperatively via a key path spend
        const claimTx = constructClaimTransaction(
            [
                {
                    ...swapOutput,
                    keys,
                    preimage,
                    cooperative: true,
                    type: OutputType.Taproot,
                    txHash: lockupTx.getHash(),
                },
            ],
            address.toOutputScript(destinationAddress, network),
            chainFee,
        )
        const { boltzHttpUrl } = this.settings.getSettings().swapsSettings
        // Get the partial signature from Boltz
        const claimUrl = `${boltzHttpUrl}/v2/swap/reverse/${createdResponse.id}/claim`
        const claimReq = {
            index: 0,
            transaction: claimTx.toHex(),
            preimage: preimage.toString('hex'),
            pubNonce: Buffer.from(musig.getPublicNonce()).toString('hex'),
        }
        const boltzSigRes = await loggedPost<{ pubNonce: string, partialSignature: string }>(this.log, claimUrl, claimReq)
        if (!boltzSigRes.ok) {
            return boltzSigRes
        }
        const boltzSig = boltzSigRes.data

        // Aggregate the nonces
        musig.aggregateNonces([
            [boltzPublicKey, Buffer.from(boltzSig.pubNonce, 'hex')],
        ]);

        // Initialize the session to sign the claim transaction
        musig.initializeSession(
            claimTx.hashForWitnessV1(
                0,
                [swapOutput.script],
                [swapOutput.value],
                Transaction.SIGHASH_DEFAULT,
            ),
        );

        // Add the partial signature from Boltz
        musig.addPartial(
            boltzPublicKey,
            Buffer.from(boltzSig.partialSignature, 'hex'),
        );

        // Create our partial signature
        musig.signPartial();

        // Witness of the input to the aggregated signature
        claimTx.ins[0].witness = [musig.aggregatePartials()];

        // Broadcast the finalized transaction
        const broadcastUrl = `${boltzHttpUrl}/v2/chain/BTC/transaction`
        const broadcastReq = {
            hex: claimTx.toHex(),
        }

        const broadcastResponse = await loggedPost<any>(this.log, broadcastUrl, broadcastReq)
        if (!broadcastResponse.ok) {
            return broadcastResponse
        }
        this.log('Transaction broadcasted', broadcastResponse.data)
        const txId = claimTx.getId()
        return { ok: true, txId }
    }
}

const loggedPost = async <T>(log: PubLogger, url: string, req: any): Promise<{ ok: true, data: T } | { ok: false, error: string }> => {
    try {
        const { data } = await axios.post(url, req)
        return { ok: true, data: data as T }
    } catch (err: any) {
        if (err.response?.data) {
            log(ERROR, 'Error sending request', err.response.data)
            return { ok: false, error: err.response.data }
        }
        log(ERROR, 'Error sending request', err.message)
        return { ok: false, error: err.message }
    }
}

const loggedGet = async <T>(log: PubLogger, url: string): Promise<{ ok: true, data: T } | { ok: false, error: string }> => {
    try {
        const { data } = await axios.get(url)
        return { ok: true, data: data as T }
    } catch (err: any) {
        if (err.response?.data) {
            log(ERROR, 'Error getting request', err.response.data)
            return { ok: false, error: err.response.data }
        }
        log(ERROR, 'Error getting request', err.message)
        return { ok: false, error: err.message }
    }
}