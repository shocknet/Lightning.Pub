//const grpc = require('@grpc/grpc-js');
import { credentials, Metadata } from '@grpc/grpc-js'
import { GrpcTransport } from "@protobuf-ts/grpc-transport";
import fs from 'fs'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { LightningClient } from '../../../proto/lnd/lightning.client.js'
import { InvoicesClient } from '../../../proto/lnd/invoices.client.js'
import { RouterClient } from '../../../proto/lnd/router.client.js'
import { GetInfoResponse, AddressType, NewAddressResponse, AddInvoiceResponse, Invoice_InvoiceState, PayReq, Payment_PaymentStatus, Payment } from '../../../proto/lnd/lightning.js'
import { OpenChannelReq } from './openChannelReq.js';
import { AddInvoiceReq } from './addInvoiceReq.js';
import { PayInvoiceReq } from './payInvoiceReq.js';
import { SendCoinsReq } from './sendCoinsReq.js';
import { EnvMustBeInteger, EnvMustBeNonEmptyString } from '../helpers/envParser.js';
const DeadLineMetadata = (deadline = 10 * 1000) => ({ deadline: Date.now() + deadline })
export type LndSettings = {
    lndAddr: string
    lndCertPath: string
    lndMacaroonPath: string
    feeRateLimit: number
    feeFixedLimit: number
}
export const LoadLndSettingsFromEnv = (test = false): LndSettings => {
    const lndAddr = EnvMustBeNonEmptyString("LND_ADDRESS")
    const lndCertPath = EnvMustBeNonEmptyString("LND_CERT_PATH")
    const lndMacaroonPath = EnvMustBeNonEmptyString("LND_MACAROON_PATH")
    const feeRateLimit = EnvMustBeInteger("LIMIT_FEE_RATE_MILLISATS") / 1000
    const feeFixedLimit = EnvMustBeInteger("LIMIT_FEE_FIXED_SATS")
    return { lndAddr, lndCertPath, lndMacaroonPath, feeRateLimit, feeFixedLimit }
}
type TxOutput = {
    hash: string
    index: number
}
export type AddressPaidCb = (txOutput: TxOutput, address: string, amount: number) => void
export type InvoicePaidCb = (paymentRequest: string, amount: number) => void
export default class {
    lightning: LightningClient
    invoices: InvoicesClient
    router: RouterClient
    settings: LndSettings
    ready = false
    latestKnownBlockHeigh = 0
    latestKnownSettleIndex = 0
    abortController = new AbortController()
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    constructor(settings: LndSettings, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb) {
        this.settings = settings
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
        const { lndAddr, lndCertPath, lndMacaroonPath } = this.settings
        const lndCert = fs.readFileSync(lndCertPath);
        const macaroon = fs.readFileSync(lndMacaroonPath).toString('hex');
        const sslCreds = credentials.createSsl(lndCert);
        const macaroonCreds = credentials.createFromMetadataGenerator(
            function (args: any, callback: any) {
                let metadata = new Metadata();
                metadata.add('macaroon', macaroon);
                callback(null, metadata);
            },
        );
        const creds = credentials.combineChannelCredentials(
            sslCreds,
            macaroonCreds,
        );
        const transport = new GrpcTransport({ host: lndAddr, channelCredentials: creds })
        this.lightning = new LightningClient(transport)
        this.invoices = new InvoicesClient(transport)
        this.router = new RouterClient(transport)
        this.SubscribeAddressPaid()
    }
    Stop() {
        this.abortController.abort()
    }
    async Warmup() { this.ready = true }

    async GetInfo(): Promise<GetInfoResponse> {
        const res = await this.lightning.getInfo({}, DeadLineMetadata())
        return res.response
    }
    checkReady() {
        if (!this.ready) throw new Error("lnd not ready, warmup required before usage")
    }
    SubscribeAddressPaid() {
        const stream = this.lightning.subscribeTransactions({
            account: "",
            endHeight: 0,
            startHeight: this.latestKnownBlockHeigh,
        }, { abort: this.abortController.signal })
        stream.responses.onMessage(tx => {
            if (tx.blockHeight > this.latestKnownBlockHeigh) {
                this.latestKnownBlockHeigh = tx.blockHeight
            }
            if (tx.numConfirmations > 0) {
                tx.outputDetails.forEach(output => {
                    if (output.isOurAddress) {
                        this.addressPaidCb({ hash: tx.txHash, index: Number(output.outputIndex) }, output.address, Number(output.amount))
                    }
                })
            }
        })
        stream.responses.onError(error => {
            // TODO...
        })
    }

    SubscribeInvoicePaid() {
        const stream = this.lightning.subscribeInvoices({
            settleIndex: this.latestKnownSettleIndex,
            addIndex: 0,
        }, { abort: this.abortController.signal })
        stream.responses.onMessage(invoice => {
            if (invoice.state === Invoice_InvoiceState.SETTLED) {
                this.latestKnownSettleIndex = Number(invoice.settleIndex)
                this.invoicePaidCb(invoice.paymentRequest, Number(invoice.amtPaidSat))
            }
        })
        stream.responses.onError(error => {
            // TODO...
        })
    }
    async NewAddress(addressType: Types.AddressType): Promise<NewAddressResponse> {
        this.checkReady()
        let lndAddressType: AddressType
        switch (addressType) {
            case Types.AddressType.NESTED_PUBKEY_HASH:
                lndAddressType = AddressType.NESTED_PUBKEY_HASH
                break;
            case Types.AddressType.WITNESS_PUBKEY_HASH:
                lndAddressType = AddressType.WITNESS_PUBKEY_HASH
                break;
            case Types.AddressType.TAPROOT_PUBKEY:
                lndAddressType = AddressType.TAPROOT_PUBKEY
                break;
            default:
                throw new Error("unknown address type " + addressType)
        }
        const res = await this.lightning.newAddress({ account: "", type: lndAddressType }, DeadLineMetadata())
        return res.response
    }

    async NewInvoice(value: number, memo: string): Promise<AddInvoiceResponse> {
        this.checkReady()
        const res = await this.lightning.addInvoice(AddInvoiceReq(value, memo), DeadLineMetadata())
        return res.response
    }

    async DecodeInvoice(paymentRequest: string): Promise<PayReq> {
        const res = await this.lightning.decodePayReq({ payReq: paymentRequest }, DeadLineMetadata())
        return res.response
    }

    GetFeeLimitAmount(amount: number) {
        return Math.ceil(amount * this.settings.feeRateLimit + this.settings.feeFixedLimit);
    }

    GetMaxWithinLimit(amount: number) {
        return Math.max(0, Math.floor(amount * (1 - this.settings.feeRateLimit) - this.settings.feeFixedLimit))
    }

    async PayInvoice(invoice: string, amount: number, feeLimit: number): Promise<Payment> {
        this.checkReady()
        const abortController = new AbortController()
        const stream = this.router.sendPaymentV2(PayInvoiceReq(invoice, amount, feeLimit), { abort: abortController.signal })
        return new Promise((res, rej) => {
            stream.responses.onError(error => {
                rej(error)
            })
            stream.responses.onMessage(payment => {
                switch (payment.status) {
                    case Payment_PaymentStatus.FAILED:
                        rej(payment.failureReason)
                        return
                    case Payment_PaymentStatus.SUCCEEDED:
                        res(payment)
                }
            })
        })
    }

    async EstimateChainFees(address: string, amount: number, targetConf: number) {
        this.checkReady()
        const res = await this.lightning.estimateFee({
            addrToAmount: { [address]: amount },
            minConfs: 1,
            spendUnconfirmed: false,
            targetConf: targetConf
        })
        return res.response
    }

    async PayAddress(address: string, amount: number, satPerVByte: number, label = "") {
        this.checkReady()
        const res = await this.lightning.sendCoins(SendCoinsReq(address, amount, satPerVByte, label), DeadLineMetadata())
        return res.response
    }


    async OpenChannel(destination: string, closeAddress: string, fundingAmount: number, pushSats: number): Promise<string> {
        this.checkReady()
        const abortController = new AbortController()
        const req = OpenChannelReq(destination, closeAddress, fundingAmount, pushSats)
        const stream = this.lightning.openChannel(req, { abort: abortController.signal })
        return new Promise((res, rej) => {
            stream.responses.onMessage(message => {

                switch (message.update.oneofKind) {
                    case 'chanPending':
                        abortController.abort()
                        res(Buffer.from(message.pendingChanId).toString('base64'))
                        break
                    default:
                        abortController.abort()
                        rej("unexpected state response: " + message.update.oneofKind)
                }
            })
            stream.responses.onError(error => {
                rej(error)
            })
        })
    }
}


