// This file was autogenerated from a .proto file, DO NOT EDIT!

export type ResultError = { status: 'ERROR', reason: string }
export type RequestInfo = { rpcName: string, batch: boolean, nostr: boolean, batchSize: number }
export type RequestStats = { startMs: number, start: bigint, parse: bigint, guard: bigint, validate: bigint, handle: bigint }
export type RequestMetric = AuthContext & RequestInfo & RequestStats & { error?: string }
export type ProtoSocketState = 'OPEN' | 'CLOSED'
export type ProtoSocket<T> = {
    getState: () => ProtoSocketState
    send: (res: T, err: Error | null) => void
}
export type AdminContext = {
    admin_id: string
}
export type AdminMethodInputs = EnrollServicePub_Input
export type AdminMethodOutputs = EnrollServicePub_Output
export type GuestContext = {
}
export type GuestMethodInputs = Health_Input
export type GuestMethodOutputs = Health_Output
export type NostrAppContext = {
    nostr_app_npub: string
}
export type NostrAppMethodInputs = SendNotification_Input
export type NostrAppMethodOutputs = SendNotification_Output
export type AuthContext = AdminContext | GuestContext | NostrAppContext

export type EnrollServicePub_Input = { rpcName: 'EnrollServicePub', req: ServiceNpub }
export type EnrollServicePub_Output = ResultError | { status: 'OK' }

export type Health_Input = { rpcName: 'Health' }
export type Health_Output = ResultError | { status: 'OK' }

export type SendNotification_Input = { rpcName: 'SendNotification', req: Notification }
export type SendNotification_Output = ResultError | { status: 'OK' }

export type ServerMethods = {
    EnrollServicePub?: (req: EnrollServicePub_Input & { ctx: AdminContext }) => Promise<void>
    Health?: (req: Health_Input & { ctx: GuestContext }) => Promise<void>
    SendNotification?: (req: SendNotification_Input & { ctx: NostrAppContext }) => Promise<void>
}


export type OptionsBaseMessage = {
    allOptionalsAreSet?: true
}

export type Empty = {
}
export const EmptyOptionalFields: [] = []
export type EmptyOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
}
export const EmptyValidate = (o?: Empty, opts: EmptyOptions = {}, path: string = 'Empty::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    return null
}

export type Notification = {
    data: string
    recipient_registration_tokens: string[]
}
export const NotificationOptionalFields: [] = []
export type NotificationOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    data_CustomCheck?: (v: string) => boolean
    recipient_registration_tokens_CustomCheck?: (v: string[]) => boolean
}
export const NotificationValidate = (o?: Notification, opts: NotificationOptions = {}, path: string = 'Notification::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.data !== 'string') return new Error(`${path}.data: is not a string`)
    if (opts.data_CustomCheck && !opts.data_CustomCheck(o.data)) return new Error(`${path}.data: custom check failed`)

    if (!Array.isArray(o.recipient_registration_tokens)) return new Error(`${path}.recipient_registration_tokens: is not an array`)
    for (let index = 0; index < o.recipient_registration_tokens.length; index++) {
        if (typeof o.recipient_registration_tokens[index] !== 'string') return new Error(`${path}.recipient_registration_tokens[${index}]: is not a string`)
    }
    if (opts.recipient_registration_tokens_CustomCheck && !opts.recipient_registration_tokens_CustomCheck(o.recipient_registration_tokens)) return new Error(`${path}.recipient_registration_tokens: custom check failed`)

    return null
}

export type ServiceNpub = {
    pubkey_hex: string
}
export const ServiceNpubOptionalFields: [] = []
export type ServiceNpubOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    pubkey_hex_CustomCheck?: (v: string) => boolean
}
export const ServiceNpubValidate = (o?: ServiceNpub, opts: ServiceNpubOptions = {}, path: string = 'ServiceNpub::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.pubkey_hex !== 'string') return new Error(`${path}.pubkey_hex: is not a string`)
    if (opts.pubkey_hex_CustomCheck && !opts.pubkey_hex_CustomCheck(o.pubkey_hex)) return new Error(`${path}.pubkey_hex: custom check failed`)

    return null
}

