import * as Types from '../../../proto/autogenerated/ts/types.js'
import Main from '../main/index.js'
export default (mainHandler: Main): Types.ServerMethods => {
    return {
        EncryptionExchange: async (ctx, req) => { },
        Health: async (ctx) => { },
        LndGetInfo: async (ctx) => {
            const info = await mainHandler.lnd.GetInfo()
            return { alias: info.alias }
        },
        AddUser: async (ctx, req) => {
            const err = Types.AddUserRequestValidate(req, {
                callbackUrl_CustomCheck: url => url.startsWith("http://") || url.startsWith("https://"),
                name_CustomCheck: name => name.length > 0,
                secret_CustomCheck: secret => secret.length >= 8
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.AddBasicUser(req)
        },
        AuthUser: async (ctx, req) => {
            throw new Error("unimplemented")
        },
        OpenChannel: async (ctx, req) => {
            const err = Types.OpenChannelRequestValidate(req, {
                fundingAmount_CustomCheck: amt => amt > 0,
                pushAmount_CustomCheck: amt => amt > 0,
                destination_CustomCheck: dest => dest !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.OpenChannel(ctx.user_id, req)
        },
        NewAddress: async (ctx, req) => {
            return mainHandler.NewAddress(ctx.user_id, req)
        },
        PayAddress: async (ctx, req) => {
            const err = Types.PayAddressRequestValidate(req, {
                address_CustomCheck: addr => addr !== '',
                amoutSats_CustomCheck: amt => amt > 0,
                targetConf_CustomCheck: target => target > 0
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.PayAddress(ctx.user_id, req)
        },
        NewInvoice: async (ctx, req) => {
            throw new Error("unimplemented")
        },
        PayInvoice: async (ctx, req) => {
            throw new Error("unimplemented")
        },
        GetLnurlWithdrawLink: async (ctx) => {
            return mainHandler.GetLnurlChannelLink(ctx.user_id)
        },
        GetLnurlWithdrawInfo: async (ctx) => {
            if (!ctx.k1) {
                throw new Error("invalid lnurl withdraw to get info")
            }
            return mainHandler.GetLnurlWithdrawInfo(ctx.k1)
        },
        HandleLnurlWithdraw: async (ctx) => {
            if (!ctx.k1 || !ctx.pr) {
                throw new Error("invalid lnurl withdraw to handle")
            }
            return mainHandler.HandleLnurlWithdraw(ctx.k1, ctx.pr)
        },
        GetLnurlPayInfo: async (ctx) => {
            if (!ctx.k1) {
                throw new Error("invalid lnurl pay to get info")
            }
            return mainHandler.GetLnurlPayInfo(ctx.k1)
        },
        HandleLnurlPay: async (ctx) => {
            if (!ctx.k1 || !ctx.amount) {
                throw new Error("invalid lnurl pay to handle")
            }
            if (isNaN(+ctx.amount)) {
                throw new Error("invalid amount in lnurl pay to handle")
            }
            return mainHandler.HandleLnurlPay(ctx.k1, +ctx.amount)
        },
        GetLNURLChannelLink: async (ctx) => {
            throw new Error("unimplemented")
        }
    }
}