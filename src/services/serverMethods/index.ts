import * as Types from '../../../proto/autogenerated/ts/types.js'
import { getLogger } from '../helpers/logger.js'
import main from '../main/index.js'
import Main from '../main/index.js'
export default (mainHandler: Main): Types.ServerMethods => {
    return {
        GetUsageMetrics: async ({ ctx }) => {
            return mainHandler.metricsManager.GetUsageMetrics()
        },
        GetAppsMetrics: async ({ ctx, req }) => {
            return mainHandler.metricsManager.GetAppsMetrics(req)
        },
        GetLndMetrics: async ({ ctx, req }) => {
            return mainHandler.metricsManager.GetLndMetrics(req)
        },
        EncryptionExchange: async () => { },
        Health: async () => { await mainHandler.lnd.Health() },
        LndGetInfo: async ({ ctx }) => {
            const info = await mainHandler.lnd.GetInfo()
            return { alias: info.alias }
        },
        BanUser: async ({ ctx, req }) => {
            const err = Types.BanUserRequestValidate(req, {
                user_id_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.appUserManager.BanUser(req.user_id)
        },
        SetMockInvoiceAsPaid: async ({ ctx, req }) => {
            const err = Types.SetMockInvoiceAsPaidRequestValidate(req, {
                invoice_CustomCheck: invoice => invoice !== '',
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.paymentManager.SetMockInvoiceAsPaid(req)
        },
        UserHealth: async () => { },
        GetUserInfo: ({ ctx }) => mainHandler.appUserManager.GetUserInfo(ctx),
        GetUserOperations: async ({ ctx, req }) => {
            return mainHandler.paymentManager.GetUserOperations(ctx.user_id, req)
        },
        GetPaymentState: async ({ ctx, req }) => {
            const err = Types.GetPaymentStateRequestValidate(req, {
                invoice_CustomCheck: invoice => invoice !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.paymentManager.GetPaymentState(ctx.user_id, req)
        },
        OpenChannel: async ({ ctx, req }) => {
            const err = Types.OpenChannelRequestValidate(req, {
                fundingAmount_CustomCheck: amt => amt > 0,
                pushAmount_CustomCheck: amt => amt > 0,
                destination_CustomCheck: dest => dest !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.paymentManager.OpenChannel(ctx.user_id, req)
        },
        NewAddress: ({ ctx, req }) => mainHandler.paymentManager.NewAddress(ctx, req),
        PayAddress: async ({ ctx, req }) => {
            const err = Types.PayAddressRequestValidate(req, {
                address_CustomCheck: addr => addr !== '',
                amoutSats_CustomCheck: amt => amt > 0,
                satsPerVByte_CustomCheck: spb => spb > 0
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.paymentManager.PayAddress(ctx, req)
        },
        NewInvoice: ({ ctx, req }) => mainHandler.appUserManager.NewInvoice(ctx, req),
        DecodeInvoice: async ({ ctx, req }) => {
            return mainHandler.paymentManager.DecodeInvoice(req)
        },
        PayInvoice: async ({ ctx, req }) => {
            const err = Types.PayInvoiceRequestValidate(req, {
                invoice_CustomCheck: invoice => invoice !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.appUserManager.PayInvoice(ctx, req)
        },
        GetLnurlWithdrawLink: ({ ctx }) => mainHandler.paymentManager.GetLnurlWithdrawLink(ctx),
        GetLnurlWithdrawInfo: async ({ ctx, query }) => {
            if (!query.k1) {
                throw new Error("invalid lnurl withdraw to get info")
            }
            return mainHandler.paymentManager.GetLnurlWithdrawInfo(query.k1)
        },
        HandleLnurlWithdraw: async ({ query }) => {
            if (!query.k1 || !query.pr) {
                throw new Error("invalid lnurl withdraw to handle")
            }
            return mainHandler.paymentManager.HandleLnurlWithdraw(query.k1, query.pr)
        },
        GetLnurlPayLink: ({ ctx }) => mainHandler.paymentManager.GetLnurlPayLink(ctx),
        GetLnurlPayInfo: async ({ ctx, query }) => {
            if (!query.k1) {
                throw new Error("invalid lnurl pay to get info")
            }
            return mainHandler.paymentManager.GetLnurlPayInfo(query.k1)
        },
        HandleLnurlPay: async ({ ctx, query }) => {
            return mainHandler.paymentManager.HandleLnurlPay(query)
        },
        HandleLnurlAddress: async ({ ctx, params }) => {
            if (!params.address_name) {
                throw new Error("invalid address_name to lnurl address")
            }
            return mainHandler.paymentManager.HandleLnurlAddress(params.address_name)
        },
        AddProduct: async ({ ctx, req }) => {
            return mainHandler.productManager.AddProduct(ctx.user_id, req)
        },
        NewProductInvoice: async ({ query }) => {
            if (!query.id) {
                throw new Error("product id must be non empty")
            }
            return mainHandler.productManager.NewProductInvoice(query.id)
        },
        GetLNURLChannelLink: async ({ ctx }) => {
            throw new Error("unimplemented")
        },
        AddApp: async ({ ctx, req }) => {
            const err = Types.AuthAppRequestValidate(req, {
                name_CustomCheck: name => name !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddApp(req)
        },
        AuthApp: async ({ ctx, req }) => {
            const err = Types.AuthAppRequestValidate(req, {
                name_CustomCheck: name => name !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AuthApp(req)
        },
        GetApp: async ({ ctx }) => {
            return mainHandler.applicationManager.GetApp(ctx.app_id)
        },
        AddAppUser: async ({ ctx, req }) => {
            const err = Types.AddAppUserRequestValidate(req, {
                identifier_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddAppUser(ctx.app_id, req)
        },
        AddAppInvoice: async ({ ctx, req }) => {
            const err = Types.AddAppInvoiceRequestValidate(req, {
                payer_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddAppInvoice(ctx.app_id, req)
        },
        AddAppUserInvoice: async ({ ctx, req }) => {
            const err = Types.AddAppUserInvoiceRequestValidate(req, {
                payer_identifier_CustomCheck: id => id !== '',
                receiver_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddAppUserInvoice(ctx.app_id, req)
        },
        GetAppUser: async ({ ctx, req }) => {
            const err = Types.GetAppUserRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.GetAppUser(ctx.app_id, req)
        },
        PayAppUserInvoice: async ({ ctx, req }) => {
            const err = Types.PayAppUserInvoiceRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.PayAppUserInvoice(ctx.app_id, req)
        },
        SendAppUserToAppUserPayment: async ({ ctx, req }) => {
            const err = Types.SendAppUserToAppUserPaymentRequestValidate(req, {
                to_user_identifier_CustomCheck: id => id !== '',
                from_user_identifier_CustomCheck: id => id !== '',
                amount_CustomCheck: amount => amount > 0
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.applicationManager.SendAppUserToAppUserPayment(ctx.app_id, req)
        },
        SendAppUserToAppPayment: async ({ ctx, req }) => {
            const err = Types.SendAppUserToAppPaymentRequestValidate(req, {
                from_user_identifier_CustomCheck: id => id !== '',
                amount_CustomCheck: amount => amount > 0
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.applicationManager.SendAppUserToAppPayment(ctx.app_id, req)
        },
        GetAppUserLNURLInfo: async ({ ctx, req }) => {
            const err = Types.GetAppUserLNURLInfoRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.GetAppUserLNURLInfo(ctx.app_id, req)
        },
        SetMockAppUserBalance: async ({ ctx, req }) => {
            const err = Types.SetMockAppUserBalanceRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.applicationManager.SetMockAppUserBalance(ctx.app_id, req)
        },
        SetMockAppBalance: async ({ ctx, req }) => {
            await mainHandler.applicationManager.SetMockAppBalance(ctx.app_id, req)
        },
        GetLiveUserOperations: async ({ ctx, cb }) => {
        },
        GetMigrationUpdate: async ({ ctx, cb }) => {
        },
        RequestNPubLinkingToken: async ({ ctx, req }) => {
            const err = Types.RequestNPubLinkingTokenRequestValidate(req, {
                user_identifier_CustomCheck: userIdentifier => userIdentifier !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.RequestNPubLinkingToken(ctx.app_id, req)
        },
        LinkNPubThroughToken: async ({ ctx, req }) => {
            const err = Types.LinkNPubThroughTokenRequestValidate(req, {
                nostr_pub_CustomCheck: nostrPub => nostrPub !== '',
                token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.LinkNpubThroughToken(ctx, req)
        },
        EnrollAdminToken: async ({ ctx, req }) => {
            const err = Types.EnrollAdminTokenRequestValidate(req, {
                admin_token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.PromoteUserToAdmin(ctx.app_id, ctx.app_user_id, req.admin_token)
        },
        CreateOneTimeInviteLink: async ({ ctx, req }) => {
            const err = Types.CreateOneTimeInviteLinkRequestValidate(req, {
                sats_CustomCheck: sats => sats === undefined || typeof sats === "number"
            })
            if (err != null) throw new Error(err.message)
                return mainHandler.adminManager.CreateInviteLink(ctx.admin_id, req.sats)
        },
        UseInviteLink: async ({ ctx, req }) => {
            const err = Types.UseInviteLinkRequestValidate(req, {
                invite_token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.UseInviteLink(ctx, req);
        },
        GetInviteLinkState: async ({ ctx, req }) => {
            const err = Types.GetInviteTokenStateRequestValidate(req, {
                invite_token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
                return mainHandler.adminManager.GetInviteTokenState(ctx, req);
        }
        
    }
}