import * as Types from '../../../proto/autogenerated/ts/types'
import Main from '../main'
export default (mainHandler: Main): Types.ServerMethods => {
    return {
        EncryptionExchange: async (ctx: Types.EncryptionExchange_Context, req: Types.EncryptionExchangeRequest): Promise<void> => { },
        Health: async (ctx: Types.Health_Context): Promise<void> => { },
        LndGetInfo: async (ctx: Types.LndGetInfo_Context): Promise<Types.LndGetInfoResponse> => {
            const info = await mainHandler.lnd.GetInfo()
            return { alias: info.alias }
        },
        AddUser: async (ctx: Types.GuestContext, req: Types.AddUserRequest): Promise<Types.AddUserResponse> => {
            const err = Types.AddUserRequestValidate(req, {
                callback_url_CustomCheck: url => url.startsWith("http://") || url.startsWith("https://"),
                name_CustomCheck: name => name.length > 0,
                secret_CustomCheck: secret => secret.length >= 8
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.AddUser(req)
        },
        AuthUser: async (ctx: Types.GuestContext, req: Types.AuthUserRequest): Promise<Types.AuthUserResponse> => {
            throw new Error("unimplemented")
        },
        OpenChannel: async (ctx: Types.UserContext, req: Types.OpenChannelRequest): Promise<Types.OpenChannelResponse> => {
            const err = Types.OpenChannelRequestValidate(req, {
                funding_amount_CustomCheck: amt => amt > 0,
                push_amount_CustomCheck: amt => amt > 0,
                destination_CustomCheck: dest => dest !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.OpenChannel(ctx.user_id, req)
        },
        NewAddress: async (ctx: Types.UserContext, req: Types.NewAddressRequest): Promise<Types.NewAddressResponse> => {
            return mainHandler.NewAddress(ctx.user_id, req)
        },
        PayAddress: async (ctx: Types.UserContext, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> => {
            const err = Types.PayAddressRequestValidate(req, {
                address_CustomCheck: addr => addr !== '',
                amout_sats_CustomCheck: amt => amt > 0,
                target_conf_CustomCheck: target => target > 0
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.PayAddress(ctx.user_id, req)
        },
        NewInvoice: async (ctx: Types.UserContext, req: Types.NewInvoiceRequest): Promise<Types.NewInvoiceResponse> => {
            throw new Error("unimplemented")
        },
        PayInvoice: async (ctx: Types.UserContext, req: Types.PayInvoiceRequest): Promise<Types.PayInvoiceResponse> => {
            throw new Error("unimplemented")
        },
        GetOpenChannelLNURL: async (ctx: Types.UserContext): Promise<Types.GetOpenChannelLNURLResponse> => {
            throw new Error("unimplemented")
        }
    }
}