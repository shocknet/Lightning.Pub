import * as Types from '../../../proto/autogenerated/ts/types.js'
import { getLogger } from '../helpers/logger.js'
import main from '../main/index.js'
import Main from '../main/index.js'
export default (mainHandler: Main): Types.ServerMethods => {
    return {
        SubmitWebRtcMessage: async ({ ctx, req }) => {
            const err = Types.WebRtcMessageValidate(req, {
                message_Options: {
                    candidate_CustomCheck: candidate => candidate !== '',
                    offer_CustomCheck: offer => offer !== '',
                }
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.utils.tlvStorageFactory.WebRtcMessage({ userPub: ctx.operator_id, appId: ctx.app_id }, req.message)
        },
        SubToWebRtcCandidates: async ({ ctx }) => { },
        GetUsageMetrics: async ({ ctx, req }) => {
            return mainHandler.metricsManager.GetUsageMetrics(req)
        },
        GetBundleMetrics: async ({ ctx, req }) => {
            return mainHandler.utils.stateBundler.GetBundleMetrics(req)
        },
        GetSingleUsageMetrics: async ({ ctx, req }) => {
            const err = Types.SingleMetricReqValidate(req, {
                app_id_CustomCheck: id => id === "",
                metrics_name_CustomCheck: name => name !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.metricsManager.GetSingleUsageMetrics(req)
        },
        GetSingleBundleMetrics: async ({ ctx, req }) => {
            const err = Types.SingleMetricReqValidate(req, {
                app_id_CustomCheck: id => id === "",
                metrics_name_CustomCheck: name => name !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.utils.stateBundler.GetSingleBundleMetrics(req)
        },
        GetErrorStats: async ({ ctx }) => {
            return mainHandler.metricsManager.GetErrorStats()
        },
        GetAppsMetrics: async ({ ctx, req }) => {
            return mainHandler.metricsManager.GetAppsMetrics(req)
        },
        GetLndMetrics: async ({ ctx, req }) => {
            return mainHandler.metricsManager.GetLndMetrics(req)
        },
        GetLndForwardingMetrics: async ({ ctx, req }) => {
            return mainHandler.metricsManager.GetLndForwardingMetrics(req)
        },
        ResetMetricsStorages: async ({ ctx }) => {
            return mainHandler.utils.tlvStorageFactory.ResetStorages()
        },
        ZipMetricsStorages: async ({ ctx }) => {
            const path = await mainHandler.utils.tlvStorageFactory.ZipStorages()
            return { path }
        },
        ListChannels: async ({ ctx }) => {
            return mainHandler.adminManager.ListChannels()
        },
        AddPeer: async ({ ctx, req }) => {
            const err = Types.AddPeerRequestValidate(req, {
                pubkey_CustomCheck: pubkey => pubkey !== '',
                host_CustomCheck: host => host !== '',
                port_CustomCheck: port => port > 0
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.AddPeer(req)
        },
        UpdateChannelPolicy: async ({ ctx, req }) => {
            const err = Types.UpdateChannelPolicyRequestValidate(req, {
                update_Options: {
                    channel_point_CustomCheck: cp => cp !== '',
                }
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.UpdateChannelPolicy(req)
        },
        OpenChannel: async ({ ctx, req }) => {
            const err = Types.OpenChannelRequestValidate(req, {
                node_pubkey_CustomCheck: pubkey => pubkey !== '',
                local_funding_amount_CustomCheck: amt => amt > 0,
                sat_per_v_byte_CustomCheck: spv => spv > 0,
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.OpenChannel(req)
        },
        CloseChannel: async ({ ctx, req }) => {
            const err = Types.CloseChannelRequestValidate(req, {
                funding_txid_CustomCheck: chanId => chanId !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.CloseChannel(req)
        },
        GetProvidersDisruption: async () => {
            return mainHandler.metricsManager.GetProvidersDisruption()
        },
        PingSubProcesses: async () => {
            await mainHandler.pingSubProcesses()
        },
        EncryptionExchange: async () => { },
        Health: async () => { await mainHandler.lnd.Health() },
        LndGetInfo: async ({ ctx }) => {
            return await mainHandler.adminManager.LndGetInfo()
        },
        BanUser: async ({ ctx, req }) => {
            const err = Types.BanUserRequestValidate(req, {
                user_id_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.appUserManager.BanUser(req.user_id)
        },
        GetSeed: async ({ ctx }) => {
            return mainHandler.unlocker.GetSeed()
        },
        SetMockInvoiceAsPaid: async ({ ctx, req }) => {
            const err = Types.SetMockInvoiceAsPaidRequestValidate(req, {
                invoice_CustomCheck: invoice => invoice !== '',
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.paymentManager.SetMockInvoiceAsPaid(req)
        },
        UserHealth: async () => {
            try { await mainHandler.lnd.Health(); return { downtime_reason: "" } }
            catch (e: any) { return { downtime_reason: e.message } }
        },
        GetUserInfo: ({ ctx }) => mainHandler.appUserManager.GetUserInfo(ctx),
        UpdateCallbackUrl: async ({ ctx, req }) => {
            return mainHandler.appUserManager.UpdateCallbackUrl(ctx, req)
        },
        GetUserOperations: async ({ ctx, req }) => {
            return mainHandler.paymentManager.GetUserOperations(ctx.user_id, req)
        },
        GetPaymentState: async ({ ctx, req }) => {
            const err = Types.GetPaymentStateRequestValidate(req, {
                invoice_CustomCheck: invoice => invoice !== ""
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.paymentManager.GetPaymentState(ctx.user_id, req)
        },
        NewAddress: ({ ctx, req }) => mainHandler.paymentManager.NewAddress(ctx, req),
        PayAddress: async ({ ctx, req }) => {
            const err = Types.PayAddressRequestValidate(req, {
                address_CustomCheck: addr => addr !== '',
                amoutSats_CustomCheck: amt => amt > 0,
                satsPerVByte_CustomCheck: spb => spb > 0
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.paymentManager.PayAddress(ctx, req)
        },
        NewInvoice: ({ ctx, req }) => mainHandler.appUserManager.NewInvoice(ctx, req),
        DecodeInvoice: async ({ ctx, req }) => {
            return mainHandler.paymentManager.DecodeInvoice(req)
        },
        PayInvoice: async ({ ctx, req }) => {
            const err = Types.PayInvoiceRequestValidate(req, {
                invoice_CustomCheck: invoice => invoice !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.appUserManager.PayInvoice(ctx, req)
        },
        GetLnurlWithdrawLink: ({ ctx }) => mainHandler.paymentManager.GetLnurlWithdrawLink(ctx),
        GetLnurlWithdrawInfo: async ({ ctx, query }) => {
            if (!query.k1) {
                throw new Error("invalid lnurl withdraw to get info")
            }
            return mainHandler.paymentManager.GetLnurlWithdrawInfo(query.k1)
        },
        HandleLnurlWithdraw: async ({ query }) => {
            if (!query.k1 || !query.pr) {
                throw new Error("invalid lnurl withdraw to handle")
            }
            return mainHandler.paymentManager.HandleLnurlWithdraw(query.k1, query.pr)
        },
        GetLnurlPayLink: ({ ctx }) => mainHandler.paymentManager.GetLnurlPayLink(ctx),
        GetLnurlPayInfo: async ({ ctx, query }) => {
            if (!query.k1) {
                throw new Error("invalid lnurl pay to get info")
            }
            return mainHandler.paymentManager.GetLnurlPayInfo(query.k1)
        },
        HandleLnurlPay: async ({ ctx, query }) => {
            return mainHandler.paymentManager.HandleLnurlPay(query)
        },
        HandleLnurlAddress: async ({ ctx, params }) => {
            if (!params.address_name) {
                throw new Error("invalid address_name to lnurl address")
            }
            return mainHandler.paymentManager.HandleLnurlAddress(params.address_name)
        },
        AddProduct: async ({ ctx, req }) => {
            return mainHandler.productManager.AddProduct(ctx.user_id, req)
        },
        NewProductInvoice: async ({ query }) => {
            if (!query.id) {
                throw new Error("product id must be non empty")
            }
            return mainHandler.productManager.NewProductInvoice(query.id)
        },
        GetLNURLChannelLink: async ({ ctx }) => {
            throw new Error("unimplemented")
        },
        AddApp: async ({ ctx, req }) => {
            const err = Types.AuthAppRequestValidate(req, {
                name_CustomCheck: name => name !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddApp(req)
        },
        AuthApp: async ({ ctx, req }) => {
            const err = Types.AuthAppRequestValidate(req, {
                name_CustomCheck: name => name !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AuthApp(req)
        },
        GetApp: async ({ ctx }) => {
            return mainHandler.applicationManager.GetApp(ctx.app_id)
        },
        AddAppUser: async ({ ctx, req }) => {
            const err = Types.AddAppUserRequestValidate(req, {
                identifier_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddAppUser(ctx.app_id, req)
        },
        AddAppInvoice: async ({ ctx, req }) => {
            const err = Types.AddAppInvoiceRequestValidate(req, {
                payer_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddAppInvoice(ctx.app_id, req)
        },
        AddAppUserInvoice: async ({ ctx, req }) => {
            const err = Types.AddAppUserInvoiceRequestValidate(req, {
                payer_identifier_CustomCheck: id => id !== '',
                receiver_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.AddAppUserInvoice(ctx.app_id, req)
        },
        GetAppUser: async ({ ctx, req }) => {
            const err = Types.GetAppUserRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.GetAppUser(ctx.app_id, req)
        },
        PayAppUserInvoice: async ({ ctx, req }) => {
            const err = Types.PayAppUserInvoiceRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.PayAppUserInvoice(ctx.app_id, req)
        },
        SendAppUserToAppUserPayment: async ({ ctx, req }) => {
            const err = Types.SendAppUserToAppUserPaymentRequestValidate(req, {
                to_user_identifier_CustomCheck: id => id !== '',
                from_user_identifier_CustomCheck: id => id !== '',
                amount_CustomCheck: amount => amount > 0
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.applicationManager.SendAppUserToAppUserPayment(ctx.app_id, req)
        },
        SendAppUserToAppPayment: async ({ ctx, req }) => {
            const err = Types.SendAppUserToAppPaymentRequestValidate(req, {
                from_user_identifier_CustomCheck: id => id !== '',
                amount_CustomCheck: amount => amount > 0
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.applicationManager.SendAppUserToAppPayment(ctx.app_id, req)
        },
        GetAppUserLNURLInfo: async ({ ctx, req }) => {
            const err = Types.GetAppUserLNURLInfoRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.GetAppUserLNURLInfo(ctx.app_id, req)
        },
        SetMockAppUserBalance: async ({ ctx, req }) => {
            const err = Types.SetMockAppUserBalanceRequestValidate(req, {
                user_identifier_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            await mainHandler.applicationManager.SetMockAppUserBalance(ctx.app_id, req)
        },
        SetMockAppBalance: async ({ ctx, req }) => {
            await mainHandler.applicationManager.SetMockAppBalance(ctx.app_id, req)
        },
        GetLiveDebitRequests: async ({ ctx }) => { },
        GetLiveManageRequests: async ({ ctx }) => { },
        GetLiveUserOperations: async ({ ctx, cb }) => {
        },
        GetMigrationUpdate: async ({ ctx, cb }) => {
        },
        GetNPubLinkingState: async ({ ctx, req }) => {
            const err = Types.GetNPubLinkingValidate(req, {
                user_identifier_CustomCheck: userIdentifier => userIdentifier !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.GetNPubLinkingState(ctx.app_id, req)
        },
        RequestNPubLinkingToken: async ({ ctx, req }) => {
            const err = Types.RequestNPubLinkingTokenRequestValidate(req, {
                user_identifier_CustomCheck: userIdentifier => userIdentifier !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.RequestNPubLinkingToken(ctx.app_id, req, false)
        },
        ResetNPubLinkingToken: async ({ ctx, req }) => {
            const err = Types.RequestNPubLinkingTokenRequestValidate(req, {
                user_identifier_CustomCheck: userIdentifier => userIdentifier !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.RequestNPubLinkingToken(ctx.app_id, req, true)
        },
        LinkNPubThroughToken: async ({ ctx, req }) => {
            const err = Types.LinkNPubThroughTokenRequestValidate(req, {
                token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.LinkNpubThroughToken(ctx, req)
        },
        EnrollAdminToken: async ({ ctx, req }) => {
            const err = Types.EnrollAdminTokenRequestValidate(req, {
                admin_token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.PromoteUserToAdmin(ctx.app_id, ctx.app_user_id, req.admin_token)
        },
        CreateOneTimeInviteLink: async ({ ctx, req }) => {
            const err = Types.CreateOneTimeInviteLinkRequestValidate(req, {
                sats_CustomCheck: sats => sats === undefined || typeof sats === "number"
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.CreateInviteLink(ctx.admin_id, req.sats)
        },
        UseInviteLink: async ({ ctx, req }) => {
            const err = Types.UseInviteLinkRequestValidate(req, {
                invite_token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.applicationManager.UseInviteLink(ctx, req);
        },
        GetInviteLinkState: async ({ ctx, req }) => {
            const err = Types.GetInviteTokenStateRequestValidate(req, {
                invite_token_CustomCheck: token => token !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.adminManager.GetInviteTokenState(ctx, req);
        },
        AuthorizeDebit: async ({ ctx, req }) => {
            return mainHandler.debitManager.AuthorizeDebit(ctx, req)
        },
        GetDebitAuthorizations: async ({ ctx }) => {
            return mainHandler.debitManager.GetDebitAuthorizations(ctx)
        },
        AuthorizeManage: async ({ ctx, req }) => {
            return mainHandler.managementManager.AuthorizeManage(ctx, req)
        },
        GetManageAuthorizations: async ({ ctx }) => {
            return mainHandler.managementManager.GetManageAuthorizations(ctx)
        },
        BanDebit: async ({ ctx, req }) => {
            const err = Types.DebitOperationValidate(req, {
                npub_CustomCheck: pub => pub !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.debitManager.BanDebit(ctx, req)
        },
        ResetDebit: async ({ ctx, req }) => {
            const err = Types.DebitOperationValidate(req, {
                npub_CustomCheck: pub => pub !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.debitManager.ResetDebit(ctx, req)
        },
        EditDebit: async ({ ctx, req }) => {
            return mainHandler.debitManager.EditDebit(ctx, req);
        },
        RespondToDebit: async ({ ctx, req }) => {
            return mainHandler.debitManager.RespondToDebit(ctx, req);
        },
        AddUserOffer: async ({ ctx, req }) => {
            const err = Types.OfferConfigValidate(req, {
                label_CustomCheck: label => label !== '',
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.offerManager.AddUserOffer(ctx, req)
        },
        DeleteUserOffer: async ({ ctx, req }) => {
            const err = Types.OfferIdValidate(req, {
                offer_id_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.offerManager.DeleteUserOffer(ctx, req)
        },
        UpdateUserOffer: async ({ ctx, req }) => {
            return mainHandler.offerManager.UpdateUserOffer(ctx, req)
        },
        GetUserOffers: async ({ ctx }) => {
            return mainHandler.offerManager.GetUserOffers(ctx)
        },
        GetUserOffer: async ({ ctx, req }) => {
            const err = Types.OfferIdValidate(req, {
                offer_id_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.offerManager.GetUserOffer(ctx, req)
        },
        GetUserOfferInvoices: async ({ ctx, req }) => {
            const err = Types.GetUserOfferInvoicesReqValidate(req, {
                offer_id_CustomCheck: id => id !== ''
            })
            if (err != null) throw new Error(err.message)
            return mainHandler.offerManager.GetUserOfferInvoices(ctx, req)
        },
        GetHttpCreds: async ({ ctx }) => {
            return mainHandler.appUserManager.GetHttpCreds(ctx)
        },
    }
}
