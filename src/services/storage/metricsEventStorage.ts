import fs from 'fs'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { StorageSettings } from "./index.js";
import { decodeListTLV, encodeListTLV, encodeTLV, parseTLV } from '../helpers/tlv.js';
const chunkSizeBytes = 128 * 1024
export default class {
    settings: StorageSettings
    metricsPath: string
    cachePath: string
    metaReady = false
    metricsMeta: Record<string, Record<string, { chunks: number[] }>> = {}
    pendingMetrics: Record<string, Record<string, { tlvs: Uint8Array[] }>> = {}
    last24hCache: { ts: number, ok: number, fail: number }[] = []
    lastPersistedMetrics: number = 0
    lastPersistedCache: number = 0
    constructor(settings: StorageSettings) {
        this.settings = settings;
        this.metricsPath = [settings.dataDir, "metric_events"].join("/")
        this.cachePath = [settings.dataDir, "metric_cache"].join("/")
        if (!fs.existsSync(this.cachePath)) {
            fs.mkdirSync(this.cachePath, { recursive: true });
        }
        this.initMetricsMeta()
        this.loadCache()
        setInterval(() => {
            if (Date.now() - this.lastPersistedMetrics > 1000 * 60 * 4) {
                this.persistMetrics()
            }
            if (Date.now() - this.lastPersistedCache > 1000 * 60 * 4) {
                this.persistCache()
            }
        }, 1000 * 60 * 5)
        process.on('exit', () => {
            this.persistMetrics()
            this.persistCache()
        });

        // catch ctrl+c event and exit normally
        process.on('SIGINT', () => {
            console.log('Ctrl-C...');
            process.exit(2);
        });

        //catch uncaught exceptions, trace, then exit normally
        process.on('uncaughtException', (e) => {
            console.log('Uncaught Exception...');
            console.log(e.stack);
            process.exit(99);
        });
    }

    getlast24hCache = () => { return this.last24hCache }

    rotateCache = (nowUnix: number) => {
        const yesterday = nowUnix - 60 * 60 * 24
        const latest = this.last24hCache.findIndex(c => c.ts >= yesterday)
        if (latest === -1) {
            this.last24hCache = []
            return
        } else if (latest === 0) {
            return
        }
        this.last24hCache = this.last24hCache.slice(latest)
    }

    pushToCache = (ok: boolean) => {
        const now = Math.floor(Date.now() / 1000)
        this.rotateCache(now)
        if (this.last24hCache.length === 0) {
            this.last24hCache.push({ ts: now, ok: ok ? 1 : 0, fail: ok ? 0 : 1 })
            return
        }
        const last = this.last24hCache[this.last24hCache.length - 1]
        if (last.ts === now) {
            last.ok += ok ? 1 : 0
            last.fail += ok ? 0 : 1
        } else {
            this.last24hCache.push({ ts: now, ok: ok ? 1 : 0, fail: ok ? 0 : 1 })
        }
    }

    persistCache = () => {
        const last24CachePath = [this.cachePath, "last24hSF.json"].join("/")
        fs.writeFileSync(last24CachePath, JSON.stringify(this.last24hCache), {})
    }

    loadCache = () => {
        const last24CachePath = [this.cachePath, "last24hSF.json"].join("/")
        if (fs.existsSync(last24CachePath)) {
            this.last24hCache = JSON.parse(fs.readFileSync(last24CachePath, 'utf-8'))
            this.rotateCache(Math.floor(Date.now() / 1000))
        }
    }

    AddMetricEvent = (appId: string, method: string, metric: Uint8Array, success: boolean) => {
        if (!this.metaReady) {
            throw new Error("meta metrics not ready")
        }
        if (!this.pendingMetrics[appId]) {
            this.pendingMetrics[appId] = {}
        }
        if (!this.pendingMetrics[appId][method]) {
            this.pendingMetrics[appId][method] = { tlvs: [] }
        }
        this.pendingMetrics[appId][method].tlvs.push(metric)
        this.pushToCache(success)

    }

    LoadLatestMetrics = async (): Promise<Types.UsageMetrics> => {
        this.persistMetrics()
        const metrics: Types.UsageMetrics = { apps: {} }
        this.foreachMetricMethodFile((app, method, tlvFiles) => {
            if (tlvFiles.length === 0) { return }
            const methodPath = [this.metricsPath, app, method].join("/")
            const latest = tlvFiles[tlvFiles.length - 1]
            const tlvFile = [methodPath, `${latest}.mtlv`].join("/")
            const tlv = fs.readFileSync(tlvFile)
            const decoded = decodeListTLV(parseTLV(tlv))
            if (!metrics.apps[app]) {
                metrics.apps[app] = { app_metrics: {} }
            }
            metrics.apps[app].app_metrics[method] = {
                base_64_tlvs: decoded.map(d => Buffer.from(d).toString('base64')),
                current_chunk: latest,
                available_chunks: tlvFiles
            }
        })
        return metrics
    }

    persistMetrics = () => {
        if (!this.metaReady) {
            throw new Error("meta metrics not ready")
        }
        this.lastPersistedMetrics = Date.now()
        const tosync = this.pendingMetrics
        this.pendingMetrics = {}
        const apps = Object.keys(tosync)
        apps.map(app => {
            const appPath = [this.metricsPath, app].join("/")
            if (!fs.existsSync(appPath)) {
                fs.mkdirSync(appPath, { recursive: true });
            }
            const methods = Object.keys(tosync[app])
            methods.map(methodName => {
                const methodPath = [appPath, methodName].join("/")
                if (!fs.existsSync(methodPath)) {
                    fs.mkdirSync(methodPath, { recursive: true });
                }
                const method = tosync[app][methodName]
                const meta = this.getMetricsMeta(app, methodName)
                const chunks = meta.chunks.length > 0 ? meta.chunks : [0]
                const latest = chunks[chunks.length - 1]
                const tlv = encodeTLV(encodeListTLV(method.tlvs))
                const tlvFile = [methodPath, `${latest}.mtlv`].join("/")
                fs.appendFileSync(tlvFile, Buffer.from(tlv))
                if (fs.lstatSync(tlvFile).size > chunkSizeBytes) {
                    this.updateMetricsMeta(app, methodName, [...chunks, latest + 1])
                }
            })
        })
    }

    initMetricsMeta = () => {
        this.foreachMetricMethodFile((app, method, tlvFiles) => {
            this.updateMetricsMeta(app, method, tlvFiles)
        })
        this.metaReady = true
    }

    updateMetricsMeta = (appId: string, method: string, sortedChunks: number[]) => {
        if (!this.metricsMeta[appId]) {
            this.metricsMeta[appId] = {}
        }
        this.metricsMeta[appId][method] = { chunks: sortedChunks }
    }

    getMetricsMeta = (appId: string, method: string) => {
        if (!this.metricsMeta[appId]) {
            return { chunks: [] }
        }
        return this.metricsMeta[appId][method] || { chunks: [] }
    }

    foreachMetricMethodFile = (cb: (appId: string, method: string, tlvFiles: number[]) => void) => {
        if (!fs.existsSync(this.metricsPath)) {
            fs.mkdirSync(this.metricsPath, { recursive: true });
        }
        const apps = fs.readdirSync(this.metricsPath)
        apps.forEach(appDir => {
            const appPath = [this.metricsPath, appDir].join("/")
            if (!fs.lstatSync(appPath).isDirectory()) {
                return
            }
            const methods = fs.readdirSync(appPath)
            methods.forEach(methodDir => {
                const methodPath = [appPath, methodDir].join("/")
                if (!fs.lstatSync(methodPath).isDirectory()) {
                    return
                }
                const tlvFiles = fs.readdirSync(methodPath)
                    .filter(f => f.endsWith(".mtlv"))
                    .map(f => +f.slice(0, -".mtlv".length))
                    .filter(n => !isNaN(n))
                    .sort((a, b) => a - b)
                cb(appDir, methodDir, tlvFiles)
            })
        })
    }
}