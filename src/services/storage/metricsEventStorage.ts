import fs from 'fs'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { StorageSettings } from "./index.js";
import { decodeListTLV, encodeListTLV, encodeTLV, parseTLV } from '../helpers/tlv.js';
import { TlvFilesStorage } from './tlvFilesStorage.js';
export default class {
    tlvStorage: TlvFilesStorage
    cachePath: string
    last24hCache: { ts: number, ok: number, fail: number }[] = []
    lastPersistedCache: number = 0
    constructor(settings: StorageSettings) {
        const metricsPath = [settings.dataDir, "metric_events"].filter(s => !!s).join("/")
        this.tlvStorage = new TlvFilesStorage(metricsPath)
        this.cachePath = [settings.dataDir, "metric_cache"].filter(s => !!s).join("/")
        if (!fs.existsSync(this.cachePath)) {
            fs.mkdirSync(this.cachePath, { recursive: true });
        }
        this.loadCache()
        setInterval(() => {
            if (Date.now() - this.lastPersistedCache > 1000 * 60 * 4) {
                this.persistCache()
            }
        }, 1000 * 60 * 5)
        process.on('exit', () => {
            this.persistCache()
        });


    }

    getlast24hCache = () => { return this.last24hCache }

    rotateCache = (nowUnix: number) => {
        const yesterday = nowUnix - 60 * 60 * 24
        const latest = this.last24hCache.findIndex(c => c.ts >= yesterday)
        if (latest === -1) {
            this.last24hCache = []
            return
        } else if (latest === 0) {
            return
        }
        this.last24hCache = this.last24hCache.slice(latest)
    }

    pushToCache = (ok: boolean) => {
        const now = Math.floor(Date.now() / 1000)
        this.rotateCache(now)
        if (this.last24hCache.length === 0) {
            this.last24hCache.push({ ts: now, ok: ok ? 1 : 0, fail: ok ? 0 : 1 })
            return
        }
        const last = this.last24hCache[this.last24hCache.length - 1]
        if (last.ts === now) {
            last.ok += ok ? 1 : 0
            last.fail += ok ? 0 : 1
        } else {
            this.last24hCache.push({ ts: now, ok: ok ? 1 : 0, fail: ok ? 0 : 1 })
        }
    }

    persistCache = () => {
        const last24CachePath = [this.cachePath, "last24hSF.json"].filter(s => !!s).filter(s => !!s).join("/")
        fs.writeFileSync(last24CachePath, JSON.stringify(this.last24hCache), {})
    }

    loadCache = () => {
        const last24CachePath = [this.cachePath, "last24hSF.json"].filter(s => !!s).filter(s => !!s).join("/")
        if (fs.existsSync(last24CachePath)) {
            this.last24hCache = JSON.parse(fs.readFileSync(last24CachePath, 'utf-8'))
            this.rotateCache(Math.floor(Date.now() / 1000))
        }
    }

    AddMetricEvent = (appId: string, method: string, metric: Uint8Array, success: boolean) => {
        this.tlvStorage.AddTlv(appId, method, metric)
        this.pushToCache(success)

    }

    LoadLatestMetrics = async (limit = 100): Promise<Types.UsageMetrics> => {
        const raw = this.tlvStorage.LoadLatest(limit)
        const metrics: Types.UsageMetrics = { apps: {} }
        Object.keys(raw).forEach(app => {
            metrics.apps[app] = { app_metrics: {} }
            Object.keys(raw[app]).forEach(method => {
                const data = raw[app][method]
                metrics.apps[app].app_metrics[method] = {
                    base_64_tlvs: data.tlvs.map(d => Buffer.from(d).toString('base64')),
                    current_chunk: data.current_chunk,
                    available_chunks: data.available_chunks
                }
            })
        })
        return metrics
    }
    LoadMetricsFile = async (app: string, method: string, chunk: number): Promise<Types.UsageMetricTlv> => {
        const { fileData, chunks } = this.tlvStorage.LoadFile(app, method, chunk)
        //const tlv = await this.LoadRawMetricsFile(app, method, chunk)
        const decoded = decodeListTLV(parseTLV(fileData))
        return {
            base_64_tlvs: decoded.map(d => Buffer.from(d).toString('base64')),
            current_chunk: chunk,
            available_chunks: chunks
        }
    }
}