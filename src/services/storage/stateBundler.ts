import { LatestBundleMetricReq } from "../../../proto/autogenerated/ts/types.js"
import { getLogger } from "../helpers/logger.js"
import { decodeListTLV, integerToUint8Array, parseTLV } from "../helpers/tlv.js"
import { StorageSettings } from "./index.js"
import { TlvFilesStorage } from "./tlvFilesStorage.js"
import * as Types from "../../../proto/autogenerated/ts/types.js"
const transactionStatePointTypes = ['addedInvoice', 'invoiceWasPaid', 'paidAnInvoice', 'addedAddress', 'addressWasPaid', 'paidAnAddress', 'user2user'] as const
const balanceStatePointTypes = ['providerBalance', 'providerMaxWithdrawable', 'walletBalance', 'channelBalance', 'usersBalance', 'feesPaidForLiquidity', 'totalLndBalance', 'accumulatedHtlcFees', 'deltaUsers', 'deltaExternal'] as const
const maxStatePointTypes = ['maxProviderRespTime'] as const
export type TransactionStatePointType = typeof transactionStatePointTypes[number]
export type BalanceStatePointType = typeof balanceStatePointTypes[number]
export type MaxStatePointType = typeof maxStatePointTypes[number]
/*export type TransactionStatePoint = {
    type: typeof TransactionStatePointTypes[number]
    with: 'lnd' | 'internal' | 'provider'
    by: 'user' | 'system'
    amount: number
    success: boolean
    networkFee?: number
    serviceFee?: number
    liquidtyFee?: number
}*/

type StateBundle = Record<string, number>
export type TxPointSettings = {
    used: 'lnd' | 'internal' | 'provider' | 'unknown'
    from: 'user' | 'system'
    meta?: string[]
    timeDiscount?: true
}
export class StateBundler {

    tlvStorage: TlvFilesStorage
    reportLog = getLogger({ component: 'stateBundlerReport' })
    prevValues: Record<string, number> = {}
    interval: NodeJS.Timeout
    constructor(settings: StorageSettings) {
        const bundlerPath = [settings.dataDir, "bundler_events"].filter(s => !!s).join("/")
        this.tlvStorage = new TlvFilesStorage(bundlerPath)
        this.tlvStorage.initMeta()
        this.interval = setInterval(() => {
            const mem = process.memoryUsage()
            this.AddValue('_root', 'memory_rss', mem.rss || 0, true)
            this.AddValue('_root', 'memory_buffer', mem.arrayBuffers || 0, true)
            this.AddValue('_root', 'memory_heap_total', mem.heapTotal || 0, true)
            this.AddValue('_root', 'memory_heap_used', mem.heapUsed || 0, true)
            this.AddValue('_root', 'memory_external', mem.external || 0, true)
        }, 60 * 1000)
    }

    Stop() {
        clearInterval(this.interval)
    }

    async GetBundleMetrics(req: Types.LatestBundleMetricReq): Promise<Types.BundleMetrics> {
        const latest = this.tlvStorage.LoadLatest(req.limit)
        const metrics: Types.BundleMetrics = { apps: {} }
        Object.keys(latest).forEach(app => {
            metrics.apps[app] = { app_bundles: {} }
            Object.keys(latest[app]).forEach(dataName => {
                const data = latest[app][dataName]
                metrics.apps[app].app_bundles[dataName] = {
                    current_chunk: data.current_chunk,
                    available_chunks: data.available_chunks,
                    base_64_data: data.tlvs.map(d => Buffer.from(d).toString('base64'))
                }
            })
        })
        return metrics
    }

    async GetSingleBundleMetrics(req: Types.SingleMetricReq): Promise<Types.BundleData> {
        const { fileData, chunks } = this.tlvStorage.LoadFile(req.app_id, req.metrics_name, req.page)
        const decoded = decodeListTLV(parseTLV(fileData))
        return {
            current_chunk: req.page,
            available_chunks: chunks,
            base_64_data: decoded.map(d => Buffer.from(d).toString('base64'))
        }
    }

    AddValue = (appId: string, key: string, v: number, updateOnly = false) => {
        const prevValueKey = `${appId}_${key}`
        if (updateOnly && this.prevValues[prevValueKey] === v) {
            return
        }
        this.prevValues[prevValueKey] = v
        this.tlvStorage.AddTlv(appId, key, this.serializeNow(v))
    }

    AddTxPoint = (actionName: TransactionStatePointType, v: number, settings: TxPointSettings, appId = '_root') => {
        const { used, from } = settings
        const meta = settings.meta || []
        const key = [actionName, from, used, ...meta].join('_')

        this.AddValue(appId, key, v)
    }

    AddTxPointFailed = (actionName: TransactionStatePointType, v: number, settings: TxPointSettings, appId = '_root') => {
        const { used, from } = settings
        const meta = settings.meta || []
        const key = [actionName, from, used, ...meta, 'failed'].join('_')
        this.AddValue(appId, key, v)
    }

    AddBalancePoint = (actionName: BalanceStatePointType, v: number, meta = [], appId = '_root') => {
        const key = [actionName, ...meta].join('_')
        this.AddValue(appId, key, v, true)
    }

    AddMaxPoint = (actionName: MaxStatePointType, v: number, meta = [], appId = '_root') => {
        const key = [actionName, ...meta].join('_')
        this.AddValue(appId, key, v)
    }

    serializeNow = (v: number) => {
        const nowUnix = Math.floor(Date.now() / 1000)
        const entry = new Uint8Array(8)
        entry.set(integerToUint8Array(nowUnix), 0)
        entry.set(integerToUint8Array(v), 4)
        return entry
    }

    /*     triggerReportCheck = () => {
            const discountSeconds = Math.floor(this.totalSatsForDiscount / this.satsPer1SecondDiscount)
            const totalElapsed = Date.now() - this.latestReport
            const elapsedWithDiscount = totalElapsed + discountSeconds * 1000
            if (elapsedWithDiscount > this.reportPeriod) {
                this.Report()
            }
        } */

    /*     smallLogEvent(event: TransactionStatePointType, from: 'user' | 'system') {
            const char = from === 'user' ? 'U' : 'S'
            switch (event) {
                case 'addedAddress':
                case 'addedInvoice':
                    process.stdout.write(`${char}+,`)
                    return
                case 'addressWasPaid':
                case 'invoiceWasPaid':
                    process.stdout.write(`${char}>,`)
                    return
                case 'paidAnAddress':
                case 'paidAnInvoice':
                    process.stdout.write(`${char}<,`)
                    return
                case 'user2user':
                    process.stdout.write(`UU`)
            }
        } */

    /*     Report = () => {
            this.totalSatsForDiscount = 0
            this.latestReport = Date.now()
            this.reportLog("+++++ since last report:")
            Object.entries(this.sinceLatestReport).forEach(([key, value]) => {
                this.reportLog(key, value)
            })
            this.reportLog("+++++ since start:")
            Object.entries(this.sinceStart).forEach(([key, value]) => {
                this.reportLog(key, value)
            })
            this.lastReport = { ...this.sinceLatestReport }
            this.sinceLatestReport = {}
        } */
}