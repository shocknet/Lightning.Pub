import fs from 'fs'
import path from 'path';
import { config as loadEnvFile } from 'dotenv'
import { getLogger } from "../helpers/logger.js"
import NewWizardServer from "../../../proto/wizard_service/autogenerated/ts/express_server.js"
import * as WizardTypes from "../../../proto/wizard_service/autogenerated/ts/types.js"
import { MainSettings } from "../main/settings.js"
import Storage from '../storage/index.js'
import { Unlocker } from "../main/unlocker.js"
export type WizardSettings = {
    sourceName: string
    relayUrl: string
    automateLiquidity: boolean
    pushBackupsToNostr: boolean
}
const defaultProviderPub = ""
export class Wizard {
    log = getLogger({ component: "wizard" })
    settings: MainSettings
    unlocker: Unlocker
    initialized = false
    configQueue: { res: (reload: boolean) => void }[] = []
    pendingConfig: WizardSettings | null = null
    constructor(mainSettings: MainSettings, storage: Storage) {
        this.settings = mainSettings
        this.log('Starting wizard...')
        this.unlocker = new Unlocker(mainSettings, storage)
        const wizardServer = NewWizardServer({
            WizardState: async () => { return { already_initialized: await this.IsInitialized() } },
            WizardConfig: async ({ req }) => { return this.wizardConfig(req) },
            WizardConfirm: async ({ req }) => { return this.wizardConfirm(req) },
        }, { GuestAuthGuard: async () => "", metricsCallback: () => { }, staticFiles: 'static' })
        wizardServer.Listen(mainSettings.servicePort + 1)
    }

    IsInitialized = () => {
        if (this.initialized) {
            return true
        }
        return this.unlocker.IsInitialized()
    }

    WaitUntilConfigured = async (): Promise<boolean> => {
        if (this.initialized) {
            return false
        }
        return new Promise((res) => {
            this.configQueue.push({ res })
        })
    }

    wizardConfig = async (req: WizardTypes.ConfigRequest): Promise<WizardTypes.ConfigResponse> => {
        const err = WizardTypes.ConfigRequestValidate(req, {
            source_name_CustomCheck: source => source !== '',
            relay_url_CustomCheck: relay => relay !== '',
        })
        if (err != null) { throw new Error(err.message) }

        const res = await this.unlocker.InitInteractive()
        if (res.alreadyInitizialized) {
            this.initialized = true
            this.configQueue.forEach(q => q.res(false))
            return { already_initialized: true, confirmation_id: "", seed: [] }
        }
        this.pendingConfig = { sourceName: req.source_name, relayUrl: req.relay_url, automateLiquidity: req.automate_liquidity, pushBackupsToNostr: req.push_backups_to_nostr }
        return { already_initialized: false, confirmation_id: res.confirmationId, seed: res.seed }

    }

    wizardConfirm = async (req: WizardTypes.ConfirmRequest): Promise<WizardTypes.ConfirmResponse> => {
        const err = WizardTypes.ConfirmRequestValidate(req, {
            confirmation_id_CustomCheck: conf => conf !== '',
        })
        if (err != null) { throw new Error(err.message) }

        const res = await this.unlocker.ConfirmInitInteractive(req.confirmation_id)
        if (res?.alreadyInitizialized) {
            this.initialized = true
            this.configQueue.forEach(q => q.res(false))
            return { admin_key: "" }
        }
        this.initialized = true
        this.updateEnvFile()
        this.configQueue.forEach(q => q.res(true))
        return { admin_key: process.env.ADMIN_TOKEN || "" }
    }

    updateEnvFile = () => {
        if (!this.pendingConfig) {
            return
        }
        let envFileContent: string[] = []
        try {
            envFileContent = fs.readFileSync('.env', 'utf-8').split('\n')
        } catch (err: any) {
            if (err.code !== 'ENOENT') {
            }
        }

        const toMerge: string[] = []
        const sourceNameIndex = envFileContent.findIndex(line => line.startsWith('DEFAULT_APP_NAME'))
        if (sourceNameIndex === -1) {
            toMerge.push(`DEFAULT_APP_NAME=${this.pendingConfig.sourceName}`)
        } else {
            envFileContent[sourceNameIndex] = `DEFAULT_APP_NAME=${this.pendingConfig.sourceName}`
        }
        const relayUrlIndex = envFileContent.findIndex(line => line.startsWith('RELAY_URL'))
        if (relayUrlIndex === -1) {
            toMerge.push(`RELAY_URL=${this.pendingConfig.relayUrl}`)
        } else {
            envFileContent[relayUrlIndex] = `RELAY_URL=${this.pendingConfig.relayUrl}`
        }

        const automateLiquidityIndex = envFileContent.findIndex(line => line.startsWith('LIQUIDITY_PROVIDER_PUB'))
        if (automateLiquidityIndex === -1) {
            toMerge.push(`LIQUIDITY_PROVIDER_PUB=${this.pendingConfig.automateLiquidity ? defaultProviderPub : ""}`)
        } else {
            envFileContent[automateLiquidityIndex] = `LIQUIDITY_PROVIDER_PUB=`
        }

        const pushBackupsToNostrIndex = envFileContent.findIndex(line => line.startsWith('PUSH_BACKUPS_TO_NOSTR'))
        if (pushBackupsToNostrIndex === -1) {
            toMerge.push(`PUSH_BACKUPS_TO_NOSTR=${this.pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`)
        } else {
            envFileContent[pushBackupsToNostrIndex] = `PUSH_BACKUPS_TO_NOSTR=${this.pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`
        }
        const merged = [...envFileContent, ...toMerge].join('\n')
        fs.writeFileSync('.env', merged)
        loadEnvFile()
    }
}