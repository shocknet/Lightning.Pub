import fs from 'fs'
import path from 'path';
import { config as loadEnvFile } from 'dotenv'
import { getLogger } from "../helpers/logger.js"
import NewWizardServer from "../../../proto/wizard_service/autogenerated/ts/express_server.js"
import * as WizardTypes from "../../../proto/wizard_service/autogenerated/ts/types.js"
import { MainSettings } from "../main/settings.js"
import Storage from '../storage/index.js'
import { Unlocker } from "../main/unlocker.js"
import { AdminManager } from '../main/adminManager.js';
export type WizardSettings = {
    sourceName: string
    relayUrl: string
    automateLiquidity: boolean
    pushBackupsToNostr: boolean
}
const defaultProviderPub = ""
export class Wizard {
    log = getLogger({ component: "wizard" })
    settings: MainSettings
    adminManager: AdminManager
    storage: Storage
    configQueue: { res: (reload: boolean) => void }[] = []
    pendingConfig: WizardSettings | null = null
    awaitingNprofile: { res: (nprofile: string) => void }[] = []
    nprofile = ""
    relays: string[] = []
    constructor(mainSettings: MainSettings, storage: Storage, adminManager: AdminManager) {
        this.settings = mainSettings
        this.adminManager = adminManager
        this.storage = storage
        this.log('Starting wizard...')
        const wizardServer = NewWizardServer({
            WizardState: async () => { return this.WizardState() },
            WizardConfig: async ({ req }) => { return this.wizardConfig(req) },
            GetAdminConnectInfo: async () => { return this.GetAdminConnectInfo() },
            GetServiceState: async () => { return this.GetServiceState() }
        }, { GuestAuthGuard: async () => "", metricsCallback: () => { }, staticFiles: 'static' })
        wizardServer.Listen(mainSettings.servicePort + 1)
    }

    GetServiceState = async (): Promise<WizardTypes.ServiceStateResponse> => {
        try {
            const apps = await this.storage.applicationStorage.GetApplications()
            const appNamesList = apps.map(app => app.name).join(', ')
            const relays = this.settings.nostrRelaySettings ? this.settings.nostrRelaySettings.relays : [];
            const relayUrl = (relays && relays.length > 0) ? relays[0] : '';
            const defaultApp = apps.find(a => a.name === this.settings.defaultAppName) || apps[0]
            return {
                admin_npub: this.adminManager.GetAdminNpub(),
                http_url: this.settings.serviceUrl,
                lnd_state: WizardTypes.LndState.OFFLINE,
                nprofile: this.nprofile,
                provider_name: appNamesList,
                relay_connected: false,
                relays: this.relays,
                watchdog_ok: false,
                source_name: this.settings.defaultAppName || appNamesList,
                relay_url: relayUrl,
                automate_liquidity: this.settings.liquiditySettings.liquidityProviderPub !== 'null',
                push_backups_to_nostr: this.settings.pushBackupsToNostr,
                avatar_url: (defaultApp as any)?.avatar_url || '',
                app_id: defaultApp?.app_id || ''
            }
        } catch (e) {
            this.log(`Error in GetServiceState: ${(e as Error).message}`)
            // Return a default/error state that is still valid JSON to prevent client-side parse errors
            return {
                admin_npub: '',
                http_url: '',
                lnd_state: WizardTypes.LndState.OFFLINE,
                nprofile: '',
                provider_name: 'Error loading state',
                relay_connected: false,
                relays: [],
                watchdog_ok: false,
                source_name: 'Error',
                relay_url: '',
                automate_liquidity: false,
                push_backups_to_nostr: false,
                avatar_url: '',
                app_id: ''
            }
        }
    }
    WizardState = async (): Promise<WizardTypes.StateResponse> => {
        return {
            config_sent: this.pendingConfig !== null,
            admin_linked: this.adminManager.GetAdminNpub() !== "",
        }
    }
    IsInitialized = () => {
        return !!this.adminManager.GetAdminNpub()
    }

    GetAdminConnectInfo = async (): Promise<WizardTypes.AdminConnectInfoResponse> => {
        const nprofile = await this.getNprofile()
        const enrolledAdmin = this.adminManager.GetAdminNpub()
        if (enrolledAdmin !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ENROLLED_NPUB,
                    enrolled_npub: enrolledAdmin
                }
            }
        }
        const adminEnroll = this.adminManager.ReadAdminEnrollToken()
        if (adminEnroll !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ADMIN_TOKEN,
                    admin_token: adminEnroll
                }
            }
        }
        throw new Error("something went wrong initializing admin creds")
    }

    getNprofile = async (): Promise<string> => {
        if (this.nprofile !== "") {
            return this.nprofile
        }
        console.log("waiting for nprofile")
        return new Promise((res) => {
            this.awaitingNprofile.push({ res })
        })
    }

    AddConnectInfo = (nprofile: string, relays: string[]) => {
        this.nprofile = nprofile
        this.relays = relays
        this.awaitingNprofile.forEach(q => q.res(nprofile))
        this.awaitingNprofile = []
    }

    Configure = async (): Promise<boolean> => {
        if (this.IsInitialized() || this.pendingConfig !== null) {
            return false
        }
        return new Promise((res) => {
            this.configQueue.push({ res })
        })
    }

    wizardConfig = async (req: WizardTypes.ConfigRequest): Promise<void> => {
        const err = WizardTypes.ConfigRequestValidate(req, {
            source_name_CustomCheck: source => source !== '',
            relay_url_CustomCheck: relay => relay !== '',
        })
        if (err != null) { throw new Error(err.message) }
        if (this.IsInitialized() || this.pendingConfig !== null) {
            throw new Error("already initialized")
        }
        const pendingConfig = { sourceName: req.source_name, relayUrl: req.relay_url, automateLiquidity: req.automate_liquidity, pushBackupsToNostr: req.push_backups_to_nostr }
        
        // Also update the application name in the database
        try {
            const appsList = await this.storage.applicationStorage.GetApplications()
            const defaultNames = ['wallet', 'wallet-test', this.settings.defaultAppName]
            const existingDefaultApp = appsList.find(app => defaultNames.includes(app.name))
            if (existingDefaultApp) {
                await this.storage.applicationStorage.UpdateApplication(existingDefaultApp, { name: req.source_name, avatar_url: (req as any).avatar_url || existingDefaultApp.avatar_url })
            }
        } catch (e) {
            this.log(`Error updating app name: ${(e as Error).message}`)
        }

        this.updateEnvFile(pendingConfig)
        this.configQueue.forEach(q => q.res(true))
        this.configQueue = []
        return
    }

    updateEnvFile = (pendingConfig: WizardSettings) => {
        let envFileContent: string[] = []
        try {
            envFileContent = fs.readFileSync('.env', 'utf-8').split('\n')
        } catch (err: any) {
            if (err.code !== 'ENOENT') {
                throw err
            }
        }

        const toMerge: string[] = []
        const sourceNameIndex = envFileContent.findIndex(line => line.startsWith('DEFAULT_APP_NAME'))
        if (sourceNameIndex === -1) {
            toMerge.push(`DEFAULT_APP_NAME=${pendingConfig.sourceName}`)
        } else {
            envFileContent[sourceNameIndex] = `DEFAULT_APP_NAME=${pendingConfig.sourceName}`
        }
        const relayUrlIndex = envFileContent.findIndex(line => line.startsWith('RELAY_URL'))
        if (relayUrlIndex === -1) {
            toMerge.push(`RELAY_URL=${pendingConfig.relayUrl}`)
        } else {
            envFileContent[relayUrlIndex] = `RELAY_URL=${pendingConfig.relayUrl}`
        }

        const automateLiquidityIndex = envFileContent.findIndex(line => line.startsWith('LIQUIDITY_PROVIDER_PUB'))
        if (pendingConfig.automateLiquidity) {
            if (automateLiquidityIndex !== -1) {
                envFileContent.splice(automateLiquidityIndex, 1)
            }
        } else {
            if (automateLiquidityIndex === -1) {
                toMerge.push(`LIQUIDITY_PROVIDER_PUB=null`)
            } else {
                envFileContent[automateLiquidityIndex] = `LIQUIDITY_PROVIDER_PUB=null`
            }
        }

        const pushBackupsToNostrIndex = envFileContent.findIndex(line => line.startsWith('PUSH_BACKUPS_TO_NOSTR'))
        if (pushBackupsToNostrIndex === -1) {
            toMerge.push(`PUSH_BACKUPS_TO_NOSTR=${pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`)
        } else {
            envFileContent[pushBackupsToNostrIndex] = `PUSH_BACKUPS_TO_NOSTR=${pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`
        }
        const merged = [...envFileContent, ...toMerge].join('\n')
        fs.writeFileSync('.env', merged)
        loadEnvFile()
    }
}