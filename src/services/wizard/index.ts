import { getLogger } from "../helpers/logger.js"
import NewWizardServer from "../../../proto/wizard_service/autogenerated/ts/express_server.js"
import * as WizardTypes from "../../../proto/wizard_service/autogenerated/ts/types.js"
import SettingsManager from "../main/settingsManager.js"
import Storage from '../storage/index.js'
import { Unlocker } from "../main/unlocker.js"
import { AdminManager } from '../main/adminManager.js';
export type WizardSettings = {
    sourceName: string
    relayUrl: string
    automateLiquidity: boolean
    pushBackupsToNostr: boolean
}
const defaultProviderPub = ""
export class Wizard {
    log = getLogger({ component: "wizard" })
    settings: SettingsManager
    adminManager: AdminManager
    storage: Storage
    configQueue: { res: (reload: boolean) => void }[] = []
    awaitingNprofile: { res: (nprofile: string) => void }[] = []
    nprofile = ""
    relays: string[] = []
    constructor(settings: SettingsManager, storage: Storage, adminManager: AdminManager) {
        this.settings = settings
        this.adminManager = adminManager
        this.storage = storage
        this.log('Starting wizard...')
        const wizardServer = NewWizardServer({
            WizardState: async () => { return this.WizardState() },
            WizardConfig: async ({ req }) => { return this.wizardConfig(req) },
            GetAdminConnectInfo: async () => { return this.GetAdminConnectInfo() },
            GetServiceState: async () => { return this.GetServiceState() }
        }, { GuestAuthGuard: async () => "", metricsCallback: () => { }, staticFiles: 'static' })
        wizardServer.Listen(settings.getSettings().serviceSettings.servicePort + 1)
    }

    GetServiceState = async (): Promise<WizardTypes.ServiceStateResponse> => {
        try {
            const apps = await this.storage.applicationStorage.GetApplications()
            const appNamesList = apps.map(app => app.name).join(', ')
            const relays = this.settings.getSettings().nostrRelaySettings.relays
            const relayUrl = (relays && relays.length > 0) ? relays[0] : '';
            const defaultApp = apps.find(a => a.name === this.settings.getSettings().serviceSettings.defaultAppName) || apps[0]
            // Determine LND state and watchdog
            let lndState: WizardTypes.LndState = WizardTypes.LndState.OFFLINE
            let watchdogOk = false
            try {
                const info = await this.adminManager.LndGetInfo()
                const online = info.synced_to_chain && info.synced_to_graph
                lndState = online ? WizardTypes.LndState.ONLINE : WizardTypes.LndState.SYNCING
                watchdogOk = !info.watchdog_barking
            } catch {
                lndState = WizardTypes.LndState.OFFLINE
                watchdogOk = false
            }
            return {
                admin_npub: this.adminManager.GetAdminNpub(),
                http_url: this.settings.getSettings().serviceSettings.serviceUrl,
                lnd_state: lndState,
                nprofile: this.nprofile,
                provider_name: defaultApp?.name || appNamesList,
                relay_connected: this.adminManager.GetNostrConnected(),
                relays: this.relays,
                watchdog_ok: watchdogOk,
                source_name: defaultApp?.name || this.settings.getSettings().serviceSettings.defaultAppName || appNamesList,
                relay_url: relayUrl,
                automate_liquidity: !this.settings.getSettings().liquiditySettings.disableLiquidityProvider,
                push_backups_to_nostr: this.settings.getSettings().serviceSettings.pushBackupsToNostr,
                avatar_url: defaultApp?.avatar_url || '',
                app_id: defaultApp?.app_id || ''
            }
        } catch (e) {
            this.log(`Error in GetServiceState: ${(e as Error).message}`)
            // Return a default/error state that is still valid JSON to prevent client-side parse errors
            return {
                admin_npub: '',
                http_url: '',
                lnd_state: WizardTypes.LndState.OFFLINE,
                nprofile: '',
                provider_name: 'Error loading state',
                relay_connected: false,
                relays: [],
                watchdog_ok: false,
                source_name: 'Error',
                relay_url: '',
                automate_liquidity: false,
                push_backups_to_nostr: false,
                avatar_url: '',
                app_id: ''
            }
        }
    }


    WizardState = async (): Promise<WizardTypes.StateResponse> => {
        return {
            config_sent: false,
            admin_linked: this.adminManager.GetAdminNpub() !== "",
        }
    }
    IsInitialized = () => {
        return !!this.adminManager.GetAdminNpub()
    }

    GetAdminConnectInfo = async (): Promise<WizardTypes.AdminConnectInfoResponse> => {
        const nprofile = await this.getNprofile()
        const enrolledAdmin = this.adminManager.GetAdminNpub()
        if (enrolledAdmin !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ENROLLED_NPUB,
                    enrolled_npub: enrolledAdmin
                }
            }
        }
        const adminEnroll = this.adminManager.ReadAdminEnrollToken()
        if (adminEnroll !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ADMIN_TOKEN,
                    admin_token: adminEnroll
                }
            }
        }
        throw new Error("something went wrong initializing admin creds")
    }

    getNprofile = async (): Promise<string> => {
        if (this.nprofile !== "") {
            return this.nprofile
        }
        this.log("waiting for nprofile")
        // Add timeout to prevent hanging forever
        return Promise.race([
            new Promise<string>((res) => {
            this.awaitingNprofile.push({ res })
            }),
            new Promise<string>((_, reject) => {
                setTimeout(() => reject(new Error("timeout waiting for nprofile")), 30000)
        })
        ])
    }

    AddConnectInfo = (nprofile: string, relays: string[]) => {
        this.nprofile = nprofile
        this.relays = relays
        this.awaitingNprofile.forEach(q => q.res(nprofile))
        this.awaitingNprofile = []
    }

    Configure = async (): Promise<boolean> => {
        if (this.IsInitialized()) {
            return false
        }
        return new Promise((res) => {
            this.configQueue.push({ res })
        })
    }

    wizardConfig = async (req: WizardTypes.ConfigRequest): Promise<void> => {
        const err = WizardTypes.ConfigRequestValidate(req, {
            source_name_CustomCheck: source => source !== '',
            relay_url_CustomCheck: relay => relay !== '',
        })
        if (err != null) { throw new Error(err.message) }
        const pendingConfig = { sourceName: req.source_name, relayUrl: req.relay_url, automateLiquidity: req.automate_liquidity, pushBackupsToNostr: req.push_backups_to_nostr }

        // Persist app name/avatar to DB regardless (idempotent behavior)
        // automateLiquidity=true means enable automation, so disableLiquidityProvider should be false
        await this.settings.updateDisableLiquidityProvider(!pendingConfig.automateLiquidity)
        await this.settings.updatePushBackupsToNostr(pendingConfig.pushBackupsToNostr)
        const oldAppName = this.settings.getSettings().serviceSettings.defaultAppName
        const nameUpdated = await this.settings.updateDefaultAppName(pendingConfig.sourceName)
        // Always try to update the default app info (handles avatar update even if name didn't change)
        await this.updateDefaultApp(oldAppName, req.avatar_url)
        
        const relayUpdated = await this.settings.updateRelayUrl(pendingConfig.relayUrl)
        if (relayUpdated && this.IsInitialized()) {
            await this.adminManager.ResetNostr()
        }

        // If already initialized, treat as idempotent update for env and exit
        if (this.IsInitialized()) {
            this.log("reloaded wizard config")
            if (nameUpdated) this.log("name updated")
            if (relayUpdated) this.log("relay updated")
            return
        }

        // First-time configuration flow
        this.configQueue.forEach(q => q.res(true))
        this.configQueue = []
        return
    }

    updateDefaultApp = async (currentName: string, avatarUrl?: string): Promise<void> => {
        const newName = this.settings.getSettings().serviceSettings.defaultAppName
        try {
            const appsList = await this.storage.applicationStorage.GetApplications()
            const defaultNames = ['wallet', 'wallet-test', currentName]
            let existingDefaultApp = appsList.find(app => defaultNames.includes(app.name)) || appsList[0]
            
            if (existingDefaultApp) {
                await this.storage.applicationStorage.UpdateApplication(existingDefaultApp, { 
                    name: newName, 
                    avatar_url: avatarUrl !== undefined ? avatarUrl : existingDefaultApp.avatar_url 
                    // Note: We don't update ID here to maintain consistency
                })
            } else {
                // If no app exists yet (first run), create it now so settings are preserved
                const newApp = await this.storage.applicationStorage.AddApplication(newName, true)
                if (avatarUrl) {
                    await this.storage.applicationStorage.UpdateApplication(newApp, { avatar_url: avatarUrl })
                }
            }
        } catch (e) {
            this.log(`Error updating app info: ${(e as Error).message}`)
        }
    }

    // Dev helper: Reset wizard in-memory state (doesn't clear DB settings)
    ResetWizardState = async (): Promise<void> => {
        this.log("Resetting wizard in-memory state for dev/testing")
        this.nprofile = ""
        this.relays = []
        // Clear any pending config queues
        this.configQueue.forEach(q => q.res(false))
        this.configQueue = []
        this.awaitingNprofile.forEach(q => q.res(""))
        this.awaitingNprofile = []
        // Note: To fully reset wizard config, clear AdminSettings DB entries:
        // DEFAULT_APP_NAME, NOSTR_RELAYS, DISABLE_LIQUIDITY_PROVIDER, PUSH_BACKUPS_TO_NOSTR
    }
}