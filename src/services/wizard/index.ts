import fs from 'fs'
import path from 'path';
import { config as loadEnvFile } from 'dotenv'
import { getLogger } from "../helpers/logger.js"
import NewWizardServer from "../../../proto/wizard_service/autogenerated/ts/express_server.js"
import * as WizardTypes from "../../../proto/wizard_service/autogenerated/ts/types.js"
import { MainSettings } from "../main/settings.js"
import Storage from '../storage/index.js'
import { Unlocker } from "../main/unlocker.js"
import { AdminManager } from '../main/adminManager.js';
export type WizardSettings = {
    sourceName: string
    relayUrl: string
    automateLiquidity: boolean
    pushBackupsToNostr: boolean
}
const defaultProviderPub = ""
export class Wizard {
    log = getLogger({ component: "wizard" })
    settings: MainSettings
    adminManager: AdminManager
    storage: Storage
    configQueue: { res: (reload: boolean) => void }[] = []
    pendingConfig: WizardSettings | null = null
    awaitingNprofile: { res: (nprofile: string) => void }[] = []
    nprofile = ""
    relays: string[] = []
    constructor(mainSettings: MainSettings, storage: Storage, adminManager: AdminManager) {
        this.settings = mainSettings
        this.adminManager = adminManager
        this.storage = storage
        this.log('Starting wizard...')
        const wizardServer = NewWizardServer({
            WizardState: async () => { return this.WizardState() },
            WizardConfig: async ({ req }) => { return this.wizardConfig(req) },
            GetAdminConnectInfo: async () => { return this.GetAdminConnectInfo() },
            GetServiceState: async () => { return this.GetServiceState() }
        }, { GuestAuthGuard: async () => "", metricsCallback: () => { }, staticFiles: 'static' })
        wizardServer.Listen(mainSettings.servicePort + 1)
    }

    GetServiceState = async (): Promise<WizardTypes.ServiceStateResponse> => {
        const apps = await this.storage.applicationStorage.GetApplications()
        const appNamesList = apps.map(app => app.name).join(', ')
        return {
            admin_npub: this.adminManager.GetAdminNpub(),
            http_url: this.settings.serviceUrl,
            lnd_state: WizardTypes.LndState.OFFLINE,
            nprofile: this.nprofile,
            provider_name: appNamesList,
            relay_connected: false,
            relays: this.relays,
            watchdog_ok: false
        }
    }
    WizardState = async (): Promise<WizardTypes.StateResponse> => {
        return {
            config_sent: this.pendingConfig !== null,
            admin_linked: this.adminManager.GetAdminNpub() !== "",
        }
    }
    IsInitialized = () => {
        return !!this.adminManager.GetAdminNpub()
    }

    GetAdminConnectInfo = async (): Promise<WizardTypes.AdminConnectInfoResponse> => {
        const nprofile = await this.getNprofile()
        const enrolledAdmin = this.adminManager.GetAdminNpub()
        if (enrolledAdmin !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ENROLLED_NPUB,
                    enrolled_npub: enrolledAdmin
                }
            }
        }
        const adminEnroll = this.adminManager.ReadAdminEnrollToken()
        if (adminEnroll !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ADMIN_TOKEN,
                    admin_token: adminEnroll
                }
            }
        }
        throw new Error("something went wrong initializing admin creds")
    }

    getNprofile = async (): Promise<string> => {
        if (this.nprofile !== "") {
            return this.nprofile
        }
        console.log("waiting for nprofile")
        return new Promise((res) => {
            this.awaitingNprofile.push({ res })
        })
    }

    AddConnectInfo = (nprofile: string, relays: string[]) => {
        this.nprofile = nprofile
        this.relays = relays
        this.awaitingNprofile.forEach(q => q.res(nprofile))
        this.awaitingNprofile = []
    }

    Configure = async (): Promise<boolean> => {
        if (this.IsInitialized() || this.pendingConfig !== null) {
            return false
        }
        return new Promise((res) => {
            this.configQueue.push({ res })
        })
    }

    wizardConfig = async (req: WizardTypes.ConfigRequest): Promise<void> => {
        const err = WizardTypes.ConfigRequestValidate(req, {
            source_name_CustomCheck: source => source !== '',
            relay_url_CustomCheck: relay => relay !== '',
        })
        if (err != null) { throw new Error(err.message) }
        if (this.IsInitialized() || this.pendingConfig !== null) {
            throw new Error("already initialized")
        }
        const pendingConfig = { sourceName: req.source_name, relayUrl: req.relay_url, automateLiquidity: req.automate_liquidity, pushBackupsToNostr: req.push_backups_to_nostr }
        this.updateEnvFile(pendingConfig)
        this.configQueue.forEach(q => q.res(true))
        this.configQueue = []
        return
    }

    updateEnvFile = (pendingConfig: WizardSettings) => {
        let envFileContent: string[] = []
        try {
            envFileContent = fs.readFileSync('.env', 'utf-8').split('\n')
        } catch (err: any) {
            if (err.code !== 'ENOENT') {
                throw err
            }
        }

        const toMerge: string[] = []
        const sourceNameIndex = envFileContent.findIndex(line => line.startsWith('DEFAULT_APP_NAME'))
        if (sourceNameIndex === -1) {
            toMerge.push(`DEFAULT_APP_NAME=${pendingConfig.sourceName}`)
        } else {
            envFileContent[sourceNameIndex] = `DEFAULT_APP_NAME=${pendingConfig.sourceName}`
        }
        const relayUrlIndex = envFileContent.findIndex(line => line.startsWith('RELAY_URL'))
        if (relayUrlIndex === -1) {
            toMerge.push(`RELAY_URL=${pendingConfig.relayUrl}`)
        } else {
            envFileContent[relayUrlIndex] = `RELAY_URL=${pendingConfig.relayUrl}`
        }

        const automateLiquidityIndex = envFileContent.findIndex(line => line.startsWith('LIQUIDITY_PROVIDER_PUB'))
        if (automateLiquidityIndex === -1) {
            toMerge.push(`LIQUIDITY_PROVIDER_PUB=${pendingConfig.automateLiquidity ? defaultProviderPub : ""}`)
        } else {
            envFileContent[automateLiquidityIndex] = `LIQUIDITY_PROVIDER_PUB=null`
        }

        const pushBackupsToNostrIndex = envFileContent.findIndex(line => line.startsWith('PUSH_BACKUPS_TO_NOSTR'))
        if (pushBackupsToNostrIndex === -1) {
            toMerge.push(`PUSH_BACKUPS_TO_NOSTR=${pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`)
        } else {
            envFileContent[pushBackupsToNostrIndex] = `PUSH_BACKUPS_TO_NOSTR=${pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`
        }
        const merged = [...envFileContent, ...toMerge].join('\n')
        fs.writeFileSync('.env', merged)
        loadEnvFile()
    }
}