import { getLogger } from "../helpers/logger.js"
import NewWizardServer from "../../../proto/wizard_service/autogenerated/ts/express_server.js"
import * as WizardTypes from "../../../proto/wizard_service/autogenerated/ts/types.js"
import SettingsManager from "../main/settingsManager.js"
import Storage from '../storage/index.js'
import { Unlocker } from "../main/unlocker.js"
import { AdminManager } from '../main/adminManager.js';
export type WizardSettings = {
    sourceName: string
    relayUrl: string
    automateLiquidity: boolean
    pushBackupsToNostr: boolean
}
const defaultProviderPub = ""
export class Wizard {
    log = getLogger({ component: "wizard" })
    settings: SettingsManager
    adminManager: AdminManager
    storage: Storage
    configQueue: { res: (reload: boolean) => void }[] = []
    awaitingNprofile: { res: (nprofile: string) => void }[] = []
    nprofile = ""
    relays: string[] = []
    constructor(settings: SettingsManager, storage: Storage, adminManager: AdminManager) {
        this.settings = settings
        this.adminManager = adminManager
        this.storage = storage
        this.log('Starting wizard...')
        const wizardServer = NewWizardServer({
            WizardState: async () => { return this.WizardState() },
            WizardConfig: async ({ req }) => { return this.wizardConfig(req) },
            GetAdminConnectInfo: async () => { return this.GetAdminConnectInfo() },
            GetServiceState: async () => { return this.GetServiceState() }
        }, { GuestAuthGuard: async () => "", metricsCallback: () => { }, staticFiles: 'static' })
        wizardServer.Listen(settings.getSettings().serviceSettings.servicePort + 1)
    }

    GetServiceState = async (): Promise<WizardTypes.ServiceStateResponse> => {
        try {
            const apps = await this.storage.applicationStorage.GetApplications()
            const appNamesList = apps.map(app => app.name).join(', ')
            const relays = this.settings.getSettings().nostrRelaySettings.relays
            const relayUrl = (relays && relays.length > 0) ? relays[0] : '';
            const defaultApp = apps.find(a => a.name === this.settings.getSettings().serviceSettings.defaultAppName) || apps[0]
            // Determine LND state and watchdog
            let lndState: WizardTypes.LndState = WizardTypes.LndState.OFFLINE
            let watchdogOk = false
            try {
                const info = await this.adminManager.LndGetInfo()
                const online = info.synced_to_chain && info.synced_to_graph
                lndState = online ? WizardTypes.LndState.ONLINE : WizardTypes.LndState.SYNCING
                watchdogOk = !info.watchdog_barking
            } catch {
                lndState = WizardTypes.LndState.OFFLINE
                watchdogOk = false
            }
            return {
                admin_npub: this.adminManager.GetAdminNpub(),
                http_url: this.settings.getSettings().serviceSettings.serviceUrl,
                lnd_state: lndState,
                nprofile: this.nprofile,
                provider_name: defaultApp?.name || appNamesList,
                relay_connected: this.adminManager.GetNostrConnected(),
                relays: this.relays,
                watchdog_ok: watchdogOk,
                source_name: defaultApp?.name || this.settings.getSettings().serviceSettings.defaultAppName || appNamesList,
                relay_url: relayUrl,
                automate_liquidity: this.settings.getSettings().liquiditySettings.liquidityProviderPub !== 'null',
                push_backups_to_nostr: this.settings.getSettings().serviceSettings.pushBackupsToNostr,
                avatar_url: defaultApp?.avatar_url || '',
                app_id: defaultApp?.app_id || ''
            }
        } catch (e) {
            this.log(`Error in GetServiceState: ${(e as Error).message}`)
            // Return a default/error state that is still valid JSON to prevent client-side parse errors
            return {
                admin_npub: '',
                http_url: '',
                lnd_state: WizardTypes.LndState.OFFLINE,
                nprofile: '',
                provider_name: 'Error loading state',
                relay_connected: false,
                relays: [],
                watchdog_ok: false,
                source_name: 'Error',
                relay_url: '',
                automate_liquidity: false,
                push_backups_to_nostr: false,
                avatar_url: '',
                app_id: ''
            }
        }
    }


    WizardState = async (): Promise<WizardTypes.StateResponse> => {
        return {
            config_sent: false,
            admin_linked: this.adminManager.GetAdminNpub() !== "",
        }
    }
    IsInitialized = () => {
        return !!this.adminManager.GetAdminNpub()
    }

    GetAdminConnectInfo = async (): Promise<WizardTypes.AdminConnectInfoResponse> => {
        const nprofile = await this.getNprofile()
        const enrolledAdmin = this.adminManager.GetAdminNpub()
        if (enrolledAdmin !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ENROLLED_NPUB,
                    enrolled_npub: enrolledAdmin
                }
            }
        }
        const adminEnroll = this.adminManager.ReadAdminEnrollToken()
        if (adminEnroll !== "") {
            return {
                nprofile, connect_info: {
                    type: WizardTypes.AdminConnectInfoResponse_connect_info_type.ADMIN_TOKEN,
                    admin_token: adminEnroll
                }
            }
        }
        throw new Error("something went wrong initializing admin creds")
    }

    getNprofile = async (): Promise<string> => {
        if (this.nprofile !== "") {
            return this.nprofile
        }
        console.log("waiting for nprofile")
        return new Promise((res) => {
            this.awaitingNprofile.push({ res })
        })
    }

    AddConnectInfo = (nprofile: string, relays: string[]) => {
        this.nprofile = nprofile
        this.relays = relays
        this.awaitingNprofile.forEach(q => q.res(nprofile))
        this.awaitingNprofile = []
    }

    Configure = async (): Promise<boolean> => {
        if (this.IsInitialized()) {
            return false
        }
        return new Promise((res) => {
            this.configQueue.push({ res })
        })
    }

    wizardConfig = async (req: WizardTypes.ConfigRequest): Promise<void> => {
        const err = WizardTypes.ConfigRequestValidate(req, {
            source_name_CustomCheck: source => source !== '',
            relay_url_CustomCheck: relay => relay !== '',
        })
        if (err != null) { throw new Error(err.message) }
        const pendingConfig = { sourceName: req.source_name, relayUrl: req.relay_url, automateLiquidity: req.automate_liquidity, pushBackupsToNostr: req.push_backups_to_nostr }

        // Persist app name/avatar to DB regardless (idempotent behavior)
        await this.settings.updateDisableLiquidityProvider(pendingConfig.automateLiquidity)
        await this.settings.updatePushBackupsToNostr(pendingConfig.pushBackupsToNostr)
        const oldAppName = this.settings.getSettings().serviceSettings.defaultAppName
        const nameUpdated = await this.settings.updateDefaultAppName(pendingConfig.sourceName)
        if (nameUpdated) {
            await this.updateDefaultApp(oldAppName, req.avatar_url)
        }
        const relayUpdated = await this.settings.updateRelayUrl(pendingConfig.relayUrl)
        if (relayUpdated && this.IsInitialized()) {
            await this.adminManager.ResetNostr()
        }

        // If already initialized, treat as idempotent update for env and exit
        if (this.IsInitialized()) {
            this.log("reloaded wizard config")
            if (nameUpdated) this.log("name updated")
            if (relayUpdated) this.log("relay updated")
            return
        }

        // First-time configuration flow
        this.configQueue.forEach(q => q.res(true))
        this.configQueue = []
        return
    }

    async updateConfigs(pendingConfig: WizardSettings): Promise<void> {
        await this.settings.updateDefaultAppName(pendingConfig.sourceName)
        await this.settings.updateRelayUrl(pendingConfig.relayUrl)
        await this.settings.updateDisableLiquidityProvider(pendingConfig.automateLiquidity)
        await this.settings.updatePushBackupsToNostr(pendingConfig.pushBackupsToNostr)
    }

    updateDefaultApp = async (currentName: string, avatarUrl?: string): Promise<void> => {
        const newName = this.settings.getSettings().serviceSettings.defaultAppName
        try {
            const appsList = await this.storage.applicationStorage.GetApplications()
            const defaultNames = ['wallet', 'wallet-test', currentName]
            const existingDefaultApp = appsList.find(app => defaultNames.includes(app.name)) || appsList[0]
            if (existingDefaultApp) {
                await this.storage.applicationStorage.UpdateApplication(existingDefaultApp, { name: newName, avatar_url: avatarUrl || existingDefaultApp.avatar_url })
            }
        } catch (e) {
            this.log(`Error updating app info: ${(e as Error).message}`)
        }
    }
    /* 
        updateEnvFile = (pendingConfig: WizardSettings) => {
            let envFileContent: string[] = []
            try {
                envFileContent = fs.readFileSync('.env', 'utf-8').split('\n')
            } catch (err: any) {
                if (err.code !== 'ENOENT') {
                    throw err
                }
            }
    
            const toMerge: string[] = []
            const sourceNameIndex = envFileContent.findIndex(line => line.startsWith('DEFAULT_APP_NAME'))
            if (sourceNameIndex === -1) {
                toMerge.push(`DEFAULT_APP_NAME=${pendingConfig.sourceName}`)
            } else {
                envFileContent[sourceNameIndex] = `DEFAULT_APP_NAME=${pendingConfig.sourceName}`
            }
    
            const relayUrlIndex = envFileContent.findIndex(line => line.startsWith('RELAY_URL'))
            if (relayUrlIndex === -1) {
                toMerge.push(`RELAY_URL=${pendingConfig.relayUrl}`)
            } else {
                envFileContent[relayUrlIndex] = `RELAY_URL=${pendingConfig.relayUrl}`
            }
    
            const automateLiquidityIndex = envFileContent.findIndex(line => line.startsWith('LIQUIDITY_PROVIDER_PUB'))
            if (pendingConfig.automateLiquidity) {
                if (automateLiquidityIndex !== -1) {
                    envFileContent.splice(automateLiquidityIndex, 1)
                }
            } else {
                if (automateLiquidityIndex === -1) {
                    toMerge.push(`LIQUIDITY_PROVIDER_PUB=null`)
                } else {
                    envFileContent[automateLiquidityIndex] = `LIQUIDITY_PROVIDER_PUB=null`
                }
            }
    
            const pushBackupsToNostrIndex = envFileContent.findIndex(line => line.startsWith('PUSH_BACKUPS_TO_NOSTR'))
            if (pushBackupsToNostrIndex === -1) {
                toMerge.push(`PUSH_BACKUPS_TO_NOSTR=${pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`)
            } else {
                envFileContent[pushBackupsToNostrIndex] = `PUSH_BACKUPS_TO_NOSTR=${pendingConfig.pushBackupsToNostr ? 'true' : 'false'}`
            }
            const merged = [...envFileContent, ...toMerge].join('\n')
            fs.writeFileSync('.env', merged)
            loadEnvFile()
        } */
}