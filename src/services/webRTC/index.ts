//@ts-ignore
import wrtc from 'wrtc'
import Storage from '../storage/index.js'
import { ERROR, getLogger } from "../helpers/logger.js"
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { NostrSend, SendData, SendInitiator } from "../nostr/handler.js"
import { encodeTLbV, encodeTLV, encodeTLVDataPacket } from '../helpers/tlv.js'
import { Utils } from '../helpers/utilsWrapper.js'
import { TlvFilesStorage } from '../storage/tlv/tlvFilesStorage.js'
import { TlvStorageInterface } from '../storage/tlv/tlvFilesStorageFactory.js'
type IceCandidate = { type: string, candidate?: string, sdpMid?: string, sdpMLineIndex?: number }
const configuration = { 'iceServers': [{ 'urls': 'stun:relay.webwormhole.io' }] }
export type WebRtcUserInfo = { userPub: string, appId: string }

export type TlvStorageGetter = (t: Types.SingleMetricType) => TlvFilesStorage

export default class webRTC {
    //private storage: Storage
    private log = getLogger({ component: 'webRTC' })
    private connections: Record<string, RTCPeerConnection> = {}
    private _nostrSend: NostrSend
    private tlvStorageGetter: TlvStorageGetter
    //private utils: Utils
    constructor(tlvStorageGetter: TlvStorageGetter) {
        this.tlvStorageGetter = tlvStorageGetter
    }
    attachNostrSend(f: NostrSend) {
        this._nostrSend = f
    }
    private nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    private sendCandidate = (u: WebRtcUserInfo, candidate: string) => {
        const message: Types.WebRtcCandidate & { requestId: string, status: 'OK' } = { candidate, requestId: "SubToWebRtcCandidates", status: 'OK' }
        this.nostrSend({ type: 'app', appId: u.appId }, { type: 'content', content: JSON.stringify(message), pub: u.userPub })
    }

    OnMessage = async (u: WebRtcUserInfo, message: Types.WebRtcMessage_message): Promise<Types.WebRtcAnswer> => {
        if (message.type === Types.WebRtcMessage_message_type.OFFER) {
            return this.connect(u, message.offer)
        } else if (message.type === Types.WebRtcMessage_message_type.CANDIDATE) {
            return this.onCandidate(u, message.candidate)
        }
        return {}
    }

    private onCandidate = async (u: WebRtcUserInfo, candidate: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        if (!this.connections[key]) {
            throw new Error('Connection not found')
        }
        const conn = this.connections[key]
        const iceCandidate: IceCandidate = JSON.parse(candidate)
        if (iceCandidate.candidate) {
            await conn.addIceCandidate(iceCandidate);
        }
        return {}
    }
    private connect = async (u: WebRtcUserInfo, offer: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        this.log("connect", key)
        if (this.connections[key]) {
            this.connections[key].close()
        }
        const conn = new wrtc.RTCPeerConnection(configuration) as RTCPeerConnection
        conn.onicecandidate = (event) => {
            const message: IceCandidate = {
                type: 'candidate'
            };
            if (event.candidate) {
                message.candidate = event.candidate.candidate;
                message.sdpMid = event.candidate.sdpMid || undefined;
                message.sdpMLineIndex = event.candidate.sdpMLineIndex || undefined;
            }
            this.sendCandidate(u, JSON.stringify(message))
        }
        conn.onconnectionstatechange = () => {
            if (conn.connectionState === 'disconnected') {
                conn.close()
                delete this.connections[key]
            }
        }
        conn.ondatachannel = (event) => {
            const channel = event.channel
            channel.addEventListener('message', async (event) => {
                try {
                    const j = JSON.parse(event.data) as Types.SingleMetricReq
                    const err = Types.SingleMetricReqValidate(j, {
                        app_id_CustomCheck: id => id === u.appId,
                        metrics_name_CustomCheck: name => name !== ""
                    })
                    if (err) {
                        this.log(ERROR, 'SingleUsageMetricReqValidate', err)
                        return
                    }
                    const tlvStorage = this.tlvStorageGetter(j.metric_type)
                    const { fileData } = await tlvStorage.LoadFile(j.app_id, j.metrics_name, j.page)
                    const id = j.request_id || Math.floor(Math.random() * 100_000_000)
                    let i = 0
                    const packets: Buffer[] = []
                    while (i < fileData.length) {
                        const chunk = fileData.slice(i, Math.min(i + 15_000, fileData.length))
                        packets.push(chunk)
                        i += 15_000
                    }
                    for (let i = 0; i < packets.length; i++) {
                        const packet = packets[i]
                        const tlv = encodeTLVDataPacket({ dataId: id, packetNum: i + 1, totalPackets: packets.length, data: packet })
                        const bytes = encodeTLbV(tlv)
                        channel.send(bytes)
                    }
                } catch (e: any) {
                    this.log(ERROR, 'ondatachannel', e.message || e)
                }
            })
        }
        await conn.setRemoteDescription(JSON.parse(offer))
        const answer = await conn.createAnswer()
        await conn.setLocalDescription(answer)
        this.connections[key] = conn
        return { answer: JSON.stringify(answer) }
    }

    getConnectionsKey = (u: WebRtcUserInfo) => {
        return u.appId + ":" + u.userPub
    }
}