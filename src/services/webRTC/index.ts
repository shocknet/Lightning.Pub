import { getLogger } from "../helpers/logger.js"
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { NostrSend, SendData, SendInitiator } from "../nostr/handler.js"
type IceCandidate = { type: string, candidate?: string, sdpMid?: string, sdpMLineIndex?: number }
const configuration = { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] }
type UserInfo = { userPub: string, appId: string }
export default class webRTC {

    private log = getLogger({ component: 'webRTC' })
    private connections: Record<string, RTCPeerConnection> = {}
    private _nostrSend: NostrSend
    attachNostrSend(f: NostrSend) {
        this._nostrSend = f
    }
    private nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    private sendCandidate = (u: UserInfo, candidate: string) => {
        const message: Types.WebRtcCandidate & { requestId: string, status: 'OK' } = { candidate, requestId: "SubToWebRtcCandidates", status: 'OK' }
        this.nostrSend({ type: 'app', appId: u.appId }, { type: 'content', content: JSON.stringify(message), pub: u.userPub })
    }

    OnMessage = async (u: UserInfo, message: Types.WebRtcMessage_message): Promise<Types.WebRtcAnswer> => {
        if (message.type === Types.WebRtcMessage_message_type.OFFER) {
            return this.connect(u, message.offer)
        } else if (message.type === Types.WebRtcMessage_message_type.CANDIDATE) {
            return this.onCandidate(u, message.candidate)
        }
        return {}
    }
    private onCandidate = async (u: UserInfo, candidate: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        if (!this.connections[key]) {
            throw new Error('Connection not found')
        }
        const conn = this.connections[key]
        const iceCandidate: IceCandidate = JSON.parse(candidate)
        if (!iceCandidate.candidate) {
            await conn.addIceCandidate(undefined);
        } else {
            await conn.addIceCandidate(iceCandidate);
        }
        return {}
    }
    private connect = async (u: UserInfo, offer: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        console.log("connect", key)
        if (this.connections[key]) {
            throw new Error('Connection already exists')
        }
        const conn = new RTCPeerConnection(configuration)
        conn.onicecandidate = (event) => {
            const message: IceCandidate = {
                type: 'candidate'
            };
            if (event.candidate) {
                message.candidate = event.candidate.candidate;
                message.sdpMid = event.candidate.sdpMid || undefined;
                message.sdpMLineIndex = event.candidate.sdpMLineIndex || undefined;
            }
            this.sendCandidate(u, JSON.stringify(message))
        }
        conn.onconnectionstatechange = (event) => {
            console.log('onconnectionstatechange', event)
        }
        conn.ondatachannel = (event) => {
            console.log('ondatachannel', event)
        }
        conn.oniceconnectionstatechange = (event) => {
            console.log('oniceconnectionstatechange', event)
        }
        conn.onicegatheringstatechange = (event) => {
            console.log('onicegatheringstatechange', event)
        }
        await conn.setRemoteDescription(JSON.parse(offer))
        const answer = await conn.createAnswer()
        await conn.setLocalDescription(answer)
        this.connections[key] = conn
        console.log("answer", answer)
        return { answer: JSON.stringify(answer) }
    }

    getConnectionsKey = (u: UserInfo) => {
        return u.appId + ":" + u.userPub
    }
}