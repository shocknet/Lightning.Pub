//@ts-ignore
import wrtc from 'wrtc'
import Storage from '../storage/index.js'
import { ERROR, getLogger } from "../helpers/logger.js"
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { NostrSend, SendData, SendInitiator } from "../nostr/handler.js"
import { encodeTLV, encodeTLVDataPacket } from '../helpers/tlv.js'
type IceCandidate = { type: string, candidate?: string, sdpMid?: string, sdpMLineIndex?: number }
const configuration = { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] }
type UserInfo = { userPub: string, appId: string }
export default class webRTC {
    private storage: Storage
    private log = getLogger({ component: 'webRTC' })
    private connections: Record<string, RTCPeerConnection> = {}
    private _nostrSend: NostrSend
    constructor(storage: Storage) {
        this.storage = storage
    }
    attachNostrSend(f: NostrSend) {
        this._nostrSend = f
    }
    private nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    private sendCandidate = (u: UserInfo, candidate: string) => {
        const message: Types.WebRtcCandidate & { requestId: string, status: 'OK' } = { candidate, requestId: "SubToWebRtcCandidates", status: 'OK' }
        this.nostrSend({ type: 'app', appId: u.appId }, { type: 'content', content: JSON.stringify(message), pub: u.userPub })
    }

    OnMessage = async (u: UserInfo, message: Types.WebRtcMessage_message): Promise<Types.WebRtcAnswer> => {
        if (message.type === Types.WebRtcMessage_message_type.OFFER) {
            return this.connect(u, message.offer)
        } else if (message.type === Types.WebRtcMessage_message_type.CANDIDATE) {
            return this.onCandidate(u, message.candidate)
        }
        return {}
    }
    private onCandidate = async (u: UserInfo, candidate: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        if (!this.connections[key]) {
            throw new Error('Connection not found')
        }
        const conn = this.connections[key]
        const iceCandidate: IceCandidate = JSON.parse(candidate)
        if (!iceCandidate.candidate) {
            await conn.addIceCandidate(undefined);
        } else {
            await conn.addIceCandidate(iceCandidate);
        }
        return {}
    }
    private connect = async (u: UserInfo, offer: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        console.log("connect", key)
        if (this.connections[key]) {
            this.connections[key].close()
        }
        const conn = new wrtc.RTCPeerConnection(configuration) as RTCPeerConnection
        conn.onicecandidate = (event) => {
            const message: IceCandidate = {
                type: 'candidate'
            };
            if (event.candidate) {
                message.candidate = event.candidate.candidate;
                message.sdpMid = event.candidate.sdpMid || undefined;
                message.sdpMLineIndex = event.candidate.sdpMLineIndex || undefined;
            }
            this.sendCandidate(u, JSON.stringify(message))
        }
        conn.onconnectionstatechange = (event) => {
            console.log('onconnectionstatechange', conn.connectionState)
        }
        conn.ondatachannel = (event) => {
            console.log('ondatachannel', event)
            const channel = event.channel
            channel.addEventListener('message', async (event) => {
                const j = JSON.parse(event.data) as Types.SingleUsageMetricReq
                const err = Types.SingleUsageMetricReqValidate(j, {
                    app_id_CustomCheck: id => id === u.appId,
                    metrics_name_CustomCheck: name => name !== ""
                })
                if (err) {
                    this.log(ERROR, 'SingleUsageMetricReqValidate', err)
                    return
                }
                const res = await this.storage.metricsEventStorage.LoadRawMetricsFile(j.app_id, j.metrics_name, j.page)
                const id = Math.floor(Math.random() * 2_000_000_000)
                let i = 0
                const packets: Buffer[] = []
                while (i < res.length) {
                    const chunk = res.slice(i, Math.min(i + 15_000, res.length))
                    packets.push(chunk)
                    i += 15_000
                }
                for (let i = 0; i < packets.length; i++) {
                    const packet = packets[i]
                    const tlv = encodeTLVDataPacket({ dataId: id, packetNum: i + 1, totalPackets: packets.length, data: packet })
                    const bytes = encodeTLV(tlv)
                    channel.send(bytes)
                }
            })
        }
        /*         conn.oniceconnectionstatechange = (event) => {
                    console.log('oniceconnectionstatechange', event)
                }
                conn.onicegatheringstatechange = (event) => {
                    console.log('onicegatheringstatechange', event)
                } */
        await conn.setRemoteDescription(JSON.parse(offer))
        const answer = await conn.createAnswer()
        await conn.setLocalDescription(answer)
        this.connections[key] = conn
        console.log("answer", answer)
        return { answer: JSON.stringify(answer) }
    }

    getConnectionsKey = (u: UserInfo) => {
        return u.appId + ":" + u.userPub
    }
}