//@ts-ignore
import wrtc from 'wrtc'
import Storage from '../storage/index.js'
import { ERROR, getLogger } from "../helpers/logger.js"
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { NostrSend, SendData, SendInitiator } from "../nostr/handler.js"
import { encodeTLbV, encodeTLV, encodeTLVDataPacket } from '../helpers/tlv.js'
import { Utils } from '../helpers/utilsWrapper.js'
type IceCandidate = { type: string, candidate?: string, sdpMid?: string, sdpMLineIndex?: number }
const configuration = { 'iceServers': [{ 'urls': 'stun:relay.webwormhole.io' }] }
export type WebRtcUserInfo = { userPub: string, appId: string, appUserId: string, userId: string }

/* export type GetUserInfoGetter = (t: Types.GetUserInfo_Input) => Promise<Types.GetUserInfo_Output>
export type UserHealthGetter = (t: Types.UserHealth_Input) => Promise<Types.UserHealth_Output>
export type GetOperationsGetter = (t: Types.GetUserOperations_Input) => Promise<Types.GetUserOperations_Output>
export type DecodeInvoiceGetter = (t: Types.DecodeInvoice_Input) => Promise<Types.DecodeInvoice_Output>
export type GetUserOfferGetter = (t: Types.GetUserOffer_Input) => Promise<Types.GetUserOffer_Output>
export type NewInvoiceGetter = (t: Types.NewInvoice_Input) => Promise<Types.NewInvoice_Output>
export type AddUserOfferGetter = (t: Types.AddUserOffer_Input) => Promise<Types.AddUserOffer_Output>
export type GetUserOffersGetter = (t: Types.GetUserOffers_Input) => Promise<Types.GetUserOffers_Output> */
export type SupportedInput = (Types.GetUserInfo_Input | Types.UserHealth_Input | Types.GetUserOperations_Input | Types.DecodeInvoice_Input
    | Types.GetUserOffer_Input | Types.NewInvoice_Input | Types.AddUserOffer_Input | Types.GetUserOffers_Input) & { request_id?: number }
export type Getter = (u: WebRtcUserInfo, t: SupportedInput) => Promise<any>

export default class webRTC2 {
    //private storage: Storage
    private log = getLogger({ component: 'webRTC' })
    private connections: Record<string, RTCPeerConnection> = {}
    private _nostrSend: NostrSend
    private serverMethods: Types.ServerMethods
    //private utils: Utils
    constructor() {
        //this.serverMethods = serverMethods
    }
    attachServerMethods(m: Types.ServerMethods) {
        this.serverMethods = m
    }
    attachNostrSend(f: NostrSend) {
        this._nostrSend = f
    }
    private nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    private sendCandidate = (u: WebRtcUserInfo, candidate: string) => {
        const message: Types.WebRtcCandidate & { requestId: string, status: 'OK' } = { candidate, requestId: "SubToUserWebRtcCandidates", status: 'OK' }
        this.nostrSend({ type: 'app', appId: u.appId }, { type: 'content', content: JSON.stringify(message), pub: u.userPub })
    }

    OnMessage = async (u: WebRtcUserInfo, message: Types.WebRtcMessage_message): Promise<Types.WebRtcAnswer> => {
        if (message.type === Types.WebRtcMessage_message_type.OFFER) {
            return this.connect(u, message.offer)
        } else if (message.type === Types.WebRtcMessage_message_type.CANDIDATE) {
            return this.onCandidate(u, message.candidate)
        }
        return {}
    }

    private handleRequest = async (u: WebRtcUserInfo, data: SupportedInput) => {
        console.log('handleRequest', data)
        if (!this.serverMethods) throw new Error('Server methods not attached')
        const rpcName = data.rpcName
        switch (rpcName) {
            case 'GetUserInfo':
                if (!this.serverMethods.GetUserInfo) throw new Error('GetUserInfo not implemented')
                return this.serverMethods.GetUserInfo({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'UserHealth':
                if (!this.serverMethods.UserHealth) throw new Error('UserHealth not implemented')
                return this.serverMethods.UserHealth({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'GetUserOperations':
                if (!this.serverMethods.GetUserOperations) throw new Error('GetUserOperations not implemented')
                return this.serverMethods.GetUserOperations({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'DecodeInvoice':
                if (!this.serverMethods.DecodeInvoice) throw new Error('DecodeInvoice not implemented')
                return this.serverMethods.DecodeInvoice({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'GetUserOffer':
                if (!this.serverMethods.GetUserOffer) throw new Error('GetUserOffer not implemented')
                return this.serverMethods.GetUserOffer({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'NewInvoice':
                if (!this.serverMethods.NewInvoice) throw new Error('NewInvoice not implemented')
                return this.serverMethods.NewInvoice({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'AddUserOffer':
                if (!this.serverMethods.AddUserOffer) throw new Error('AddUserOffer not implemented')
                return this.serverMethods.AddUserOffer({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            case 'GetUserOffers':
                if (!this.serverMethods.GetUserOffers) throw new Error('GetUserOffers not implemented')
                return this.serverMethods.GetUserOffers({ ...data, ctx: { app_id: u.appId, app_user_id: u.appUserId, user_id: u.userId } })
            default:
                throw new Error(`Unsupported request: ${rpcName}`)
        }
    }

    private onData = async (u: WebRtcUserInfo, data: string, channel: RTCDataChannel) => {
        try {
            const j = JSON.parse(data) as SupportedInput
            const r = await this.handleRequest(u, j)
            const rawData = Buffer.from(JSON.stringify(r))
            //const { fileData } = await tlvStorage.LoadFile(j.app_id, j.metrics_name, j.page)
            const id = j.request_id || Math.floor(Math.random() * 100_000_000)
            let i = 0
            const packets: Buffer[] = []
            while (i < rawData.length) {
                const chunk = rawData.slice(i, Math.min(i + 15_000, rawData.length))
                packets.push(chunk)
                i += 15_000
            }
            for (let i = 0; i < packets.length; i++) {
                const packet = packets[i]
                const tlv = encodeTLVDataPacket({ dataId: id, packetNum: i + 1, totalPackets: packets.length, data: packet })
                const bytes = encodeTLbV(tlv)
                channel.send(bytes)
            }
        } catch (e: any) {
            this.log(ERROR, 'ondatachannel', e.message || e)
        }
    }

    private onCandidate = async (u: WebRtcUserInfo, candidate: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        if (!this.connections[key]) {
            throw new Error('Connection not found')
        }
        const conn = this.connections[key]
        const iceCandidate: IceCandidate = JSON.parse(candidate)
        if (iceCandidate.candidate) {
            await conn.addIceCandidate(iceCandidate);
        }
        return {}
    }
    private connect = async (u: WebRtcUserInfo, offer: string): Promise<Types.WebRtcAnswer> => {
        const key = this.getConnectionsKey(u)
        this.log("connect", key)
        if (this.connections[key]) {
            this.connections[key].close()
        }
        const conn = new wrtc.RTCPeerConnection(configuration) as RTCPeerConnection
        conn.onicecandidate = (event) => {
            const message: IceCandidate = {
                type: 'candidate'
            };
            if (event.candidate) {
                message.candidate = event.candidate.candidate;
                message.sdpMid = event.candidate.sdpMid || undefined;
                message.sdpMLineIndex = event.candidate.sdpMLineIndex || undefined;
            }
            this.sendCandidate(u, JSON.stringify(message))
        }
        conn.onconnectionstatechange = () => {
            if (conn.connectionState === 'disconnected') {
                conn.close()
                delete this.connections[key]
            }
        }
        conn.ondatachannel = (event) => {
            const channel = event.channel
            channel.addEventListener('message', async (event) => {
                this.onData(u, event.data, channel)
            })
        }
        await conn.setRemoteDescription(JSON.parse(offer))
        const answer = await conn.createAnswer()
        await conn.setLocalDescription(answer)
        this.connections[key] = conn
        return { answer: JSON.stringify(answer) }
    }

    getConnectionsKey = (u: WebRtcUserInfo) => {
        return u.appId + ":" + u.userPub
    }
}