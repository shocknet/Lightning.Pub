import { getRepository } from "typeorm";
import { User } from "../storage/entity/User.js";
import { UserOffer } from "../storage/entity/UserOffer.js";
import { ManagementGrant } from "../storage/entity/ManagementGrant.js";
import { NostrEvent, NostrSend } from "../nostr/handler.js";
import Storage from "../storage/index.js";
import { OfferManager } from "./offerManager.js";
import * as Types from "../../../proto/autogenerated/ts/types.js";
import { MainSettings } from "./settings.js";
import { nofferEncode, OfferPointer, OfferPriceType, NmanageRequest, NmanageResponse, NmanageCreateOffer, NmanageUpdateOffer, NmanageDeleteOffer, NmanageGetOffer, NmanageListOffers, OfferData, OfferFields } from "@shocknet/clink-sdk";
import { UnsignedEvent } from "nostr-tools";
type Result<T> = { success: true, result: T } | { success: false, error: string, code: number }

export class ManagementManager {
    private nostrSend: NostrSend;
    private storage: Storage;
    private settings: MainSettings;

    constructor(storage: Storage, settings: MainSettings) {
        this.storage = storage;
        this.settings = settings;
    }

    attachNostrSend(f: NostrSend) {
        this.nostrSend = f
    }

    public async handleRequest(nmanageReq: NmanageRequest, event: NostrEvent): Promise<void> {
        try {
            const r = await this.doNmanage(nmanageReq, event)
            let e: UnsignedEvent
            if (!r.success) {
                e = newNmanageResponse(JSON.stringify({ code: r.code, error: codeToMessage(r.code) }), event)
            } else {
                e = newNmanageResponse(JSON.stringify(r.result), event)
            }
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
        } catch (err) {
            const e = newNmanageResponse(JSON.stringify({ code: 2, error: codeToMessage(2) }), event)
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
        }
    }

    private async doNmanage(nmanageReq: NmanageRequest, event: NostrEvent): Promise<Result<NmanageResponse>> {
        const action = nmanageReq.action
        switch (action) {
            case "create":
                const createResult = await this.createOffer(nmanageReq)
                return this.getNmanageResponse(event.appId, createResult)
            case "update":
                const updateResult = await this.updateOffer(nmanageReq, event.pub);
                return this.getNmanageResponse(event.appId, updateResult)
            case "delete":
                const deleteResult = await this.deleteOffer(nmanageReq, event.pub);
                return this.getNmanageResponse(event.appId, deleteResult)
            case "get":
                const getResult = await this.getOffer(nmanageReq, event.pub);
                return this.getNmanageResponse(event.appId, getResult)
            case "list":
                const listResult = await this.listOffers(nmanageReq, event.pub);
                return this.getNmanageResponse(event.appId, listResult)
            default:
                return { success: false, error: `Unknown action: ${action}`, code: 1 }
        }
    }

    private getOfferData(offer: UserOffer, appPub: string): OfferData {
        const pointer: OfferPointer = {
            offer: offer.offer_id,
            pubkey: appPub,
            relay: this.settings.nostrRelaySettings.relays[0],
            priceType: offer.price_sats > 0 ? OfferPriceType.Fixed : OfferPriceType.Spontaneous,
            price: offer.price_sats,
        }
        return {
            id: offer.offer_id,
            label: offer.label,
            price_sats: offer.price_sats,
            callback_url: offer.callback_url,
            payer_data: Object.keys(offer.expected_data || {}),
            noffer: nofferEncode(pointer),
        }
    }

    private async getNmanageResponse(appId: string, result: Result<UserOffer | UserOffer[] | void>): Promise<Result<NmanageResponse>> {
        if (!result.success) {
            return result
        }
        const args = result.result
        const app = await this.storage.applicationStorage.GetApplication(appId)
        if (args && Array.isArray(args)) {
            return {
                success: true, result: {
                    res: 'ok', resource: 'offer', details: args.map(offer => this.getOfferData(offer, app.nostr_public_key!))
                }
            }
        }
        if (!args) {
            return { success: true, result: { res: 'ok', resource: 'offer' } }
        }
        return {
            success: true, result: {
                res: 'ok', resource: 'offer', details: this.getOfferData(args, app.nostr_public_key!)
            }
        }
    }

    private async getOffer(nmanageReq: NmanageGetOffer, requestorPub: string): Promise<Result<UserOffer>> {
        const offer = await this.validateOfferAccess(nmanageReq.offer.id, requestorPub)
        if (!offer.success) {
            return offer
        }
        return { success: true, result: offer.result }
    }

    private async listOffers(nmanageReq: NmanageListOffers, requestorPub: string): Promise<Result<UserOffer[]>> {
        const appUserId = nmanageReq.pointer
        if (!appUserId) {
            return { success: false, error: 'No pointer provided', code: 1 }
        }
        const grantResult = await this.validateGrantAccess(appUserId, requestorPub)
        if (!grantResult.success) {
            return grantResult
        }
        const offers = await this.storage.offerStorage.getManagedUserOffers(appUserId, requestorPub)
        return { success: true, result: offers }
    }

    private validateOfferFields(fields: OfferFields): Result<void> {
        if (!fields.label || typeof fields.label !== 'string') {
            return { success: false, error: 'Label is required', code: 1 }
        }
        if (fields.price_sats && typeof fields.price_sats !== 'number') {
            return { success: false, error: 'Price must be a number', code: 1 }
        }
        if (fields.callback_url && typeof fields.callback_url !== 'string') {
            return { success: false, error: 'Callback URL must be a string', code: 1 }
        }
        if (fields.payer_data && !Array.isArray(fields.payer_data)) {
            return { success: false, error: 'Payer data must be an array', code: 1 }
        }

        return { success: true, result: undefined }
    }

    private async createOffer(nmanageReq: NmanageCreateOffer): Promise<Result<UserOffer>> {
        const appUserId = nmanageReq.pointer
        if (!appUserId) {
            return { success: false, error: 'No pointer provided', code: 1 }
        }
        const grantResult = await this.validateGrantAccess(appUserId, appUserId)
        if (!grantResult.success) {
            return grantResult
        }
        const validateResult = this.validateOfferFields(nmanageReq.offer.fields)
        if (!validateResult.success) {
            return validateResult
        }
        const dataMap: Record<string, Types.OfferDataType> = {}
        nmanageReq.offer.fields.payer_data.forEach(data => {
            dataMap[data] = Types.OfferDataType.DATA_STRING
        })
        const offer = await this.storage.offerStorage.AddUserOffer(appUserId, {
            label: nmanageReq.offer.fields.label,
            callback_url: nmanageReq.offer.fields.callback_url,
            price_sats: nmanageReq.offer.fields.price_sats,
            expected_data: dataMap,
        })
        return { success: true, result: offer }
    }

    private async validateGrantAccess(appUserId: string, requestorPub: string): Promise<Result<void>> {
        const grant = await this.storage.managementStorage.getGrant(appUserId, requestorPub)

        if (!grant) {
            // TODO request from user
            return { success: false, error: 'No grant found', code: 1 }
        }

        if (grant.expires_at_unix < Date.now()) {
            return { success: false, error: 'Grant expired', code: 3 }
        }
        return { success: true, result: undefined }
    }

    private async validateOfferAccess(offerId: string, requestorPub: string): Promise<Result<UserOffer>> {
        const offer = await this.storage.offerStorage.GetOffer(offerId)
        if (!offer) {
            return { success: false, error: 'Offer not found', code: 1 }
        }
        if (offer.management_pubkey !== requestorPub) {
            return { success: false, error: 'App not authorized to update offer', code: 1 }
        }
        const grantResult = await this.validateGrantAccess(offer.app_user_id, requestorPub)
        if (!grantResult.success) {
            return grantResult
        }
        return { success: true, result: offer }
    }

    private async updateOffer(nmanageReq: NmanageUpdateOffer, requestorPub: string): Promise<Result<UserOffer>> {
        const offer = await this.validateOfferAccess(nmanageReq.offer.id, requestorPub)
        if (!offer.success) {
            return offer
        }
        const validateResult = this.validateOfferFields(nmanageReq.offer.fields)
        if (!validateResult.success) {
            return validateResult
        }
        const dataMap: Record<string, Types.OfferDataType> = {}
        for (const data of nmanageReq.offer.fields.payer_data || []) {
            if (typeof data !== 'string') {
                return { success: false, error: 'Payer data must be a string', code: 1 }
            }
            dataMap[data] = Types.OfferDataType.DATA_STRING
        }
        await this.storage.offerStorage.UpdateUserOffer(offer.result.app_user_id, nmanageReq.offer.id, {
            label: nmanageReq.offer.fields.label,
            callback_url: nmanageReq.offer.fields.callback_url,
            price_sats: nmanageReq.offer.fields.price_sats,
            expected_data: dataMap,
        })
        const updatedOffer = await this.storage.offerStorage.GetOffer(nmanageReq.offer.id)
        if (!updatedOffer) {
            return { success: false, error: 'Offer not found', code: 2 }
        }
        return { success: true, result: updatedOffer }
    }

    private async deleteOffer(nmanageReq: NmanageDeleteOffer, requestorPub: string): Promise<Result<void>> {
        const offerResult = await this.validateOfferAccess(nmanageReq.offer.id, requestorPub)
        if (!offerResult.success) {
            return offerResult
        }
        await this.storage.offerStorage.DeleteUserOffer(offerResult.result.app_user_id, offerResult.result.offer_id)
        return { success: true, result: undefined }
    }
}

const newNmanageResponse = (content: string, event: NostrEvent): UnsignedEvent => {
    return {
        content,
        created_at: Math.floor(Date.now() / 1000),
        kind: 21003,
        pubkey: "",
        tags: [
            ['p', event.pub],
            ['e', event.id],
        ],
    }
}
const codeToMessage = (code: number, reason = "") => {
    switch (code) {
        case 1: return 'Request Denied'
        case 2: return 'Temporary Failure: ' + reason
        case 3: return 'Expired Request'
        case 4: return 'Rate Limited'
        case 5: return 'Invalid Field or Value'
        case 6: return 'Invalid Request: ' + reason
        default: throw new Error("unknown error code" + code)
    }
}