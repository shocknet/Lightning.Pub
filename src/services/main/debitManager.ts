import * as Types from "../../../proto/autogenerated/ts/types.js";
import ApplicationManager from "./applicationManager.js";
import Storage from '../storage/index.js'
import LND from "../lnd/lnd.js"
import { ERROR, getLogger } from "../helpers/logger.js";
import { DebitAccess, DebitAccessRules } from '../storage/entity/DebitAccess.js';
import { Application } from '../storage/entity/Application.js';
import { ApplicationUser } from '../storage/entity/ApplicationUser.js';
import { NostrEvent, NostrSend, SendData, SendInitiator } from '../nostr/handler.js';
import { UnsignedEvent } from 'nostr-tools';
import { NdebitData, NdebitFailure, NdebitSuccess, NdebitSuccessPayment, RecurringDebitTimeUnit } from "@shocknet/clink-sdk";

export const expirationRuleName = 'expiration'
export const frequencyRuleName = 'frequency'
const unitToIntervalType = (unit: RecurringDebitTimeUnit) => {
    switch (unit) {
        case 'day': return Types.IntervalType.DAY
        case 'week': return Types.IntervalType.WEEK
        case 'month': return Types.IntervalType.MONTH
        default: throw new Error("invalid unit")
    }
}
const intervalTypeToUnit = (interval: Types.IntervalType): RecurringDebitTimeUnit => {
    switch (interval) {
        case Types.IntervalType.DAY: return 'day'
        case Types.IntervalType.WEEK: return 'week'
        case Types.IntervalType.MONTH: return 'month'
        default: throw new Error("invalid interval")
    }
}
const IntervalTypeToSeconds = (interval: Types.IntervalType) => {
    switch (interval) {
        case Types.IntervalType.DAY: return 24 * 60 * 60
        case Types.IntervalType.WEEK: return 7 * 24 * 60 * 60
        case Types.IntervalType.MONTH: return 30 * 24 * 60 * 60
        default: throw new Error("invalid interval")
    }
}
const debitRulesToDebitAccessRules = (rule: Types.DebitRule[]): DebitAccessRules | undefined => {
    let rules: DebitAccessRules | undefined = undefined
    rule.forEach(r => {
        if (!rules) {
            rules = {}
        }
        const { rule } = r
        switch (rule.type) {
            case Types.DebitRule_rule_type.EXPIRATION_RULE:

                rules[expirationRuleName] = [rule.expiration_rule.expires_at_unix.toString()]
                break
            case Types.DebitRule_rule_type.FREQUENCY_RULE:
                const intervals = rule.frequency_rule.number_of_intervals.toString()
                const unit = intervalTypeToUnit(rule.frequency_rule.interval)
                rules[frequencyRuleName] = [intervals, unit, rule.frequency_rule.amount.toString()];
                break
            default:
                throw new Error("invalid rule")
        }
    })
    return rules
}

const debitAccessRulesToDebitRules = (rules: DebitAccessRules | null): Types.DebitRule[] => {
    if (!rules) {
        return []
    }
    return Object.entries(rules).map(([key, val]) => {
        switch (key) {
            case expirationRuleName:
                return {
                    rule: {
                        type: Types.DebitRule_rule_type.EXPIRATION_RULE,
                        expiration_rule: {
                            expires_at_unix: +val[0]
                        }
                    }
                }
            case frequencyRuleName:
                return {
                    rule: {
                        type: Types.DebitRule_rule_type.FREQUENCY_RULE,
                        frequency_rule: {
                            number_of_intervals: +val[0],
                            interval: unitToIntervalType(val[1] as RecurringDebitTimeUnit),
                            amount: +val[2]
                        }
                    }
                }
            default:
                throw new Error("invalid rule")
        }
    })
}
const nip68errs = {
    1: "Request Denied Warning",
    2: "Temporary Failure",
    3: "Expired Request",
    4: "Rate Limited",
    5: "Invalid Amount",
    6: "Invalid Request",
}
type HandleNdebitRes = { status: 'fail', debitRes: NdebitFailure }
    | { status: 'invoicePaid', op: Types.UserOperation, app: Application, appUser: ApplicationUser, debitRes: NdebitSuccessPayment }
    | { status: 'authRequired', liveDebitReq: Types.LiveDebitRequest, app: Application, appUser: ApplicationUser }
    | { status: 'authOk', debitRes: NdebitSuccess }
export class DebitManager {


    _nostrSend: NostrSend | null = null

    applicationManager: ApplicationManager

    storage: Storage
    lnd: LND
    logger = getLogger({ component: 'DebitManager' })
    constructor(storage: Storage, lnd: LND, applicationManager: ApplicationManager) {
        this.storage = storage
        this.lnd = lnd
        this.applicationManager = applicationManager
    }

    attachNostrSend = (nostrSend: NostrSend) => {
        this._nostrSend = nostrSend
    }
    nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    AuthorizeDebit = async (ctx: Types.UserContext, req: Types.DebitAuthorizationRequest): Promise<Types.DebitAuthorization> => {
        const access = await this.storage.debitStorage.AddDebitAccess(ctx.app_user_id, {
            authorize: true,
            npub: req.authorize_npub,
            rules: debitRulesToDebitAccessRules(req.rules)
        })
        if (req.request_id) {
            this.sendDebitResponse({ res: 'ok' }, { pub: req.authorize_npub, id: req.request_id, appId: ctx.app_id })
        }
        return {
            debit_id: access.serial_id.toString(),
            npub: req.authorize_npub,
            authorized: true,
            rules: req.rules
        }
    }

    GetDebitAuthorizations = async (ctx: Types.UserContext): Promise<Types.DebitAuthorizations> => {
        const allDebitsAccesses = await this.storage.debitStorage.GetAllUserDebitAccess(ctx.app_user_id)
        const debits: Types.DebitAuthorization[] = allDebitsAccesses.map(access => ({
            debit_id: access.serial_id.toString(),
            authorized: access.authorized,
            npub: access.npub,
            rules: debitAccessRulesToDebitRules(access.rules)
        }))
        return { debits }
    }

    EditDebit = async (ctx: Types.UserContext, req: Types.DebitAuthorizationRequest): Promise<void> => {
        const access = await this.storage.debitStorage.GetDebitAccess(ctx.app_user_id, req.authorize_npub);
        if (!access) {
            throw new Error("Debit does not exist")
        }
        await this.storage.debitStorage.UpdateDebitAccessRules(ctx.app_user_id, req.authorize_npub, debitRulesToDebitAccessRules(req.rules));
    }

    BanDebit = async (ctx: Types.UserContext, req: Types.DebitOperation): Promise<void> => {
        await this.storage.debitStorage.DenyDebitAccess(ctx.app_user_id, req.npub)
    }
    ResetDebit = async (ctx: Types.UserContext, req: Types.DebitOperation): Promise<void> => {
        await this.storage.debitStorage.RemoveDebitAccess(ctx.app_user_id, req.npub)
    }

    RespondToDebit = async (ctx: Types.UserContext, req: Types.DebitResponse): Promise<void> => {
        switch (req.response.type) {
            case Types.DebitResponse_response_type.DENIED:
                this.sendDebitResponse({ res: 'GFY', error: nip68errs[1], code: 1 }, { pub: req.npub, id: req.request_id, appId: ctx.app_id })
                return
            case Types.DebitResponse_response_type.INVOICE:
                const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
                const appUser = await this.storage.applicationStorage.GetApplicationUser(app, ctx.app_user_id)
                const { op, payment } = await this.sendDebitPayment(ctx.app_id, ctx.app_user_id, req.npub, req.response.invoice)
                const debitRes: NdebitSuccessPayment = { res: 'ok', preimage: payment.preimage }
                this.notifyPaymentSuccess(appUser, debitRes, op, { appId: ctx.app_id, pub: req.npub, id: req.request_id })
                return
            default:
                throw new Error("invalid debit response type")
        }
    }

    handleNip68Debit = async (pointerdata: NdebitData, event: NostrEvent) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        const res = await this.payNdebitInvoice(event, pointerdata)
        if (res.status === 'fail' || res.status === 'authOk') {
            const e = newNdebitResponse(JSON.stringify(res.debitRes), event)
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
            return
        }
        const { appUser } = res
        if (res.status === 'authRequired') {
            const message: Types.LiveDebitRequest & { requestId: string, status: 'OK' } = { ...res.liveDebitReq, requestId: "GetLiveDebitRequests", status: 'OK' }
            if (appUser.nostr_public_key) {// TODO - fix before support for http streams
                this.nostrSend({ type: 'app', appId: event.appId }, { type: 'content', content: JSON.stringify(message), pub: appUser.nostr_public_key })
            }
            return
        }
        const { op, debitRes } = res
        this.notifyPaymentSuccess(appUser, debitRes, op, event)
    }

    notifyPaymentSuccess = (appUser: ApplicationUser, debitRes: NdebitSuccessPayment, op: Types.UserOperation, event: { pub: string, id: string, appId: string }) => {
        const message: Types.LiveUserOperation & { requestId: string, status: 'OK' } = { operation: op, requestId: "GetLiveUserOperations", status: 'OK' }
        if (appUser.nostr_public_key) { // TODO - fix before support for http streams
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'content', content: JSON.stringify(message), pub: appUser.nostr_public_key })
        }
        this.sendDebitResponse(debitRes, event)
    }

    sendDebitResponse = (debitRes: NdebitFailure | NdebitSuccess | NdebitSuccessPayment, event: { pub: string, id: string, appId: string }) => {
        const e = newNdebitResponse(JSON.stringify(debitRes), event)
        this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
    }

    payNdebitInvoice = async (event: NostrEvent, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        try {
            return await this.doNdebit(event, pointerdata)
        } catch (e: any) {
            this.logger(ERROR, e.message || e)
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
    }

    doNdebit = async (event: NostrEvent, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        const { appId, pub: requestorPub } = event
        const { amount_sats, pointer, bolt11, frequency } = pointerdata
        if (!pointer) {
            // TODO: debit from app owner balance
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
        const appUserId = pointer
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const appUser = await this.storage.applicationStorage.GetApplicationUser(app, appUserId)
        let decodedAmount = null
        if (bolt11) {
            const decoded = await this.lnd.DecodeInvoice(bolt11)
            decodedAmount = decoded.numSatoshis
        }
        if (frequency) {
            const amt = amount_sats || decodedAmount
            if (!amt) {
                return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[5], code: 5 } }
            }
            const debitAccess = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
            if (!debitAccess) {
                return {
                    status: 'authRequired', app, appUser, liveDebitReq: {
                        request_id: event.id,
                        npub: requestorPub,
                        debit: {
                            type: Types.LiveDebitRequest_debit_type.FREQUENCY,
                            frequency: {
                                interval: unitToIntervalType(frequency.unit),
                                number_of_intervals: frequency.number,
                                amount: amt,
                            }
                        }
                    }
                }
            } else if (!debitAccess.authorized) {
                return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
            }
            return { status: 'authOk', debitRes: { res: 'ok' } }
        }

        if (!bolt11) {
            if (!amount_sats) {
                const debitAccess = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
                if (!debitAccess) {
                    return {
                        status: 'authRequired', app, appUser, liveDebitReq: {
                            request_id: event.id,
                            npub: requestorPub,
                            debit: {
                                type: Types.LiveDebitRequest_debit_type.FULL_ACCESS,
                                full_access: {}
                            }
                        }
                    }
                } else if (!debitAccess.authorized) {
                    return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
                }
                return { status: 'authOk', debitRes: { res: 'ok' } }
            }
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }

        if (!decodedAmount) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }
        if (amount_sats && amount_sats !== decodedAmount) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[5], code: 5 } }
        }

        const authorization = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
        if (!authorization) {
            return {
                status: 'authRequired', app, appUser, liveDebitReq: {
                    request_id: event.id,
                    npub: requestorPub,
                    debit: {
                        type: Types.LiveDebitRequest_debit_type.INVOICE,
                        invoice: bolt11
                    }
                }
            }
        }
        if (!authorization.authorized) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
        await this.validateAccessRules(authorization, app, appUser)
        const { op, payment } = await this.sendDebitPayment(appId, appUserId, requestorPub, bolt11)
        return { status: 'invoicePaid', op, app, appUser, debitRes: { res: 'ok', preimage: payment.preimage } }
    }

    sendDebitPayment = async (appId: string, appUserId: string, requestorPub: string, bolt11: string) => {
        const payment = await this.applicationManager.PayAppUserInvoice(appId, { amount: 0, invoice: bolt11, user_identifier: appUserId, debit_npub: requestorPub })
        await this.storage.debitStorage.IncrementDebitAccess(appUserId, requestorPub, payment.amount_paid + payment.service_fee + payment.network_fee)
        const op = this.newPaymentOperation(payment, bolt11)
        return { payment, op }
    }

    validateAccessRules = async (access: DebitAccess, app: Application, appUser: ApplicationUser): Promise<boolean> => {
        const { rules } = access
        if (!rules) {
            return true
        }
        if (rules[expirationRuleName]) {
            const [expiration] = rules[expirationRuleName]
            if (+expiration < Date.now()) {
                await this.storage.debitStorage.RemoveDebitAccess(access.app_user_id, access.npub)
                return false
            }
        }
        if (rules[frequencyRuleName]) {
            const [number, unit, max] = rules[frequencyRuleName]
            const intervalType = unitToIntervalType(unit as RecurringDebitTimeUnit)
            const seconds = IntervalTypeToSeconds(intervalType) * (+number)
            const sinceUnix = Math.floor(Date.now() / 1000) * seconds
            const payments = await this.storage.paymentStorage.GetUserDebitPayments(appUser.user.user_id, sinceUnix, access.npub)
            let total = 0
            for (const payment of payments) {
                total += payment.paid_amount
            }
            if (total > +max) {
                return false
            }
        }
        return true
    }

    newPaymentOperation = (payment: Types.PayInvoiceResponse, bolt11: string) => {
        return {
            amount: payment.amount_paid,
            paidAtUnix: Math.floor(Date.now() / 1000),
            inbound: false,
            type: Types.UserOperationType.OUTGOING_INVOICE,
            identifier: bolt11,
            operationId: payment.operation_id,
            network_fee: payment.network_fee,
            service_fee: payment.service_fee,
            confirmed: true,
            tx_hash: "",
            internal: payment.network_fee === 0
        }
    }
}

const newNdebitResponse = (content: string, event: { pub: string, id: string }): UnsignedEvent => {
    return {
        content,
        created_at: Math.floor(Date.now() / 1000),
        kind: 21002,
        pubkey: "",
        tags: [
            ['p', event.pub],
            ['e', event.id],
        ],
    }
}