import * as Types from "../../../proto/autogenerated/ts/types.js";
import ApplicationManager from "./applicationManager.js";
import { DebitKeyType } from "../storage/entity/DebitAccess.js";
import Storage from '../storage/index.js'
import LND from "../lnd/lnd.js"
import { ERROR, getLogger } from "../helpers/logger.js";
export type NdebitData = { pointer?: string, bolt11: string, amount_sats: number }
export type NdebitSuccess = { res: 'ok', preimage: string }
export type NdebitFailure = { res: 'GFY', error: string, code: number }
const nip68errs = {
    1: "Request Denied Warning",
    2: "Temporary Failure",
    3: "Expired Request",
    4: "Rate Limited",
    5: "Invalid Amount",
    6: "Invalid Request",
}
export type NdebitResponse = NdebitSuccess | NdebitFailure
type HandleNdebitRes = { ok: false, debitRes: NdebitFailure } | { ok: true, op: Types.UserOperation, appUserId: string, debitRes: NdebitSuccess }
export class DebitManager {
    applicationManager: ApplicationManager
    storage: Storage
    lnd: LND
    logger = getLogger({ component: 'DebitManager' })
    constructor(storage: Storage) {
        this.storage = storage
    }

    payNdebitInvoice = async (appId: string, requestorPub: string, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        try {
            return await this.doNdebit(appId, requestorPub, pointerdata)
        } catch (e: any) {
            this.logger(ERROR, e.message || e)
            return { ok: false, debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
    }

    doNdebit = async (appId: string, requestorPub: string, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        const { amount_sats, bolt11, pointer } = pointerdata
        if (!bolt11) {
            return { ok: false, debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }
        const decoded = await this.lnd.DecodeInvoice(bolt11)
        if (decoded.numSatoshis === 0) {
            return { ok: false, debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }
        if (amount_sats && amount_sats !== decoded.numSatoshis) {
            return { ok: false, debitRes: { res: 'GFY', error: nip68errs[5], code: 5 } }
        }
        if (!pointer) {
            // TODO: debit from app owner balance
            return { ok: false, debitRes: { res: 'GFY', error: nip68errs[2], code: 2 } }
        }
        const split = pointer.split(':')

        let keyType: DebitKeyType
        let key: string
        let appUserId: string
        if (split.length === 1) {
            keyType = 'pubKey'
            key = requestorPub
            appUserId = split[0]
        } else {
            keyType = 'simpleId'
            key = split[0]
            appUserId = split[1]
        }
        const authorization = await this.storage.debitStorage.GetDebitAccess(appUserId, key, keyType)
        if (!authorization) {
            return { ok: false, debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
        const payment = await this.applicationManager.PayAppUserInvoice(appId, { amount: 0, invoice: bolt11, user_identifier: appUserId })
        await this.storage.debitStorage.IncrementDebitAccess(appUserId, key, keyType, payment.amount_paid + payment.service_fee + payment.network_fee)
        const op = this.newPaymentOperation(payment, bolt11)
        return { ok: true, op, appUserId, debitRes: { res: 'ok', preimage: payment.preimage } }
    }

    newPaymentOperation = (payment: Types.PayInvoiceResponse, bolt11: string) => {
        return {
            amount: payment.amount_paid,
            paidAtUnix: Date.now() / 1000,
            inbound: false,
            type: Types.UserOperationType.OUTGOING_INVOICE,
            identifier: bolt11,
            operationId: payment.operation_id,
            network_fee: payment.network_fee,
            service_fee: payment.service_fee,
            confirmed: true,
            tx_hash: "",
            internal: payment.network_fee === 0
        }
    }
}

