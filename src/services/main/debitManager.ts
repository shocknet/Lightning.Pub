import * as Types from "../../../proto/autogenerated/ts/types.js";
import ApplicationManager from "./applicationManager.js";
import Storage from '../storage/index.js'
import LND from "../lnd/lnd.js"
import { ERROR, getLogger } from "../helpers/logger.js";
import { DebitAccess, DebitAccessRules } from '../storage/entity/DebitAccess.js';
import { Application } from '../storage/entity/Application.js';
import { ApplicationUser } from '../storage/entity/ApplicationUser.js';
import { NostrEvent, NostrSend, SendData, SendInitiator } from '../nostr/handler.js';
import { UnsignedEvent } from 'nostr-tools';
import { Ndebit, NdebitData, NdebitFailure, NdebitSuccess, RecurringDebitTimeUnit } from "@shocknet/clink-sdk";
import { debitAccessRulesToDebitRules, newNdebitResponse,debitRulesToDebitAccessRules, 
    nip68errs, AuthRequiredRes, HandleNdebitRes, expirationRuleName, 
    frequencyRuleName,IntervalTypeToSeconds,unitToIntervalType } from "./debitTypes.js";

export class DebitManager {


    _nostrSend: NostrSend | null = null

    applicationManager: ApplicationManager

    storage: Storage
    lnd: LND
    logger = getLogger({ component: 'DebitManager' })
    constructor(storage: Storage, lnd: LND, applicationManager: ApplicationManager) {
        this.storage = storage
        this.lnd = lnd
        this.applicationManager = applicationManager
    }

    attachNostrSend = (nostrSend: NostrSend) => {
        this._nostrSend = nostrSend
    }
    nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

/*     AuthorizeDebit = async (ctx: Types.UserContext, req: Types.DebitAuthorizationRequest): Promise<Types.DebitAuthorization> => {
        const access = await this.storage.debitStorage.AddDebitAccess(ctx.app_user_id, {
            authorize: true,
            npub: req.authorize_npub,
            rules: debitRulesToDebitAccessRules(req.rules)
        })
        if (req.request_id) {
            this.sendDebitResponse({ res: 'ok' }, { pub: req.authorize_npub, id: req.request_id, appId: ctx.app_id })
        }
        return {
            debit_id: access.serial_id.toString(),
            npub: req.authorize_npub,
            authorized: true,
            rules: req.rules
        }
    } */

    GetDebitAuthorizations = async (ctx: Types.UserContext): Promise<Types.DebitAuthorizations> => {
        const allDebitsAccesses = await this.storage.debitStorage.GetAllUserDebitAccess(ctx.app_user_id)
        const debits: Types.DebitAuthorization[] = allDebitsAccesses.map(access => ({
            debit_id: access.serial_id.toString(),
            authorized: access.authorized,
            npub: access.npub,
            rules: debitAccessRulesToDebitRules(access.rules)
        }))
        return { debits }
    }

    EditDebit = async (ctx: Types.UserContext, req: Types.DebitAuthorizationRequest): Promise<void> => {
        const access = await this.storage.debitStorage.GetDebitAccess(ctx.app_user_id, req.authorize_npub);
        if (!access) {
            throw new Error("Debit does not exist")
        }
        await this.storage.debitStorage.UpdateDebitAccessRules(ctx.app_user_id, req.authorize_npub, debitRulesToDebitAccessRules(req.rules));
    }

    BanDebit = async (ctx: Types.UserContext, req: Types.DebitOperation): Promise<void> => {
        await this.storage.debitStorage.DenyDebitAccess(ctx.app_user_id, req.npub)
    }
    ResetDebit = async (ctx: Types.UserContext, req: Types.DebitOperation): Promise<void> => {
        await this.storage.debitStorage.RemoveDebitAccess(ctx.app_user_id, req.npub)
    }

    RespondToDebit = async (ctx: Types.UserContext, req: Types.DebitResponse): Promise<void> => {
        switch (req.response.type) {
            case Types.DebitResponse_response_type.DENIED:
                this.sendDebitResponse({ res: 'GFY', error: nip68errs[1], code: 1 }, { pub: req.npub, id: req.request_id, appId: ctx.app_id })
                return
            case Types.DebitResponse_response_type.INVOICE:
                await this.paySingleInvoice(ctx, {invoice: req.response.invoice, npub: req.npub, request_id: req.request_id})
                return
            case Types.DebitResponse_response_type.AUTHORIZE:
                await this.handleAuthorization(ctx, req.response.authorize, { npub: req.npub, request_id: req.request_id })
                return
            default:
                throw new Error("invalid debit response type")
        }
    }

    paySingleInvoice = async (ctx: Types.UserContext, {invoice,npub,request_id}:{invoice:string, npub:string, request_id:string}) => {
        try {
            const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
            const appUser = await this.storage.applicationStorage.GetApplicationUser(app, ctx.app_user_id)
            const { op, payment } = await this.sendDebitPayment(ctx.app_id, ctx.app_user_id, npub, invoice)
            const debitRes: NdebitSuccess = { res: 'ok', preimage: payment.preimage }
            this.notifyPaymentSuccess(appUser, debitRes, op, { appId: ctx.app_id, pub: npub, id: request_id })
        } catch (e: any) {
            this.sendDebitResponse({ res: 'GFY', error: nip68errs[1], code: 1 }, { pub: npub, id: request_id, appId: ctx.app_id })
            throw e
        }
        
    }

    handleAuthorization = async(ctx: Types.UserContext,debit:Types.DebitToAuthorize, {npub,request_id}:{ npub:string, request_id:string})=>{
        const access = await this.storage.debitStorage.AddDebitAccess(ctx.app_user_id, {
            authorize: true,
            npub,
            rules: debitRulesToDebitAccessRules(debit.rules)
        })
        const { invoice } = debit
        if (!request_id) {
            return
        }
        if (!invoice) {
            this.sendDebitResponse({ res: 'ok' }, { pub: npub, id: request_id, appId: ctx.app_id })
            return
        }
        try {
            const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
            const appUser = await this.storage.applicationStorage.GetApplicationUser(app, ctx.app_user_id)
            this.validateAccessRules(access, app, appUser)
            const { op, payment } = await this.sendDebitPayment(ctx.app_id, ctx.app_user_id, npub, invoice)
            const debitRes: NdebitSuccess = { res: 'ok', preimage: payment.preimage }
            this.notifyPaymentSuccess(appUser, debitRes, op, { appId: ctx.app_id, pub: npub, id: request_id })
        } catch (e: any) {
            this.sendDebitResponse({ res: 'GFY', error: nip68errs[1], code: 1 }, { pub: npub, id: request_id, appId: ctx.app_id })
            throw e
        }
        
    }

    handleNip68Debit = async (pointerdata: NdebitData, event: NostrEvent) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        const res = await this.payNdebitInvoice(event, pointerdata)
        if (res.status === 'fail' || res.status === 'authOk') {
            const e = newNdebitResponse(JSON.stringify(res.debitRes), event)
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
            return
        }
        const { appUser } = res
        if (res.status === 'authRequired') {
            this.handleAuthRequired(pointerdata, event, res)
            return
        }
        const { op, debitRes } = res
        this.notifyPaymentSuccess(appUser, debitRes, op, event)
    }

    handleAuthRequired = (data:NdebitData, event: NostrEvent, res: AuthRequiredRes) => {
        if (!res.appUser.nostr_public_key) {
            this.sendDebitResponse({ res: 'GFY', error: nip68errs[1], code: 1 }, { pub: event.pub, id: event.id, appId: event.appId })
            return
        }
        const message: Types.LiveDebitRequest & { requestId: string, status: 'OK' } = { ...res.liveDebitReq, requestId: "GetLiveDebitRequests", status: 'OK' }
        this.nostrSend({ type: 'app', appId: event.appId }, { type: 'content', content: JSON.stringify(message), pub: res.appUser.nostr_public_key })
    }

    notifyPaymentSuccess = (appUser: ApplicationUser, debitRes: NdebitSuccess, op: Types.UserOperation, event: { pub: string, id: string, appId: string }) => {
        const message: Types.LiveUserOperation & { requestId: string, status: 'OK' } = { operation: op, requestId: "GetLiveUserOperations", status: 'OK' }
        if (appUser.nostr_public_key) { // TODO - fix before support for http streams
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'content', content: JSON.stringify(message), pub: appUser.nostr_public_key })
        }
        this.sendDebitResponse(debitRes, event)
    }

    sendDebitResponse = (debitRes: NdebitFailure | NdebitSuccess, event: { pub: string, id: string, appId: string }) => {
        const e = newNdebitResponse(JSON.stringify(debitRes), event)
        this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
    }

    payNdebitInvoice = async (event: NostrEvent, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        try {
            return await this.doNdebit(event, pointerdata)
        } catch (e: any) {
            this.logger(ERROR, e.message || e)
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
    }

    doNdebit = async (event: NostrEvent, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        const { appId, pub: requestorPub } = event
        const { amount_sats, pointer, bolt11, frequency } = pointerdata
        if (!pointer) {
            // TODO: debit from app owner balance
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
        const appUserId = pointer
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const appUser = await this.storage.applicationStorage.GetApplicationUser(app, appUserId)
        let decodedAmount = null
        if (bolt11) {
            const decoded = await this.lnd.DecodeInvoice(bolt11)
            decodedAmount = decoded.numSatoshis
        }
        if (frequency) {
            const amt = amount_sats || decodedAmount
            if (!amt) {
                return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[5], code: 5 } }
            }
            const debitAccess = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
            if (!debitAccess) {
                return {
                    status: 'authRequired', app, appUser, liveDebitReq: {
                        request_id: event.id,
                        npub: requestorPub,
                        debit: {
                            type: Types.LiveDebitRequest_debit_type.FREQUENCY,
                            frequency: {
                                interval: unitToIntervalType(frequency.unit),
                                number_of_intervals: frequency.number,
                                amount: amt,
                            }
                        }
                    }
                }
            } else if (!debitAccess.authorized) {
                return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
            }
            return { status: 'authOk', debitRes: { res: 'ok' } }
        }

        if (!bolt11) {
            if (!amount_sats) {
                const debitAccess = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
                if (!debitAccess) {
                    return {
                        status: 'authRequired', app, appUser, liveDebitReq: {
                            request_id: event.id,
                            npub: requestorPub,
                            debit: {
                                type: Types.LiveDebitRequest_debit_type.FULL_ACCESS,
                                full_access: {}
                            }
                        }
                    }
                } else if (!debitAccess.authorized) {
                    return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
                }
                return { status: 'authOk', debitRes: { res: 'ok' } }
            }
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }

        if (!decodedAmount) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }
        if (amount_sats && amount_sats !== decodedAmount) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[5], code: 5 } }
        }

        const authorization = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
        if (!authorization) {
            return {
                status: 'authRequired', app, appUser, liveDebitReq: {
                    request_id: event.id,
                    npub: requestorPub,
                    debit: {
                        type: Types.LiveDebitRequest_debit_type.INVOICE,
                        invoice: bolt11
                    }
                }
            }
        }
        if (!authorization.authorized) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
        await this.validateAccessRules(authorization, app, appUser)
        const { op, payment } = await this.sendDebitPayment(appId, appUserId, requestorPub, bolt11)
        return { status: 'invoicePaid', op, app, appUser, debitRes: { res: 'ok', preimage: payment.preimage } }
    }

    sendDebitPayment = async (appId: string, appUserId: string, requestorPub: string, bolt11: string) => {
        const payment = await this.applicationManager.PayAppUserInvoice(appId, { amount: 0, invoice: bolt11, user_identifier: appUserId, debit_npub: requestorPub })
        await this.storage.debitStorage.IncrementDebitAccess(appUserId, requestorPub, payment.amount_paid + payment.service_fee + payment.network_fee)
        const op = this.newPaymentOperation(payment, bolt11)
        return { payment, op }
    }

    validateAccessRules = async (access: DebitAccess, app: Application, appUser: ApplicationUser): Promise<boolean> => {
        const { rules } = access
        if (!rules) {
            return true
        }
        if (rules[expirationRuleName]) {
            const [expiration] = rules[expirationRuleName]
            if (+expiration < Date.now()) {
                await this.storage.debitStorage.RemoveDebitAccess(access.app_user_id, access.npub)
                return false
            }
        }
        if (rules[frequencyRuleName]) {
            const [number, unit, max] = rules[frequencyRuleName]
            const intervalType = unitToIntervalType(unit as RecurringDebitTimeUnit)
            const seconds = IntervalTypeToSeconds(intervalType) * (+number)
            const sinceUnix = Math.floor(Date.now() / 1000) * seconds
            const payments = await this.storage.paymentStorage.GetUserDebitPayments(appUser.user.user_id, sinceUnix, access.npub)
            let total = 0
            for (const payment of payments) {
                total += payment.paid_amount
            }
            if (total > +max) {
                return false
            }
        }
        return true
    }

    newPaymentOperation = (payment: Types.PayInvoiceResponse, bolt11: string) => {
        return {
            amount: payment.amount_paid,
            paidAtUnix: Math.floor(Date.now() / 1000),
            inbound: false,
            type: Types.UserOperationType.OUTGOING_INVOICE,
            identifier: bolt11,
            operationId: payment.operation_id,
            network_fee: payment.network_fee,
            service_fee: payment.service_fee,
            confirmed: true,
            tx_hash: "",
            internal: payment.network_fee === 0
        }
    }
}

