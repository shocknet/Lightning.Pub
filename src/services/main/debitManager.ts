import crypto from 'crypto';
import * as Types from "../../../proto/autogenerated/ts/types.js";
import ApplicationManager from "./applicationManager.js";
import Storage from '../storage/index.js'
import LND from "../lnd/lnd.js"
import { ERROR, getLogger } from "../helpers/logger.js";
import { DebitAccess, DebitAccessRules } from '../storage/entity/DebitAccess.js';
export const expirationRuleName = 'expiration'
export const frequencyRuleName = 'frequency'
type RecurringDebitTimeUnit = 'day' | 'week' | 'month'
type RecurringDebit = { frequency: { number: number, unit: RecurringDebitTimeUnit } }
const unitToIntervalType = (unit: RecurringDebitTimeUnit) => {
    switch (unit) {
        case 'day': return Types.IntervalType.DAY
        case 'week': return Types.IntervalType.WEEK
        case 'month': return Types.IntervalType.MONTH
        default: throw new Error("invalid unit")
    }

}
export type NdebitData = { pointer?: string, amount_sats: number } & (RecurringDebit | { bolt11: string })
export type NdebitSuccess = { res: 'ok' }
export type NdebitSuccessPayment = { res: 'ok', preimage: string }
export type NdebitFailure = { res: 'GFY', error: string, code: number }
const nip68errs = {
    1: "Request Denied Warning",
    2: "Temporary Failure",
    3: "Expired Request",
    4: "Rate Limited",
    5: "Invalid Amount",
    6: "Invalid Request",
}
type HandleNdebitRes = { status: 'fail', debitRes: NdebitFailure }
    | { status: 'invoicePaid', op: Types.UserOperation, appUserId: string, debitRes: NdebitSuccessPayment }
    | { status: 'authRequired', liveDebitReq: Types.LiveDebitRequest, appUserId: string }
    | { status: 'authOk', debitRes: NdebitSuccess }
export class DebitManager {



    applicationManager: ApplicationManager
    storage: Storage
    lnd: LND
    logger = getLogger({ component: 'DebitManager' })
    constructor(storage: Storage, lnd: LND, applicationManager: ApplicationManager) {
        this.storage = storage
        this.lnd = lnd
        this.applicationManager = applicationManager
    }

    AuthorizeDebit = async (ctx: Types.UserContext, req: Types.DebitAuthorizationRequest): Promise<Types.DebitAuthorization> => {
        const access = await this.storage.debitStorage.AddDebitAccess(ctx.app_user_id, req.authorize_npub)
        return {
            debit_id: access.serial_id.toString(),
            npub: req.authorize_npub,
            authorized: true,
            rules: []
        }
    }

    GetDebitAuthorizations = async (ctx: Types.UserContext): Promise<Types.DebitAuthorizations> => {
        const allDebitsAccesses = await this.storage.debitStorage.GetAllUserDebitAccess(ctx.app_user_id)
        const debits: Types.DebitAuthorization[] = allDebitsAccesses.map(access => ({
            debit_id: access.serial_id.toString(),
            authorized: access.authorized,
            npub: access.npub,
            rules: []
        }))
        return { debits }
    }

    RemoveAuthorizedDebit = async (ctx: Types.UserContext, req: Types.RemoveAuthorizedDebitRequest): Promise<void> => {
        await this.storage.debitStorage.RemoveDebitAccess(ctx.app_user_id, req.npub)
    }

    payNdebitInvoice = async (appId: string, requestorPub: string, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        try {
            return await this.doNdebit(appId, requestorPub, pointerdata)
        } catch (e: any) {
            this.logger(ERROR, e.message || e)
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
    }

    doNdebit = async (appId: string, requestorPub: string, pointerdata: NdebitData): Promise<HandleNdebitRes> => {
        const { amount_sats, pointer } = pointerdata
        if (!pointer) {
            // TODO: debit from app owner balance
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[2], code: 2 } }
        }
        const appUserId = pointer
        const pointerFreq = pointerdata as RecurringDebit
        if (pointerFreq.frequency) {
            const debitAccess = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
            if (!debitAccess) {
                return {
                    status: 'authRequired', appUserId, liveDebitReq: {
                        amount: pointerdata.amount_sats,
                        npub: requestorPub,
                        debit: {
                            type: Types.LiveDebitRequest_debit_type.FREQUENCY,
                            frequency: {
                                interval: unitToIntervalType(pointerFreq.frequency.unit),
                                number_of_intervals: pointerFreq.frequency.number,
                            }
                        }
                    }
                }
            } else if (!debitAccess.authorized) {
                return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
            }
            return { status: 'authOk', debitRes: { res: 'ok' } }
        }
        const { bolt11 } = pointerdata as { bolt11: string }
        if (!bolt11) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }
        const decoded = await this.lnd.DecodeInvoice(bolt11)
        if (decoded.numSatoshis === 0) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[6], code: 6 } }
        }
        if (amount_sats && amount_sats !== decoded.numSatoshis) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[5], code: 5 } }
        }

        const authorization = await this.storage.debitStorage.GetDebitAccess(appUserId, requestorPub)
        if (!authorization) {
            return {
                status: 'authRequired', appUserId, liveDebitReq: {
                    amount: pointerdata.amount_sats,
                    npub: requestorPub,
                    debit: {
                        type: Types.LiveDebitRequest_debit_type.INVOICE,
                        invoice: bolt11
                    }
                }
            }
        }
        if (!authorization.authorized) {
            return { status: 'fail', debitRes: { res: 'GFY', error: nip68errs[1], code: 1 } }
        }
        await this.validateAccessRules(authorization)
        const payment = await this.applicationManager.PayAppUserInvoice(appId, { amount: 0, invoice: bolt11, user_identifier: appUserId })
        await this.storage.debitStorage.IncrementDebitAccess(appUserId, requestorPub, payment.amount_paid + payment.service_fee + payment.network_fee)
        const op = this.newPaymentOperation(payment, bolt11)
        return { status: 'invoicePaid', op, appUserId, debitRes: { res: 'ok', preimage: payment.preimage } }
    }

    validateAccessRules = async (access: DebitAccess): Promise<boolean> => {
        const { rules } = access
        if (!rules) {
            return true
        }
        return false
        // TODO: rules validation
        /*         if (rules[expirationRuleName]) {
        
                }
                if (rules[frequencyRuleName]) {
        
                } */
    }


    newPaymentOperation = (payment: Types.PayInvoiceResponse, bolt11: string) => {
        return {
            amount: payment.amount_paid,
            paidAtUnix: Date.now() / 1000,
            inbound: false,
            type: Types.UserOperationType.OUTGOING_INVOICE,
            identifier: bolt11,
            operationId: payment.operation_id,
            network_fee: payment.network_fee,
            service_fee: payment.service_fee,
            confirmed: true,
            tx_hash: "",
            internal: payment.network_fee === 0
        }
    }
}

