import { bech32 } from 'bech32'
import crypto from 'crypto'
import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { MainSettings } from './settings.js'
import { InboundOptionals, defaultInvoiceExpiry } from '../storage/paymentStorage.js'
import LND from '../lnd/lnd.js'
import { Application } from '../storage/entity/Application.js'
import { ERROR, getLogger, PubLogger } from '../helpers/logger.js'
import { UserReceivingAddress } from '../storage/entity/UserReceivingAddress.js'
import { AddressPaidCb, InvoicePaidCb, PaidInvoice } from '../lnd/settings.js'
import { UserReceivingInvoice, ZapInfo } from '../storage/entity/UserReceivingInvoice.js'
import { Payment_PaymentStatus, SendCoinsResponse } from '../../../proto/lnd/lightning.js'
import { Event, verifiedSymbol, verifyEvent } from 'nostr-tools'
import { AddressReceivingTransaction } from '../storage/entity/AddressReceivingTransaction.js'
import { UserTransactionPayment } from '../storage/entity/UserTransactionPayment.js'
import { Watchdog } from './watchdog.js'
import { LiquidityProvider } from './liquidityProvider.js'
import { LiquidityManager } from './liquidityManager.js'
import { Utils } from '../helpers/utilsWrapper.js'
import { UserInvoicePayment } from '../storage/entity/UserInvoicePayment.js'
interface UserOperationInfo {
    serial_id: number
    paid_amount: number
    paid_at_unix: number
    invoice?: string
    address?: string
    from_user?: { user_id: string }
    to_user?: { user_id: string }
    service_fee?: number
    service_fees?: number
    routing_fees?: number
    chain_fees?: number
    confs?: number
    tx_hash?: string;
    user_address?: {
        address: string
    };
    internal?: boolean;
}
export type PendingTx = { type: 'incoming', tx: AddressReceivingTransaction } | { type: 'outgoing', tx: UserTransactionPayment }
const defaultLnurlPayMetadata = (text: string) => `[["text/plain", "${text}"]]`
const defaultLnAddressMetadata = (text: string, id: string) => `[["text/plain", "${text}"],["text/identifier", "${id}"]]`
const confInOne = 1000 * 1000
const confInTwo = 100 * 1000 * 1000
export default class {
    storage: Storage
    settings: MainSettings
    lnd: LND
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    log = getLogger({ component: "PaymentManager" })
    watchDog: Watchdog
    liquidityManager: LiquidityManager
    utils: Utils
    constructor(storage: Storage, lnd: LND, settings: MainSettings, liquidityManager: LiquidityManager, utils: Utils, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb) {
        this.storage = storage
        this.settings = settings
        this.lnd = lnd
        this.liquidityManager = liquidityManager
        this.utils = utils
        this.watchDog = new Watchdog(settings.watchDogSettings, this.liquidityManager, this.lnd, this.storage, this.utils, this.liquidityManager.rugPullTracker)
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
    }
    Stop() {
        this.watchDog.Stop()
    }

    checkPendingPayments = async () => {
        const log = getLogger({ component: 'pendingPaymentsOnStart' })
        const pendingPayments = await this.storage.paymentStorage.GetPendingPayments()
        for (const p of pendingPayments) {
            log("checking state of payment: ", p.invoice)
            if (p.internal) {
                log("found pending internal payment", p.serial_id)
            } else if (p.liquidityProvider) {
                log("found pending liquidity provider payment", p.serial_id)
                await this.checkPendingProviderPayment(log, p)
            } else {
                log("found pending external payment", p.serial_id)
                await this.checkPendingLndPayment(log, p)
            }
        }
    }

    checkPendingProviderPayment = async (log: PubLogger, p: UserInvoicePayment) => {
        const state = await this.lnd.liquidProvider.GetPaymentState(p.invoice)
        if (state.paid_at_unix < 0) {
            const fullAmount = p.paid_amount + p.service_fees + p.routing_fees
            log("found a failed provider payment, refunding", fullAmount, "sats to user", p.user.user_id)
            await this.storage.txQueue.PushToQueue({
                dbTx: true, description: "refund failed provider payment", exec: async tx => {
                    await this.storage.userStorage.IncrementUserBalance(p.user.user_id, fullAmount, "payment_refund:" + p.invoice, tx)
                    await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, 0, 0, false, undefined, tx)
                }
            })
            return
        } else if (state.paid_at_unix > 0) {
            log("provider payment succeeded", p.serial_id, "updating payment info")
            const routingFeeLimit = p.routing_fees
            const serviceFee = p.service_fees
            const actualFee = state.network_fee + state.service_fee
            await this.storage.txQueue.PushToQueue({
                dbTx: true, description: "pending provider payment success after restart", exec: async tx => {
                    if (routingFeeLimit - actualFee > 0) {
                        this.log("refund pending provider payment routing fee", routingFeeLimit, actualFee, "sats")
                        await this.storage.userStorage.IncrementUserBalance(p.user.user_id, routingFeeLimit - actualFee, "routing_fee_refund:" + p.invoice, tx)
                    }
                    await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, actualFee, p.service_fees, true, undefined, tx)
                }
            })
            if (p.linkedApplication && p.user.user_id !== p.linkedApplication.owner.user_id && serviceFee > 0) {
                await this.storage.userStorage.IncrementUserBalance(p.linkedApplication.owner.user_id, serviceFee, "fees")
            }
            const user = await this.storage.userStorage.GetUser(p.user.user_id)
            this.storage.eventsLog.LogEvent({ type: 'invoice_payment', userId: p.user.user_id, appId: p.linkedApplication?.app_id || "", appUserId: "", balance: user.balance_sats, data: p.invoice, amount: p.paid_amount })
            return
        }
        log("provider payment still pending", p.serial_id, "no action will be performed")
    }

    checkPendingLndPayment = async (log: PubLogger, p: UserInvoicePayment) => {
        const decoded = await this.lnd.DecodeInvoice(p.invoice)
        const payment = await this.lnd.GetPaymentFromHash(decoded.paymentHash)
        if (!payment || payment.paymentHash !== decoded.paymentHash) {
            log(ERROR, "lnd payment not found for pending payment hash ", decoded.paymentHash)
            return
        }

        switch (payment.status) {
            case Payment_PaymentStatus.UNKNOWN:
                log("pending payment in unknown state", p.serial_id, "no action will be performed")
                return
            case Payment_PaymentStatus.IN_FLIGHT:
                log("pending payment in flight", p.serial_id, "no action will be performed")
                return
            case Payment_PaymentStatus.SUCCEEDED:
                log("pending payment succeeded", p.serial_id, "updating payment info")
                const routingFeeLimit = p.routing_fees
                const serviceFee = p.service_fees
                const actualFee = Number(payment.feeSat)
                await this.storage.txQueue.PushToQueue({
                    dbTx: true, description: "pending payment success after restart", exec: async tx => {
                        if (routingFeeLimit - actualFee > 0) {
                            this.log("refund pending payment routing fee", routingFeeLimit, actualFee, "sats")
                            await this.storage.userStorage.IncrementUserBalance(p.user.user_id, routingFeeLimit - actualFee, "routing_fee_refund:" + p.invoice, tx)
                        }
                        await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, actualFee, p.service_fees, true, undefined, tx)
                    }
                })
                if (p.linkedApplication && p.user.user_id !== p.linkedApplication.owner.user_id && serviceFee > 0) {
                    await this.storage.userStorage.IncrementUserBalance(p.linkedApplication.owner.user_id, serviceFee, "fees")
                }
                const user = await this.storage.userStorage.GetUser(p.user.user_id)
                this.storage.eventsLog.LogEvent({ type: 'invoice_payment', userId: p.user.user_id, appId: p.linkedApplication?.app_id || "", appUserId: "", balance: user.balance_sats, data: p.invoice, amount: p.paid_amount })
                return
            case Payment_PaymentStatus.FAILED:
                const fullAmount = p.paid_amount + p.service_fees + p.routing_fees
                log("found a failed pending payment, refunding", fullAmount, "sats to user", p.user.user_id)
                await this.storage.txQueue.PushToQueue({
                    dbTx: true, description: "refund failed pending payment", exec: async tx => {
                        await this.storage.userStorage.IncrementUserBalance(p.user.user_id, fullAmount, "payment_refund:" + p.invoice, tx)
                        await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, 0, 0, false, undefined, tx)
                    }
                })
            default:
                break;
        }
    }

    getServiceFee(action: Types.UserOperationType, amount: number, appUser: boolean): number {
        switch (action) {
            case Types.UserOperationType.INCOMING_TX:
                return Math.ceil(this.settings.incomingTxFee * amount)
            case Types.UserOperationType.OUTGOING_TX:
                return Math.ceil(this.settings.outgoingTxFee * amount)
            case Types.UserOperationType.INCOMING_INVOICE:
                if (appUser) {
                    return Math.ceil(this.settings.incomingAppUserInvoiceFee * amount)
                }
                return Math.ceil(this.settings.incomingAppInvoiceFee * amount)
            case Types.UserOperationType.OUTGOING_INVOICE:
                if (appUser) {
                    return Math.ceil(this.settings.outgoingAppUserInvoiceFee * amount)
                }
                return Math.ceil(this.settings.outgoingAppInvoiceFee * amount)
            case Types.UserOperationType.OUTGOING_USER_TO_USER || Types.UserOperationType.INCOMING_USER_TO_USER:
                if (appUser) {
                    return Math.ceil(this.settings.userToUserFee * amount)
                }
                return Math.ceil(this.settings.appToUserFee * amount)
            default:
                throw new Error("Unknown service action type")
        }
    }

    async SetMockInvoiceAsPaid(req: Types.SetMockInvoiceAsPaidRequest) {
        if (!this.settings.lndSettings.mockLnd) {
            throw new Error("mock disabled, cannot set invoice as paid")
        }
        await this.lnd.SetMockInvoiceAsPaid(req.invoice, req.amount)
    }

    async SetMockUserBalance(userId: string, balance: number) {
        if (!this.settings.lndSettings.mockLnd) {
            throw new Error("mock disabled, cannot set invoice as paid")
        }
        getLogger({})("setting mock balance...")
        await this.storage.userStorage.UpdateUser(userId, { balance_sats: balance })
    }

    async NewAddress(ctx: Types.UserContext, req: Types.NewAddressRequest): Promise<Types.NewAddressResponse> {
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const user = await this.storage.userStorage.GetUser(ctx.user_id)
        if (user.locked) {
            throw new Error("user is banned, cannot generate address")
        }
        const existingAddress = await this.storage.paymentStorage.GetExistingUserAddress(ctx.user_id, app)
        if (existingAddress) {
            return { address: existingAddress.address }
        }
        const res = await this.lnd.NewAddress(req.addressType, { useProvider: false, from: 'user' })
        const userAddress = await this.storage.paymentStorage.AddUserAddress(user, res.address, { linkedApplication: app })
        this.storage.eventsLog.LogEvent({ type: 'new_address', userId: user.user_id, appUserId: "", appId: app.app_id, balance: user.balance_sats, data: res.address, amount: 0 })
        return { address: userAddress.address }
    }

    async NewInvoice(userId: string, req: Types.NewInvoiceRequest, options: InboundOptionals = { expiry: defaultInvoiceExpiry }): Promise<Types.NewInvoiceResponse> {
        const user = await this.storage.userStorage.GetUser(userId)
        if (user.locked) {
            throw new Error("user is banned, cannot generate invoice")
        }
        const use = await this.liquidityManager.beforeInvoiceCreation(req.amountSats)
        const res = await this.lnd.NewInvoice(req.amountSats, req.memo, options.expiry, { useProvider: use === 'provider', from: 'user' })
        const userInvoice = await this.storage.paymentStorage.AddUserInvoice(user, res.payRequest, options, res.providerDst)
        const appId = options.linkedApplication ? options.linkedApplication.app_id : ""
        this.storage.eventsLog.LogEvent({ type: 'new_invoice', userId: user.user_id, appUserId: "", appId, balance: user.balance_sats, data: userInvoice.invoice, amount: req.amountSats })
        return {
            invoice: userInvoice.invoice
        }
    }

    GetMaxPayableInvoice(balance: number, appUser: boolean): number {
        let maxWithinServiceFee = 0
        if (appUser) {
            maxWithinServiceFee = Math.max(0, Math.floor(balance * (1 - this.settings.outgoingAppUserInvoiceFee)))
        } else {
            maxWithinServiceFee = Math.max(0, Math.floor(balance * (1 - this.settings.outgoingAppInvoiceFee)))
        }
        return this.lnd.GetMaxWithinLimit(maxWithinServiceFee)
    }
    async DecodeInvoice(req: Types.DecodeInvoiceRequest): Promise<Types.DecodeInvoiceResponse> {
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        return {
            amount: Number(decoded.numSatoshis)
        }
    }

    async PayInvoice(userId: string, req: Types.PayInvoiceRequest, linkedApplication: Application): Promise<Types.PayInvoiceResponse> {
        await this.watchDog.PaymentRequested()
        const maybeBanned = await this.storage.userStorage.GetUser(userId)
        if (maybeBanned.locked) {
            throw new Error("user is banned, cannot send payment")
        }
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        if (decoded.numSatoshis !== 0 && req.amount !== 0) {
            throw new Error("invoice has value, do not provide amount the the request")
        }
        if (decoded.numSatoshis === 0 && req.amount === 0) {
            throw new Error("invoice has no value, an amount must be provided in the request")
        }
        const payAmount = req.amount !== 0 ? req.amount : Number(decoded.numSatoshis)
        const isAppUserPayment = userId !== linkedApplication.owner.user_id
        const serviceFee = this.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, payAmount, isAppUserPayment)
        const internalInvoice = await this.storage.paymentStorage.GetInvoiceOwner(req.invoice)
        if (internalInvoice && internalInvoice.paid_at_unix > 0) {
            throw new Error("this invoice was already paid")
        }
        const invoiceAlreadyPaid = await this.storage.paymentStorage.GetPaymentOwner(req.invoice)
        if (invoiceAlreadyPaid && invoiceAlreadyPaid.paid_at_unix > 0) {
            throw new Error("this invoice was already paid")
        }
        let paymentInfo = { preimage: "", amtPaid: 0, networkFee: 0, serialId: 0 }
        if (internalInvoice) {
            paymentInfo = await this.PayInternalInvoice(userId, internalInvoice, { payAmount, serviceFee }, linkedApplication, req.debit_npub)
        } else {
            paymentInfo = await this.PayExternalInvoice(userId, req.invoice, { payAmount, serviceFee, amountForLnd: req.amount }, linkedApplication, req.debit_npub)
        }
        if (isAppUserPayment && serviceFee > 0) {
            await this.storage.userStorage.IncrementUserBalance(linkedApplication.owner.user_id, serviceFee, "fees")
        }
        const user = await this.storage.userStorage.GetUser(userId)
        this.storage.eventsLog.LogEvent({ type: 'invoice_payment', userId, appId: linkedApplication.app_id, appUserId: "", balance: user.balance_sats, data: req.invoice, amount: payAmount })
        return {
            preimage: paymentInfo.preimage,
            amount_paid: paymentInfo.amtPaid,
            operation_id: `${Types.UserOperationType.OUTGOING_INVOICE}-${paymentInfo.serialId}`,
            network_fee: paymentInfo.networkFee,
            service_fee: serviceFee,
        }
    }

    async PayExternalInvoice(userId: string, invoice: string, amounts: { payAmount: number, serviceFee: number, amountForLnd: number }, linkedApplication: Application, debitNpub?: string) {
        if (this.settings.disableExternalPayments) {
            throw new Error("something went wrong sending payment, please try again later")
        }
        const existingPendingPayment = await this.storage.paymentStorage.GetPaymentOwner(invoice)
        if (existingPendingPayment) {
            if (existingPendingPayment.paid_at_unix > 0) {
                throw new Error("this invoice was already paid")
            } else if (existingPendingPayment.paid_at_unix < 0) {
                throw new Error("this invoice was already paid and failed, try another invoice")
            }
            throw new Error("payment already in progress")
        }
        const { amountForLnd, payAmount, serviceFee } = amounts
        const totalAmountToDecrement = payAmount + serviceFee
        const routingFeeLimit = this.lnd.GetFeeLimitAmount(payAmount)
        const use = await this.liquidityManager.beforeOutInvoicePayment(payAmount)
        const provider = use === 'provider' ? this.lnd.liquidProvider.GetProviderDestination() : undefined
        const pendingPayment = await this.storage.txQueue.PushToQueue({
            dbTx: true, description: "payment started", exec: async tx => {
                await this.storage.userStorage.DecrementUserBalance(userId, totalAmountToDecrement + routingFeeLimit, invoice, tx)
                return await this.storage.paymentStorage.AddPendingExternalPayment(userId, invoice, { payAmount, serviceFee, networkFee: routingFeeLimit }, linkedApplication, provider, tx, debitNpub)
            }
        })
        this.log("ready to pay")
        try {
            const payment = await this.lnd.PayInvoice(invoice, amountForLnd, routingFeeLimit, payAmount, { useProvider: use === 'provider', from: 'user' }, index => {
                this.storage.paymentStorage.SetExternalPaymentIndex(pendingPayment.serial_id, index)
            })
            if (routingFeeLimit - payment.feeSat > 0) {
                this.log("refund routing fee", routingFeeLimit, payment.feeSat, "sats")
                await this.storage.userStorage.IncrementUserBalance(userId, routingFeeLimit - payment.feeSat, "routing_fee_refund:" + invoice)
            }

            await this.storage.paymentStorage.UpdateExternalPayment(pendingPayment.serial_id, payment.feeSat, serviceFee, true, payment.providerDst)
            return { preimage: payment.paymentPreimage, amtPaid: payment.valueSat, networkFee: payment.feeSat, serialId: pendingPayment.serial_id }

        } catch (err) {
            await this.storage.userStorage.IncrementUserBalance(userId, totalAmountToDecrement + routingFeeLimit, "payment_refund:" + invoice)
            await this.storage.paymentStorage.UpdateExternalPayment(pendingPayment.serial_id, 0, 0, false)
            throw err
        }
    }

    async PayInternalInvoice(userId: string, internalInvoice: UserReceivingInvoice, amounts: { payAmount: number, serviceFee: number }, linkedApplication: Application, debitNpub?: string) {
        if (internalInvoice.paid_at_unix > 0) {
            throw new Error("this invoice was already paid")
        }
        const { payAmount, serviceFee } = amounts
        const totalAmountToDecrement = payAmount + serviceFee
        await this.storage.userStorage.DecrementUserBalance(userId, totalAmountToDecrement, internalInvoice.invoice)
        try {
            await this.invoicePaidCb(internalInvoice.invoice, payAmount, 'internal')
            const newPayment = await this.storage.paymentStorage.AddInternalPayment(userId, internalInvoice.invoice, payAmount, serviceFee, linkedApplication, debitNpub)
            this.utils.stateBundler.AddTxPoint('paidAnInvoice', payAmount, { used: 'internal', from: 'user' })
            return { preimage: "", amtPaid: payAmount, networkFee: 0, serialId: newPayment.serial_id }
        } catch (err) {
            await this.storage.userStorage.IncrementUserBalance(userId, totalAmountToDecrement, "internal_payment_refund:" + internalInvoice.invoice)
            this.utils.stateBundler.AddTxPointFailed('paidAnInvoice', payAmount, { used: 'internal', from: 'user' })

            throw err
        }

    }


    async PayAddress(ctx: Types.UserContext, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> {
        throw new Error("address payment currently disabled, use Lightning instead")
        await this.watchDog.PaymentRequested()
        this.log("paying address", req.address, "for user", ctx.user_id, "with amount", req.amoutSats)
        const maybeBanned = await this.storage.userStorage.GetUser(ctx.user_id)
        if (maybeBanned.locked) {
            throw new Error("user is banned, cannot send chain tx")
        }
        const { blockHeight } = await this.lnd.GetInfo()
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const serviceFee = this.getServiceFee(Types.UserOperationType.OUTGOING_TX, req.amoutSats, false)
        const isAppUserPayment = ctx.user_id !== app.owner.user_id
        const internalAddress = await this.storage.paymentStorage.GetAddressOwner(req.address)
        let txId = ""
        let chainFees = 0
        if (!internalAddress) {
            this.log("paying external address")
            const estimate = await this.lnd.EstimateChainFees(req.address, req.amoutSats, 1)
            const vBytes = Math.ceil(Number(estimate.feeSat / estimate.satPerVbyte))
            chainFees = vBytes * req.satsPerVByte
            const total = req.amoutSats + chainFees
            // WARNING, before re-enabling this, make sure to add the tx_hash to the DecrementUserBalance "reason"!!
            this.storage.userStorage.DecrementUserBalance(ctx.user_id, total + serviceFee, req.address)
            try {
                const payment = await this.lnd.PayAddress(req.address, req.amoutSats, req.satsPerVByte, "", { useProvider: false, from: 'user' })
                txId = payment.txid
            } catch (err) {
                // WARNING, before re-enabling this, make sure to add the tx_hash to the IncrementUserBalance "reason"!!
                await this.storage.userStorage.IncrementUserBalance(ctx.user_id, total + serviceFee, req.address)
                throw err
            }
        } else {
            this.log("paying internal address")
            txId = crypto.randomBytes(32).toString("hex")
            const addressData = `${req.address}:${txId}`
            await this.storage.userStorage.DecrementUserBalance(ctx.user_id, req.amoutSats + serviceFee, addressData)
            this.addressPaidCb({ hash: txId, index: 0 }, req.address, req.amoutSats, 'internal')
        }

        if (isAppUserPayment && serviceFee > 0) {
            await this.storage.userStorage.IncrementUserBalance(app.owner.user_id, serviceFee, 'fees')
        }

        const newTx = await this.storage.paymentStorage.AddUserTransactionPayment(ctx.user_id, req.address, txId, 0, req.amoutSats, chainFees, serviceFee, !!internalAddress, blockHeight, app)
        const user = await this.storage.userStorage.GetUser(ctx.user_id)
        const txData = `${newTx.address}:${newTx.tx_hash}`
        this.storage.eventsLog.LogEvent({ type: 'address_payment', userId: ctx.user_id, appId: app.app_id, appUserId: "", balance: user.balance_sats, data: txData, amount: req.amoutSats })
        return {
            txId: txId,
            operation_id: `${Types.UserOperationType.OUTGOING_TX}-${newTx.serial_id}`,
            network_fee: chainFees,
            service_fee: serviceFee
        }
    }

    balanceCheckUrl(k1: string): string {
        return `${this.settings.serviceUrl}/api/guest/lnurl_withdraw/info?k1=${k1}`
    }

    isDefaultServiceUrl(): boolean {
        if (
            this.settings.serviceUrl.includes("localhost")
            ||
            this.settings.serviceUrl.includes("127.0.0.1")
        ) {
            return true
        }
        return false;
    }

    async GetLnurlWithdrawLink(ctx: Types.UserContext): Promise<Types.LnurlLinkResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const key = await this.storage.paymentStorage.AddUserEphemeralKey(ctx.user_id, 'balanceCheck', app)
        return {
            lnurl: this.encodeLnurl(this.balanceCheckUrl(key.key)),
            k1: key.key
        }
    }

    async GetLnurlWithdrawInfo(balanceCheckK1: string): Promise<Types.LnurlWithdrawInfoResponse> {
        throw new Error("LNURL withdraw currenlty not supported for non application users")
        /*const key = await this.storage.paymentStorage.UseUserEphemeralKey(balanceCheckK1, 'balanceCheck')
        const maxWithdrawable = this.GetMaxPayableInvoice(key.user.balance_sats)
        const callbackK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'withdraw')
        const newBalanceCheckK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'balanceCheck')
        const payInfoK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'pay')
        return {
            tag: "withdrawRequest",
            callback: `${this.settings.serviceUrl}/api/guest/lnurl_withdraw/handle`,
            defaultDescription: "lnurl withdraw from lightning.pub",
            k1: callbackK1.key,
            maxWithdrawable: maxWithdrawable * 1000,
            minWithdrawable: 10000,
            balanceCheck: this.balanceCheckUrl(newBalanceCheckK1.key),
            payLink: `${this.settings.serviceUrl}/api/guest/lnurl_pay/info?k1=${payInfoK1.key}`,
        }*/
    }

    async HandleLnurlWithdraw(k1: string, invoice: string): Promise<void> {
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(k1, 'withdraw')
        if (!key.linkedApplication) {
            throw new Error("found lnurl key entry with no linked application")
        }
        try {
            await this.PayInvoice(key.user.user_id, { invoice: invoice, amount: 0 }, key.linkedApplication)
        } catch (err: any) {
            console.error("error sending payment for lnurl withdraw to ", key.user.user_id, err)
            throw new Error("failed to pay invoice")
        }
    }

    lnurlPayUrl(k1: string): string {
        return `${this.settings.serviceUrl}/api/guest/lnurl_pay/info?k1=${k1}`
    }

    async GetLnurlPayLink(ctx: Types.UserContext): Promise<Types.LnurlLinkResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const key = await this.storage.paymentStorage.AddUserEphemeralKey(ctx.user_id, 'pay', app)
        const lnurl = this.encodeLnurl(this.lnurlPayUrl(key.key))
        return {
            lnurl,
            k1: key.key
        }
    }

    async GetLnurlPayInfoFromUser(userId: string, linkedApplication: Application, opts: { baseUrl?: string, metadata?: string } = {}): Promise<Types.LnurlPayInfoResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const { baseUrl, metadata } = opts
        const payK1 = await this.storage.paymentStorage.AddUserEphemeralKey(userId, 'pay', linkedApplication)
        const url = baseUrl ? baseUrl : `${this.settings.serviceUrl}/api/guest/lnurl_pay/handle`
        const { remote } = await this.lnd.ChannelBalance()
        return {
            tag: 'payRequest',
            callback: `${url}?k1=${payK1.key}`,
            maxSendable: remote * 1000,
            minSendable: 10000,
            metadata: metadata ? metadata : defaultLnurlPayMetadata(this.settings.lnurlMetaText),
            allowsNostr: !!linkedApplication.nostr_public_key,
            nostrPubkey: linkedApplication.nostr_public_key || ""
        }
    }

    async GetLnurlPayInfo(payInfoK1: string): Promise<Types.LnurlPayInfoResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(payInfoK1, 'pay', true)
        if (!key.linkedApplication) {
            throw new Error("invalid lnurl request")
        }
        const { remote } = await this.lnd.ChannelBalance()
        return {
            tag: 'payRequest',
            callback: `${this.settings.serviceUrl}/api/guest/lnurl_pay/handle?k1=${payInfoK1}`,
            maxSendable: remote * 1000,
            minSendable: 10000,
            metadata: defaultLnurlPayMetadata(this.settings.lnurlMetaText),
            allowsNostr: !!key.linkedApplication.nostr_public_key,
            nostrPubkey: key.linkedApplication.nostr_public_key || ""
        }
    }

    parseTags(tag: string, tags: string[][], opts: { multiples?: boolean, required?: boolean } = {}): string[] {
        const { multiples, required } = opts
        const found = tags.filter(t => t && t.length >= 2 && t[0] === tag)
        if (found.length === 0) {
            if (required) {
                throw new Error(`missing tag for "${tag}"`)
            }
            return []
        }
        if (found.length === 1) {
            const elements = found[0]
            elements.shift()
            if (elements.length === 0) {
                throw new Error(`invalid content for "${tag}" tag`)
            }
            if (!multiples && elements.length !== 1) {
                throw new Error(`too many contents for "${tag}" tag`)

            }
            return elements
        }
        throw new Error(`too many entries for "${tag}" tag`)
    }

    validateZapEvent(event: string, amt: number): ZapInfo {
        const nostrEvent = JSON.parse(event) as Event
        delete nostrEvent[verifiedSymbol]
        const verified = verifyEvent(nostrEvent)
        if (!verified) {
            throw new Error("nostr event not valid")
        }
        if (nostrEvent.kind !== 9734) {
            throw new Error("nostr event not a zap event")
        }
        const p = this.parseTags("p", nostrEvent.tags, { required: true })
        const e = this.parseTags("e", nostrEvent.tags)
        const relays = this.parseTags("relays", nostrEvent.tags, { required: true, multiples: true })
        const amount = this.parseTags("amount", nostrEvent.tags)
        if (amount.length > 0 && +amount[0] !== amt) {
            throw new Error("amount mismatch")
        }
        return { pub: p[0], eventId: e.length > 0 ? e[0] : "", relays, description: event }
    }

    async HandleLnurlPay(ctx: Types.HandleLnurlPay_Query): Promise<Types.HandleLnurlPayResponse> {
        if (!ctx.k1 || !ctx.amount) {
            throw new Error("invalid lnurl pay to handle")
        }
        const amountMillis = +ctx.amount
        if (isNaN(amountMillis)) {
            throw new Error("invalid amount in lnurl pay to handle")
        }
        let zapInfo: ZapInfo | undefined
        if (ctx.nostr) {
            zapInfo = this.validateZapEvent(ctx.nostr, amountMillis)
        }
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(ctx.k1, 'pay', true)
        const sats = amountMillis / 1000
        if (!Number.isInteger(sats)) {
            throw new Error("millisats amount must be integer sats amount")
        }
        if (!key.linkedApplication) {
            throw new Error("cannot handle lnurl for non application user")
        }
        let log = getLogger({ appName: key.linkedApplication.name })
        if (zapInfo) {
            log("this payment is a zap")
        } else {
            log("this payment is NOT a zap", ctx)

        }
        const invoice = await this.NewInvoice(key.user.user_id, {
            amountSats: sats,
            memo: zapInfo ? zapInfo.description : defaultLnurlPayMetadata(this.settings.lnurlMetaText)
        }, { expiry: defaultInvoiceExpiry, linkedApplication: key.linkedApplication, zapInfo })
        return {
            pr: invoice.invoice,
            routes: []
        }
    }

    async HandleLnurlAddress(addressName: string): Promise<Types.LnurlPayInfoResponse> {
        const linkedUser = await this.storage.applicationStorage.FindNostrAppUser(addressName)
        if (!linkedUser) {
            throw new Error("this address is not linked to any user")
        }
        return this.GetLnurlPayInfoFromUser(linkedUser.user.user_id, linkedUser.application, { metadata: defaultLnAddressMetadata(this.settings.lnurlMetaText, addressName) })
    }

    mapOperations(operations: UserOperationInfo[], type: Types.UserOperationType, inbound: boolean): Types.UserOperations {
        if (operations.length === 0) {
            return {
                fromIndex: 0,
                toIndex: 0,
                operations: []
            }
        }
        return {
            toIndex: operations[0].serial_id,
            fromIndex: operations[operations.length - 1].serial_id,
            operations: operations.map((o: UserOperationInfo): Types.UserOperation => {
                let identifier = "";
                if (o.invoice) {
                    identifier = o.invoice
                } else if (o.address) {
                    identifier = o.address;
                } else if (o.user_address) {
                    identifier = o.user_address.address;
                } else if (type === Types.UserOperationType.INCOMING_USER_TO_USER && o.from_user) {
                    identifier = o.from_user.user_id
                } else if (type === Types.UserOperationType.OUTGOING_INVOICE && o.to_user) {
                    identifier = o.to_user.user_id
                }
                return {
                    inbound,
                    type,
                    amount: o.paid_amount,
                    paidAtUnix: o.paid_at_unix,
                    identifier,
                    operationId: `${type}-${o.serial_id}`,
                    network_fee: o.chain_fees || o.routing_fees || 0,
                    service_fee: o.service_fee || o.service_fees || 0,
                    confirmed: typeof o.confs === 'number' ? o.confs > 0 : true,
                    tx_hash: o.tx_hash || "",
                    internal: !!o.internal
                }
            })
        }
    }

    async GetPaymentState(userId: string, req: Types.GetPaymentStateRequest): Promise<Types.PaymentState> {
        const user = await this.storage.userStorage.GetUser(userId)
        if (user.locked) {
            throw new Error("user is banned, cannot retrieve payment state")
        }
        const invoice = await this.storage.paymentStorage.GetPaymentOwner(req.invoice)
        if (!invoice || invoice.user.user_id !== userId) {
            throw new Error("invoice not found")
        }
        return {
            paid_at_unix: invoice.paid_at_unix,
            amount: invoice.paid_amount,
            network_fee: invoice.routing_fees,
            service_fee: invoice.service_fees,
        }
    }

    async GetUserOperations(userId: string, req: Types.GetUserOperationsRequest): Promise<Types.GetUserOperationsResponse> {
        const user = await this.storage.userStorage.GetUser(userId)
        if (user.locked) {
            throw new Error("user is banned, cannot retrieve operations")
        }
        const [outgoingInvoices, outgoingTransactions, incomingInvoices, incomingTransactions, incomingUserToUser, outgoingUserToUser] = await Promise.all([
            this.storage.paymentStorage.GetUserInvoicePayments(userId, req.latestOutgoingInvoice, req.max_size),
            this.storage.paymentStorage.GetUserTransactionPayments(userId, req.latestOutgoingTx, req.max_size),
            this.storage.paymentStorage.GetUserInvoicesFlaggedAsPaid(userId, req.latestIncomingInvoice, req.max_size),
            this.storage.paymentStorage.GetUserReceivingTransactions(userId, req.latestIncomingTx, req.max_size),
            this.storage.paymentStorage.GetUserToUserReceivedPayments(userId, req.latestIncomingUserToUserPayment, req.max_size),
            this.storage.paymentStorage.GetUserToUserSentPayments(userId, req.latestOutgoingUserToUserPayment, req.max_size)
        ])
        return {
            latestIncomingInvoiceOperations: this.mapOperations(incomingInvoices, Types.UserOperationType.INCOMING_INVOICE, true),
            latestIncomingTxOperations: this.mapOperations(incomingTransactions, Types.UserOperationType.INCOMING_TX, true),
            latestOutgoingInvoiceOperations: this.mapOperations(outgoingInvoices, Types.UserOperationType.OUTGOING_INVOICE, false),
            latestOutgoingTxOperations: this.mapOperations(outgoingTransactions, Types.UserOperationType.OUTGOING_TX, false),
            latestIncomingUserToUserPayemnts: this.mapOperations(incomingUserToUser, Types.UserOperationType.INCOMING_USER_TO_USER, true),
            latestOutgoingUserToUserPayemnts: this.mapOperations(outgoingUserToUser, Types.UserOperationType.OUTGOING_USER_TO_USER, false)
        }
    }

    async SendUserToUserPayment(fromUserId: string, toUserId: string, amount: number, linkedApplication: Application): Promise<{ amount: number, fees: number }> {
        const payment = await this.storage.StartTransaction(async tx => {
            const fromUser = await this.storage.userStorage.GetUser(fromUserId, tx)
            const toUser = await this.storage.userStorage.GetUser(toUserId, tx)
            if (fromUser.locked || toUser.locked) {
                throw new Error("one of the users is banned, cannot send payment")
            }
            if (fromUser.balance_sats < amount) {
                throw new Error("not enough balance to send payment")
            }
            const isAppUserPayment = fromUser.user_id !== linkedApplication.owner.user_id
            let fee = this.getServiceFee(Types.UserOperationType.OUTGOING_USER_TO_USER, amount, isAppUserPayment)
            const toDecrement = amount + fee
            const paymentEntry = await this.storage.paymentStorage.AddPendingUserToUserPayment(fromUserId, toUserId, amount, fee, linkedApplication, tx)
            await this.storage.userStorage.DecrementUserBalance(fromUser.user_id, toDecrement, `${toUserId}:${paymentEntry.serial_id}`, tx)
            await this.storage.userStorage.IncrementUserBalance(toUser.user_id, amount, `${fromUserId}:${paymentEntry.serial_id}`, tx)
            await this.storage.paymentStorage.SetPendingUserToUserPaymentAsPaid(paymentEntry.serial_id, tx)
            if (isAppUserPayment && fee > 0) {
                await this.storage.userStorage.IncrementUserBalance(linkedApplication.owner.user_id, fee, 'fees', tx)
            }
            return paymentEntry
        })
        const fromUser = await this.storage.userStorage.GetUser(fromUserId)
        const toUser = await this.storage.userStorage.GetUser(toUserId)
        this.storage.eventsLog.LogEvent({ type: 'u2u_sender', userId: fromUserId, appId: linkedApplication.app_id, appUserId: "", balance: fromUser.balance_sats, data: toUserId, amount: payment.paid_amount + payment.service_fees })
        this.storage.eventsLog.LogEvent({ type: 'u2u_receiver', userId: toUserId, appId: linkedApplication.app_id, appUserId: "", balance: toUser.balance_sats, data: fromUserId, amount: amount })
        return { amount: payment.paid_amount, fees: payment.service_fees }
    }

    async CheckNewlyConfirmedTxs(height: number) {
        const pending = await this.storage.paymentStorage.GetPendingTransactions()
        let lowestHeight = height
        const map: Record<string, PendingTx> = {}

        const checkTx = (t: PendingTx) => {
            if (t.tx.broadcast_height < lowestHeight) { lowestHeight = t.tx.broadcast_height }
            map[t.tx.tx_hash] = t
        }
        pending.incoming.forEach(t => checkTx({ type: "incoming", tx: t }))
        pending.outgoing.forEach(t => checkTx({ type: "outgoing", tx: t }))
        const { transactions } = await this.lnd.GetTransactions(lowestHeight)
        const newlyConfirmedTxs = transactions.map(tx => {
            const { txHash, numConfirmations: confs, amount: amt } = tx
            const t = map[txHash]
            if (!t || confs === 0) {
                return
            }
            if (confs > 2 || (amt <= confInTwo && confs > 1) || (amt <= confInOne && confs > 0)) {
                return { ...t, confs }
            }
        })
        return newlyConfirmedTxs.filter(t => t !== undefined) as (PendingTx & { confs: number })[]
    }

    async GetLndBalance() {
        return this.lnd.GetBalance()
    }

    encodeLnurl(base: string) {
        if (!base || typeof base !== 'string') {
            throw new Error("provided string for lnurl encode is not a string or is an empty string")
        }
        let words = bech32.toWords(Buffer.from(base, 'utf8'));
        return bech32.encode('lnurl', words, 1023);
    }
}

