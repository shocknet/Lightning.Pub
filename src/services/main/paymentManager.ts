import { bech32 } from 'bech32'
import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { MainSettings } from './settings.js'
import { InboundOptionals, defaultInvoiceExpiry } from '../storage/paymentStorage.js'
import { LightningHandler } from '../lnd/index.js'
import { Application } from '../storage/entity/Application.js'
interface UserOperationInfo {
    serial_id: number
    paid_amount: number
    paid_at_unix: number
}
const logoBas64 = "data:image/png;base64,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"
const defaultLnurlPayMetadata = `[["text/plain", "lnurl pay to Lightning.pub"], ["image/png;base64",${logoBas64}]]`

export default class {

    storage: Storage
    settings: MainSettings
    lnd: LightningHandler
    constructor(storage: Storage, lnd: LightningHandler, settings: MainSettings) {
        this.storage = storage
        this.settings = settings
        this.lnd = lnd
    }
    getServiceFee(action: Types.UserOperationType, amount: number): number {
        switch (action) {
            case Types.UserOperationType.INCOMING_TX:
                return Math.ceil(this.settings.incomingTxFee * amount)
            case Types.UserOperationType.OUTGOING_TX:
                return Math.ceil(this.settings.outgoingTxFee * amount)
            case Types.UserOperationType.INCOMING_INVOICE:
                return Math.ceil(this.settings.incomingInvoiceFee * amount)
            case Types.UserOperationType.OUTGOING_INVOICE:
                return Math.ceil(this.settings.outgoingInvoiceFee * amount)
            case Types.UserOperationType.OUTGOING_USER_TO_USER || Types.UserOperationType.INCOMING_USER_TO_USER:
                return Math.ceil(this.settings.userToUserFee * amount)
            default:
                throw new Error("Unknown service action type")
        }
    }

    async SetMockInvoiceAsPaid(req: Types.SetMockInvoiceAsPaidRequest) {
        if (!this.settings.lndSettings.mockLnd) {
            throw new Error("mock disabled, cannot set invoice as paid")
        }
        await this.lnd.SetMockInvoiceAsPaid(req.invoice, req.amount)
    }

    async SetMockUserBalance(userId: string, balance: number) {
        if (!this.settings.lndSettings.mockLnd) {
            throw new Error("mock disabled, cannot set invoice as paid")
        }
        console.log("setting mock balance...")
        await this.storage.userStorage.UpdateUser(userId, { balance_sats: balance })
    }

    async NewAddress(userId: string, req: Types.NewAddressRequest): Promise<Types.NewAddressResponse> {
        const res = await this.lnd.NewAddress(req.addressType)
        const userAddress = await this.storage.paymentStorage.AddUserAddress(userId, res.address)
        return {
            address: userAddress.address
        }
    }

    async NewInvoice(userId: string, req: Types.NewInvoiceRequest, options: InboundOptionals = { expiry: defaultInvoiceExpiry }): Promise<Types.NewInvoiceResponse> {
        const user = await this.storage.userStorage.GetUser(userId)
        const res = await this.lnd.NewInvoice(req.amountSats, req.memo, options.expiry)
        const userInvoice = await this.storage.paymentStorage.AddUserInvoice(user, res.payRequest, options)
        return {
            invoice: userInvoice.invoice
        }
    }

    async lockUserWithMinBalance(userId: string, minBalance: number) {
        console.log("locking", userId)
        return this.storage.StartTransaction(async tx => {
            const user = await this.storage.userStorage.GetUser(userId, tx)
            if (user.locked) {
                throw new Error("user is already withdrawing")
            }
            if (user.balance_sats < minBalance) {
                throw new Error("insufficient balance")
            }
            // this call will fail if the user is already locked
            await this.storage.userStorage.LockUser(userId, tx)
        })
    }

    GetMaxPayableInvoice(balance: number): number {
        const maxWithinServiceFee = Math.max(0, Math.floor(balance * (1 - this.settings.outgoingInvoiceFee)))
        return this.lnd.GetMaxWithinLimit(maxWithinServiceFee)
    }
    async DecodeInvoice(req: Types.DecodeInvoiceRequest): Promise<Types.DecodeInvoiceResponse> {
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        return {
            amount: Number(decoded.numSatoshis)
        }
    }
    async PayInvoice(userId: string, req: Types.PayInvoiceRequest, linkedApplication?: Application): Promise<Types.PayInvoiceResponse> {
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        if (decoded.numSatoshis !== 0 && req.amount !== 0) {
            throw new Error("invoice has value, do not provide amount the the request")
        }
        if (decoded.numSatoshis === 0 && req.amount === 0) {
            throw new Error("invoice has no value, an amount must be provided in the request")
        }
        const payAmount = req.amount !== 0 ? req.amount : Number(decoded.numSatoshis)
        const serviceFee = this.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, payAmount)
        const totalAmountToDecrement = payAmount + serviceFee

        const routingFeeLimit = this.lnd.GetFeeLimitAmount(payAmount)
        await this.lockUserWithMinBalance(userId, totalAmountToDecrement + routingFeeLimit)
        const payment = await this.lnd.PayInvoice(req.invoice, req.amount, routingFeeLimit)
        await this.storage.userStorage.DecrementUserBalance(userId, totalAmountToDecrement + Number(payment.feeSat))
        if (linkedApplication) {
            await this.storage.userStorage.IncrementUserBalance(linkedApplication.owner.user_id, serviceFee)
        } else {
            //const appOwner = await this.storage.applicationStorage.IsApplicationOwner(userId)
        }
        await this.storage.userStorage.UnlockUser(userId)
        await this.storage.paymentStorage.AddUserInvoicePayment(userId, req.invoice, payAmount, Number(payment.feeSat), serviceFee)
        return {
            preimage: payment.paymentPreimage,
            amount_paid: Number(payment.valueSat)
        }
    }

    async PayAddress(userId: string, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> {
        const estimate = await this.lnd.EstimateChainFees(req.address, req.amoutSats, req.targetConf)
        const satPerVByte = Number(estimate.satPerVbyte)
        const chainFees = Number(estimate.feeSat)
        const total = req.amoutSats + chainFees
        const serviceFee = this.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, req.amoutSats)
        await this.lockUserWithMinBalance(userId, total + serviceFee)
        const payment = await this.lnd.PayAddress(req.address, req.amoutSats, satPerVByte)
        await this.storage.userStorage.DecrementUserBalance(userId, total + serviceFee)
        await this.storage.userStorage.UnlockUser(userId)
        await this.storage.paymentStorage.AddUserTransactionPayment(userId, req.address, payment.txid, 0, req.amoutSats, chainFees, serviceFee)
        return {
            txId: payment.txid
        }
    }

    balanceCheckUrl(k1: string): string {
        return `${this.settings.serviceUrl}/api/guest/lnurl_withdraw/info?k1=${k1}`
    }

    async GetLnurlChannelLink(userId: string): Promise<Types.LnurlLinkResponse> {
        const key = await this.storage.paymentStorage.AddUserEphemeralKey(userId, 'balanceCheck')
        return {
            lnurl: this.encodeLnurl(this.balanceCheckUrl(key.key)),
            k1: key.key
        }
    }

    async GetLnurlWithdrawInfo(balanceCheckK1: string): Promise<Types.LnurlWithdrawInfoResponse> {
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(balanceCheckK1, 'balanceCheck')
        const maxWithdrawable = this.GetMaxPayableInvoice(key.user.balance_sats)
        const callbackK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'withdraw')
        const newBalanceCheckK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'balanceCheck')
        const payInfoK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'pay')
        return {
            tag: "withdrawRequest",
            callback: `${this.settings.serviceUrl}/api/guest/lnurl_withdraw/handle`,
            defaultDescription: "lnurl withdraw from lightning.pub",
            k1: callbackK1.key,
            maxWithdrawable: maxWithdrawable * 1000,
            minWithdrawable: 0,
            balanceCheck: this.balanceCheckUrl(newBalanceCheckK1.key),
            payLink: `${this.settings.serviceUrl}/api/guest/lnurl_pay/info?k1=${payInfoK1.key}`,
        }
    }

    async HandleLnurlWithdraw(k1: string, invoice: string): Promise<void> {
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(k1, 'withdraw')
        try {
            await this.PayInvoice(key.user.user_id, { invoice: invoice, amount: 0 })
        } catch (err: any) {
            console.error("error sending payment for lnurl withdraw to ", key.user.user_id, err)
            throw new Error("failed to pay invoice")
        }
    }

    async GetLnurlPayInfoFromUser(userId: string, baseUrl?: string): Promise<Types.LnurlPayInfoResponse> {
        const payK1 = await this.storage.paymentStorage.AddUserEphemeralKey(userId, 'pay')
        const url = baseUrl ? baseUrl : `${this.settings.serviceUrl}/api/guest/lnurl_pay/handle`
        return {
            tag: 'payRequest',
            callback: `${url}?k1=${payK1.key}`,
            maxSendable: 10000000000,
            minSendable: 0,
            metadata: defaultLnurlPayMetadata
        }
    }

    async GetLnurlPayInfoFromK1(payInfoK1: string): Promise<Types.LnurlPayInfoResponse> {
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(payInfoK1, 'payInfo')
        const payK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'pay')
        return {
            tag: 'payRequest',
            callback: `${this.settings.serviceUrl}/api/guest/lnurl_pay/handle?k1=${payK1.key}`,
            maxSendable: 10000000,
            minSendable: 0,
            metadata: defaultLnurlPayMetadata
        }
    }

    async HandleLnurlPay(payK1: string, amountMillis: number): Promise<Types.HandleLnurlPayResponse> {
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(payK1, 'pay')
        const sats = amountMillis / 1000
        if (!Number.isInteger(sats)) {
            throw new Error("millisats amount must be integer sats amount")
        }
        const invoice = await this.NewInvoice(key.user.user_id, {
            amountSats: sats,
            memo: defaultLnurlPayMetadata
        })
        return {
            pr: invoice.invoice,
            routes: []
        }
    }

    async OpenChannel(userId: string, req: Types.OpenChannelRequest): Promise<Types.OpenChannelResponse> { throw new Error("WIP") }

    mapOperations(operations: UserOperationInfo[], type: Types.UserOperationType, inbound: boolean): Types.UserOperations {
        if (operations.length === 0) {
            return {
                fromIndex: 0,
                toIndex: 0,
                operations: []
            }
        }
        return {
            toIndex: operations[0].serial_id,
            fromIndex: operations[operations.length - 1].serial_id,
            operations: operations.map((o: UserOperationInfo): Types.UserOperation => ({
                inbound,
                type,
                amount: o.paid_amount,
                paidAtUnix: o.paid_at_unix
            }))
        }
    }

    async GetUserOperations(userId: string, req: Types.GetUserOperationsRequest): Promise<Types.GetUserOperationsResponse> {
        const [outgoingInvoices, outgoingTransactions, incomingInvoices, incomingTransactions, incomingUserToUser, outgoingUserToUser] = await Promise.all([
            this.storage.paymentStorage.GetUserInvoicePayments(userId, req.latestOutgoingInvoice),
            this.storage.paymentStorage.GetUserTransactionPayments(userId, req.latestOutgoingTx),
            this.storage.paymentStorage.GetUserInvoicesFlaggedAsPaid(userId, req.latestIncomingInvoice),
            this.storage.paymentStorage.GetUserReceivingTransactions(userId, req.latestIncomingTx),
            this.storage.paymentStorage.GetUserToUserReceivedPayments(userId, req.latestIncomingUserToUserPayment),
            this.storage.paymentStorage.GetUserToUserSentPayments(userId, req.latestOutgoingUserToUserPayment)
        ])
        return {
            latestIncomingInvoiceOperations: this.mapOperations(incomingInvoices, Types.UserOperationType.INCOMING_INVOICE, true),
            latestIncomingTxOperations: this.mapOperations(incomingTransactions, Types.UserOperationType.INCOMING_TX, true),
            latestOutgoingInvoiceOperations: this.mapOperations(outgoingInvoices, Types.UserOperationType.OUTGOING_INVOICE, false),
            latestOutgoingTxOperations: this.mapOperations(outgoingTransactions, Types.UserOperationType.OUTGOING_TX, false),
            latestIncomingUserToUserPayemnts: this.mapOperations(incomingUserToUser, Types.UserOperationType.INCOMING_USER_TO_USER, true),
            latestOutgoingUserToUserPayemnts: this.mapOperations(outgoingUserToUser, Types.UserOperationType.OUTGOING_USER_TO_USER, false)
        }
    }

    async SendUserToUserPayment(fromUserId: string, toUserId: string, amount: number, linkedApplication?: Application) {
        await this.storage.StartTransaction(async tx => {
            const fromUser = await this.storage.userStorage.GetUser(fromUserId, tx)
            const toUser = await this.storage.userStorage.GetUser(toUserId, tx)
            if (fromUser.balance_sats < amount) {
                throw new Error("not enough balance to send user to user payment")
            }
            const fee = this.getServiceFee(Types.UserOperationType.OUTGOING_USER_TO_USER, amount)
            const toIncrement = amount - fee
            await this.storage.userStorage.DecrementUserBalance(fromUser.user_id, amount, tx)
            await this.storage.userStorage.IncrementUserBalance(toUser.user_id, toIncrement, tx)
            await this.storage.paymentStorage.AddUserToUserPayment(fromUserId, toUserId, amount, fee)
            if (linkedApplication) {
                await this.storage.userStorage.IncrementUserBalance(linkedApplication.owner.user_id, fee)
            }
        })
    }

    encodeLnurl(base: string) {
        if (!base || typeof base !== 'string') {
            throw new Error("provided string for lnurl encode is not a string or is an empty string")
        }
        let words = bech32.toWords(Buffer.from(base, 'utf8'));
        return bech32.encode('lnurl', words, 1023);
    }
}

