import { bech32 } from 'bech32'
import crypto from 'crypto'
import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { InboundOptionals, defaultInvoiceExpiry } from '../storage/paymentStorage.js'
import LND from '../lnd/lnd.js'
import { Application } from '../storage/entity/Application.js'
import { ERROR, getLogger, PubLogger } from '../helpers/logger.js'
import { AddressPaidCb, InvoicePaidCb } from '../lnd/settings.js'
import { UserReceivingInvoice, ZapInfo } from '../storage/entity/UserReceivingInvoice.js'
import { Payment_PaymentStatus } from '../../../proto/lnd/lightning.js'
import { Event, verifiedSymbol, verifyEvent } from 'nostr-tools'
import { AddressReceivingTransaction } from '../storage/entity/AddressReceivingTransaction.js'
import { UserTransactionPayment } from '../storage/entity/UserTransactionPayment.js'
import { UserReceivingAddress } from '../storage/entity/UserReceivingAddress.js'
import { Watchdog } from './watchdog.js'
import { LiquidityManager } from './liquidityManager.js'
import { Utils } from '../helpers/utilsWrapper.js'
import { UserInvoicePayment } from '../storage/entity/UserInvoicePayment.js'
import SettingsManager from './settingsManager.js'
import { Swaps, TransactionSwapData } from '../lnd/swaps.js'
interface UserOperationInfo {
    serial_id: number
    paid_amount: number
    paid_at_unix: number
    invoice?: string
    address?: string
    from_user?: { user_id: string }
    to_user?: { user_id: string }
    service_fee?: number
    service_fees?: number
    routing_fees?: number
    chain_fees?: number
    confs?: number
    tx_hash?: string;
    user_address?: {
        address: string
    };
    internal?: boolean;
}


export type PendingTx = { type: 'incoming', tx: AddressReceivingTransaction } | { type: 'outgoing', tx: UserTransactionPayment }
const defaultLnurlPayMetadata = (text: string) => `[["text/plain", "${text}"]]`
const defaultLnAddressMetadata = (text: string, id: string) => `[["text/plain", "${text}"],["text/identifier", "${id}"]]`
const confInOne = 1000 * 1000
const confInTwo = 100 * 1000 * 1000
export default class {
    storage: Storage
    settings: SettingsManager
    lnd: LND
    addressPaidCb: AddressPaidCb
    invoicePaidCb: InvoicePaidCb
    log = getLogger({ component: "PaymentManager" })
    watchDog: Watchdog
    liquidityManager: LiquidityManager
    utils: Utils
    swaps: Swaps
    invoiceLock: InvoiceLock
    constructor(storage: Storage, lnd: LND, settings: SettingsManager, liquidityManager: LiquidityManager, utils: Utils, addressPaidCb: AddressPaidCb, invoicePaidCb: InvoicePaidCb) {
        this.storage = storage
        this.settings = settings
        this.lnd = lnd
        this.liquidityManager = liquidityManager
        this.utils = utils
        this.watchDog = new Watchdog(settings, this.liquidityManager, this.lnd, this.storage, this.utils, this.liquidityManager.rugPullTracker)
        this.swaps = new Swaps(settings)
        this.addressPaidCb = addressPaidCb
        this.invoicePaidCb = invoicePaidCb
        this.invoiceLock = new InvoiceLock()
    }


    Stop() {
        this.watchDog.Stop()
        this.swaps.Stop()
    }

    checkPaymentStatus = async () => {
        const log = getLogger({ component: 'checkPaymentStatus' })
        const pendingPayments = await this.storage.paymentStorage.GetPendingPayments()
        for (const p of pendingPayments) {
            log("checking status of payment: ", p.invoice)
            if (p.internal) {
                log("found pending internal payment", p.serial_id)
            } else if (p.liquidityProvider) {
                log("found pending liquidity provider payment", p.serial_id)
                await this.checkPendingProviderPayment(log, p)
            } else {
                log("found pending external payment", p.serial_id)
                await this.checkPendingLndPayment(log, p)
            }
        }
    }

    checkPendingProviderPayment = async (log: PubLogger, p: UserInvoicePayment) => {
        const state = await this.lnd.liquidProvider.GetPaymentState(p.invoice)
        if (state.paid_at_unix < 0) {
            const fullAmount = p.paid_amount + p.service_fees
            log("found a failed provider payment, refunding", fullAmount, "sats to user", p.user.user_id)
            await this.storage.StartTransaction(async tx => {
                await this.storage.userStorage.IncrementUserBalance(p.user.user_id, fullAmount, "payment_refund:" + p.invoice, tx)
                await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, 0, 0, false, undefined, tx)
            }, "refund failed provider payment")
            return
        } else if (state.paid_at_unix > 0) {
            log("provider payment succeeded", p.serial_id, "updating payment info")
            const serviceFee = p.service_fees
            const networkFee = state.service_fee
            await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, networkFee, serviceFee, true)
            const remainingFee = serviceFee - networkFee
            if (remainingFee < 0) {
                this.log("WARNING: provider fee was higher than expected,", remainingFee, "were lost")
            }

            if (p.linkedApplication && p.user.user_id !== p.linkedApplication.owner.user_id && remainingFee > 0) {
                await this.storage.userStorage.IncrementUserBalance(p.linkedApplication.owner.user_id, remainingFee, "fees")
            }
            const user = await this.storage.userStorage.GetUser(p.user.user_id)
            this.storage.eventsLog.LogEvent({ type: 'invoice_payment', userId: p.user.user_id, appId: p.linkedApplication?.app_id || "", appUserId: "", balance: user.balance_sats, data: p.invoice, amount: p.paid_amount })
            return
        }
        log("provider payment still pending", p.serial_id, "no action will be performed")
    }

    checkPendingLndPayment = async (log: PubLogger, p: UserInvoicePayment) => {
        // Skip LND payment checks when bypass is enabled
        if (this.liquidityManager.settings.getSettings().liquiditySettings.useOnlyLiquidityProvider) {
            log("USE_ONLY_LIQUIDITY_PROVIDER enabled, skipping LND payment check for", p.serial_id)
            return
        }
        const decoded = await this.lnd.DecodeInvoice(p.invoice)
        const payment = await this.lnd.GetPaymentFromHash(decoded.paymentHash)
        if (!payment || payment.paymentHash !== decoded.paymentHash) {
            log(ERROR, "lnd payment not found for pending payment hash ", decoded.paymentHash)
            return
        }
        switch (payment.status) {
            case Payment_PaymentStatus.UNKNOWN:
                log("pending payment in unknown state", p.serial_id, "no action will be performed")
                return
            case Payment_PaymentStatus.IN_FLIGHT:
                log("pending payment in flight", p.serial_id, "no action will be performed")
                return
            case Payment_PaymentStatus.SUCCEEDED:
                log("pending payment succeeded", p.serial_id, "updating payment info")
                const serviceFee = p.service_fees
                const networkFee = Number(payment.feeSat)

                await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, networkFee, p.service_fees, true, undefined)
                const remainingFee = serviceFee - networkFee
                if (remainingFee < 0) { // should not be possible beacuse of the fee limit
                    this.log("WARNING: lnd fee was higher than expected,", remainingFee, "were lost")
                }
                if (p.linkedApplication && p.user.user_id !== p.linkedApplication.owner.user_id && remainingFee > 0) {
                    await this.storage.userStorage.IncrementUserBalance(p.linkedApplication.owner.user_id, remainingFee, "fees")
                }
                const user = await this.storage.userStorage.GetUser(p.user.user_id)
                this.storage.eventsLog.LogEvent({ type: 'invoice_payment', userId: p.user.user_id, appId: p.linkedApplication?.app_id || "", appUserId: "", balance: user.balance_sats, data: p.invoice, amount: p.paid_amount })
                return
            case Payment_PaymentStatus.FAILED:
                const fullAmount = p.paid_amount + p.service_fees
                log("found a failed pending payment, refunding", fullAmount, "sats to user", p.user.user_id)
                await this.storage.StartTransaction(async tx => {
                    await this.storage.userStorage.IncrementUserBalance(p.user.user_id, fullAmount, "payment_refund:" + p.invoice, tx)
                    await this.storage.paymentStorage.UpdateExternalPayment(p.serial_id, 0, 0, false, undefined, tx)
                }, "refund failed pending payment")
                return
            default:
                break;
        }
    }

    checkMissedChainTxs = async () => {
        const log = getLogger({ component: 'checkMissedChainTxs' })
        
        if (this.liquidityManager.settings.getSettings().liquiditySettings.useOnlyLiquidityProvider) {
            log("USE_ONLY_LIQUIDITY_PROVIDER enabled, skipping chain tx check")
            return
        }

        try {
            const lndInfo = await this.lnd.GetInfo()
            const lndPubkey = lndInfo.identityPubkey
            
            const startHeight = await this.storage.liquidityStorage.GetLatestCheckedHeight('lnd', lndPubkey)
            log(`checking for missed confirmed chain transactions from height ${startHeight}...`)

            const { transactions } = await this.lnd.GetTransactions(startHeight)
            log(`retrieved ${transactions.length} transactions from LND`)

            const recoveredCount = await this.processMissedChainTransactions(transactions, log)

            // Update latest checked height to current block height
            const currentHeight = lndInfo.blockHeight
            await this.storage.liquidityStorage.UpdateLatestCheckedHeight('lnd', lndPubkey, currentHeight)

            if (recoveredCount > 0) {
                log(`processed ${recoveredCount} missed chain tx(s)`)
            } else {
                log("no missed chain transactions found")
            }
        } catch (err: any) {
            log(ERROR, "failed to check for missed chain transactions:", err.message || err)
        }
    }

    private async processMissedChainTransactions(transactions: any[], log: PubLogger): Promise<number> {
        let recoveredCount = 0

        for (const tx of transactions) {
            if (tx.numConfirmations === 0 || !tx.outputDetails || tx.outputDetails.length === 0) {
                continue
            }

            const outputsWithAddresses = await this.collectOutputsWithAddresses(tx.outputDetails)
            const hasUserOutputs = outputsWithAddresses.some(o => o.userAddress !== null)

            for (const { output, userAddress } of outputsWithAddresses) {
                if (!userAddress) {
                    await this.processRootAddressOutput(output, tx, hasUserOutputs, log)
                    continue
                }

                const processed = await this.processUserAddressOutput(output, tx, userAddress, log)
                if (processed) {
                    recoveredCount++
                }
            }
        }

        return recoveredCount
    }

    private async collectOutputsWithAddresses(outputDetails: any[]): Promise<Array<{ output: any, userAddress: UserReceivingAddress | null }>> {
        const outputs: Array<{ output: any, userAddress: UserReceivingAddress | null }> = []

        for (const output of outputDetails) {
            if (!output.address || !output.isOurAddress) {
                continue
            }

            const userAddress = await this.storage.paymentStorage.GetAddressOwner(output.address)
            outputs.push({ output, userAddress })
        }

        return outputs
    }

    private async processRootAddressOutput(output: any, tx: any, hasUserOutputs: boolean, log: PubLogger): Promise<void> {
        // Root outputs in transactions with user outputs are change, not new funds
        if (hasUserOutputs) {
            return
        }

        const amount = Number(output.amount)
        const outputIndex = Number(output.outputIndex)
        const rootOpId = `${output.address}:${tx.txHash}:${outputIndex}`
        
        const existingRootOp = await this.storage.dbs.FindOne('RootOperation', { 
            where: { operation_identifier: rootOpId, operation_type: "chain" } 
        })
        
        if (!existingRootOp) {
            await this.storage.metricsStorage.AddRootOperation("chain", rootOpId, amount)
        }
    }

    private async processUserAddressOutput(output: any, tx: any, userAddress: UserReceivingAddress, log: PubLogger): Promise<boolean> {
        const existingTx = await this.storage.paymentStorage.GetAddressReceivingTransactionOwner(
            output.address,
            tx.txHash
        )

        if (existingTx) {
            return false
        }

        const amount = Number(output.amount)
        const outputIndex = Number(output.outputIndex)
        log(`processing missed chain tx: address=${output.address}, txHash=${tx.txHash}, amount=${amount}, outputIndex=${outputIndex}`)

        try {
            await this.recordMissedUserTransaction(output, tx, userAddress, amount, outputIndex, log)
            return true
        } catch (err: any) {
            log(ERROR, `failed to process missed chain tx for address=${output.address}, txHash=${tx.txHash}:`, err.message || err)
            this.utils.stateBundler.AddTxPointFailed(
                'addressWasPaid',
                amount,
                { used: 'lnd', from: 'system' },
                userAddress.linkedApplication?.app_id
            )
            return false
        }
    }

    private async recordMissedUserTransaction(output: any, tx: any, userAddress: UserReceivingAddress, amount: number, outputIndex: number, log: PubLogger): Promise<void> {
        await this.storage.StartTransaction(async dbTx => {
            if (!userAddress.linkedApplication) {
                log(ERROR, "found address with no linked application during recovery:", output.address)
                return
            }

            const isManagedUser = userAddress.user.user_id !== userAddress.linkedApplication.owner.user_id
            const fee = this.getReceiveServiceFee(Types.UserOperationType.INCOMING_TX, amount, isManagedUser)
            const blockHeight = tx.blockHeight || 0

            const addedTx = await this.storage.paymentStorage.AddAddressReceivingTransaction(
                userAddress,
                tx.txHash,
                outputIndex,
                amount,
                fee,
                false,
                blockHeight,
                dbTx
            )

            const addressData = `${output.address}:${tx.txHash}`
            this.storage.eventsLog.LogEvent({
                type: 'address_paid',
                userId: userAddress.user.user_id,
                appId: userAddress.linkedApplication.app_id,
                appUserId: "",
                balance: userAddress.user.balance_sats,
                data: addressData,
                amount
            })
            
            await this.storage.userStorage.IncrementUserBalance(
                userAddress.user.user_id,
                amount - fee,
                addressData,
                dbTx
            )

            if (fee > 0) {
                await this.storage.userStorage.IncrementUserBalance(
                    userAddress.linkedApplication.owner.user_id,
                    fee,
                    'fees',
                    dbTx
                )
            }

            this.utils.stateBundler.AddTxPoint(
                'addressWasPaid',
                amount,
                { used: 'lnd', from: 'system', timeDiscount: true },
                userAddress.linkedApplication.app_id
            )

            log(`successfully processed missed chain tx: address=${output.address}, txHash=${tx.txHash}, amount=${amount}`)
        }, "process missed chain tx")
    }

    getReceiveServiceFee = (action: Types.UserOperationType, amount: number, managedUser: boolean): number => {
        switch (action) {
            case Types.UserOperationType.INCOMING_TX:
                return 0
            case Types.UserOperationType.INCOMING_INVOICE:
                // Incoming invoice fees are always 0 (not configurable)
                return 0
            case Types.UserOperationType.INCOMING_USER_TO_USER:
                if (managedUser) {
                    return Math.ceil(this.settings.getSettings().serviceFeeSettings.userToUserFee * amount)
                }
                return Math.ceil(this.settings.getSettings().serviceFeeSettings.rootToUserFee * amount)
            default:
                throw new Error("Unknown receive action type")
        }
    }

    getInvoicePaymentServiceFee = (amount: number, managedUser: boolean): number => {
        if (!managedUser) {
            return 0 // Root doesn't pay service fee to themselves
        }
        return Math.ceil(this.settings.getSettings().serviceFeeSettings.serviceFee * amount)
    }

    getSendServiceFee = (action: Types.UserOperationType, amount: number, managedUser: boolean): number => {
        switch (action) {
            case Types.UserOperationType.OUTGOING_TX:
                throw new Error("OUTGOING_TX is not a valid send service fee action")
            case Types.UserOperationType.OUTGOING_INVOICE:
                const fee = this.getInvoicePaymentServiceFee(amount, managedUser)
                // Only managed users pay the service fee floor
                if (!managedUser) {
                    return 0
                }
                return Math.max(fee, this.settings.getSettings().serviceFeeSettings.serviceFeeFloor)
            case Types.UserOperationType.OUTGOING_USER_TO_USER:
                if (managedUser) {
                    return Math.ceil(this.settings.getSettings().serviceFeeSettings.userToUserFee * amount)
                }
                return Math.ceil(this.settings.getSettings().serviceFeeSettings.rootToUserFee * amount)
            default:
                throw new Error("Unknown service action type")
        }
    }

    getRoutingFeeLimit = (amount: number): number => {
        const { routingFeeLimitBps, routingFeeFloor } = this.settings.getSettings().lndSettings
        const limit = Math.floor(amount * routingFeeLimitBps / 10000)
        return Math.max(limit, routingFeeFloor)
    }

    async SetMockInvoiceAsPaid(req: Types.SetMockInvoiceAsPaidRequest) {
        if (!this.settings.getSettings().lndSettings.mockLnd) {
            throw new Error("mock disabled, cannot set invoice as paid")
        }
        await this.lnd.SetMockInvoiceAsPaid(req.invoice, req.amount)
    }

    async SetMockUserBalance(userId: string, balance: number) {
        if (!this.settings.getSettings().lndSettings.mockLnd) {
            throw new Error("mock disabled, cannot set invoice as paid")
        }
        getLogger({})("setting mock balance...")
        await this.storage.userStorage.UpdateUser(userId, { balance_sats: balance })
    }

    async NewAddress(ctx: Types.UserContext, req: Types.NewAddressRequest): Promise<Types.NewAddressResponse> {
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const user = await this.storage.userStorage.GetUser(ctx.user_id)
        if (user.locked) {
            throw new Error("user is banned, cannot generate address")
        }
        const existingAddress = await this.storage.paymentStorage.GetExistingUserAddress(ctx.user_id, app)
        if (existingAddress) {
            return { address: existingAddress.address }
        }
        const res = await this.lnd.NewAddress(req.addressType, { useProvider: false, from: 'user' })
        const userAddress = await this.storage.paymentStorage.AddUserAddress(user, res.address, { linkedApplication: app })
        this.storage.eventsLog.LogEvent({ type: 'new_address', userId: user.user_id, appUserId: "", appId: app.app_id, balance: user.balance_sats, data: res.address, amount: 0 })
        return { address: userAddress.address }
    }

    async NewInvoice(userId: string, req: Types.NewInvoiceRequest, options: InboundOptionals = { expiry: defaultInvoiceExpiry }): Promise<Types.NewInvoiceResponse> {
        const user = await this.storage.userStorage.GetUser(userId)
        if (user.locked) {
            throw new Error("user is banned, cannot generate invoice")
        }
        const use = await this.liquidityManager.beforeInvoiceCreation(req.amountSats)
        const res = await this.lnd.NewInvoice(req.amountSats, req.memo, options.expiry, { useProvider: use === 'provider', from: 'user' }, req.blind)
        const userInvoice = await this.storage.paymentStorage.AddUserInvoice(user, res.payRequest, options, res.providerPubkey)
        const appId = options.linkedApplication ? options.linkedApplication.app_id : ""
        this.storage.eventsLog.LogEvent({ type: 'new_invoice', userId: user.user_id, appUserId: "", appId, balance: user.balance_sats, data: userInvoice.invoice, amount: req.amountSats })
        return {
            invoice: userInvoice.invoice
        }
    }

    GetFees = (): Types.CumulativeFees => {
        const { serviceFeeBps, serviceFeeFloor } = this.settings.getSettings().serviceFeeSettings
        return { serviceFeeFloor, serviceFeeBps }
    }

    GetMaxPayableInvoice(balance: number): Types.CumulativeFees & { max: number } {
        const { serviceFeeFloor, serviceFeeBps } = this.GetFees()
        const div = 1 + (serviceFeeBps / 10000)
        const maxWithoutFixed = Math.floor(balance / div)
        const fee = balance - maxWithoutFixed
        const max = balance - Math.max(fee, serviceFeeFloor)
        return { max, serviceFeeFloor, serviceFeeBps }
    }
    async DecodeInvoice(req: Types.DecodeInvoiceRequest): Promise<Types.DecodeInvoiceResponse> {
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        return {
            amount: Number(decoded.numSatoshis)
        }
    }

    async PayInvoice(userId: string, req: Types.PayInvoiceRequest, linkedApplication: Application, optionals: { swapOperationId?: string, ack?: (op: Types.UserOperation) => void } = {}): Promise<Types.PayInvoiceResponse & { operation: Types.UserOperation }> {
        await this.watchDog.PaymentRequested()
        const maybeBanned = await this.storage.userStorage.GetUser(userId)
        if (maybeBanned.locked) {
            throw new Error("user is banned, cannot send payment")
        }
        if (req.expected_fees) {
            const { serviceFeeFloor, serviceFeeBps } = req.expected_fees
            const serviceFixed = this.settings.getSettings().serviceFeeSettings.serviceFeeFloor
            const serviceBps = this.settings.getSettings().serviceFeeSettings.serviceFeeBps
            if (serviceFixed !== serviceFeeFloor || serviceBps !== serviceFeeBps) {
                throw new Error("fees do not match the expected fees")
            }
        }
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        if (decoded.numSatoshis !== 0 && req.amount !== 0) {
            throw new Error("invoice has value, do not provide amount the the request")
        }
        if (decoded.numSatoshis === 0 && req.amount === 0) {
            throw new Error("invoice has no value, an amount must be provided in the request")
        }
        const payAmount = req.amount !== 0 ? req.amount : Number(decoded.numSatoshis)
        const isManagedUser = userId !== linkedApplication.owner.user_id
        const serviceFee = this.getSendServiceFee(Types.UserOperationType.OUTGOING_INVOICE, payAmount, isManagedUser)
        const internalInvoice = await this.storage.paymentStorage.GetInvoiceOwner(req.invoice)
        if (internalInvoice && internalInvoice.paid_at_unix > 0) {
            throw new Error("this invoice was already paid")
        }
        const invoiceAlreadyPaid = await this.storage.paymentStorage.GetPaymentOwner(req.invoice)
        if (invoiceAlreadyPaid && invoiceAlreadyPaid.paid_at_unix > 0) {
            throw new Error("this invoice was already paid")
        }
        let paymentInfo = { preimage: "", amtPaid: 0, networkFee: 0, serialId: 0 }
        if (this.invoiceLock.isLocked(req.invoice)) {
            throw new Error("this invoice is already being paid")
        }
        this.invoiceLock.lock(req.invoice)
        try {
            if (internalInvoice) {
                paymentInfo = await this.PayInternalInvoice(userId, internalInvoice, { payAmount, serviceFee }, linkedApplication, req.debit_npub)
            } else {
                paymentInfo = await this.PayExternalInvoice(userId, req.invoice, { payAmount, serviceFee, amountForLnd: req.amount }, linkedApplication, { ...optionals, debitNpub: req.debit_npub })
            }
            this.invoiceLock.unlock(req.invoice)
        } catch (err) {
            this.invoiceLock.unlock(req.invoice)
            throw err
        }
        const feeDiff = serviceFee - paymentInfo.networkFee
        if (isManagedUser && feeDiff > 0) {
            await this.storage.userStorage.IncrementUserBalance(linkedApplication.owner.user_id, feeDiff, "fees")
        }
        const user = await this.storage.userStorage.GetUser(userId)
        this.storage.eventsLog.LogEvent({ type: 'invoice_payment', userId, appId: linkedApplication.app_id, appUserId: "", balance: user.balance_sats, data: req.invoice, amount: payAmount })
        const opId = `${Types.UserOperationType.OUTGOING_INVOICE}-${paymentInfo.serialId}`
        const operation = this.newInvoicePaymentOperation({ invoice: req.invoice, opId, amount: paymentInfo.amtPaid, networkFee: paymentInfo.networkFee, serviceFee: serviceFee, confirmed: true, paidAtUnix: Math.floor(Date.now() / 1000) })
        return {
            preimage: paymentInfo.preimage,
            amount_paid: paymentInfo.amtPaid,
            operation_id: opId,
            network_fee: 0,
            service_fee: serviceFee,
            latest_balance: user.balance_sats,
            operation
        }
    }

    async PayExternalInvoice(userId: string, invoice: string, amounts: { payAmount: number, serviceFee: number, amountForLnd: number }, linkedApplication: Application, optionals: { debitNpub?: string, swapOperationId?: string, ack?: (op: Types.UserOperation) => void } = {}) {

        if (this.settings.getSettings().serviceSettings.disableExternalPayments) {
            throw new Error("something went wrong sending payment, please try again later")
        }
        const existingPendingPayment = await this.storage.paymentStorage.GetPaymentOwner(invoice)
        if (existingPendingPayment) {
            if (existingPendingPayment.paid_at_unix > 0) {
                throw new Error("this invoice was already paid")
            } else if (existingPendingPayment.paid_at_unix < 0) {
                throw new Error("this invoice was already paid and failed, try another invoice")
            }
            throw new Error("payment already in progress")
        }

        const { amountForLnd, payAmount, serviceFee } = amounts
        const totalAmountToDecrement = payAmount + serviceFee
        const routingFeeLimit = this.getRoutingFeeLimit(payAmount)
        const use = await this.liquidityManager.beforeOutInvoicePayment(payAmount, serviceFee)
        const provider = use === 'provider' ? this.lnd.liquidProvider.GetProviderPubkey() : undefined
        const pendingPayment = await this.storage.StartTransaction(async tx => {
            await this.storage.userStorage.DecrementUserBalance(userId, totalAmountToDecrement, invoice, tx)
            return await this.storage.paymentStorage.AddPendingExternalPayment(userId, invoice, { payAmount, serviceFee, networkFee: 0 }, linkedApplication, provider, tx, optionals)
        }, "payment started")
        this.log("ready to pay")
        const opId = `${Types.UserOperationType.OUTGOING_INVOICE}-${pendingPayment.serial_id}`
        const op = this.newInvoicePaymentOperation({ invoice, opId, amount: payAmount, networkFee: 0, serviceFee: serviceFee, confirmed: false, paidAtUnix: 0 })
        optionals.ack?.(op)
        try {
            const payment = await this.lnd.PayInvoice(invoice, amountForLnd, { routingFeeLimit, serviceFee }, payAmount, { useProvider: use === 'provider', from: 'user' }, index => {
                this.storage.paymentStorage.SetExternalPaymentIndex(pendingPayment.serial_id, index)
            })
            await this.storage.paymentStorage.UpdateExternalPayment(pendingPayment.serial_id, payment.feeSat, serviceFee, true, payment.providerPubkey)
            const feeDiff = serviceFee - payment.feeSat
            if (feeDiff < 0) { // should not happen to lnd beacuse of the fee limit, culd happen to provider if the fee used to calculate the provider fee are out of date
                this.log("WARNING: network fee was higher than expected,", feeDiff, "were lost by", use === 'provider' ? "provider" : "lnd")
            }
            return { preimage: payment.paymentPreimage, amtPaid: payment.valueSat, networkFee: payment.feeSat, serialId: pendingPayment.serial_id }

        } catch (err) {
            await this.storage.userStorage.IncrementUserBalance(userId, totalAmountToDecrement, "payment_refund:" + invoice)
            await this.storage.paymentStorage.UpdateExternalPayment(pendingPayment.serial_id, 0, 0, false)
            throw err
        }
    }

    async PayInternalInvoice(userId: string, internalInvoice: UserReceivingInvoice, amounts: { payAmount: number, serviceFee: number }, linkedApplication: Application, debitNpub?: string) {
        if (internalInvoice.paid_at_unix > 0) {
            throw new Error("this invoice was already paid")
        }
        const { payAmount, serviceFee } = amounts
        const totalAmountToDecrement = payAmount + serviceFee
        await this.storage.userStorage.DecrementUserBalance(userId, totalAmountToDecrement, internalInvoice.invoice)
        try {
            await this.invoicePaidCb(internalInvoice.invoice, payAmount, 'internal')
            const newPayment = await this.storage.paymentStorage.AddInternalPayment(userId, internalInvoice.invoice, payAmount, serviceFee, linkedApplication, debitNpub)
            this.utils.stateBundler.AddTxPoint('paidAnInvoice', payAmount, { used: 'internal', from: 'user' }, linkedApplication.app_id)
            return { preimage: "", amtPaid: payAmount, networkFee: 0, serialId: newPayment.serial_id }
        } catch (err) {
            await this.storage.userStorage.IncrementUserBalance(userId, totalAmountToDecrement, "internal_payment_refund:" + internalInvoice.invoice)
            this.utils.stateBundler.AddTxPointFailed('paidAnInvoice', payAmount, { used: 'internal', from: 'user' }, linkedApplication.app_id)
            throw err
        }
    }

    async GetTransactionSwapQuote(ctx: Types.UserContext, req: Types.TransactionSwapRequest): Promise<Types.TransactionSwapQuote> {
        const feesRes = await this.swaps.reverseSwaps.GetFees()
        if (!feesRes.ok) {
            throw new Error(feesRes.error)
        }
        const { claim, lockup } = feesRes.fees.minerFees
        const minerFee = claim + lockup
        const chainTotal = req.transaction_amount_sats + minerFee
        const res = await this.swaps.reverseSwaps.SwapTransaction(chainTotal)
        if (!res.ok) {
            throw new Error(res.error)
        }
        const decoded = await this.lnd.DecodeInvoice(res.createdResponse.invoice)
        const swapFee = decoded.numSatoshis - chainTotal
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const isManagedUser = ctx.user_id !== app.owner.user_id
        const serviceFee = this.getSendServiceFee(Types.UserOperationType.OUTGOING_INVOICE, decoded.numSatoshis, isManagedUser)
        const newSwap = await this.storage.paymentStorage.AddTransactionSwap({
            app_user_id: ctx.app_user_id,
            swap_quote_id: res.createdResponse.id,
            swap_tree: JSON.stringify(res.createdResponse.swapTree),
            lockup_address: res.createdResponse.lockupAddress,
            refund_public_key: res.createdResponse.refundPublicKey,
            timeout_block_height: res.createdResponse.timeoutBlockHeight,
            invoice: res.createdResponse.invoice,
            invoice_amount: decoded.numSatoshis,
            transaction_amount: chainTotal,
            swap_fee_sats: swapFee,
            chain_fee_sats: minerFee,
            preimage: res.preimage,
            ephemeral_private_key: res.privKey,
            ephemeral_public_key: res.pubkey,
        })
        return {
            swap_operation_id: newSwap.swap_operation_id,
            swap_fee_sats: swapFee,
            invoice_amount_sats: decoded.numSatoshis,
            transaction_amount_sats: req.transaction_amount_sats,
            chain_fee_sats: minerFee,
            service_fee_sats: serviceFee,
        }
    }






    async PayAddress(ctx: Types.UserContext, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> {
        await this.watchDog.PaymentRequested()
        this.log("paying address", req.address, "for user", ctx.user_id, "with amount", req.amoutSats)
        const maybeBanned = await this.storage.userStorage.GetUser(ctx.user_id)
        if (maybeBanned.locked) {
            throw new Error("user is banned, cannot send chain tx")
        }
        const internalAddress = await this.storage.paymentStorage.GetAddressOwner(req.address)
        if (internalAddress) {
            return this.PayInternalAddress(ctx, req)
        }
        return this.PayAddressWithSwap(ctx, req)
    }

    async PayAddressWithSwap(ctx: Types.UserContext, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> {
        this.log("paying external address")
        if (!req.swap_operation_id) {
            throw new Error("request a swap quote before paying an external address")
        }
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const txSwap = await this.storage.paymentStorage.GetTransactionSwap(req.swap_operation_id, ctx.app_user_id)
        if (!txSwap) {
            throw new Error("swap quote not found")
        }
        const info = await this.lnd.GetInfo()
        if (info.blockHeight >= txSwap.timeout_block_height) {
            throw new Error("swap timeout")
        }
        const keys = this.swaps.GetKeys(txSwap.ephemeral_private_key)
        const data: TransactionSwapData = {
            createdResponse: {
                id: txSwap.swap_quote_id,
                invoice: txSwap.invoice,
                lockupAddress: txSwap.lockup_address,
                refundPublicKey: txSwap.refund_public_key,
                swapTree: txSwap.swap_tree,
                timeoutBlockHeight: txSwap.timeout_block_height,
                onchainAmount: txSwap.transaction_amount,
            },
            info: {
                destinationAddress: req.address,
                keys,
                chainFee: txSwap.chain_fee_sats,
                preimage: Buffer.from(txSwap.preimage, 'hex'),
            }
        }
        let swapResult = { ok: false, error: "swap never completed" } as { ok: true, txId: string } | { ok: false, error: string }
        this.swaps.reverseSwaps.SubscribeToTransactionSwap(data, result => {
            swapResult = result
        })
        let payment: Types.PayInvoiceResponse
        try {
            payment = await this.PayInvoice(ctx.user_id, {
                amount: 0,
                invoice: txSwap.invoice
            }, app, { swapOperationId: req.swap_operation_id })
            if (!swapResult.ok) {
                this.log("invoice payment successful, but swap failed")
                await this.storage.paymentStorage.FailTransactionSwap(req.swap_operation_id, req.address, swapResult.error)
                throw new Error(swapResult.error)
            }
            this.log("swap completed successfully")
            await this.storage.paymentStorage.FinalizeTransactionSwap(req.swap_operation_id, req.address, swapResult.txId)
        } catch (err: any) {
            if (swapResult.ok) {
                this.log("failed to pay swap invoice, but swap completed successfully", swapResult.txId)
                await this.storage.paymentStorage.FailTransactionSwap(req.swap_operation_id, req.address, err.message)
            } else {
                this.log("failed to pay swap invoice and swap failed", swapResult.error)
                await this.storage.paymentStorage.FailTransactionSwap(req.swap_operation_id, req.address, swapResult.error)
            }
            throw err
        }
        const networkFeesTotal = txSwap.chain_fee_sats + txSwap.swap_fee_sats // + payment.network_fee
        return {
            txId: swapResult.txId,
            network_fee: networkFeesTotal,
            service_fee: payment.service_fee,
            operation_id: payment.operation_id,
        }
    }

    async PayInternalAddress(ctx: Types.UserContext, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> {
        this.log("paying internal address")
        if (req.swap_operation_id) {
            await this.storage.paymentStorage.DeleteTransactionSwap(req.swap_operation_id)
        }
        const { blockHeight } = await this.lnd.GetInfo()
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const isManagedUser = ctx.user_id !== app.owner.user_id
        const serviceFee = this.getSendServiceFee(Types.UserOperationType.OUTGOING_USER_TO_USER, req.amoutSats, isManagedUser)

        const txId = crypto.randomBytes(32).toString("hex")
        const addressData = `${req.address}:${txId}`
        await this.storage.userStorage.DecrementUserBalance(ctx.user_id, req.amoutSats + serviceFee, addressData)
        this.addressPaidCb({ hash: txId, index: 0 }, req.address, req.amoutSats, 'internal')
        if (isManagedUser && serviceFee > 0) {
            await this.storage.userStorage.IncrementUserBalance(app.owner.user_id, serviceFee, 'fees')
        }
        const chainFees = 0
        const internalAddress = true
        const newTx = await this.storage.paymentStorage.AddUserTransactionPayment(ctx.user_id, req.address, txId, 0, req.amoutSats, chainFees, serviceFee, internalAddress, blockHeight, app)
        const user = await this.storage.userStorage.GetUser(ctx.user_id)
        const txData = `${newTx.address}:${newTx.tx_hash}`
        this.storage.eventsLog.LogEvent({ type: 'address_payment', userId: ctx.user_id, appId: app.app_id, appUserId: "", balance: user.balance_sats, data: txData, amount: req.amoutSats })
        return {
            txId: txId,
            operation_id: `${Types.UserOperationType.OUTGOING_TX}-${newTx.serial_id}`,
            network_fee: chainFees,
            service_fee: serviceFee
        }
    }

    async ListSwaps(ctx: Types.UserContext): Promise<Types.SwapsList> {
        const swaps = await this.storage.paymentStorage.ListCompletedSwaps(ctx.app_user_id)
        const pendingSwaps = await this.storage.paymentStorage.ListPendingTransactionSwaps(ctx.app_user_id)
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const isManagedUser = ctx.user_id !== app.owner.user_id
        return {
            swaps: swaps.map(s => {
                const p = s.payment
                const opId = `${Types.UserOperationType.OUTGOING_TX}-${p?.serial_id}`
                const op = p ? this.newInvoicePaymentOperation({ amount: p.paid_amount, confirmed: p.paid_at_unix !== 0, invoice: p.invoice, opId, networkFee: p.routing_fees, serviceFee: p.service_fees, paidAtUnix: p.paid_at_unix }) : undefined
                return {
                    operation_payment: op,
                    swap_operation_id: s.swap.swap_operation_id,
                    address_paid: s.swap.address_paid,
                    failure_reason: s.swap.failure_reason,
                }
            }),
            quotes: pendingSwaps.map(s => {
                const serviceFee = this.getSendServiceFee(Types.UserOperationType.OUTGOING_INVOICE, s.invoice_amount, isManagedUser)
                return {
                    swap_operation_id: s.swap_operation_id,
                    invoice_amount_sats: s.invoice_amount,
                    transaction_amount_sats: s.transaction_amount,
                    chain_fee_sats: s.chain_fee_sats,
                    service_fee_sats: serviceFee,
                    swap_fee_sats: s.swap_fee_sats,
                }
            })
        }
    }

    balanceCheckUrl(k1: string): string {
        return `${this.settings.getSettings().serviceSettings.serviceUrl}/api/guest/lnurl_withdraw/info?k1=${k1}`
    }

    isDefaultServiceUrl(): boolean {
        if (
            this.settings.getSettings().serviceSettings.serviceUrl.includes("localhost")
            ||
            this.settings.getSettings().serviceSettings.serviceUrl.includes("127.0.0.1")
        ) {
            return true
        }
        return false;
    }

    async GetLnurlWithdrawLink(ctx: Types.UserContext): Promise<Types.LnurlLinkResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const key = await this.storage.paymentStorage.AddUserEphemeralKey(ctx.user_id, 'balanceCheck', app)
        return {
            lnurl: this.encodeLnurl(this.balanceCheckUrl(key.key)),
            k1: key.key
        }
    }

    async GetLnurlWithdrawInfo(balanceCheckK1: string): Promise<Types.LnurlWithdrawInfoResponse> {
        throw new Error("LNURL withdraw currenlty not supported for non application users")
        /*const key = await this.storage.paymentStorage.UseUserEphemeralKey(balanceCheckK1, 'balanceCheck')
        const maxWithdrawable = this.GetMaxPayableInvoice(key.user.balance_sats)
        const callbackK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'withdraw')
        const newBalanceCheckK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'balanceCheck')
        const payInfoK1 = await this.storage.paymentStorage.AddUserEphemeralKey(key.user.user_id, 'pay')
        return {
            tag: "withdrawRequest",
            callback: `${this.settings.serviceUrl}/api/guest/lnurl_withdraw/handle`,
            defaultDescription: "lnurl withdraw from lightning.pub",
            k1: callbackK1.key,
            maxWithdrawable: maxWithdrawable * 1000,
            minWithdrawable: 10000,
            balanceCheck: this.balanceCheckUrl(newBalanceCheckK1.key),
            payLink: `${this.settings.serviceUrl}/api/guest/lnurl_pay/info?k1=${payInfoK1.key}`,
        }*/
    }

    async HandleLnurlWithdraw(k1: string, invoice: string): Promise<void> {
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(k1, 'withdraw')
        if (!key.linkedApplication) {
            throw new Error("found lnurl key entry with no linked application")
        }
        try {
            await this.PayInvoice(key.user.user_id, { invoice: invoice, amount: 0 }, key.linkedApplication)
        } catch (err: any) {
            console.error("error sending payment for lnurl withdraw to ", key.user.user_id, err)
            throw new Error("failed to pay invoice")
        }
    }

    lnurlPayUrl(k1: string): string {
        return `${this.settings.getSettings().serviceSettings.serviceUrl}/api/guest/lnurl_pay/info?k1=${k1}`
    }

    async GetLnurlPayLink(ctx: Types.UserContext): Promise<Types.LnurlLinkResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const key = await this.storage.paymentStorage.AddUserEphemeralKey(ctx.user_id, 'pay', app)
        const lnurl = this.encodeLnurl(this.lnurlPayUrl(key.key))
        return {
            lnurl,
            k1: key.key
        }
    }

    async GetLnurlPayInfoFromUser(userId: string, linkedApplication: Application, opts: { baseUrl?: string, metadata?: string } = {}): Promise<Types.LnurlPayInfoResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const { baseUrl, metadata } = opts
        const payK1 = await this.storage.paymentStorage.AddUserEphemeralKey(userId, 'pay', linkedApplication)
        const url = baseUrl ? baseUrl : `${this.settings.getSettings().serviceSettings.serviceUrl}/api/guest/lnurl_pay/handle`
        const { remote } = await this.lnd.ChannelBalance()
        let maxSendable = remote * 1000
        if (remote === 0 && (await this.liquidityManager.liquidityProvider.IsReady())) {
            maxSendable = 10_000_000 * 1000
        }
        return {
            tag: 'payRequest',
            callback: `${url}?k1=${payK1.key}`,
            maxSendable: maxSendable,
            minSendable: 10000,
            metadata: metadata ? metadata : defaultLnurlPayMetadata(this.settings.getSettings().serviceSettings.lnurlMetaText),
            allowsNostr: !!linkedApplication.nostr_public_key,
            nostrPubkey: linkedApplication.nostr_public_key || ""
        }
    }

    async GetLnurlPayInfo(payInfoK1: string): Promise<Types.LnurlPayInfoResponse> {
        if (this.isDefaultServiceUrl()) {
            throw new Error("Lnurl not enabled. Make sure to set SERVICE_URL env variable")
        }
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(payInfoK1, 'pay', true)
        if (!key.linkedApplication) {
            throw new Error("invalid lnurl request")
        }
        const { remote } = await this.lnd.ChannelBalance()
        let maxSendable = remote * 1000
        if (remote === 0 && (await this.liquidityManager.liquidityProvider.IsReady())) {
            maxSendable = 10_000_000 * 1000
        }
        return {
            tag: 'payRequest',
            callback: `${this.settings.getSettings().serviceSettings.serviceUrl}/api/guest/lnurl_pay/handle?k1=${payInfoK1}`,
            maxSendable: maxSendable,
            minSendable: 10000,
            metadata: defaultLnurlPayMetadata(this.settings.getSettings().serviceSettings.lnurlMetaText),
            allowsNostr: !!key.linkedApplication.nostr_public_key,
            nostrPubkey: key.linkedApplication.nostr_public_key || ""
        }
    }

    parseTags(tag: string, tags: string[][], opts: { multiples?: boolean, required?: boolean } = {}): string[] {
        const { multiples, required } = opts
        const found = tags.filter(t => t && t.length >= 2 && t[0] === tag)
        if (found.length === 0) {
            if (required) {
                throw new Error(`missing tag for "${tag}"`)
            }
            return []
        }
        if (found.length === 1) {
            const elements = found[0]
            elements.shift()
            if (elements.length === 0) {
                throw new Error(`invalid content for "${tag}" tag`)
            }
            if (!multiples && elements.length !== 1) {
                throw new Error(`too many contents for "${tag}" tag`)

            }
            return elements
        }
        throw new Error(`too many entries for "${tag}" tag`)
    }

    validateZapEvent(event: string, amt: number): ZapInfo {
        const nostrEvent = JSON.parse(event) as Event
        delete nostrEvent[verifiedSymbol]
        const verified = verifyEvent(nostrEvent)
        if (!verified) {
            throw new Error("nostr event not valid")
        }
        if (nostrEvent.kind !== 9734) {
            throw new Error("nostr event not a zap event")
        }
        const p = this.parseTags("p", nostrEvent.tags, { required: true })
        const e = this.parseTags("e", nostrEvent.tags)
        const relays = this.parseTags("relays", nostrEvent.tags, { required: true, multiples: true })
        const amount = this.parseTags("amount", nostrEvent.tags)
        if (amount.length > 0 && +amount[0] !== amt) {
            throw new Error("amount mismatch")
        }
        return { pub: p[0], eventId: e.length > 0 ? e[0] : "", relays, description: event }
    }

    async HandleLnurlPay(ctx: Types.HandleLnurlPay_Query): Promise<Types.HandleLnurlPayResponse> {
        if (!ctx.k1 || !ctx.amount) {
            throw new Error("invalid lnurl pay to handle")
        }
        const amountMillis = +ctx.amount
        if (isNaN(amountMillis)) {
            throw new Error("invalid amount in lnurl pay to handle")
        }
        let zapInfo: ZapInfo | undefined
        if (ctx.nostr) {
            zapInfo = this.validateZapEvent(ctx.nostr, amountMillis)
        }
        const key = await this.storage.paymentStorage.UseUserEphemeralKey(ctx.k1, 'pay', true)
        const sats = amountMillis / 1000
        if (!Number.isInteger(sats)) {
            throw new Error("millisats amount must be integer sats amount")
        }
        if (!key.linkedApplication) {
            throw new Error("cannot handle lnurl for non application user")
        }
        let log = getLogger({ appName: key.linkedApplication.name })
        if (zapInfo) {
            log("this payment is a zap")
        } else {
            log("this payment is NOT a zap", ctx)

        }
        const invoice = await this.NewInvoice(key.user.user_id, {
            amountSats: sats,
            memo: zapInfo ? zapInfo.description : defaultLnurlPayMetadata(this.settings.getSettings().serviceSettings.lnurlMetaText)
        }, { expiry: defaultInvoiceExpiry, linkedApplication: key.linkedApplication, zapInfo })
        return {
            pr: invoice.invoice,
            routes: []
        }
    }

    async HandleLnurlAddress(addressName: string): Promise<Types.LnurlPayInfoResponse> {
        const linkedUser = await this.storage.applicationStorage.FindNostrAppUser(addressName)
        if (!linkedUser) {
            throw new Error("this address is not linked to any user")
        }
        return this.GetLnurlPayInfoFromUser(linkedUser.user.user_id, linkedUser.application, {
            metadata: defaultLnAddressMetadata(this.settings.getSettings().serviceSettings.lnurlMetaText, addressName)
        })
    }

    mapOperations(operations: UserOperationInfo[], type: Types.UserOperationType, inbound: boolean): Types.UserOperations {
        if (operations.length === 0) {
            return {
                fromIndex: { ts: 0, id: 0 },
                toIndex: { ts: 0, id: 0 },
                operations: []
            }
        }
        return {
            // We fetch in ascending order
            toIndex: { ts: operations.at(-1)!.paid_at_unix, id: operations.at(-1)!.serial_id },
            fromIndex: { ts: operations[0].paid_at_unix, id: operations[0]!.serial_id },
            operations: operations.map((o: UserOperationInfo): Types.UserOperation => {
                let identifier = "";
                if (o.invoice) {
                    identifier = o.invoice
                } else if (o.address) {
                    identifier = o.address;
                } else if (o.user_address) {
                    identifier = o.user_address.address;
                } else if (type === Types.UserOperationType.INCOMING_USER_TO_USER && o.from_user) {
                    identifier = o.from_user.user_id
                } else if (type === Types.UserOperationType.OUTGOING_INVOICE && o.to_user) {
                    identifier = o.to_user.user_id
                }
                return {
                    inbound,
                    type,
                    amount: o.paid_amount,
                    paidAtUnix: o.paid_at_unix,
                    identifier,
                    operationId: `${type}-${o.serial_id}`,
                    network_fee: o.chain_fees || o.routing_fees || 0,
                    service_fee: o.service_fee || o.service_fees || 0,
                    confirmed: typeof o.confs === 'number' ? o.confs > 0 : true,
                    tx_hash: o.tx_hash || "",
                    internal: !!o.internal
                }
            })
        }
    }

    newInvoicePaymentOperation = (opInfo: { invoice: string, opId: string, amount: number, networkFee: number, serviceFee: number, confirmed: boolean, paidAtUnix: number }): Types.UserOperation => {
        const { invoice, opId, amount, networkFee, serviceFee, confirmed, paidAtUnix } = opInfo
        return {
            amount: amount,
            paidAtUnix: paidAtUnix,
            inbound: false,
            type: Types.UserOperationType.OUTGOING_INVOICE,
            identifier: invoice,
            operationId: opId,
            network_fee: networkFee,
            service_fee: serviceFee,
            confirmed,
            tx_hash: "",
            internal: networkFee === 0
        }
    }

    async GetPaymentState(userId: string, req: Types.GetPaymentStateRequest): Promise<Types.PaymentState> {
        const user = await this.storage.userStorage.GetUser(userId)
        if (user.locked) {
            throw new Error("user is banned, cannot retrieve payment state")
        }
        const invoice = await this.storage.paymentStorage.GetPaymentOwner(req.invoice)
        if (!invoice || invoice.user.user_id !== userId) {
            throw new Error("invoice not found")
        }
        return {
            paid_at_unix: invoice.paid_at_unix,
            amount: invoice.paid_amount,
            network_fee: 0,
            service_fee: invoice.service_fees,
        }
    }

    async GetUserOperations(userId: string, req: Types.GetUserOperationsRequest): Promise<Types.GetUserOperationsResponse> {
        const user = await this.storage.userStorage.GetUser(userId)
        if (user.locked) {
            throw new Error("user is banned, cannot retrieve operations")
        }
        const [outgoingInvoices, outgoingTransactions, incomingInvoices, incomingTransactions, incomingUserToUser, outgoingUserToUser] = await Promise.all([
            this.storage.paymentStorage.GetUserInvoicePayments(userId, req.latestOutgoingInvoice.id, req.max_size), //
            this.storage.paymentStorage.GetUserTransactionPayments(userId, req.latestOutgoingTx.id, req.max_size),
            this.storage.paymentStorage.GetUserInvoicesFlaggedAsPaid(user.serial_id, req.latestIncomingInvoice.id, req.latestIncomingInvoice.ts, req.max_size),
            this.storage.paymentStorage.GetUserReceivingTransactions(userId, req.latestIncomingTx.id, req.max_size),
            this.storage.paymentStorage.GetUserToUserReceivedPayments(userId, req.latestIncomingUserToUserPayment.id, req.max_size),
            this.storage.paymentStorage.GetUserToUserSentPayments(userId, req.latestOutgoingUserToUserPayment.id, req.max_size)
        ])
        return {
            latestIncomingInvoiceOperations: this.mapOperations(incomingInvoices, Types.UserOperationType.INCOMING_INVOICE, true),
            latestIncomingTxOperations: this.mapOperations(incomingTransactions, Types.UserOperationType.INCOMING_TX, true),
            latestOutgoingInvoiceOperations: this.mapOperations(outgoingInvoices, Types.UserOperationType.OUTGOING_INVOICE, false),
            latestOutgoingTxOperations: this.mapOperations(outgoingTransactions, Types.UserOperationType.OUTGOING_TX, false),
            latestIncomingUserToUserPayemnts: this.mapOperations(incomingUserToUser, Types.UserOperationType.INCOMING_USER_TO_USER, true),
            latestOutgoingUserToUserPayemnts: this.mapOperations(outgoingUserToUser, Types.UserOperationType.OUTGOING_USER_TO_USER, false)
        }
    }

    async SendUserToUserPayment(fromUserId: string, toUserId: string, amount: number, linkedApplication: Application): Promise<{ amount: number, fees: number }> {
        const payment = await this.storage.StartTransaction(async tx => {
            const fromUser = await this.storage.userStorage.GetUser(fromUserId, tx)
            const toUser = await this.storage.userStorage.GetUser(toUserId, tx)
            if (fromUser.locked || toUser.locked) {
                throw new Error("one of the users is banned, cannot send payment")
            }
            if (fromUser.balance_sats < amount) {
                throw new Error("not enough balance to send payment")
            }
            const isManagedUser = fromUser.user_id !== linkedApplication.owner.user_id
            let fee = this.getSendServiceFee(Types.UserOperationType.OUTGOING_USER_TO_USER, amount, isManagedUser)
            const toDecrement = amount + fee
            const paymentEntry = await this.storage.paymentStorage.AddPendingUserToUserPayment(fromUserId, toUserId, amount, fee, linkedApplication, tx)
            await this.storage.userStorage.DecrementUserBalance(fromUser.user_id, toDecrement, `${toUserId}:${paymentEntry.serial_id}`, tx)
            await this.storage.userStorage.IncrementUserBalance(toUser.user_id, amount, `${fromUserId}:${paymentEntry.serial_id}`, tx)
            await this.storage.paymentStorage.SetPendingUserToUserPaymentAsPaid(paymentEntry.serial_id, tx)
            if (isManagedUser && fee > 0) {
                await this.storage.userStorage.IncrementUserBalance(linkedApplication.owner.user_id, fee, 'fees', tx)
            }
            return paymentEntry
        })
        const fromUser = await this.storage.userStorage.GetUser(fromUserId)
        const toUser = await this.storage.userStorage.GetUser(toUserId)
        this.storage.eventsLog.LogEvent({ type: 'u2u_sender', userId: fromUserId, appId: linkedApplication.app_id, appUserId: "", balance: fromUser.balance_sats, data: toUserId, amount: payment.paid_amount + payment.service_fees })
        this.storage.eventsLog.LogEvent({ type: 'u2u_receiver', userId: toUserId, appId: linkedApplication.app_id, appUserId: "", balance: toUser.balance_sats, data: fromUserId, amount: amount })
        return { amount: payment.paid_amount, fees: payment.service_fees }
    }

    async CheckNewlyConfirmedTxs(height: number) {
        const pending = await this.storage.paymentStorage.GetPendingTransactions()
        let lowestHeight = height
        const map: Record<string, PendingTx> = {}

        const checkTx = (t: PendingTx) => {
            if (t.tx.broadcast_height < lowestHeight) { lowestHeight = t.tx.broadcast_height }
            map[t.tx.tx_hash] = t
        }
        pending.incoming.forEach(t => checkTx({ type: "incoming", tx: t }))
        pending.outgoing.forEach(t => checkTx({ type: "outgoing", tx: t }))
        const { transactions } = await this.lnd.GetTransactions(lowestHeight)
        const newlyConfirmedTxs = transactions.map(tx => {
            const { txHash, numConfirmations: confs, amount: amt } = tx
            const t = map[txHash]
            if (!t || confs === 0) {
                return
            }
            if (confs > 2 || (amt <= confInTwo && confs > 1) || (amt <= confInOne && confs > 0)) {
                return { ...t, confs }
            }
        })
        return newlyConfirmedTxs.filter(t => t !== undefined) as (PendingTx & { confs: number })[]
    }

    async CleanupOldUnpaidInvoices() {
        this.log("Cleaning up old unpaid invoices")
        const affected = await this.storage.paymentStorage.RemoveOldUnpaidInvoices()
        this.log("Cleaned up", affected, "old unpaid invoices")
    }

    async GetLndBalance() {
        return this.lnd.GetBalance()
    }

    encodeLnurl(base: string) {
        if (!base || typeof base !== 'string') {
            throw new Error("provided string for lnurl encode is not a string or is an empty string")
        }
        let words = bech32.toWords(Buffer.from(base, 'utf8'));
        return bech32.encode('lnurl', words, 1023);
    }
}


class InvoiceLock {
    locked: Record<string, boolean> = {}
    lock(invoice: string) {
        this.locked[invoice] = true
    }
    unlock(invoice: string) {
        delete this.locked[invoice]
    }
    isLocked(invoice: string) {
        return this.locked[invoice]
    }
}