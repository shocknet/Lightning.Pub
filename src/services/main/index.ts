import jwt from 'jsonwebtoken'
import Storage, { LoadStorageSettingsFromEnv, StorageSettings } from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import LND, { AddressPaidCb, InvoicePaidCb, LndSettings, LoadLndSettingsFromEnv } from '../lnd/index.js'
import { EnvMustBeInteger, EnvMustBeNonEmptyString } from '../helpers/envParser.js'
export type MainSettings = {
    storageSettings: StorageSettings,
    lndSettings: LndSettings,
    jwtSecret: string
    incomingTxFee: number
    outgoingTxFee: number
    incomingInvoiceFee: number
    outgoingInvoiceFee: number
}
export const LoadMainSettingsFromEnv = (test = false): MainSettings => {
    return {
        lndSettings: LoadLndSettingsFromEnv(test),
        storageSettings: LoadStorageSettingsFromEnv(test),
        jwtSecret: EnvMustBeNonEmptyString("JWT_SECRET"),
        incomingTxFee: EnvMustBeInteger("SERVICE_FEE_INCOMING_TX_PERCENT") / 100,
        outgoingTxFee: EnvMustBeInteger("SERVICE_FEE_OUTGOING_TX_PERCENT") / 100,
        incomingInvoiceFee: EnvMustBeInteger("SERVICE_FEE_INCOMING_INVOICE_PERCENT") / 100,
        outgoingInvoiceFee: EnvMustBeInteger("SERVICE_FEE_OUTGOING_INVOICE_PERCENT") / 100,
    }
}
enum ActionType {
    INCOMING_TX = "INCOMING_TX",
    OUTGOING_TX = "OUTGOING_TX",
    INCOMING_INVOICE = "INCOMING_INVOICE",
    OUTGOING_INVOICE = "OUTGOING_INVOICE"

}
export default class {
    storage: Storage
    lnd: LND
    settings: MainSettings
    constructor(settings: MainSettings) {
        this.settings = settings
        this.storage = new Storage(settings.storageSettings)
        this.lnd = new LND(settings.lndSettings, this.addressPaidCb, this.invoicePaidCb)
    }
    getServiceFee(action: ActionType, amount: number): number {
        switch (action) {
            case ActionType.INCOMING_TX:
                return Math.ceil(this.settings.incomingTxFee * amount)
            case ActionType.OUTGOING_TX:
                return Math.ceil(this.settings.outgoingTxFee * amount)
            case ActionType.INCOMING_INVOICE:
                return Math.ceil(this.settings.incomingInvoiceFee * amount)
            case ActionType.OUTGOING_INVOICE:
                return Math.ceil(this.settings.outgoingInvoiceFee * amount)
            default:
                throw new Error("Unknown service action type")
        }
    }
    addressPaidCb: AddressPaidCb = (txOutput, address, amount) => {
        this.storage.StartTransaction(async tx => {
            const userAddress = await this.storage.GetAddressOwner(address, tx)
            if (!userAddress) { return }
            const fee = this.getServiceFee(ActionType.INCOMING_TX, amount)
            try {
                // This call will fail if the transaction is already registered
                const addedTx = await this.storage.AddAddressReceivingTransaction(userAddress, txOutput.hash, txOutput.index, amount, fee, tx)
                await this.storage.IncrementUserBalance(userAddress.user.user_id, addedTx.amount, tx)
            } catch {

            }
        })
    }
    invoicePaidCb: InvoicePaidCb = (paymentRequest, amount) => {
        this.storage.StartTransaction(async tx => {
            const userInvoice = await this.storage.GetInvoiceOwner(paymentRequest, tx)
            if (!userInvoice || userInvoice.paid) { return }
            const fee = this.getServiceFee(ActionType.INCOMING_INVOICE, amount)
            try {
                // This call will fail if the invoice is already registered
                await this.storage.FlagInvoiceAsPaid(userInvoice, amount, fee, tx)
                await this.storage.IncrementUserBalance(userInvoice.user.user_id, amount, tx)
            } catch { }
        })
    }
    SignUserToken(userId: string): string {
        return jwt.sign({ userId }, this.settings.jwtSecret);
    }

    DecodeUserToken(token?: string): string {
        if (!token) throw new Error("empty auth token provided")
        return (jwt.verify(token, this.settings.jwtSecret) as { userId: string }).userId
    }

    async AddUser(req: Types.AddUserRequest): Promise<Types.AddUserResponse> {
        const newUser = await this.storage.AddUser(req.name, req.callback_url, req.secret)
        return {
            user_id: newUser.user_id,
            auth_token: this.SignUserToken(newUser.user_id)
        }
    }

    async NewAddress(userId: string, req: Types.NewAddressRequest): Promise<Types.NewAddressResponse> {
        const res = await this.lnd.NewAddress(req.address_type)
        const userAddress = await this.storage.AddUserAddress(userId, res.address)
        return {
            address: userAddress.address
        }
    }

    async NewInvoice(userId: string, req: Types.NewInvoiceRequest): Promise<Types.NewInvoiceResponse> {
        const res = await this.lnd.NewInvoice(req.amount_sats)
        const userInvoice = await this.storage.AddUserInvoice(userId, res.paymentRequest)
        return {
            invoice: userInvoice.invoice
        }
    }

    async lockUserWithMinBalance(userId: string, minBalance: number) {
        return this.storage.StartTransaction(async tx => {
            const user = await this.storage.GetUser(userId, tx)
            if (user.balance_sats < minBalance) {
                throw new Error("insufficient balance")
            }
            // this call will fail if the user is already locked
            await this.storage.LockUser(userId, tx)
        })
    }

    async PayInvoice(userId: string, req: Types.PayInvoiceRequest): Promise<Types.PayInvoiceResponse> {
        const decoded = await this.lnd.DecodeInvoice(req.invoice)
        if (decoded.numSatoshis !== 0 && req.amount !== 0) {
            throw new Error("invoice has value, do not provide amount the the request")
        }
        if (decoded.numSatoshis === 0 && req.amount === 0) {
            throw new Error("invoice has no value, an amount must be provided in the request")
        }
        const payAmount = req.amount !== 0 ? req.amount : Number(decoded.numSatoshis)
        const serviceFee = this.getServiceFee(ActionType.OUTGOING_INVOICE, payAmount)
        const totalAmountToDecrement = payAmount + serviceFee


        const routingFeeLimit = this.lnd.GetFeeLimitAmount(payAmount)
        await this.lockUserWithMinBalance(userId, totalAmountToDecrement + routingFeeLimit)
        const payment = await this.lnd.PayInvoice(req.invoice, req.amount, routingFeeLimit)
        await this.storage.DecrementUserBalance(userId, totalAmountToDecrement + Number(payment.feeSat))
        await this.storage.UnlockUser(userId)
        await this.storage.AddUserInvoicePayment(userId, req.invoice, payAmount, Number(payment.feeSat), serviceFee)
        return {
            preimage: payment.paymentPreimage
        }
    }

    async PayAddress(userId: string, req: Types.PayAddressRequest): Promise<Types.PayAddressResponse> {
        const estimate = await this.lnd.EstimateChainFees(req.address, req.amout_sats, req.target_conf)
        const satPerVByte = Number(estimate.satPerVbyte)
        const chainFees = Number(estimate.feeSat)
        const total = req.amout_sats + chainFees
        const serviceFee = this.getServiceFee(ActionType.OUTGOING_INVOICE, req.amout_sats)
        await this.lockUserWithMinBalance(userId, total + serviceFee)
        const payment = await this.lnd.PayAddress(req.address, req.amout_sats, satPerVByte)
        await this.storage.DecrementUserBalance(userId, total + serviceFee)
        await this.storage.UnlockUser(userId)
        await this.storage.AddUserTransactionPayment(userId, req.address, payment.txid, 0, req.amout_sats, chainFees, serviceFee)
        return {
            tx_id: payment.txid
        }
    }

    async OpenChannel(userId: string, req: Types.OpenChannelRequest): Promise<Types.OpenChannelResponse> { throw new Error("WIP") }
}