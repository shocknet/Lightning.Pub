import fetch from "node-fetch"
import Storage, { LoadStorageSettingsFromEnv } from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import LND, { AddressPaidCb, InvoicePaidCb, LoadLndSettingsFromEnv } from '../lnd/index.js'
import { EnvMustBeInteger, EnvMustBeNonEmptyString } from '../helpers/envParser.js'
import ProductManager from './productManager.js'
import ApplicationManager from './applicationManager.js'
import UserManager from './userManager.js'
import PaymentManager from './paymentManager.js'
import { MainSettings } from './settings.js'
export const LoadMainSettingsFromEnv = (test = false): MainSettings => {
    return {
        lndSettings: LoadLndSettingsFromEnv(test),
        storageSettings: LoadStorageSettingsFromEnv(test),
        jwtSecret: EnvMustBeNonEmptyString("JWT_SECRET"),
        incomingTxFee: EnvMustBeInteger("SERVICE_FEE_INCOMING_TX_PERCENT") / 100,
        outgoingTxFee: EnvMustBeInteger("SERVICE_FEE_OUTGOING_TX_PERCENT") / 100,
        incomingInvoiceFee: EnvMustBeInteger("SERVICE_FEE_INCOMING_INVOICE_PERCENT") / 100,
        outgoingInvoiceFee: EnvMustBeInteger("SERVICE_FEE_OUTGOING_INVOICE_PERCENT") / 100,
        userToUserFee: EnvMustBeInteger("SERVICE_FEE_USER_TO_USER_PERCENT") / 100,
        serviceUrl: EnvMustBeNonEmptyString("SERVICE_URL")
    }
}

type UserOperationsSub = {
    id: string
    newIncomingInvoice: (operation: Types.UserOperation) => void
    newOutgoingInvoice: (operation: Types.UserOperation) => void
    newIncomingTx: (operation: Types.UserOperation) => void
    newOutgoingTx: (operation: Types.UserOperation) => void
}

export default class {
    storage: Storage
    lnd: LND
    settings: MainSettings
    userOperationsSub: UserOperationsSub | null = null
    productManager: ProductManager
    applicationManager: ApplicationManager
    userManager: UserManager
    paymentManager: PaymentManager

    constructor(settings: MainSettings) {
        this.settings = settings
        this.storage = new Storage(settings.storageSettings)
        this.lnd = new LND(settings.lndSettings, this.addressPaidCb, this.invoicePaidCb)

        this.userManager = new UserManager(this.storage, this.settings)
        this.paymentManager = new PaymentManager(this.storage, this.lnd, this.settings)
        this.productManager = new ProductManager(this.storage, this.paymentManager, this.settings)
        this.applicationManager = new ApplicationManager(this.storage, this.settings, this.userManager, this.paymentManager)
    }

    addressPaidCb: AddressPaidCb = (txOutput, address, amount) => {
        this.storage.StartTransaction(async tx => {
            const userAddress = await this.storage.paymentStorage.GetAddressOwner(address, tx)
            if (!userAddress) { return }
            const fee = this.paymentManager.getServiceFee(Types.UserOperationType.INCOMING_TX, amount)
            try {
                // This call will fail if the transaction is already registered
                const addedTx = await this.storage.paymentStorage.AddAddressReceivingTransaction(userAddress, txOutput.hash, txOutput.index, amount, fee, tx)
                await this.storage.userStorage.IncrementUserBalance(userAddress.user.user_id, addedTx.paid_amount - fee, tx)
            } catch {

            }
        })
    }

    invoicePaidCb: InvoicePaidCb = (paymentRequest, amount) => {
        this.storage.StartTransaction(async tx => {
            const userInvoice = await this.storage.paymentStorage.GetInvoiceOwner(paymentRequest, tx)
            if (!userInvoice || userInvoice.paid_at_unix > 0) { return }
            const fee = this.paymentManager.getServiceFee(Types.UserOperationType.INCOMING_INVOICE, amount)
            const maybeApp = await this.storage.applicationStorage.IsApplicationUser(userInvoice.user.user_id)
            try {
                // This call will fail if the invoice is already registered
                await this.storage.paymentStorage.FlagInvoiceAsPaid(userInvoice, amount, fee, tx)
                await this.storage.userStorage.IncrementUserBalance(userInvoice.user.user_id, amount - fee, tx)
                await this.triggerPaidCallback(userInvoice.callbackUrl)
            } catch {
                //TODO
            }
        })
    }

    async triggerPaidCallback(url: string) {
        console.log(url)
        if (!url) {
            return
        }
        try {
            await fetch(url + "&ok=true")
        } catch (err: any) {
            console.log("error sending cb", err)
        }
    }
}