import crypto from 'crypto'
import fetch from "node-fetch"
import Storage, { LoadStorageSettingsFromEnv } from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { EnvMustBeInteger, EnvMustBeNonEmptyString } from '../helpers/envParser.js'
import ProductManager from './productManager.js'
import ApplicationManager from './applicationManager.js'
import PaymentManager from './paymentManager.js'
import { MainSettings } from './settings.js'
import NewLightningHandler, { LoadLndSettingsFromEnv, LightningHandler } from "../lnd/index.js"
import { AddressPaidCb, InvoicePaidCb, NewBlockCb } from "../lnd/settings.js"
import { getLogger, PubLogger } from "../helpers/logger.js"
import AppUserManager from "./appUserManager.js"
import { Application } from '../storage/entity/Application.js'
import { UserReceivingInvoice, ZapInfo } from '../storage/entity/UserReceivingInvoice.js'
import { UnsignedEvent } from '../nostr/tools/event.js'
import { NostrSend } from '../nostr/handler.js'
export const LoadMainSettingsFromEnv = (test = false): MainSettings => {
    return {
        lndSettings: LoadLndSettingsFromEnv(test),
        storageSettings: LoadStorageSettingsFromEnv(test),
        jwtSecret: EnvMustBeNonEmptyString("JWT_SECRET"),
        incomingTxFee: EnvMustBeInteger("INCOMING_CHAIN_FEE_ROOT_BPS") / 10000,
        outgoingTxFee: EnvMustBeInteger("OUTGOING_CHAIN_FEE_ROOT_BPS") / 10000,
        incomingAppInvoiceFee: EnvMustBeInteger("INCOMING_INVOICE_FEE_ROOT_BPS") / 10000,
        outgoingAppInvoiceFee: EnvMustBeInteger("OUTGOING_INVOICE_FEE_ROOT_BPS") / 10000,
        incomingAppUserInvoiceFee: EnvMustBeInteger("INCOMING_INVOICE_FEE_USER_BPS") / 10000,
        outgoingAppUserInvoiceFee: EnvMustBeInteger("OUTGOING_INVOICE_FEE_USER_BPS") / 10000,
        userToUserFee: EnvMustBeInteger("TX_FEE_INTERNAL_USER_BPS") / 10000,
        appToUserFee: EnvMustBeInteger("TX_FEE_INTERNAL_ROOT_BPS") / 10000,
        serviceUrl: EnvMustBeNonEmptyString("SERVICE_URL"),
        servicePort: EnvMustBeInteger("PORT")
    }
}

type UserOperationsSub = {
    id: string
    newIncomingInvoice: (operation: Types.UserOperation) => void
    newOutgoingInvoice: (operation: Types.UserOperation) => void
    newIncomingTx: (operation: Types.UserOperation) => void
    newOutgoingTx: (operation: Types.UserOperation) => void
}

export default class {
    storage: Storage
    lnd: LightningHandler
    settings: MainSettings
    userOperationsSub: UserOperationsSub | null = null
    productManager: ProductManager
    applicationManager: ApplicationManager
    appUserManager: AppUserManager
    paymentManager: PaymentManager
    paymentSubs: Record<string, ((op: Types.UserOperation) => void) | null> = {}
    nostrSend: NostrSend = () => { getLogger({})("nostr send not initialized yet") }

    constructor(settings: MainSettings) {
        this.settings = settings
        this.storage = new Storage(settings.storageSettings)
        this.lnd = NewLightningHandler(settings.lndSettings, this.addressPaidCb, this.invoicePaidCb, this.newBlockCb)

        this.paymentManager = new PaymentManager(this.storage, this.lnd, this.settings, this.addressPaidCb, this.invoicePaidCb)
        this.productManager = new ProductManager(this.storage, this.paymentManager, this.settings)
        this.applicationManager = new ApplicationManager(this.storage, this.settings, this.paymentManager)
        this.appUserManager = new AppUserManager(this.storage, this.settings, this.applicationManager)
    }

    attachNostrSend(f: NostrSend) {
        this.nostrSend = f
    }

    newBlockCb: NewBlockCb = (height) => {
        this.NewBlockHandler(height)
    }

    NewBlockHandler = async (height: number) => {
        const confirmed = await this.paymentManager.CheckPendingTransactions(height)
        await Promise.all(confirmed.map(async ({ confs, type, tx: t }) => {
            const { serial_id } = t
            if (type === 'outgoing') {
                await this.storage.paymentStorage.UpdateUserTransactionPayment(serial_id, { confs })
            } else {
                await this.storage.paymentStorage.UpdateAddressReceivingTransaction(serial_id, { confs })
                await this.storage.userStorage.IncrementUserBalance(t.user_address.user.user_id, t.paid_amount - t.service_fee)
                const operationId = `${Types.UserOperationType.INCOMING_TX}-${t.user_address.serial_id}`
                const op = { amount: t.paid_amount, paidAtUnix: Date.now() / 1000, inbound: true, type: Types.UserOperationType.INCOMING_TX, identifier: t.user_address.address, operationId, network_fee: 0, service_fee: t.service_fee, confirmed: true }
                this.sendOperationToNostr(t.user_address.linkedApplication!, t.user_address.user.user_id, op)
            }
        }))
    }

    addressPaidCb: AddressPaidCb = (txOutput, address, amount, internal) => {
        this.storage.StartTransaction(async tx => {
            const { blockHeight } = await this.lnd.GetInfo()
            const userAddress = await this.storage.paymentStorage.GetAddressOwner(address, tx)
            if (!userAddress) { return }
            const log = getLogger({})
            if (!userAddress.linkedApplication) {
                log("ERROR", "an address was paid, that has no linked application")
                return
            }
            const isAppUserPayment = userAddress.user.user_id !== userAddress.linkedApplication.owner.user_id
            let fee = this.paymentManager.getServiceFee(Types.UserOperationType.INCOMING_TX, amount, isAppUserPayment)
            if (userAddress.linkedApplication && userAddress.linkedApplication.owner.user_id === userAddress.user.user_id) {
                fee = 0
            }
            try {
                // This call will fail if the transaction is already registered
                const addedTx = await this.storage.paymentStorage.AddAddressReceivingTransaction(userAddress, txOutput.hash, txOutput.index, amount, fee, internal, blockHeight, tx)
                await this.storage.userStorage.IncrementUserBalance(userAddress.user.user_id, addedTx.paid_amount - fee, tx)
                const operationId = `${Types.UserOperationType.INCOMING_TX}-${userAddress.serial_id}`
                const op = { amount, paidAtUnix: Date.now() / 1000, inbound: true, type: Types.UserOperationType.INCOMING_TX, identifier: userAddress.address, operationId, network_fee: 0, service_fee: fee, confirmed: internal }
                this.sendOperationToNostr(userAddress.linkedApplication, userAddress.user.user_id, op)
            } catch {

            }
        })
    }

    invoicePaidCb: InvoicePaidCb = (paymentRequest, amount, internal) => {
        this.storage.StartTransaction(async tx => {
            const log = getLogger({})
            const userInvoice = await this.storage.paymentStorage.GetInvoiceOwner(paymentRequest, tx)
            if (!userInvoice) { return }
            if (userInvoice.paid_at_unix > 0 && internal) { log("cannot pay internally, invoice already paid"); return }
            if (userInvoice.paid_at_unix > 0 && !internal && userInvoice.paidByLnd) { log("invoice already paid by lnd"); return }
            if (!userInvoice.linkedApplication) {
                log("ERROR", "an invoice was paid, that has no linked application")
                return
            }
            const isAppUserPayment = userInvoice.user.user_id !== userInvoice.linkedApplication.owner.user_id
            let fee = this.paymentManager.getServiceFee(Types.UserOperationType.INCOMING_INVOICE, amount, isAppUserPayment)
            if (userInvoice.linkedApplication && userInvoice.linkedApplication.owner.user_id === userInvoice.user.user_id) {
                fee = 0
            }
            try {
                await this.storage.paymentStorage.FlagInvoiceAsPaid(userInvoice, amount, fee, internal, tx)

                await this.storage.userStorage.IncrementUserBalance(userInvoice.user.user_id, amount - fee, tx)
                if (isAppUserPayment && fee > 0) {
                    await this.storage.userStorage.IncrementUserBalance(userInvoice.linkedApplication.owner.user_id, fee, tx)
                }

                await this.triggerPaidCallback(log, userInvoice.callbackUrl)
                const operationId = `${Types.UserOperationType.INCOMING_INVOICE}-${userInvoice.serial_id}`
                const op = { amount, paidAtUnix: Date.now() / 1000, inbound: true, type: Types.UserOperationType.INCOMING_INVOICE, identifier: userInvoice.invoice, operationId, network_fee: 0, service_fee: fee, confirmed: true }
                this.sendOperationToNostr(userInvoice.linkedApplication, userInvoice.user.user_id, op)
                this.createZapReceipt(userInvoice)
                log("paid invoice processed successfully")
            } catch (err: any) {
                log("ERROR", "cannot process paid invoice", err.message || "")
            }
        })
    }

    async triggerPaidCallback(log: PubLogger, url: string) {
        if (!url) {
            return
        }
        try {
            await fetch(url + "&ok=true")
        } catch (err: any) {
            log("error sending paid callback for invoice", err.message || "")
        }
    }

    async sendOperationToNostr(app: Application, userId: string, op: Types.UserOperation) {
        const user = await this.storage.applicationStorage.GetAppUserFromUser(app, userId)
        if (!user || !user.nostr_public_key) {
            getLogger({})("cannot notify user, not a nostr user")
            return
        }
        const message: Types.LiveUserOperation & { requestId: string } = { operation: op, requestId: "GetLiveUserOperations" }
        this.nostrSend(app.app_id, { type: 'content', content: JSON.stringify(message), pub: user.nostr_public_key })
    }

    async createZapReceipt(invoice: UserReceivingInvoice) {
        const zapInfo = invoice.zap_info
        if (!zapInfo || !invoice.linkedApplication || !invoice.linkedApplication.nostr_public_key) {
            return
        }
        const tags = [["p", zapInfo.pub], ["bolt11", invoice.invoice], ["description", zapInfo.description]]
        if (zapInfo.eventId) {
            tags.push(["e", zapInfo.eventId])
        }
        const event: UnsignedEvent = {
            content: "",
            created_at: invoice.paid_at_unix,
            kind: 9735,
            pubkey: invoice.linkedApplication.nostr_public_key,
            tags,
        }
        this.nostrSend(invoice.linkedApplication.app_id, { type: 'event', event })
    }
}