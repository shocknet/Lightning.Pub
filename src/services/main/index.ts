import { nip44 } from 'nostr-tools'
import fetch from "node-fetch"
import Storage, { LoadStorageSettingsFromEnv } from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import ProductManager from './productManager.js'
import ApplicationManager from './applicationManager.js'
import PaymentManager, { PendingTx } from './paymentManager.js'
import LND from "../lnd/lnd.js"
import { AddressPaidCb, ChannelEventCb, HtlcCb, InvoicePaidCb, NewBlockCb } from "../lnd/settings.js"
import { ERROR, getLogger, PubLogger } from "../helpers/logger.js"
import AppUserManager from "./appUserManager.js"
import { Application } from '../storage/entity/Application.js'
import { UserReceivingInvoice } from '../storage/entity/UserReceivingInvoice.js'
import { UnsignedEvent } from 'nostr-tools'
import { NostrSend } from '../nostr/nostrPool.js'
import MetricsManager from '../metrics/index.js'
import { LiquidityProvider } from "./liquidityProvider.js"
import { LiquidityManager } from "./liquidityManager.js"
import { Utils } from "../helpers/utilsWrapper.js"
import { RugPullTracker } from "./rugPullTracker.js"
import { AdminManager } from "./adminManager.js"
import { Unlocker } from "./unlocker.js"
import { defaultInvoiceExpiry } from "../storage/paymentStorage.js"
import { DebitManager } from "./debitManager.js"
import { OfferManager } from "./offerManager.js"
import { parse } from "uri-template"
import webRTC from "../webRTC/index.js"
import { ManagementManager } from "./managementManager.js"
import { Agent } from "https"
import { NotificationsManager } from "./notificationsManager.js"
import { ApplicationUser } from '../storage/entity/ApplicationUser.js'
import SettingsManager from './settingsManager.js'
import { NostrSettings, AppInfo } from '../nostr/nostrPool.js'
import { ShockPushNotification } from '../ShockPush/index.js'
type UserOperationsSub = {
    id: string
    newIncomingInvoice: (operation: Types.UserOperation) => void
    newOutgoingInvoice: (operation: Types.UserOperation) => void
    newIncomingTx: (operation: Types.UserOperation) => void
    newOutgoingTx: (operation: Types.UserOperation) => void
}
const appTag = "Lightning.Pub"

export default class {
    storage: Storage
    lnd: LND
    settings: SettingsManager
    userOperationsSub: UserOperationsSub | null = null
    adminManager: AdminManager
    productManager: ProductManager
    applicationManager: ApplicationManager
    appUserManager: AppUserManager
    paymentManager: PaymentManager
    paymentSubs: Record<string, ((op: Types.UserOperation) => void) | null> = {}
    metricsManager: MetricsManager
    liquidityManager: LiquidityManager
    liquidityProvider: LiquidityProvider
    debitManager: DebitManager
    offerManager: OfferManager
    managementManager: ManagementManager
    utils: Utils
    rugPullTracker: RugPullTracker
    unlocker: Unlocker
    notificationsManager: NotificationsManager
    nostrProcessPing: (() => Promise<void>) | null = null
    nostrReset: (settings: NostrSettings) => void = () => { getLogger({})("nostr reset not initialized yet") }
    constructor(settings: SettingsManager, storage: Storage, adminManager: AdminManager, utils: Utils, unlocker: Unlocker) {
        this.settings = settings
        this.storage = storage
        this.adminManager = adminManager
        this.utils = utils
        this.unlocker = unlocker
        const updateProviderBalance = (b: number) => this.storage.liquidityStorage.IncrementTrackedProviderBalance('lnPub', settings.getSettings().liquiditySettings.liquidityProviderPub, b)
        this.liquidityProvider = new LiquidityProvider(() => this.settings.getSettings().liquiditySettings, this.utils, this.invoicePaidCb, updateProviderBalance)
        this.rugPullTracker = new RugPullTracker(this.storage, this.liquidityProvider)
        const lndGetSettings = () => ({
            lndSettings: settings.getSettings().lndSettings,
            lndNodeSettings: settings.getSettings().lndNodeSettings
        })
        this.lnd = new LND(lndGetSettings, this.liquidityProvider, () => this.unlocker.Unlock(), this.utils, this.addressPaidCb, this.invoicePaidCb, this.newBlockCb, this.htlcCb, this.channelEventCb)
        this.liquidityManager = new LiquidityManager(this.settings, this.storage, this.utils, this.liquidityProvider, this.lnd, this.rugPullTracker)
        this.metricsManager = new MetricsManager(this.storage, this.lnd)

        this.paymentManager = new PaymentManager(this.storage, this.metricsManager, this.lnd, adminManager.swaps, this.settings, this.liquidityManager, this.utils, this.addressPaidCb, this.invoicePaidCb, this.newBlockCb)
        this.productManager = new ProductManager(this.storage, this.paymentManager, this.settings)
        this.applicationManager = new ApplicationManager(this.storage, this.settings, this.paymentManager)
        this.appUserManager = new AppUserManager(this.storage, this.settings, this.applicationManager)
        this.debitManager = new DebitManager(this.storage, this.lnd, this.applicationManager)
        this.offerManager = new OfferManager(this.storage, this.settings, this.lnd, this.applicationManager, this.productManager, this.liquidityManager)
        this.managementManager = new ManagementManager(this.storage, this.settings)
        this.notificationsManager = new NotificationsManager(this.settings)
        //this.webRTC = new webRTC(this.storage, this.utils)
    }

    Stop() {
        this.lnd.Stop()
        this.applicationManager.Stop()
        this.paymentManager.Stop()
        this.utils.Stop()
        this.storage.Stop()
    }

    StartBeacons() {
        this.applicationManager.StartAppsServiceBeacon((app, fees) => {
            this.UpdateBeacon(app, { type: 'service', name: app.name, avatarUrl: app.avatar_url, fees })
        })
    }

    attachNostrSend(f: NostrSend) {
        this.utils.nostrSender.AttachNostrSend(f)
    }

    attachNostrProcessPing(f: () => Promise<void>) {
        this.nostrProcessPing = f
    }

    attachNostrReset(f: (settings: NostrSettings) => void) {
        this.nostrReset = f
        this.adminManager.attachNostrReset(() => this.ResetNostr())
    }

    async pingSubProcesses() {
        if (!this.nostrProcessPing) {
            throw new Error("nostr process ping not initialized")
        }
        const storageP = this.storage.dbs.Ping()
        const metricsP = this.storage.metricsStorage.dbs.Ping()
        const tlvP = this.utils.tlvStorageFactory.Ping()
        const nostrP = this.nostrProcessPing()
        const timeout = new Promise<true>(res => setTimeout(() => res(true), 2 * 1000))
        const storageFail = await Promise.race([storageP, timeout])
        const metricsFail = await Promise.race([metricsP, timeout])
        const tlvFail = await Promise.race([tlvP, timeout])
        const nostrFail = await Promise.race([nostrP, timeout])
        if (storageFail) {
            throw new Error("storage ping failed")
        }
        if (metricsFail) {
            throw new Error("metrics ping failed")
        }
        if (tlvFail) {
            throw new Error("tlv ping failed")
        }
        if (nostrFail) {
            throw new Error("nostr ping failed")
        }
    }

    channelEventCb: ChannelEventCb = (e, channels) => {
        this.metricsManager.ChannelEventCb(e, channels)
    }

    htlcCb: HtlcCb = (e) => {
        this.metricsManager.HtlcCb(e)
    }

    newBlockCb: NewBlockCb = (height, skipMetrics) => {
        return this.NewBlockHandler(height, skipMetrics)
    }

    NewBlockHandler = async (height: number, skipMetrics?: boolean) => {
        let confirmed: (PendingTx & { confs: number; })[]
        let log = getLogger({})
        this.storage.paymentStorage.DeleteExpiredTransactionSwaps(height)
            .catch(err => log(ERROR, "failed to delete expired transaction swaps", err.message || err))
        try {
            const balanceEvents = await this.paymentManager.GetLndBalance()
            if (!skipMetrics) {
                await this.metricsManager.NewBlockCb(height, balanceEvents)
            }
            confirmed = await this.paymentManager.CheckNewlyConfirmedTxs(height)
            await this.liquidityManager.onNewBlock()
        } catch (err: any) {
            log(ERROR, "failed to check transactions after new block", err.message || err)
            return
        }
        await Promise.all(confirmed.map(async c => {
            if (c.type === 'outgoing') {
                await this.storage.paymentStorage.UpdateUserTransactionPayment(c.tx.serial_id, { confs: c.confs })
                const { linkedApplication, user, address, paid_amount: amount, service_fees: serviceFee, serial_id: serialId, chain_fees } = c.tx;
                const operationId = `${Types.UserOperationType.OUTGOING_TX}-${serialId}`
                const op = { amount, paidAtUnix: Date.now() / 1000, inbound: false, type: Types.UserOperationType.OUTGOING_TX, identifier: address, operationId, network_fee: chain_fees, service_fee: serviceFee, confirmed: true, tx_hash: c.tx.tx_hash, internal: c.tx.internal }
                this.sendOperationToNostr(linkedApplication!, user.user_id, op)
            } else {
                this.storage.StartTransaction(async tx => {
                    const { user_address: userAddress, paid_amount: amount, service_fee: serviceFee, serial_id: serialId, tx_hash } = c.tx
                    if (!userAddress.linkedApplication) {
                        log(ERROR, "an address was paid, that has no linked application")
                        return
                    }
                    const affected = await this.storage.paymentStorage.UpdateAddressReceivingTransaction(serialId, { confs: c.confs }, tx)
                    if (!affected) {
                        throw new Error("unable to flag chain transaction as paid")
                    }
                    const addressData = `${userAddress.address}:${tx_hash}`
                    this.storage.eventsLog.LogEvent({ type: 'address_paid', userId: userAddress.user.user_id, appId: userAddress.linkedApplication.app_id, appUserId: "", balance: userAddress.user.balance_sats, data: addressData, amount })
                    await this.storage.userStorage.IncrementUserBalance(userAddress.user.user_id, amount - serviceFee, addressData, tx)
                    if (serviceFee > 0) {
                        await this.storage.userStorage.IncrementUserBalance(userAddress.linkedApplication.owner.user_id, serviceFee, 'fees', tx)
                    }
                    const operationId = `${Types.UserOperationType.INCOMING_TX}-${serialId}`
                    const op = { amount, paidAtUnix: Date.now() / 1000, inbound: true, type: Types.UserOperationType.INCOMING_TX, identifier: userAddress.address, operationId, network_fee: 0, service_fee: serviceFee, confirmed: true, tx_hash: c.tx.tx_hash, internal: c.tx.internal }
                    this.sendOperationToNostr(userAddress.linkedApplication!, userAddress.user.user_id, op)
                })
            }
        }))
    }

    addressPaidCb: AddressPaidCb = (txOutput, address, amount, used, broadcastHeight) => {
        return this.storage.StartTransaction(async tx => {
            // On-chain payments not supported when bypass is enabled
            if (this.liquidityProvider.getSettings().useOnlyLiquidityProvider) {
                getLogger({})("addressPaidCb called but USE_ONLY_LIQUIDITY_PROVIDER is enabled, ignoring")
                return
            }
            const { blockHeight } = await this.lnd.GetInfo()
            const userAddress = await this.storage.paymentStorage.GetAddressOwner(address, tx)
            if (!userAddress) {
                const isChange = await this.lnd.IsChangeAddress(address)
                if (isChange) {
                    return
                }
                await this.metricsManager.AddRootAddressPaid(address, txOutput, amount)
                return
            }
            const internal = used === 'internal'
            let log = getLogger({})
            if (!userAddress.linkedApplication) {
                log(ERROR, "an address was paid, that has no linked application")
                return
            }
            log = getLogger({ appName: userAddress.linkedApplication.name })
            const isManagedUser = userAddress.user.user_id !== userAddress.linkedApplication.owner.user_id
            const fee = this.paymentManager.getReceiveServiceFee(Types.UserOperationType.INCOMING_TX, amount, isManagedUser)
            try {
                // This call will fail if the transaction is already registered
                const txBroadcastHeight = broadcastHeight ? broadcastHeight : blockHeight
                const addedTx = await this.storage.paymentStorage.AddAddressReceivingTransaction(userAddress, txOutput.hash, txOutput.index, amount, fee, internal, txBroadcastHeight, tx)
                if (internal) {
                    const addressData = `${address}:${txOutput.hash}`
                    this.storage.eventsLog.LogEvent({ type: 'address_paid', userId: userAddress.user.user_id, appId: userAddress.linkedApplication.app_id, appUserId: "", balance: userAddress.user.balance_sats, data: addressData, amount })
                    await this.storage.userStorage.IncrementUserBalance(userAddress.user.user_id, addedTx.paid_amount - fee, addressData, tx)
                    if (fee > 0) {
                        await this.storage.userStorage.IncrementUserBalance(userAddress.linkedApplication.owner.user_id, fee, 'fees', tx)
                    }

                }
                const operationId = `${Types.UserOperationType.INCOMING_TX}-${addedTx.serial_id}`
                const op = { amount, paidAtUnix: Date.now() / 1000, inbound: true, type: Types.UserOperationType.INCOMING_TX, identifier: userAddress.address, operationId, network_fee: 0, service_fee: fee, confirmed: internal, tx_hash: txOutput.hash, internal: false }
                this.sendOperationToNostr(userAddress.linkedApplication, userAddress.user.user_id, op)
                this.utils.stateBundler.AddTxPoint('addressWasPaid', amount, { used, from: 'system', timeDiscount: true }, userAddress.linkedApplication.app_id)
            } catch (err: any) {
                this.utils.stateBundler.AddTxPointFailed('addressWasPaid', amount, { used, from: 'system' }, userAddress.linkedApplication.app_id)
                log(ERROR, "cannot process address paid transaction, already registered")
            }
        })
    }

    invoicePaidCb: InvoicePaidCb = (paymentRequest, amount, used) => {
        return this.storage.StartTransaction(async tx => {
            let log = getLogger({})
            const userInvoice = await this.storage.paymentStorage.GetInvoiceOwner(paymentRequest, tx)
            if (!userInvoice) {
                await this.metricsManager.AddRootInvoicePaid(paymentRequest, amount)
                return
            }
            const internal = used === 'internal'
            if (userInvoice.paid_at_unix > 0 && internal) { log("cannot pay internally, invoice already paid"); return }
            if (userInvoice.paid_at_unix > 0 && !internal && userInvoice.paidByLnd) { log("invoice already paid by lnd"); return }
            if (!userInvoice.linkedApplication) {
                log(ERROR, "an invoice was paid, that has no linked application")
                return
            }
            log = getLogger({ appName: userInvoice.linkedApplication.name })
            const isManagedUser = userInvoice.user.user_id !== userInvoice.linkedApplication.owner.user_id
            const fee = this.paymentManager.getReceiveServiceFee(Types.UserOperationType.INCOMING_INVOICE, amount, isManagedUser)
            try {
                await this.storage.paymentStorage.FlagInvoiceAsPaid(userInvoice, amount, fee, internal, tx)
                this.storage.eventsLog.LogEvent({ type: 'invoice_paid', userId: userInvoice.user.user_id, appId: userInvoice.linkedApplication.app_id, appUserId: "", balance: userInvoice.user.balance_sats, data: paymentRequest, amount })
                await this.storage.userStorage.IncrementUserBalance(userInvoice.user.user_id, amount - fee, userInvoice.invoice, tx)
                if (fee > 0) {
                    await this.storage.userStorage.IncrementUserBalance(userInvoice.linkedApplication.owner.user_id, fee, 'fees', tx)
                }
                await this.triggerPaidCallback(log, userInvoice.callbackUrl, { invoice: paymentRequest, amount, payerData: userInvoice.payer_data, token: userInvoice.bearer_token, rejectUnauthorized: userInvoice.rejectUnauthorized })
                const operationId = `${Types.UserOperationType.INCOMING_INVOICE}-${userInvoice.serial_id}`
                const op = { amount, paidAtUnix: Date.now() / 1000, inbound: true, type: Types.UserOperationType.INCOMING_INVOICE, identifier: userInvoice.invoice, operationId, network_fee: 0, service_fee: fee, confirmed: true, tx_hash: "", internal }
                this.sendOperationToNostr(userInvoice.linkedApplication, userInvoice.user.user_id, op)
                try {
                    this.createZapReceipt(log, userInvoice)
                } catch (err: any) {
                    log(ERROR, "cannot create zap receipt", err.message || "")
                }
                // Send CLINK receipt if this invoice was from a noffer request
                try {
                    if (userInvoice.clink_requester_pub && userInvoice.clink_requester_event_id) {
                        await this.createClinkReceipt(log, userInvoice)
                    }
                } catch (err: any) {
                    log(ERROR, "cannot create clink receipt", err.message || "")
                }
                this.liquidityManager.afterInInvoicePaid()
                this.utils.stateBundler.AddTxPoint('invoiceWasPaid', amount, { used, from: 'system', timeDiscount: true }, userInvoice.linkedApplication.app_id)
            } catch (err: any) {
                this.utils.stateBundler.AddTxPointFailed('invoiceWasPaid', amount, { used, from: 'system' }, userInvoice.linkedApplication.app_id)
                log(ERROR, "cannot process paid invoice", err.message || "")
            }
        })
    }

    async triggerPaidCallback(log: PubLogger, url: string,
        { invoice, amount, payerData, token, rejectUnauthorized }:
            {
                invoice: string,
                amount: number,
                payerData?: Record<string, string>,
                token?: string,
                rejectUnauthorized?: boolean
            }
    ) {
        if (!url) {
            return
        }
        let finalUrl = "";
        const payerDataToExpand = {
            amount,
            invoice,
            ...(payerData !== undefined ? payerData : {})
        };
        try {
            const parsed = parse(url);
            finalUrl = parsed.expand(payerDataToExpand)
        } catch (err: any) {
            log(ERROR, "error expanding callback url template for invoice", err?.message || "");
            return;
        }
        const symbol = finalUrl.includes('?') ? "&" : "?"
        finalUrl = finalUrl + symbol + "ok=true"

        /* 
         *   Construct URL to find protocol.
         *   If it's https we then use an agent
         *   with the passed rejectUnauthorized
         *   value.
         *   If it's http we don't use an agent.
         *   If it's neither we log error and
         *   return.
        */
        let parsedUrl: URL | null = null;
        let agent: Agent | undefined;
        try {
            parsedUrl = new URL(finalUrl);
        } catch (err: any) {
            log(ERROR, "error parsing callback url for invoice", err?.message || "");
            return;
        }
        if (parsedUrl.protocol === "https:") {
            agent = new Agent({
                rejectUnauthorized
            })
        } else if (parsedUrl.protocol === "http:") {
            agent = undefined
        } else {
            log(ERROR, "callback url's protocol is neither http or https");
            return;
        }
        const headers = {
            ...(token ? { Authorization: `Bearer ${token}` } : {})
        }
        try {
            log("sending paid callback to", finalUrl)
            await fetch(finalUrl, { agent, headers })
        } catch (err: any) {
            log(ERROR, "error sending paid callback for invoice", err.message || "")
        }
    }

    async sendOperationToNostr(app: Application, userId: string, op: Types.UserOperation) {
        const user = await this.storage.applicationStorage.GetAppUserFromUser(app, userId)
        if (!user || !user.nostr_public_key) {
            getLogger({ appName: app.name })("cannot notify user, not a nostr user")
            return
        }
        const balance = user.user.balance_sats
        const message: Types.LiveUserOperation & { requestId: string, status: 'OK' } =
            { operation: op, requestId: "GetLiveUserOperations", status: 'OK', latest_balance: balance }
        const j = JSON.stringify(message)
        this.utils.nostrSender.Send({ type: 'app', appId: app.app_id }, { type: 'content', content: j, pub: user.nostr_public_key })

        this.SendEncryptedNotification(app, user, op, this.getOperationMessage(op))
    }

    getOperationMessage = (op: Types.UserOperation) => {
        switch (op.type) {
            case Types.UserOperationType.INCOMING_TX:
            case Types.UserOperationType.INCOMING_INVOICE:
            case Types.UserOperationType.INCOMING_USER_TO_USER:
                return {
                    body: "You received a new payment",
                    title: "Payment Received"
                }
            case Types.UserOperationType.OUTGOING_TX:
            case Types.UserOperationType.OUTGOING_INVOICE:
            case Types.UserOperationType.OUTGOING_USER_TO_USER:
                return {
                    body: "You sent a new payment",
                    title: "Payment Sent"
                }

            default:
                return {
                    body: "Unknown operation",
                    title: "Unknown Operation"
                }
        }
    }

    async SendEncryptedNotification(app: Application, appUser: ApplicationUser, op: Types.UserOperation, { body, title }: { body: string, title: string }) {
        const devices = await this.storage.applicationStorage.GetAppUserDevices(appUser.identifier)
        if (devices.length === 0 || !app.nostr_public_key || !app.nostr_private_key || !appUser.nostr_public_key) {
            return
        }
        const tokens = devices.map(d => d.firebase_messaging_token)
        const ck = nip44.getConversationKey(Buffer.from(app.nostr_private_key, 'hex'), appUser.nostr_public_key)
        const j = JSON.stringify(op)
        const encrypted = nip44.encrypt(j, ck)
        const encryptedData: { encrypted: string, app_npub_hex: string } = { encrypted, app_npub_hex: app.nostr_public_key }
        const notification: ShockPushNotification = {
            message: JSON.stringify(encryptedData),
            body,
            title
        }
        await this.notificationsManager.SendNotification(notification, tokens, {
            pubkey: app.nostr_public_key!,
            privateKey: app.nostr_private_key!
        })
    }

    async UpdateBeacon(app: Application, content: Types.BeaconData) {
        if (!app.nostr_public_key) {
            getLogger({ appName: app.name })("cannot update beacon, public key not set")
            return
        }
        const tags = [["d", appTag]]
        const event: UnsignedEvent = {
            content: JSON.stringify(content),
            created_at: Math.floor(Date.now() / 1000),
            kind: 30078,
            pubkey: app.nostr_public_key,
            tags,
        }
        this.utils.nostrSender.Send({ type: 'app', appId: app.app_id }, { type: 'event', event })
    }

    async createZapReceipt(log: PubLogger, invoice: UserReceivingInvoice) {
        const zapInfo = invoice.zap_info
        if (!zapInfo || !invoice.linkedApplication || !invoice.linkedApplication.nostr_public_key) {
            return
        }
        const tags = [["p", zapInfo.pub], ["bolt11", invoice.invoice], ["description", zapInfo.description]]
        if (zapInfo.eventId) {
            tags.push(["e", zapInfo.eventId])
        }
        const event: UnsignedEvent = {
            content: "",
            created_at: invoice.paid_at_unix,
            kind: 9735,
            pubkey: invoice.linkedApplication.nostr_public_key,
            tags,
        }
        log({ unsigned: event })
        this.utils.nostrSender.Send({ type: 'app', appId: invoice.linkedApplication.app_id }, { type: 'event', event }, zapInfo.relays || undefined)
    }

    async createClinkReceipt(log: PubLogger, invoice: UserReceivingInvoice) {
        if (!invoice.clink_requester_pub || !invoice.clink_requester_event_id || !invoice.linkedApplication) {
            return
        }
        log("ðŸ“¤ [CLINK RECEIPT] Sending payment receipt", {
            toPub: invoice.clink_requester_pub,
            eventId: invoice.clink_requester_event_id
        })
        // Receipt payload - payer's wallet already has the preimage
        const content = JSON.stringify({ res: 'ok' })
        const event: UnsignedEvent = {
            content,
            created_at: Math.floor(Date.now() / 1000),
            kind: 21001,
            pubkey: "",
            tags: [
                ["p", invoice.clink_requester_pub],
                ["e", invoice.clink_requester_event_id],
                ["clink_version", "1"]
            ],
        }
        this.utils.nostrSender.Send(
            { type: 'app', appId: invoice.linkedApplication.app_id },
            { type: 'event', event, encrypt: { toPub: invoice.clink_requester_pub } }
        )
    }

    async ResetNostr() {
        const apps = await this.storage.applicationStorage.GetApplications()
        const nextRelay = this.settings.getSettings().nostrRelaySettings.relays[0]
        const fees = this.paymentManager.GetFees()
        for (const app of apps) {
            await this.UpdateBeacon(app, { type: 'service', name: app.name, avatarUrl: app.avatar_url, nextRelay, fees })
        }

        const defaultNames = ['wallet', 'wallet-test', this.settings.getSettings().serviceSettings.defaultAppName]
        const local = apps.find(app => defaultNames.includes(app.name))
        if (!local) {
            throw new Error("local app not initialized correctly")
        }
        this.liquidityProvider.setNostrInfo({ localId: `client_${local.app_id}`, localPubkey: local.nostr_public_key || "" })
        const relays = this.settings.getSettings().nostrRelaySettings.relays
        const appsInfo: AppInfo[] = apps.map(app => {
            return {
                appId: app.app_id,
                privateKey: app.nostr_private_key || "",
                publicKey: app.nostr_public_key || "",
                name: app.name,
                provider: app.nostr_public_key === local.nostr_public_key ? {
                    clientId: `client_${local.app_id}`,
                    pubkey: this.settings.getSettings().liquiditySettings.liquidityProviderPub,
                    relayUrl: this.settings.getSettings().liquiditySettings.providerRelayUrl
                } : undefined
            }
        })
        const s: NostrSettings = {
            apps: appsInfo,
            relays,
            maxEventContentLength: this.settings.getSettings().nostrRelaySettings.maxEventContentLength,
            /* clients: [local],
            providerDestinationPub: this.settings.getSettings().liquiditySettings.liquidityProviderPub */
        }
        this.nostrReset(s)
    }
}