import newNostrClient from '../../../proto/autogenerated/ts/nostr_client.js'
import { NostrRequest } from '../../../proto/autogenerated/ts/nostr_transport.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { ERROR, getLogger } from '../helpers/logger.js'
import { Utils } from '../helpers/utilsWrapper.js'
import { NostrEvent, NostrSend } from '../nostr/handler.js'
import { InvoicePaidCb } from '../lnd/settings.js'
import Storage from '../storage/index.js'
import SettingsManager from './settingsManager.js'
import { LiquiditySettings } from './settings.js'
export type nostrCallback<T> = { startedAtMillis: number, type: 'single' | 'stream', f: (res: T) => void }
export class LiquidityProvider {
    getSettings: () => LiquiditySettings
    client: ReturnType<typeof newNostrClient>
    clientCbs: Record<string, nostrCallback<any>> = {}
    clientId: string = ""
    myPub: string = ""
    log = getLogger({ component: 'liquidityProvider' })
    nostrSend: NostrSend | null = null
    configured = false
    pubDestination: string
    ready: boolean
    invoicePaidCb: InvoicePaidCb
    connecting = false
    configuredInterval: NodeJS.Timeout
    queue: ((state: 'ready') => void)[] = []
    utils: Utils
    pendingPayments: Record<string, number> = {}
    feesCache: Types.CumulativeFees | null = null
    lastSeenBeacon = 0
    latestReceivedBalance = 0
    incrementProviderBalance: (balance: number) => Promise<void>
    pendingPaymentsAck: Record<string, boolean> = {}
    // make the sub process accept client
    constructor(getSettings: () => LiquiditySettings, utils: Utils, invoicePaidCb: InvoicePaidCb, incrementProviderBalance: (balance: number) => Promise<any>) {
        this.utils = utils
        this.getSettings = getSettings
        const pubDestination = getSettings().liquidityProviderPub
        const disableLiquidityProvider = getSettings().disableLiquidityProvider
        if (!pubDestination) {
            this.log("No pub provider to liquidity provider, will not be initialized")
            return
        }
        if (disableLiquidityProvider) {
            this.log("Liquidity provider is disabled, will not be initialized")
            return
        }
        this.log("connecting to liquidity provider:", pubDestination)
        this.pubDestination = pubDestination
        this.invoicePaidCb = invoicePaidCb
        this.incrementProviderBalance = incrementProviderBalance
        this.client = newNostrClient({
            pubDestination: this.pubDestination,
            retrieveNostrUserAuth: async () => this.myPub,
            retrieveNostrAdminAuth: async () => this.myPub,
            retrieveNostrMetricsAuth: async () => this.myPub,
            retrieveNostrGuestWithPubAuth: async () => this.myPub
        }, this.clientSend, this.clientSub)

        this.configuredInterval = setInterval(() => {
            if (this.configured) {
                clearInterval(this.configuredInterval)
                this.Connect()
            }
        }, 1000)
    }

    GetProviderDestination() {
        return this.pubDestination
    }

    IsReady = () => {
        const seenInPast2Minutes = Date.now() - this.lastSeenBeacon < 1000 * 60 * 2
        return this.ready && !this.getSettings().disableLiquidityProvider && seenInPast2Minutes
    }

    AwaitProviderReady = async (): Promise<'inactive' | 'ready'> => {
        if (!this.pubDestination || this.getSettings().disableLiquidityProvider) {
            return 'inactive'
        }
        if (this.IsReady()) {
            return 'ready'
        }
        return new Promise<'ready'>(res => {
            this.queue.push(res)
        })
    }

    Stop = () => {
        clearInterval(this.configuredInterval)
    }

    Connect = async () => {
        await new Promise(res => setTimeout(res, 2000))
        const res = await this.GetUserState()
        if (res.status === 'ERROR' && res.reason !== 'timeout') {
            return
        }
        this.log("provider ready with balance:", res.status === 'OK' ? res.balance : 0)
        this.lastSeenBeacon = Date.now()
        this.ready = true
        this.queue.forEach(q => q('ready'))
        this.log("subbing to user operations")
        this.client.GetLiveUserOperations(async res => {
            if (res.status === 'ERROR') {
                this.log("error getting user operations", res.reason)
                return
            }
            //this.log("got user operation", res.operation)
            if (res.operation.type === Types.UserOperationType.INCOMING_INVOICE) {
                try {
                    await this.invoicePaidCb(res.operation.identifier, res.operation.amount, 'provider')
                    this.incrementProviderBalance(res.operation.amount)
                    this.latestReceivedBalance = res.latest_balance
                    if (!res.operation.inbound && !res.operation.confirmed) {
                        delete this.pendingPaymentsAck[res.operation.identifier]
                    }
                } catch (err: any) {
                    this.log("error processing incoming invoice", err.message)
                }
            }
        })
    }

    GetUserState = async () => {
        const res = await Promise.race([this.client.GetUserInfo(), new Promise<Types.ResultError>(res => setTimeout(() => res({ status: 'ERROR', reason: 'timeout' }), 10 * 1000))])
        if (res.status === 'ERROR') {
            if (res.reason !== 'timeout') {
                this.log("error getting user info", res.reason)
            }
            return res
        }
        this.feesCache = {
            networkFeeFixed: res.network_max_fee_fixed,
            serviceFeeBps: res.service_fee_bps
        }
        this.latestReceivedBalance = res.balance
        this.utils.stateBundler.AddBalancePoint('providerBalance', res.balance)
        this.utils.stateBundler.AddBalancePoint('providerMaxWithdrawable', res.max_withdrawable)
        return res
    }

    GetFees = () => {
        if (!this.feesCache) {
            throw new Error("fees not cached")
        }
        return this.feesCache
    }

    GetMaxWithdrawable = () => {
        if (!this.IsReady() || !this.feesCache) {
            return 0
        }
        const balance = this.latestReceivedBalance
        const { /* networkFeeBps, */ networkFeeFixed, serviceFeeBps } = this.feesCache
        const div = 1 + (serviceFeeBps / 10000)
        const maxWithoutFixed = Math.floor(balance / div)
        const fee = balance - maxWithoutFixed
        return balance - Math.max(fee, networkFeeFixed)
    }

    GetLatestBalance = () => {
        if (!this.IsReady()) {
            return 0
        }
        return this.latestReceivedBalance
    }

    GetPendingBalance = async () => {
        return Object.values(this.pendingPayments).reduce((a, b) => a + b, 0)
    }

    GetServiceFee = (amount: number, f?: Types.CumulativeFees) => {
        const fees = f ? f : this.GetFees()
        const serviceFeeRate = fees.serviceFeeBps / 10000
        const serviceFee = Math.ceil(serviceFeeRate * amount)
        return Math.max(serviceFee, fees.networkFeeFixed)
    }

    CanProviderPay = async (amount: number, localServiceFee: number): Promise<boolean> => {
        if (!this.IsReady()) {
            this.log("provider is not ready")
            return false
        }
        const maxW = this.GetMaxWithdrawable()
        if (maxW < amount) {
            this.log("provider does not have enough funds to pay the invoice")
            return false
        }

        const providerServiceFee = this.GetServiceFee(amount)
        if (localServiceFee < providerServiceFee) {
            this.log(`local service fee ${localServiceFee} is less than the provider's service fee ${providerServiceFee}`)
            return false
        }

        return true
    }

    AddInvoice = async (amount: number, memo: string, from: 'user' | 'system', expiry: number) => {
        try {
            if (!this.IsReady()) {
                throw new Error("liquidity provider is not ready yet, disabled or unreachable")
            }
            const res = await this.client.NewInvoice({ amountSats: amount, memo, expiry })
            if (res.status === 'ERROR') {
                this.log("error creating invoice", res.reason)
                throw new Error(res.reason)
            }
            this.utils.stateBundler.AddTxPoint('addedInvoice', amount, { used: 'provider', from })
            return res.invoice
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('addedInvoice', amount, { used: 'provider', from })
            throw err
        }

    }

    PayInvoice = async (invoice: string, decodedAmount: number, from: 'user' | 'system') => {
        try {
            if (!this.IsReady()) {
                throw new Error("liquidity provider is not ready yet, disabled or unreachable")
            }
            const fees = this.GetFees()
            const providerServiceFee = this.GetServiceFee(decodedAmount, fees)
            this.pendingPayments[invoice] = decodedAmount + providerServiceFee
            const timeout = setTimeout(() => {
                if (!this.pendingPaymentsAck[invoice]) {
                    return
                }
                this.log("10 seconds passed without a payment ack, locking provider until the next beacon")
                this.lastSeenBeacon = 0
            }, 1000 * 10)
            this.pendingPaymentsAck[invoice] = true
            const res = await this.client.PayInvoice({ invoice, amount: 0, expected_fees: fees })
            delete this.pendingPaymentsAck[invoice]
            clearTimeout(timeout)
            if (res.status === 'ERROR') {
                this.log("error paying invoice", res.reason)
                throw new Error(res.reason)
            }
            const totalPaid = res.amount_paid + res.service_fee
            this.incrementProviderBalance(-totalPaid).then(() => { delete this.pendingPayments[invoice] })
            this.latestReceivedBalance = res.latest_balance
            this.utils.stateBundler.AddTxPoint('paidAnInvoice', decodedAmount, { used: 'provider', from, timeDiscount: true })
            return res
        } catch (err) {
            delete this.pendingPayments[invoice]
            this.utils.stateBundler.AddTxPointFailed('paidAnInvoice', decodedAmount, { used: 'provider', from })
            throw err
        }
    }

    GetPaymentState = async (invoice: string) => {
        if (!this.IsReady()) {
            throw new Error("liquidity provider is not ready yet, disabled or unreachable")
        }
        const res = await this.client.GetPaymentState({ invoice })
        if (res.status === 'ERROR') {
            this.log("error getting payment state", res.reason)
            throw new Error(res.reason)
        }
        return res
    }

    GetOperations = async () => {
        if (!this.IsReady()) {
            throw new Error("liquidity provider is not ready yet, disabled or unreachable")
        }
        const res = await this.client.GetUserOperations({
            latestIncomingInvoice: { ts: 0, id: 0 }, latestOutgoingInvoice: { ts: 0, id: 0 },
            latestIncomingTx: { ts: 0, id: 0 }, latestOutgoingTx: { ts: 0, id: 0 }, latestIncomingUserToUserPayment: { ts: 0, id: 0 },
            latestOutgoingUserToUserPayment: { ts: 0, id: 0 }, max_size: 200
        })
        if (res.status === 'ERROR') {
            this.log("error getting operations", res.reason)
            throw new Error(res.reason)
        }
        return res
    }

    setNostrInfo = ({ clientId, myPub }: { myPub: string, clientId: string }) => {
        this.log("setting nostr info")
        this.clientId = clientId
        this.myPub = myPub
        this.setSetIfConfigured()
    }



    attachNostrSend(f: NostrSend) {
        this.log("attaching nostrSend action")
        this.nostrSend = f
        this.setSetIfConfigured()
    }

    setSetIfConfigured = () => {
        if (this.nostrSend && !!this.pubDestination && !!this.clientId && !!this.myPub) {
            this.configured = true
            this.log("configured to send to ")
        }
    }
    onBeaconEvent = async (beaconData: { content: string, pub: string }) => {
        if (beaconData.pub !== this.pubDestination) {
            this.log(ERROR, "got beacon from invalid pub", beaconData.pub, this.pubDestination)
            return
        }
        const beacon = JSON.parse(beaconData.content) as Types.BeaconData
        const err = Types.BeaconDataValidate(beacon)
        if (err) {
            this.log(ERROR, "error validating beacon data", err.message)
            return
        }
        if (beacon.type !== 'service') {
            this.log(ERROR, "got beacon from invalid type", beacon.type)
            return
        }
        if (beacon.fees) {
            this.feesCache = beacon.fees
        }
    }

    onEvent = async (res: { requestId: string }, fromPub: string) => {
        if (fromPub !== this.pubDestination) {
            this.log("got event from invalid pub", fromPub, this.pubDestination)
            return false
        }
        if (this.clientCbs[res.requestId]) {
            const cb = this.clientCbs[res.requestId]

            cb.f(res)
            if (cb.type === 'single') {
                delete this.clientCbs[res.requestId]
                this.utils.stateBundler.AddMaxPoint('maxProviderRespTime', Date.now() - cb.startedAtMillis)
            }
            return true
        }
        return false
    }

    clientSend = (to: string, message: NostrRequest): Promise<any> => {
        if (!this.configured || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = makeId(16)
        }
        const reqId = message.requestId
        if (this.clientCbs[reqId]) {
            throw new Error("request was already sent")
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })

        //this.nostrSend(this.relays, to, JSON.stringify(message), this.settings)

        // this.log("subbing  to single send", reqId, message.rpcName || 'no rpc name')
        return new Promise(res => {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'single',
                f: (response: any) => { res(response) },
            }
        })
    }

    clientSub = (to: string, message: NostrRequest, cb: (res: any) => void): void => {
        if (!this.configured || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = message.rpcName
        }
        const reqId = message.requestId
        if (!reqId) {
            throw new Error("invalid sub")
        }
        if (this.clientCbs[reqId]) {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'stream',
                f: (response: any) => { cb(response) },
            }
            this.log("sub for", reqId, "was already registered, overriding")
            return
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })
        this.log("subbing  to stream", reqId)
        this.clientCbs[reqId] = {
            startedAtMillis: Date.now(),
            type: 'stream',
            f: (response: any) => { cb(response) }
        }
    }
    getSingleSubs = () => {
        return Object.entries(this.clientCbs).filter(([_, cb]) => cb.type === 'single')
    }
}

export const makeId = (length: number) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}