import newNostrClient from '../../../proto/autogenerated/ts/nostr_client.js'
import { NostrRequest } from '../../../proto/autogenerated/ts/nostr_transport.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { decodeNprofile } from '../../custom-nip19.js'
import { getLogger } from '../helpers/logger.js'
import { Utils } from '../helpers/utilsWrapper.js'
import { NostrEvent, NostrSend } from '../nostr/handler.js'
import { relayInit } from '../nostr/tools/relay.js'
import { InvoicePaidCb } from '../lnd/settings.js'
import Storage from '../storage/index.js'
export type LiquidityRequest = { action: 'spend' | 'receive', amount: number }

export type nostrCallback<T> = { startedAtMillis: number, type: 'single' | 'stream', f: (res: T) => void }
export class LiquidityProvider {

    client: ReturnType<typeof newNostrClient>
    clientCbs: Record<string, nostrCallback<any>> = {}
    clientId: string = ""
    myPub: string = ""
    log = getLogger({ component: 'liquidityProvider' })
    nostrSend: NostrSend | null = null
    configured = false
    pubDestination: string
    ready: boolean
    invoicePaidCb: InvoicePaidCb
    connecting = false
    configuredInterval: NodeJS.Timeout
    queue: ((state: 'ready') => void)[] = []
    utils: Utils
    pendingPayments: Record<string, number> = {}
    updateProviderBalance: (balance: number) => void
    // make the sub process accept client
    constructor(pubDestination: string, utils: Utils, invoicePaidCb: InvoicePaidCb, updateProviderBalance: (balance: number) => void) {
        this.utils = utils
        if (!pubDestination) {
            this.log("No pub provider to liquidity provider, will not be initialized")
            return
        }
        this.log("connecting to liquidity provider:", pubDestination)
        this.pubDestination = pubDestination
        this.invoicePaidCb = invoicePaidCb
        this.updateProviderBalance = updateProviderBalance
        this.client = newNostrClient({
            pubDestination: this.pubDestination,
            retrieveNostrUserAuth: async () => this.myPub,
        }, this.clientSend, this.clientSub)

        this.configuredInterval = setInterval(() => {
            if (this.configured) {
                clearInterval(this.configuredInterval)
                this.Connect()
            }
        }, 1000)
    }

    GetProviderDestination() {
        return this.pubDestination
    }

    IsReady = () => {
        return this.ready
    }

    AwaitProviderReady = async (): Promise<'inactive' | 'ready'> => {
        if (!this.pubDestination) {
            return 'inactive'
        }
        if (this.ready) {
            return 'ready'
        }
        return new Promise<'ready'>(res => {
            this.queue.push(res)
        })
    }

    Stop = () => {
        clearInterval(this.configuredInterval)
    }

    Connect = async () => {
        await new Promise(res => setTimeout(res, 2000))
        this.log("ready")
        const res = await this.GetUserState()
        if (res.status === 'ERROR') {
            return
        }
        this.ready = true
        this.queue.forEach(q => q('ready'))
        this.log("subbing to user operations")
        this.client.GetLiveUserOperations(res => {
            console.log("got user operation", res)
            if (res.status === 'ERROR') {
                this.log("error getting user operations", res.reason)
                return
            }
            //this.log("got user operation", res.operation)
            if (res.operation.type === Types.UserOperationType.INCOMING_INVOICE) {
                this.updateProviderBalance(res.latest_balance)
                this.invoicePaidCb(res.operation.identifier, res.operation.amount, 'provider')
            }
        })
    }

    GetUserState = async () => {
        const res = await this.client.GetUserInfo()
        if (res.status === 'ERROR') {
            this.log("error getting user info", res)
            return res
        }
        this.utils.stateBundler.AddBalancePoint('providerBalance', res.balance)
        this.utils.stateBundler.AddBalancePoint('providerMaxWithdrawable', res.max_withdrawable)
        return res
    }

    GetLatestMaxWithdrawable = async () => {
        if (!this.ready) {
            return 0
        }
        const res = await this.GetUserState()
        if (res.status === 'ERROR') {
            this.log("error getting user info", res.reason)
            return 0
        }
        return res.max_withdrawable
    }

    GetLatestBalance = async () => {
        if (!this.ready) {
            return 0
        }
        const res = await this.GetUserState()
        if (res.status === 'ERROR') {
            this.log("error getting user info", res.reason)
            return 0
        }
        return res.balance
    }

    GetPendingBalance = async () => {
        return Object.values(this.pendingPayments).reduce((a, b) => a + b, 0)
    }

    CalculateExpectedFeeLimit = (amount: number, info: Types.UserInfo) => {
        const serviceFeeRate = info.service_fee_bps / 10000
        const serviceFee = Math.ceil(serviceFeeRate * amount)
        const networkMaxFeeRate = info.network_max_fee_bps / 10000
        const networkFeeLimit = Math.ceil(amount * networkMaxFeeRate + info.network_max_fee_fixed)
        return serviceFee + networkFeeLimit
    }

    CanProviderHandle = async (req: LiquidityRequest) => {
        if (!this.ready) {
            return false
        }
        const maxW = await this.GetLatestMaxWithdrawable()
        if (req.action === 'spend') {
            return maxW > req.amount
        }
        return true
    }

    AddInvoice = async (amount: number, memo: string, from: 'user' | 'system') => {
        try {
            if (!this.ready) {
                throw new Error("liquidity provider is not ready yet")
            }
            const res = await this.client.NewInvoice({ amountSats: amount, memo })
            if (res.status === 'ERROR') {
                this.log("error creating invoice", res.reason)
                throw new Error(res.reason)
            }
            this.utils.stateBundler.AddTxPoint('addedInvoice', amount, { used: 'provider', from })
            return res.invoice
        } catch (err) {
            this.utils.stateBundler.AddTxPointFailed('addedInvoice', amount, { used: 'provider', from })
            throw err
        }

    }

    PayInvoice = async (invoice: string, decodedAmount: number, from: 'user' | 'system') => {
        try {
            if (!this.ready) {
                throw new Error("liquidity provider is not ready yet")
            }
            const userInfo = await this.GetUserState()
            if (userInfo.status === 'ERROR') {
                throw new Error(userInfo.reason)
            }
            this.pendingPayments[invoice] = decodedAmount + this.CalculateExpectedFeeLimit(decodedAmount, userInfo)
            const res = await this.client.PayInvoice({ invoice, amount: 0 })
            if (res.status === 'ERROR') {
                this.log("error paying invoice", res.reason)
                throw new Error(res.reason)
            }
            delete this.pendingPayments[invoice]
            this.updateProviderBalance(userInfo.balance)
            this.utils.stateBundler.AddTxPoint('paidAnInvoice', decodedAmount, { used: 'provider', from, timeDiscount: true })
            return res
        } catch (err) {
            delete this.pendingPayments[invoice]
            this.utils.stateBundler.AddTxPointFailed('paidAnInvoice', decodedAmount, { used: 'provider', from })
            throw err
        }
    }

    GetOperations = async () => {
        if (!this.ready) {
            throw new Error("liquidity provider is not ready yet")
        }
        const res = await this.client.GetUserOperations({
            latestIncomingInvoice: 0, latestOutgoingInvoice: 0,
            latestIncomingTx: 0, latestOutgoingTx: 0, latestIncomingUserToUserPayment: 0,
            latestOutgoingUserToUserPayment: 0, max_size: 200
        })
        if (res.status === 'ERROR') {
            this.log("error getting operations", res.reason)
            throw new Error(res.reason)
        }
        return res
    }

    setNostrInfo = ({ clientId, myPub }: { myPub: string, clientId: string }) => {
        this.log("setting nostr info")
        this.clientId = clientId
        this.myPub = myPub
        this.setSetIfConfigured()
    }



    attachNostrSend(f: NostrSend) {
        this.log("attaching nostrSend action")
        this.nostrSend = f
        this.setSetIfConfigured()
    }

    setSetIfConfigured = () => {
        if (this.nostrSend && !!this.pubDestination && !!this.clientId && !!this.myPub) {
            this.configured = true
            this.log("configured to send to ", this.pubDestination)
        }
    }

    onEvent = async (res: { requestId: string }, fromPub: string) => {
        if (fromPub !== this.pubDestination) {
            this.log("got event from invalid pub", fromPub, this.pubDestination)
            return false
        }
        if (this.clientCbs[res.requestId]) {
            const cb = this.clientCbs[res.requestId]

            cb.f(res)
            if (cb.type === 'single') {
                delete this.clientCbs[res.requestId]
                this.utils.stateBundler.AddMaxPoint('maxProviderRespTime', Date.now() - cb.startedAtMillis)
            }
            return true
        }
        return false
    }

    clientSend = (to: string, message: NostrRequest): Promise<any> => {
        if (!this.configured || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = makeId(16)
        }
        const reqId = message.requestId
        if (this.clientCbs[reqId]) {
            throw new Error("request was already sent")
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })

        //this.nostrSend(this.relays, to, JSON.stringify(message), this.settings)

        // this.log("subbing  to single send", reqId, message.rpcName || 'no rpc name')
        return new Promise(res => {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'single',
                f: (response: any) => { res(response) },
            }
        })
    }

    clientSub = (to: string, message: NostrRequest, cb: (res: any) => void): void => {
        if (!this.configured || !this.nostrSend) {
            throw new Error("liquidity provider not initialized")
        }
        if (!message.requestId) {
            message.requestId = message.rpcName
        }
        const reqId = message.requestId
        if (!reqId) {
            throw new Error("invalid sub")
        }
        if (this.clientCbs[reqId]) {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'stream',
                f: (response: any) => { cb(response) },
            }
            this.log("sub for", reqId, "was already registered, overriding")
            return
        }
        this.nostrSend({ type: 'client', clientId: this.clientId }, {
            type: 'content',
            pub: to,
            content: JSON.stringify(message)
        })
        this.log("subbing  to stream", reqId)
        this.clientCbs[reqId] = {
            startedAtMillis: Date.now(),
            type: 'stream',
            f: (response: any) => { cb(response) }
        }
    }
    getSingleSubs = () => {
        return Object.entries(this.clientCbs).filter(([_, cb]) => cb.type === 'single')
    }
}

export const makeId = (length: number) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}