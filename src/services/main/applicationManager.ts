import jwt from 'jsonwebtoken'
import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { MainSettings } from './settings.js'
import PaymentManager from './paymentManager.js'
import { InboundOptionals, defaultInvoiceExpiry } from '../storage/paymentStorage.js'
import { ApplicationUser } from '../storage/entity/ApplicationUser.js'
import { PubLogger, getLogger } from '../helpers/logger.js'
import crypto from 'crypto'
import { Application } from '../storage/entity/Application.js'
import { ZapInfo } from '../storage/entity/UserReceivingInvoice.js'
import { nofferEncode, ndebitEncode, OfferPriceType, nmanageEncode } from '@shocknet/clink-sdk'
const TOKEN_EXPIRY_TIME = 2 * 60 * 1000 // 2 minutes, in milliseconds

type NsecLinkingData = {
    serialId: number,
    expiry: number
}
export default class {

    storage: Storage
    settings: MainSettings
    paymentManager: PaymentManager
    nPubLinkingTokens = new Map<string, NsecLinkingData>();
    linkingTokenInterval: NodeJS.Timeout | null = null
    serviceBeaconInterval: NodeJS.Timeout | null = null
    log: PubLogger
    constructor(storage: Storage, settings: MainSettings, paymentManager: PaymentManager) {
        this.log = getLogger({ component: "ApplicationManager" })
        this.storage = storage
        this.settings = settings
        this.paymentManager = paymentManager
        this.StartLinkingTokenInterval()
    }

    StartLinkingTokenInterval() {
        this.linkingTokenInterval = setInterval(() => {
            const now = Date.now();
            for (let [token, data] of this.nPubLinkingTokens) {
                if (data.expiry <= now) {
                    const copy = { ...data }
                    if (this.nPubLinkingTokens.delete(token)) {
                        console.log("Expired an npub linking token for user serial id: ", copy.serialId)
                    }
                }
            }
        }, 60 * 1000); // 1 minute
    }

    async StartAppsServiceBeacon(publishBeacon: (app: Application) => void) {
        this.serviceBeaconInterval = setInterval(async () => {
            try {
                const apps = await this.storage.applicationStorage.GetApplications()
                apps.forEach(app => {
                    publishBeacon(app)
                })
            } catch (e) {
                this.log("error in beacon", (e as any).message)
            }
        }, 60 * 1000)
    }

    Stop() {
        if (this.linkingTokenInterval) {
            clearInterval(this.linkingTokenInterval)
        }
        if (this.serviceBeaconInterval) {
            clearInterval(this.serviceBeaconInterval)
        }
    }
    SignAppToken(appId: string): string {
        return jwt.sign({ appId }, this.settings.jwtSecret);
    }
    DecodeAppToken(token?: string): string {
        if (!token) throw new Error("empty app token provided")
        let t = token
        if (token.startsWith("Bearer ")) {
            t = token.substring("Bearer ".length)
        }
        if (!t) throw new Error("no app token provided")
        const decoded = jwt.verify(token, this.settings.jwtSecret) as { appId?: string }
        if (!decoded.appId) {
            throw new Error("the provided token is not an app token")
        }
        return decoded.appId
    }

    async SetMockAppUserBalance(appId: string, req: Types.SetMockAppUserBalanceRequest) {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const { user } = await this.storage.applicationStorage.GetOrCreateApplicationUser(app, req.user_identifier, 0)
        await this.paymentManager.SetMockUserBalance(user.user.user_id, req.amount)
    }

    async SetMockAppBalance(appId: string, req: Types.SetMockAppBalanceRequest) {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        await this.paymentManager.SetMockUserBalance(app.owner.user_id, req.amount)
    }


    async AddApp(req: Types.AddAppRequest): Promise<Types.AuthApp> {
        const app = await this.storage.applicationStorage.AddApplication(req.name, req.allow_user_creation)
        getLogger({ appName: app.name })("app created")

        return {
            app: {
                id: app.app_id,
                name: app.name,
                balance: app.owner.balance_sats,
                npub: app.nostr_public_key || ""
            },
            auth_token: this.SignAppToken(app.app_id)
        }
    }

    async AuthApp(req: Types.AuthAppRequest): Promise<Types.AuthApp> {
        const app = await this.storage.applicationStorage.GetApplicationByName(req.name)
        if (typeof req.allow_user_creation === 'boolean') {
            await this.storage.applicationStorage.UpdateApplication(app, { allow_user_creation: req.allow_user_creation })
        }
        return {
            app: {
                id: app.app_id,
                name: app.name,
                balance: app.owner.balance_sats,
                npub: app.nostr_public_key || ""
            },
            auth_token: this.SignAppToken(app.app_id)
        }
    }

    async GetApp(appId: string): Promise<Types.Application> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        return {
            name: app.name,
            id: app.app_id,
            balance: app.owner.balance_sats,
            npub: app.nostr_public_key || ""
        }
    }

    async AddAppUser(appId: string, req: Types.AddAppUserRequest): Promise<Types.AppUser> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const log = getLogger({ appName: app.name })
        let u: ApplicationUser
        if (req.fail_if_exists) {
            u = await this.storage.applicationStorage.AddApplicationUser(app, req.identifier, req.balance)
            log(u.identifier, u.user.user_id, "user created")
        } else {
            const { user, created } = await this.storage.applicationStorage.GetOrCreateApplicationUser(app, req.identifier, req.balance)
            u = user
            if (created) log(u.identifier, u.user.user_id, "user created")
        }
        const nostrSettings = this.settings.nostrRelaySettings
        
        const ndebitString = ndebitEncode({ pubkey: app.nostr_public_key!, pointer: u.identifier, relay: nostrSettings.relays[0] })
        log("ðŸ”— [DEBUG] Generated ndebit for user", { userId: u.user.user_id, ndebit: ndebitString })
        
        return {
            identifier: u.identifier,
            info: {
                userId: u.user.user_id,
                balance: u.user.balance_sats,
                max_withdrawable: this.paymentManager.GetMaxPayableInvoice(u.user.balance_sats, true),
                user_identifier: u.identifier,
                network_max_fee_bps: this.settings.lndSettings.feeRateBps,
                network_max_fee_fixed: this.settings.lndSettings.feeFixedLimit,
                service_fee_bps: this.settings.outgoingAppUserInvoiceFeeBps,
                noffer: nofferEncode({ pubkey: app.nostr_public_key!, offer: u.identifier, priceType: OfferPriceType.Spontaneous, relay: nostrSettings.relays[0] }),
                ndebit: ndebitEncode({ pubkey: app.nostr_public_key!, pointer: u.identifier, relay: nostrSettings.relays[0] }),
                nmanage: nmanageEncode({ pubkey: app.nostr_public_key!, pointer: u.identifier, relay: nostrSettings.relays[0] }),
                callback_url: u.callback_url,
                bridge_url: this.settings.bridgeUrl

            },
            max_withdrawable: this.paymentManager.GetMaxPayableInvoice(u.user.balance_sats, true)
        }
    }

    async AddAppInvoice(appId: string, req: Types.AddAppInvoiceRequest): Promise<Types.NewInvoiceResponse> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const { user: payer } = await this.storage.applicationStorage.GetOrCreateApplicationUser(app, req.payer_identifier, 0)
        const opts: InboundOptionals = { callbackUrl: req.http_callback_url, expiry: defaultInvoiceExpiry, expectedPayer: payer.user, linkedApplication: app }
        const invoice = await this.paymentManager.NewInvoice(app.owner.user_id, req.invoice_req, opts)
        getLogger({ appName: app.name })("app invoice created to be paid by", payer.identifier)
        return invoice
    }

    async AddAppUserInvoice(appId: string, req: Types.AddAppUserInvoiceRequest): Promise<Types.NewInvoiceResponse> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const log = getLogger({ appName: app.name })
        const receiver = await this.storage.applicationStorage.GetApplicationUser(app, req.receiver_identifier)
        const { user: payer } = await this.storage.applicationStorage.GetOrCreateApplicationUser(app, req.payer_identifier, 0)
        const cbUrl = req.http_callback_url || receiver.callback_url || ""
        let zapInfo: ZapInfo | undefined = undefined
        if (req.invoice_req.zap) {
            zapInfo = this.paymentManager.validateZapEvent(req.invoice_req.zap, req.invoice_req.amountSats)
        }
        console.log("req.invoice_req.expiry", req.invoice_req.expiry)
        console.log("defaultInvoiceExpiry", defaultInvoiceExpiry)
        const expiry = req.invoice_req.expiry ? Math.min(req.invoice_req.expiry, defaultInvoiceExpiry) : defaultInvoiceExpiry
        console.log("expiry", expiry)
        const opts: InboundOptionals = {
            callbackUrl: cbUrl, expiry: expiry, expectedPayer: payer.user, linkedApplication: app, zapInfo,
            offerId: req.offer_string, payerData: req.payer_data?.data, rejectUnauthorized: req.rejectUnauthorized,
            token: req.token
        }
        const appUserInvoice = await this.paymentManager.NewInvoice(receiver.user.user_id, req.invoice_req, opts)
        return {
            invoice: appUserInvoice.invoice
        }
    }

    async GetAppUser(appId: string, req: Types.GetAppUserRequest): Promise<Types.AppUser> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const user = await this.storage.applicationStorage.GetApplicationUser(app, req.user_identifier)
        const max = this.paymentManager.GetMaxPayableInvoice(user.user.balance_sats, true)
        const nostrSettings = this.settings.nostrRelaySettings
        return {
            max_withdrawable: max, identifier: req.user_identifier, info: {
                userId: user.user.user_id, balance: user.user.balance_sats,
                max_withdrawable: this.paymentManager.GetMaxPayableInvoice(user.user.balance_sats, true),
                user_identifier: user.identifier,
                network_max_fee_bps: this.settings.lndSettings.feeRateBps,
                network_max_fee_fixed: this.settings.lndSettings.feeFixedLimit,
                service_fee_bps: this.settings.outgoingAppUserInvoiceFeeBps,
                noffer: nofferEncode({ pubkey: app.nostr_public_key!, offer: user.identifier, priceType: OfferPriceType.Spontaneous, relay: nostrSettings.relays[0] }),
                ndebit: ndebitEncode({ pubkey: app.nostr_public_key!, pointer: user.identifier, relay: nostrSettings.relays[0] }),
                nmanage: nmanageEncode({ pubkey: app.nostr_public_key!, pointer: user.identifier, relay: nostrSettings.relays[0] }),
                callback_url: user.callback_url,
                bridge_url: this.settings.bridgeUrl
            },
        }
    }

    async PayAppUserInvoice(appId: string, req: Types.PayAppUserInvoiceRequest): Promise<Types.PayInvoiceResponse> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const appUser = await this.storage.applicationStorage.GetApplicationUser(app, req.user_identifier)
        const paid = await this.paymentManager.PayInvoice(appUser.user.user_id, req, app)
        getLogger({ appName: app.name })(appUser.identifier, "invoice paid", paid.amount_paid, "sats")
        return paid
    }

    async SendAppUserToAppUserPayment(appId: string, req: Types.SendAppUserToAppUserPaymentRequest): Promise<void> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const fromUser = await this.storage.applicationStorage.GetApplicationUser(app, req.from_user_identifier)
        const { user: toUser } = await this.storage.applicationStorage.GetOrCreateApplicationUser(app, req.to_user_identifier, 0)
        await this.paymentManager.SendUserToUserPayment(fromUser.user.user_id, toUser.user.user_id, req.amount, app)
        getLogger({ appName: app.name })(toUser.identifier, "received internal payment by", fromUser.identifier, "of", req.amount, "sats")
    }

    async SendAppUserToAppPayment(appId: string, req: Types.SendAppUserToAppPaymentRequest): Promise<void> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const fromUser = await this.storage.applicationStorage.GetApplicationUser(app, req.from_user_identifier)
        await this.paymentManager.SendUserToUserPayment(fromUser.user.user_id, app.owner.user_id, req.amount, app)
        getLogger({ appName: app.name })("app received internal payment by", fromUser.identifier, "of", req.amount, "sats")
    }
    async GetAppUserLNURLInfo(appId: string, req: Types.GetAppUserLNURLInfoRequest): Promise<Types.LnurlPayInfoResponse> {
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const user = await this.storage.applicationStorage.GetApplicationUser(app, req.user_identifier)
        return this.paymentManager.GetLnurlPayInfoFromUser(user.user.user_id, app, { baseUrl: req.base_url_override })
    }

    async GetNPubLinkingState(app_id: string, req: Types.GetNPubLinking): Promise<Types.NPubLinking> {
        console.log("getting npub linking state for", req.user_identifier)
        const app = await this.storage.applicationStorage.GetApplication(app_id);
        const user = await this.storage.applicationStorage.GetApplicationUser(app, req.user_identifier);
        const iter = this.nPubLinkingTokens.keys()
        let result = iter.next()
        while (!result.done) {
            if (this.nPubLinkingTokens.get(result.value)?.serialId === user.serial_id) {
                console.log("found linking token for", req.user_identifier)
                return { state: { type: Types.NPubLinking_state_type.LINKING_TOKEN, linking_token: result.value } }
            }
            result = iter.next()
        }
        if (user.nostr_public_key) {
            console.log("user already has npub", req.user_identifier)
            return { state: { type: Types.NPubLinking_state_type.LINKED_NPUB, linked_npub: user.nostr_public_key } }
        }
        console.log("user has no npub and no linking token", req.user_identifier)
        return { state: { type: Types.NPubLinking_state_type.UNLINKED, unlinked: {} } }
    }

    async RequestNPubLinkingToken(appId: string, req: Types.RequestNPubLinkingTokenRequest, reset: boolean): Promise<Types.RequestNPubLinkingTokenResponse> {
        console.log("requesting npub linking token for", req.user_identifier)
        const app = await this.storage.applicationStorage.GetApplication(appId);
        const user = await this.storage.applicationStorage.GetApplicationUser(app, req.user_identifier);
        if (Array.from(this.nPubLinkingTokens.values()).find(t => t.serialId === user.serial_id)) {
            throw new Error("App user already waiting on linking");
        }
        if (user.nostr_public_key && !reset) {
            throw new Error("User already has an npub");
        }
        const token = crypto.randomBytes(32).toString("hex");
        this.nPubLinkingTokens.set(token, { serialId: user.serial_id, expiry: Date.now() + TOKEN_EXPIRY_TIME })
        console.log("generating linking token for", req.user_identifier)
        return { token };
    }

    async LinkNpubThroughToken(ctx: Types.GuestWithPubContext, req: Types.LinkNPubThroughTokenRequest): Promise<void> {
        console.log("linking npub", ctx.pub, " through token", req.token)
        const entry = this.nPubLinkingTokens.get(req.token)
        if (entry && entry.expiry > Date.now()) {
            const copy = { ...entry }
            const deleted = this.nPubLinkingTokens.delete(req.token)
            if (deleted) {
                await this.storage.applicationStorage.AddNPubToApplicationUser(copy.serialId, ctx.pub)
            } else {
                throw new Error("An uknown error occured")
            }
        } else {
            throw new Error("Token invalid or expired")
        }
        console.log("linked npub", ctx.pub, " through token", req.token)
    }

    async UseInviteLink(ctx: Types.GuestWithPubContext, req: Types.UseInviteLinkRequest): Promise<void> {
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id);
        const inviteToken = await this.storage.applicationStorage.FindInviteToken(req.invite_token);
        if (!inviteToken || inviteToken.used || inviteToken.application.app_id !== ctx.app_id) {
            throw new Error("Invite token not found");
        }
        await this.storage.applicationStorage.AddApplicationUser(app, crypto.randomBytes(32).toString('hex'), 0, ctx.pub)
        await this.storage.applicationStorage.SetInviteTokenAsUsed(inviteToken);

    }


}