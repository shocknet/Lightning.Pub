import * as Types from "../../../proto/autogenerated/ts/types.js";
import ApplicationManager from "./applicationManager.js";
import ProductManager from "./productManager.js";
import Storage from '../storage/index.js'
import LND from "../lnd/lnd.js"
import { ERROR, getLogger } from "../helpers/logger.js";
import { NostrEvent, NostrSend, SendData, SendInitiator } from '../nostr/handler.js';
import { UnsignedEvent } from 'nostr-tools';
import { UserOffer } from '../storage/entity/UserOffer.js';
import { LiquidityManager } from "./liquidityManager.js"
import { NofferData, OfferPriceType, nofferEncode } from '@shocknet/clink-sdk';
import SettingsManager from "./settingsManager.js";

const mapToOfferConfig = (appUserId: string, offer: UserOffer, { pubkey, relay }: { pubkey: string, relay: string }): Types.OfferConfig => {
    const offerStr = offer.offer_id
    const priceType: OfferPriceType = offer.price_sats === 0 ? OfferPriceType.Spontaneous : OfferPriceType.Fixed
    const noffer = nofferEncode({ pubkey, offer: offerStr, priceType, relay, price: offer.price_sats || undefined })
    return {
        label: offer.label,
        price_sats: offer.price_sats,
        callback_url: offer.callback_url,
        payer_data: offer.payer_data || [],
        offer_id: offer.offer_id,
        noffer: noffer,
        default_offer: appUserId === offer.app_user_id,
        createdAtUnix: offer.created_at.getTime(),
        updatedAtUnix: offer.updated_at.getTime(),
        token: offer.bearer_token,
        rejectUnauthorized: offer.rejectUnauthorized,
        blind: offer.blind
    }
}
export class OfferManager {


    _nostrSend: NostrSend | null = null
    settings: SettingsManager
    applicationManager: ApplicationManager
    productManager: ProductManager
    storage: Storage
    lnd: LND
    liquidityManager: LiquidityManager
    logger = getLogger({ component: 'OfferManager' })
    constructor(storage: Storage, settings: SettingsManager, lnd: LND, applicationManager: ApplicationManager, productManager: ProductManager, liquidityManager: LiquidityManager) {
        this.storage = storage
        this.settings = settings
        this.lnd = lnd
        this.applicationManager = applicationManager
        this.productManager = productManager
        this.liquidityManager = liquidityManager
    }

    attachNostrSend = (nostrSend: NostrSend) => {
        this._nostrSend = nostrSend
    }
    nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    async AddUserOffer(ctx: Types.UserContext, req: Types.OfferConfig): Promise<Types.OfferId> {
        const newOffer = await this.storage.offerStorage.AddUserOffer(ctx.app_user_id, {
            payer_data: req.payer_data,
            label: req.label,
            price_sats: req.price_sats,
            callback_url: req.callback_url,
            blind: req.blind,
        })
        return {
            offer_id: newOffer.offer_id
        }
    }

    async DeleteUserOffer(ctx: Types.UserContext, req: Types.OfferId) {
        await this.storage.offerStorage.DeleteUserOffer(ctx.app_user_id, req.offer_id)
    }

    async UpdateUserOffer(ctx: Types.UserContext, req: Types.OfferConfig) {
        await this.storage.offerStorage.UpdateUserOffer(ctx.app_user_id, req.offer_id, {
            payer_data: req.payer_data,
            label: req.label,
            price_sats: req.price_sats,
            callback_url: req.callback_url,
            blind: req.blind,
        })
    }
    async GetUserOfferInvoices(ctx: Types.UserContext, req: Types.GetUserOfferInvoicesReq): Promise<Types.OfferInvoices> {
        const userOffer = await this.storage.offerStorage.GetUserOffer(ctx.app_user_id, req.offer_id)
        if (!userOffer) {
            throw new Error("Offer not found")
        }
        const i = await this.storage.paymentStorage.GetOfferInvoices(req.offer_id, req.include_unpaid)
        return {
            invoices: i.map(i => ({
                invoice: i.invoice,
                offer_id: i.offer_id || "",
                paid_at_unix: i.paid_at_unix,
                amount: i.paid_amount,
                data: i.payer_data || {}
            }))
        }
    }

    async GetUserOffer(ctx: Types.UserContext, req: Types.OfferId): Promise<Types.OfferConfig> {
        const app = await this.applicationManager.GetApp(ctx.app_id)
        if (!app) {
            throw new Error("App not found")
        }
        const offer = await this.storage.offerStorage.GetUserOffer(ctx.app_user_id, req.offer_id)
        if (!offer) {
            throw new Error("Offer not found")
        }
        const nostrSettings = this.settings.getSettings().nostrRelaySettings
        return mapToOfferConfig(ctx.app_user_id, offer, { pubkey: app.npub, relay: nostrSettings.relays[0] })
    }

    async GetUserOffers(ctx: Types.UserContext): Promise<Types.UserOffers> {
        const app = await this.applicationManager.GetApp(ctx.app_id)
        if (!app) {
            throw new Error("App not found")
        }
        const offers = await this.storage.offerStorage.GetUserOffers(ctx.app_user_id)
        const defaultOffer = offers.find(o => o.app_user_id === o.offer_id)
        let toAppend: UserOffer | undefined = undefined
        if (!defaultOffer) {
            toAppend = await this.storage.offerStorage.AddDefaultUserOffer(ctx.app_user_id)
        }
        if (toAppend) {
            offers.push(toAppend)
        }
        const nostrSettings = this.settings.getSettings().nostrRelaySettings
        return {
            offers: offers.map(o => mapToOfferConfig(ctx.app_user_id, o, { pubkey: app.npub, relay: nostrSettings.relays[0] }))
        }
    }

    ValidateExpectedData(userOffer: UserOffer, payerData: any): { passed: false, validated: undefined } | { passed: true, validated: Record<string, string> } {
        const expectedKeys = userOffer.payer_data
        if (!expectedKeys || expectedKeys.length === 0) {
            return { passed: true, validated: {} }
        }
        if (typeof payerData !== 'object' || payerData === null) {
            return { passed: false, validated: undefined }
        }
        const validated: Record<string, string> = {}
        for (const key of expectedKeys) {
            if (typeof payerData[key] !== 'string') {
                return { passed: false, validated: undefined }
            }
            validated[key] = payerData[key]
        }
        return { passed: true, validated }
    }

    async handleClinkOffer(offerReq: NofferData, event: NostrEvent) {
        this.logger("üì• [OFFER REQUEST] Received offer request", {
            fromPub: event.pub,
            appId: event.appId,
            eventId: event.id,
            offer: offerReq.offer,
            amount: offerReq.amount_sats,
            payerData: offerReq.payer_data
        })

        const offerInvoice = await this.getNofferInvoice(offerReq, event.appId)

        if (!offerInvoice.success) {
            const code = offerInvoice.code
            this.logger("‚ùå [OFFER REJECTED] Offer request failed", {
                fromPub: event.pub,
                eventId: event.id,
                code,
                error: codeToMessage(code),
                max: offerInvoice.max
            })
            const e = newNofferResponse(JSON.stringify({ code, error: codeToMessage(code), range: { min: 10, max: offerInvoice.max } }), event)
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
            return
        }

        this.logger("‚úÖ [OFFER SUCCESS] Generated invoice for offer request", {
            fromPub: event.pub,
            eventId: event.id,
            invoice: offerInvoice.invoice.substring(0, 50) + "...",
            offer: offerReq.offer
        })

        const e = newNofferResponse(JSON.stringify({ bolt11: offerInvoice.invoice }), event)
        this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })

        this.logger("üì§ [OFFER RESPONSE] Sent offer response", {
            toPub: event.pub,
            eventId: event.id,
            responseEventId: "generated"
        })
        return
    }

    async HandleDefaultUserOffer(offerReq: NofferData, appId: string, remote: number, { memo, expiry }: { memo?: string, expiry?: number }): Promise<{ success: true, invoice: string } | { success: false, code: number, max: number }> {
        const { amount_sats: amount, offer } = offerReq
        if (!amount || isNaN(amount) || amount < 10 || amount > remote) {
            return { success: false, code: 5, max: remote }
        }
        const res = await this.applicationManager.AddAppUserInvoice(appId, {
            http_callback_url: "", payer_identifier: offer, receiver_identifier: offer,
            invoice_req: { amountSats: amount, memo: memo || "Default CLINK Offer", zap: offerReq.zap, expiry },
            offer_string: 'offer'
        })
        return { success: true, invoice: res.invoice }
    }

    async HandleUserOffer(offerReq: NofferData, appId: string, remote: number): Promise<{ success: true, invoice: string } | { success: false, code: number, max: number }> {
        const { amount_sats: amount, offer } = offerReq
        const userOffer = await this.storage.offerStorage.GetOffer(offer)
        const expiry = offerReq.expires_in_seconds ? offerReq.expires_in_seconds : undefined

        if (!userOffer) {
            return this.HandleDefaultUserOffer(offerReq, appId, remote, { memo: offerReq.description, expiry })
        }
        if (userOffer.app_user_id === userOffer.offer_id) {
            if (userOffer.price_sats !== 0 || userOffer.payer_data) {
                this.logger("default offer has custom price or expected data, resetting")
                await this.storage.offerStorage.UpdateUserOffer(userOffer.app_user_id, userOffer.offer_id, { price_sats: 0, payer_data: null })
                userOffer.price_sats = 0
                userOffer.payer_data = null
            }
        }
        let amt = userOffer.price_sats
        if (userOffer.price_sats === 0) {
            if (!amount || isNaN(amount) || amount < 10 || amount > remote) {
                return { success: false, code: 5, max: remote }
            }
            amt = amount
        }
        const { passed, validated } = this.ValidateExpectedData(userOffer, offerReq.payer_data)
        if (!passed) {
            this.logger("Invalid expected data", validated || {})
            return { success: false, code: 1, max: remote }
        }
        if (offerReq.description && (typeof offerReq.description !== 'string' || offerReq.description.length > 100)) {
            return { success: false, code: 1, max: remote }
        }
        const memo = offerReq.description || userOffer.label
        const res = await this.applicationManager.AddAppUserInvoice(appId, {
            http_callback_url: userOffer.callback_url, payer_identifier: userOffer.app_user_id, receiver_identifier: userOffer.app_user_id,
            invoice_req: { amountSats: amt, memo, zap: offerReq.zap, expiry, blind: userOffer.blind },
            payer_data: validated ? { data: validated } : undefined,
            offer_string: offer,
            rejectUnauthorized: userOffer.rejectUnauthorized,
            token: userOffer.bearer_token
        })
        return { success: true, invoice: res.invoice }
    }

    async getNofferInvoice(offerReq: NofferData, appId: string): Promise<{ success: true, invoice: string } | { success: false, code: number, max: number }> {
        try {
            const { remote } = await this.lnd.ChannelBalance()
            let maxSendable = remote
            if (remote === 0 && (await this.liquidityManager.liquidityProvider.IsReady())) {
                maxSendable = 10_000_000
            }
            const split = offerReq.offer.split(':')
            if (split.length === 1) {
                return this.HandleUserOffer(offerReq, appId, maxSendable)
            } else if (split[0] === 'p') {
                const product = await this.productManager.NewProductInvoice(split[1])
                return { success: true, invoice: product.invoice }
            } else {
                return { success: false, code: 1, max: maxSendable }
            }
        } catch (e: any) {
            getLogger({ component: "noffer" })(ERROR, e.message || e)
            return { success: false, code: 1, max: 0 }
        }
    }

}
const newNofferResponse = (content: string, event: NostrEvent): UnsignedEvent => {
    return {
        content,
        created_at: Math.floor(Date.now() / 1000),
        kind: 21001,
        pubkey: "",
        tags: [
            ['p', event.pub],
            ['e', event.id],
        ],
    }
}
const codeToMessage = (code: number) => {
    switch (code) {
        case 1: return 'Invalid Offer'
        case 2: return 'Temporary Failure'
        case 3: return 'Expired Offer'
        case 4: return 'Unsupported Feature'
        case 5: return 'Invalid Amount'
        default: throw new Error("unknown error code" + code)
    }
}