import crypto from 'crypto';
import * as Types from "../../../proto/autogenerated/ts/types.js";
import ApplicationManager from "./applicationManager.js";
import ProductManager from "./productManager.js";
import Storage from '../storage/index.js'
import LND from "../lnd/lnd.js"
import { ERROR, getLogger } from "../helpers/logger.js";
import { DebitAccess, DebitAccessRules } from '../storage/entity/DebitAccess.js';
import paymentManager from './paymentManager.js';
import { Application } from '../storage/entity/Application.js';
import { ApplicationUser } from '../storage/entity/ApplicationUser.js';
import { NostrEvent, NostrSend, SendData, SendInitiator } from '../nostr/handler.js';
import { UnsignedEvent } from 'nostr-tools';
import { BudgetFrequency, NdebitData, NdebitFailure, NdebitSuccess, NdebitSuccessPayment, RecurringDebitTimeUnit } from 'nostr-tools/lib/types/nip68.js';
import { NofferData } from "nostr-tools/lib/types/nip69.js"
import { UserOffer } from '../storage/entity/UserOffer.js';
import { DeepPartial } from 'typeorm';
import { nip19 } from 'nostr-tools';
import { LoadNosrtSettingsFromEnv } from '../nostr/index.js';

const mapToOfferConfig = (appUserId: string, offer: UserOffer, { pubkey, relay }: { pubkey: string, relay: string }): Types.OfferConfig => {
    if (offer.expected_data) {
        const keys = Object.keys(offer.expected_data)
        for (const key of keys) {
            const v = offer.expected_data[key] as Types.OfferDataType
            if (!Types.OfferDataType[v]) {
                offer.expected_data[key] = Types.OfferDataType.DATA_STRING
            }
        }
    }
    const offerStr = offer.offer_id
    const priceType: nip19.OfferPriceType = offer.price_sats === 0 ? nip19.OfferPriceType.Spontaneous : nip19.OfferPriceType.Fixed
    const noffer = nip19.nofferEncode({ pubkey, offer: offerStr, priceType, relay, price: offer.price_sats || undefined })
    return {
        label: offer.label,
        price_sats: offer.price_sats,
        callback_url: offer.callback_url,
        expected_data: (offer.expected_data || {}) as Record<string, Types.OfferDataType>,
        offer_id: offer.offer_id,
        noffer: noffer,
        default_offer: appUserId === offer.app_user_id
    }
}
export class OfferManager {







    _nostrSend: NostrSend | null = null

    applicationManager: ApplicationManager
    productManager: ProductManager
    storage: Storage
    lnd: LND
    logger = getLogger({ component: 'DebitManager' })
    constructor(storage: Storage, lnd: LND, applicationManager: ApplicationManager, productManager: ProductManager) {
        this.storage = storage
        this.lnd = lnd
        this.applicationManager = applicationManager
        this.productManager = productManager
    }

    attachNostrSend = (nostrSend: NostrSend) => {
        this._nostrSend = nostrSend
    }
    nostrSend: NostrSend = (initiator: SendInitiator, data: SendData, relays?: string[] | undefined) => {
        if (!this._nostrSend) {
            throw new Error("No nostrSend attached")
        }
        this._nostrSend(initiator, data, relays)
    }

    async AddUserOffer(ctx: Types.UserContext, req: Types.OfferConfig): Promise<Types.OfferId> {
        const newOffer = await this.storage.offerStorage.AddUserOffer(ctx.app_user_id, {
            expected_data: req.expected_data,
            label: req.label,
            price_sats: req.price_sats,
            callback_url: req.callback_url,
        })
        return {
            offer_id: newOffer.offer_id
        }
    }

    async DeleteUserOffer(ctx: Types.UserContext, req: Types.OfferId) {
        await this.storage.offerStorage.DeleteUserOffer(ctx.app_user_id, req.offer_id)
    }

    async UpdateUserOffer(ctx: Types.UserContext, req: Types.OfferConfig) {
        await this.storage.offerStorage.UpdateUserOffer(ctx.app_user_id, req.offer_id, {
            expected_data: req.expected_data,
            label: req.label,
            price_sats: req.price_sats,
            callback_url: req.callback_url,
        })
    }

    async GetUserOffer(ctx: Types.UserContext, req: Types.OfferId): Promise<Types.OfferConfig> {
        const app = await this.applicationManager.GetApp(ctx.app_id)
        if (!app) {
            throw new Error("App not found")
        }
        const offer = await this.storage.offerStorage.GetUserOffer(ctx.app_user_id, req.offer_id)
        if (!offer) {
            throw new Error("Offer not found")
        }
        const nostrSettings = LoadNosrtSettingsFromEnv()
        return mapToOfferConfig(ctx.app_user_id, offer, { pubkey: app.npub, relay: nostrSettings.relays[0] })
    }

    async GetUserOffers(ctx: Types.UserContext): Promise<Types.UserOffers> {
        const app = await this.applicationManager.GetApp(ctx.app_id)
        if (!app) {
            throw new Error("App not found")
        }
        const offers = await this.storage.offerStorage.GetUserOffers(ctx.app_user_id)
        const defaultOffer = offers.find(o => o.app_user_id === o.offer_id)
        let toAppend: UserOffer | undefined = undefined
        if (!defaultOffer) {
            toAppend = await this.storage.offerStorage.AddDefaultUserOffer(ctx.app_user_id)
        }
        if (toAppend) {
            offers.push(toAppend)
        }
        const nostrSettings = LoadNosrtSettingsFromEnv()
        return {
            offers: offers.map(o => mapToOfferConfig(ctx.app_user_id, o, { pubkey: app.npub, relay: nostrSettings.relays[0] }))
        }
    }

    ValidateExpectedData(userOffer: UserOffer, payerData: any): { passed: false, validated: undefined } | { passed: true, validated: Record<string, string> } {
        const expected = userOffer.expected_data
        if (!expected) {
            return { passed: true, validated: {} }
        }
        const expectedKeys = Object.keys(expected)
        if (expectedKeys.length === 0) {
            return { passed: true, validated: {} }
        }
        if (typeof payerData !== 'object' || payerData === null) {
            return { passed: false, validated: undefined }
        }
        const validated: Record<string, string> = {}
        for (const key of expectedKeys) {
            if (typeof payerData[key] !== 'string') {
                return { passed: false, validated: undefined }
            }
            validated[key] = payerData[key]
        }
        return { passed: true, validated }
    }

    async handleNip69Noffer(offerReq: NofferData, event: NostrEvent) {
        const offerInvoice = await this.getNofferInvoice(offerReq, event.appId)
        if (!offerInvoice.success) {
            const code = offerInvoice.code
            const e = newNofferResponse(JSON.stringify({ code, error: codeToMessage(code), range: { min: 10, max: offerInvoice.max } }), event)
            this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
            return
        }
        const e = newNofferResponse(JSON.stringify({ bolt11: offerInvoice.invoice }), event)
        this.nostrSend({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } })
        return
    }

    async HandleDefaultUserOffer(offerReq: NofferData, appId: string, remote: number): Promise<{ success: true, invoice: string } | { success: false, code: number, max: number }> {
        const { amount, offer } = offerReq
        if (!amount || isNaN(amount) || amount < 10 || amount > remote) {
            return { success: false, code: 5, max: remote }
        }
        const res = await this.applicationManager.AddAppUserInvoice(appId, {
            http_callback_url: "", payer_identifier: offer, receiver_identifier: offer,
            invoice_req: { amountSats: amount, memo: "Default NIP-69 Offer", zap: offerReq.zap },
            offer_string: 'offer'
        })
        return { success: true, invoice: res.invoice }
    }

    async HandleUserOffer(offerReq: NofferData, appId: string, remote: number): Promise<{ success: true, invoice: string } | { success: false, code: number, max: number }> {
        const { amount, offer } = offerReq
        const userOffer = await this.storage.offerStorage.GetOffer(offer)
        if (!userOffer) {
            return this.HandleDefaultUserOffer(offerReq, appId, remote)
        }
        let amt = userOffer.price_sats
        if (userOffer.price_sats === 0) {
            if (!amount || isNaN(amount) || amount < 10 || amount > remote) {
                return { success: false, code: 5, max: remote }
            }
            amt = amount
        }
        const { passed, validated } = this.ValidateExpectedData(userOffer, offerReq.payer_data)
        if (!passed) {
            return { success: false, code: 1, max: remote }
        }
        const res = await this.applicationManager.AddAppUserInvoice(appId, {
            http_callback_url: userOffer.callback_url, payer_identifier: userOffer.app_user_id, receiver_identifier: userOffer.app_user_id,
            invoice_req: { amountSats: amt, memo: userOffer.label, zap: offerReq.zap },
            payer_data: validated ? { data: validated } : undefined,
            offer_string: offer
        })
        return { success: true, invoice: res.invoice }
    }

    async getNofferInvoice(offerReq: NofferData, appId: string): Promise<{ success: true, invoice: string } | { success: false, code: number, max: number }> {
        try {
            const { remote } = await this.lnd.ChannelBalance()
            const split = offerReq.offer.split(':')
            if (split.length === 1) {
                return this.HandleUserOffer(offerReq, appId, remote)
            } else if (split[0] === 'p') {
                const product = await this.productManager.NewProductInvoice(split[1])
                return { success: true, invoice: product.invoice }
            } else {
                return { success: false, code: 1, max: remote }
            }
        } catch (e: any) {
            getLogger({ component: "noffer" })(ERROR, e.message || e)
            return { success: false, code: 1, max: 0 }
        }
    }

}
const newNofferResponse = (content: string, event: NostrEvent): UnsignedEvent => {
    return {
        content,
        created_at: Math.floor(Date.now() / 1000),
        kind: 21001,
        pubkey: "",
        tags: [
            ['p', event.pub],
            ['e', event.id],
        ],
    }
}
const codeToMessage = (code: number) => {
    switch (code) {
        case 1: return 'Invalid Offer'
        case 2: return 'Temporary Failure'
        case 3: return 'Expired Offer'
        case 4: return 'Unsupported Feature'
        case 5: return 'Invalid Amount'
        default: throw new Error("unknown error code" + code)
    }
}