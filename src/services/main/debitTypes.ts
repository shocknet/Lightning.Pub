import * as Types from "../../../proto/autogenerated/ts/types.js";
import { DebitAccessRules } from '../storage/entity/DebitAccess.js';
import { Application } from '../storage/entity/Application.js';
import { ApplicationUser } from '../storage/entity/ApplicationUser.js';
import { UnsignedEvent } from 'nostr-tools';
import { NdebitFailure, NdebitSuccess, RecurringDebitTimeUnit } from "@shocknet/clink-sdk";

export const expirationRuleName = 'expiration'
export const frequencyRuleName = 'frequency'
export const unitToIntervalType = (unit: RecurringDebitTimeUnit) => {
    switch (unit) {
        case 'day': return Types.IntervalType.DAY
        case 'week': return Types.IntervalType.WEEK
        case 'month': return Types.IntervalType.MONTH
        default: throw new Error("invalid unit")
    }
}
const intervalTypeToUnit = (interval: Types.IntervalType): RecurringDebitTimeUnit => {
    switch (interval) {
        case Types.IntervalType.DAY: return 'day'
        case Types.IntervalType.WEEK: return 'week'
        case Types.IntervalType.MONTH: return 'month'
        default: throw new Error("invalid interval")
    }
}
export const IntervalTypeToSeconds = (interval: Types.IntervalType) => {
    switch (interval) {
        case Types.IntervalType.DAY: return 24 * 60 * 60
        case Types.IntervalType.WEEK: return 7 * 24 * 60 * 60
        case Types.IntervalType.MONTH: return 30 * 24 * 60 * 60
        default: throw new Error("invalid interval")
    }
}
export const debitRulesToDebitAccessRules = (rule: Types.DebitRule[]): DebitAccessRules | undefined => {
    let rules: DebitAccessRules | undefined = undefined
    rule.forEach(r => {
        if (!rules) {
            rules = {}
        }
        const { rule } = r
        switch (rule.type) {
            case Types.DebitRule_rule_type.EXPIRATION_RULE:

                rules[expirationRuleName] = [rule.expiration_rule.expires_at_unix.toString()]
                break
            case Types.DebitRule_rule_type.FREQUENCY_RULE:
                const intervals = rule.frequency_rule.number_of_intervals.toString()
                const unit = intervalTypeToUnit(rule.frequency_rule.interval)
                rules[frequencyRuleName] = [intervals, unit, rule.frequency_rule.amount.toString()];
                break
            default:
                throw new Error("invalid rule")
        }
    })
    return rules
}

export const debitAccessRulesToDebitRules = (rules: DebitAccessRules | null): Types.DebitRule[] => {
    if (!rules) {
        return []
    }
    return Object.entries(rules).map(([key, val]) => {
        switch (key) {
            case expirationRuleName:
                return {
                    rule: {
                        type: Types.DebitRule_rule_type.EXPIRATION_RULE,
                        expiration_rule: {
                            expires_at_unix: +val[0]
                        }
                    }
                }
            case frequencyRuleName:
                return {
                    rule: {
                        type: Types.DebitRule_rule_type.FREQUENCY_RULE,
                        frequency_rule: {
                            number_of_intervals: +val[0],
                            interval: unitToIntervalType(val[1] as RecurringDebitTimeUnit),
                            amount: +val[2]
                        }
                    }
                }
            default:
                throw new Error("invalid rule")
        }
    })
}
export const nofferErrors = {
    1: "Request Denied Warning",
    2: "Temporary Failure",
    3: "Expired Request",
    4: "Rate Limited",
    5: "Invalid Amount",
    6: "Invalid Request",
}
export type AuthRequiredRes = { status: 'authRequired', liveDebitReq: Types.LiveDebitRequest, app: Application, appUser: ApplicationUser }
export type HandleNdebitRes = { status: 'fail', debitRes: NdebitFailure }
    | { status: 'invoicePaid', app: Application, appUser: ApplicationUser, debitRes: NdebitSuccess }
    | AuthRequiredRes
    | { status: 'authOk', debitRes: NdebitSuccess }

export const newNdebitResponse = (content: string, event: { pub: string, id: string }): UnsignedEvent => {
    return {
        content,
        created_at: Math.floor(Date.now() / 1000),
        kind: 21002,
        pubkey: "",
        tags: [
            ['p', event.pub],
            ['e', event.id],
        ],
    }
}