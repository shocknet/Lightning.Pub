import fs, { watchFile } from "fs";
import crypto from 'crypto'
import { ERROR, getLogger } from "../helpers/logger.js";
import Storage from "../storage/index.js";
import * as Types from '../../../proto/autogenerated/ts/types.js'
import LND from "../lnd/lnd.js";
import SettingsManager from "./settingsManager.js";
import { Swaps } from "../lnd/swaps/swaps.js";
import { defaultInvoiceExpiry } from "../storage/paymentStorage.js";
import { TrackedProvider } from "../storage/entity/TrackedProvider.js";
import { NodeInfo } from "../lnd/settings.js";
import { Invoice, Payment, OutputDetail, Transaction, Payment_PaymentStatus, Invoice_InvoiceState } from "../../../proto/lnd/lightning.js";
import { LiquidityProvider } from "./liquidityProvider.js";
/* type TrackedOperation = {
    ts: number
    amount: number
    type: 'user' | 'root'
}

type AssetOperation = {
    ts: number
    amount: number
    tracked?: TrackedOperation
}
type TrackedLndProvider = {
    confirmedBalance: number
    unconfirmedBalance: number
    channelsBalace: number
    payments: AssetOperation[]
    invoices: AssetOperation[]
    incomingTx: AssetOperation[]
    outgoingTx: AssetOperation[]
}
type LndAssetProvider = {
    pubkey: string
    tracked?: TrackedLndProvider
}
type TrackedLiquidityProvider = {
    balance: number
    payments: AssetOperation[]
    invoices: AssetOperation[]
}
type ProviderAssetProvider = {
    pubkey: string
    tracked?: TrackedLiquidityProvider
} */
const ROOT_OP = Types.TrackedOperationType.ROOT
const USER_OP = Types.TrackedOperationType.USER
export class AdminManager {
    settings: SettingsManager
    liquidityProvider: LiquidityProvider | null = null
    storage: Storage
    log = getLogger({ component: "adminManager" })
    adminNpub = ""
    dataDir: string
    adminNpubPath: string
    adminEnrollTokenPath: string
    adminConnectPath: string
    appNprofilePath: string
    interval: NodeJS.Timer
    appNprofile: string
    lnd: LND
    swaps: Swaps
    nostrConnected: boolean = false
    private nostrReset: () => Promise<void> = async () => { this.log("nostr reset not initialized yet") }
    constructor(settings: SettingsManager, storage: Storage, swaps: Swaps) {
        this.settings = settings
        this.storage = storage
        this.swaps = swaps
        this.dataDir = settings.getStorageSettings().dataDir
        this.adminNpubPath = getDataPath(this.dataDir, 'admin.npub')
        this.adminEnrollTokenPath = getDataPath(this.dataDir, 'admin.enroll')
        this.adminConnectPath = getDataPath(this.dataDir, 'admin.connect')
        this.log("AdminManager configured with paths:", {
            dataDir: this.dataDir || process.cwd(),
            adminNpubPath: this.adminNpubPath,
            adminEnrollTokenPath: this.adminEnrollTokenPath,
            adminConnectPath: this.adminConnectPath
        })
        this.appNprofilePath = getDataPath(this.dataDir, 'app.nprofile')
        this.start()
    }

    attachLiquidityProvider(liquidityProvider: LiquidityProvider) {
        this.liquidityProvider = liquidityProvider
    }

    attachNostrReset(f: () => Promise<void>) {
        this.nostrReset = f
    }

    async ResetNostr() {
        await this.nostrReset()
    }

    setLND = (lnd: LND) => {
        this.lnd = lnd
        this.swaps.SetLnd(lnd)
    }

    setNostrConnected = (connected: boolean) => {
        this.nostrConnected = connected
    }

    GetNostrConnected = () => {
        return this.nostrConnected
    }

    setAppNprofile = (nprofile: string) => {
        this.appNprofile = nprofile
        const enrollToken = this.ReadAdminEnrollToken()
        fs.writeFileSync(this.appNprofilePath, this.appNprofile)
        if (enrollToken) {
            const connectString = `${this.appNprofile}:${enrollToken}`
            fs.writeFileSync(this.adminConnectPath, connectString)
            fs.chmodSync(this.adminConnectPath, 0o600)
        }
    }
    Stop = () => {
        clearInterval(this.interval)
    }

    GenerateAdminEnrollToken = async () => {
        const token = crypto.randomBytes(32).toString('hex')
        fs.writeFileSync(this.adminEnrollTokenPath, token)
        fs.chmodSync(this.adminEnrollTokenPath, 0o600)

        const connectString = `${this.appNprofile}:${token}`
        fs.writeFileSync(this.adminConnectPath, connectString)
        fs.chmodSync(this.adminConnectPath, 0o600)
        return token
    }

    start = () => {
        const adminNpub = this.ReadAdminNpub()
        if (adminNpub) {
            this.adminNpub = adminNpub
        } else if (!fs.existsSync(this.adminEnrollTokenPath)) {
            this.GenerateAdminEnrollToken()
        }
        this.interval = setInterval(() => {
            if (!this.adminNpub) {
                return
            }
            const deleted = !fs.existsSync(this.adminNpubPath)
            if (deleted) {
                this.adminNpub = ""
                this.log("admin npub file deleted")
                this.GenerateAdminEnrollToken()
            }
        })
    }

    ReadAdminEnrollToken = () => {
        try {
            return fs.readFileSync(this.adminEnrollTokenPath, 'utf8').trim()
        } catch (err: any) {
            return ""
        }
    }

    ReadAdminNpub = () => {
        try {
            return fs.readFileSync(this.adminNpubPath, 'utf8').trim()
        } catch (err: any) {
            return ""
        }
    }

    GetAdminNpub = () => {
        return this.adminNpub
    }

    ClearExistingAdmin = () => {
        try {
            fs.unlinkSync(this.adminNpubPath)
        } catch (err: any) { }
    }

    PromoteUserToAdmin = async (appId: string, appUserId: string, token: string) => {
        this.log(`Attempting to promote user ${appUserId} to admin.`)
        const app = await this.storage.applicationStorage.GetApplication(appId)
        const appUser = await this.storage.applicationStorage.GetApplicationUser(app, appUserId)
        const npub = appUser.nostr_public_key
        if (!npub) {
            throw new Error("no npub found for user")
        }
        let actualToken
        try {
            actualToken = fs.readFileSync(this.adminEnrollTokenPath, 'utf8').trim()
        } catch (err: any) {
            this.log(ERROR, `Failed to read admin enroll token from ${this.adminEnrollTokenPath}:`, err.message)
            throw new Error("invalid enroll token")
        }
        if (token !== actualToken) {
            this.log(ERROR, `Provided admin token does not match stored token.`)
            throw new Error("invalid enroll token")
        }
        this.log(`Token validated. Writing admin npub ${npub} to ${this.adminNpubPath}`)
        fs.writeFileSync(this.adminNpubPath, npub)
        this.log(`Unlinking enroll token at ${this.adminEnrollTokenPath}`)
        fs.unlinkSync(this.adminEnrollTokenPath)
        this.log(`Unlinking connect file at ${this.adminConnectPath}`)
        fs.unlinkSync(this.adminConnectPath)
        this.adminNpub = npub
        this.log(`User ${npub} successfully promoted to admin in memory.`)
    }

    CreateInviteLink = async (adminNpub: string, sats?: number): Promise<Types.CreateOneTimeInviteLinkResponse> => {
        const adminAppUser = await this.storage.applicationStorage.FindNostrAppUser(adminNpub)
        if (!adminAppUser) {
            throw new Error("Admin user expected but not found!!!");
        }
        const newInviteToken = await this.storage.applicationStorage.AddInviteToken(adminAppUser.application, sats);
        return {
            invitation_link: newInviteToken.inviteToken
        }
    }

    async GetInviteTokenState(ctx: Types.AdminContext, req: Types.GetInviteTokenStateRequest): Promise<Types.GetInviteTokenStateResponse> {
        const inviteToken = await this.storage.applicationStorage.FindInviteToken(req.invite_token);
        if (!inviteToken) {
            throw new Error("Invite token not found");
        }
        return {
            used: inviteToken.used
        }
    }

    async LndGetInfo(): Promise<Types.LndGetInfoResponse> {
        const info = await this.lnd.GetInfo()
        return {
            alias: info.alias,
            synced_to_chain: info.syncedToChain,
            synced_to_graph: info.syncedToGraph,
            watchdog_barking: this.lnd.outgoingOpsLocked

        }
    }

    ListChannels = async (): Promise<Types.LndChannels> => {
        const { channels } = await this.lnd.ListChannels(true)
        const { identityPubkey } = await this.lnd.GetInfo()
        const activity = await this.storage.metricsStorage.GetChannelsActivity()
        const openChannels = await Promise.all(channels.map(async c => {
            const info = await this.lnd.GetChannelInfo(c.chanId)
            const policies = [{ pub: info.node1Pub, policy: info.node1Policy }, { pub: info.node2Pub, policy: info.node2Policy }]
            const myPolicy = policies.find(p => p.pub === identityPubkey)?.policy
            const policy: Types.ChannelPolicy | undefined = myPolicy ? {
                base_fee_msat: Number(myPolicy.feeBaseMsat),
                fee_rate_ppm: Number(myPolicy.feeRateMilliMsat),
                timelock_delta: Number(myPolicy.timeLockDelta),
                max_htlc_msat: Number(myPolicy.maxHtlcMsat),
                min_htlc_msat: Number(myPolicy.minHtlc),

            } : undefined
            return {
                channel_point: c.channelPoint,
                active: c.active,
                capacity: Number(c.capacity),
                local_balance: Number(c.localBalance),
                remote_balance: Number(c.remoteBalance),
                channel_id: c.chanId,
                label: c.peerAlias || c.remotePubkey,
                lifetime: Number(c.lifetime),
                policy,
                inactive_since_unix: activity[c.chanId] || 0
            }
        }))
        return {
            open_channels: openChannels
        }
    }

    async UpdateChannelPolicy(req: Types.UpdateChannelPolicyRequest): Promise<void> {
        const chanPoint = req.update.type === Types.UpdateChannelPolicyRequest_update_type.CHANNEL_POINT ? req.update.channel_point : ""
        const res = await this.lnd.UpdateChannelPolicy(chanPoint, req.policy)
        if (res.failedUpdates.length > 0) {
            this.log(ERROR, "failed to update policy", res.failedUpdates)
            throw new Error("failed to update policy")
        }
    }


    async AddPeer(req: Types.AddPeerRequest) {
        await this.lnd.AddPeer(req.pubkey, req.host, req.port)
    }

    async OpenChannel(req: Types.OpenChannelRequest): Promise<Types.OpenChannelResponse> {
        let closeAddr = req.close_address
        if (!closeAddr) {
            const addr = await this.lnd.NewAddress(Types.AddressType.WITNESS_PUBKEY_HASH, { useProvider: false, from: 'system' })
            closeAddr = addr.address
        }
        const res = await this.lnd.OpenChannel(req.node_pubkey, closeAddr, req.local_funding_amount, req.push_sat || 0, req.sat_per_v_byte)
        return {
            channel_id: Buffer.from(res.pendingChanId).toString('hex')
        }
    }

    async CloseChannel(req: Types.CloseChannelRequest): Promise<Types.CloseChannelResponse> {
        const res = await this.lnd.CloseChannel(req.funding_txid, req.output_index, req.force, req.sat_per_v_byte)
        return {
            closing_txid: Buffer.from(res.txid).toString('hex')
        }
    }

    async ListAdminInvoiceSwaps(): Promise<Types.InvoiceSwapsList> {
        return this.swaps.ListInvoiceSwaps("admin")
    }

    async GetAdminInvoiceSwapQuotes(req: Types.InvoiceSwapRequest): Promise<Types.InvoiceSwapQuoteList> {
        const invoice = await this.lnd.NewInvoice(req.amount_sats, "Admin Swap", defaultInvoiceExpiry, { useProvider: false, from: 'system' })
        const quotes = await this.swaps.GetInvoiceSwapQuotes("admin", invoice.payRequest)
        return { quotes }
    }

    async PayAdminInvoiceSwap(req: Types.PayAdminInvoiceSwapRequest): Promise<Types.AdminInvoiceSwapResponse> {
        const resolvedTxId = await new Promise<string>(res => {
            this.swaps.PayInvoiceSwap("admin", req.swap_operation_id, req.sat_per_v_byte, async (addr, amt) => {
                const tx = await this.lnd.PayAddress(addr, amt, req.sat_per_v_byte, "", { useProvider: false, from: 'system' })
                this.log("paid admin invoice swap", { swapOpId: req.swap_operation_id, txId: tx.txid })
                await this.storage.metricsStorage.AddRootOperation("chain_payment", tx.txid, amt, true)

                // Fetch the full transaction hex for potential refunds
                let lockupTxHex: string | undefined
                let chainFeeSats = 0
                try {
                    const txDetails = await this.lnd.GetTx(tx.txid)
                    chainFeeSats = Number(txDetails.totalFees)
                    lockupTxHex = txDetails.rawTxHex
                } catch (err: any) {
                    this.log("Warning: Could not fetch transaction hex for refund purposes:", err.message)
                }

                await this.storage.paymentStorage.SetInvoiceSwapTxId(req.swap_operation_id, tx.txid, chainFeeSats, lockupTxHex)
                this.log("saved admin swap txid", { swapOpId: req.swap_operation_id, txId: tx.txid })
                res(tx.txid)
                return { txId: tx.txid }
            })
        })
        return { tx_id: resolvedTxId }
    }

    async RefundAdminInvoiceSwap(req: Types.RefundAdminInvoiceSwapRequest): Promise<Types.AdminInvoiceSwapResponse> {
        const info = await this.lnd.GetInfo()
        const currentHeight = info.blockHeight
        const address = await this.lnd.NewAddress(Types.AddressType.WITNESS_PUBKEY_HASH, { useProvider: false, from: 'system' })
        const result = await this.swaps.RefundInvoiceSwap(req.swap_operation_id, req.sat_per_v_byte, address.address, currentHeight)
        if (result.published) {
            return { tx_id: result.txId }
        }
        await this.lnd.PublishTransaction(result.txHex)
        return { tx_id: result.txId }
    }

    async ListAdminTxSwaps(): Promise<Types.TxSwapsList> {
        return this.swaps.ListTxSwaps("admin", [], p => undefined, amt => 0)
    }

    async GetAdminTransactionSwapQuotes(req: Types.TransactionSwapRequest): Promise<Types.TransactionSwapQuoteList> {
        const quotes = await this.swaps.GetTxSwapQuotes("admin", req.transaction_amount_sats, () => 0)
        return { quotes }
    }
    async PayAdminTransactionSwap(req: Types.PayAdminTransactionSwapRequest): Promise<Types.AdminTxSwapResponse> {
        const routingFloor = this.settings.getSettings().lndSettings.routingFeeFloor
        const routingLimit = this.settings.getSettings().lndSettings.routingFeeLimitBps / 10000

        const swap = await this.swaps.PayAddrWithSwap("admin", req.swap_operation_id, req.address, async (invoice, amt) => {
            const r = Math.max(Math.ceil(routingLimit * amt), routingFloor)
            const payment = await this.lnd.PayInvoice(invoice, 0, { routingFeeLimit: r, serviceFee: 0 }, amt, { useProvider: false, from: 'system' })
            await this.storage.metricsStorage.AddRootOperation("invoice_payment", invoice, amt + payment.feeSat)
        })
        return {
            tx_id: swap.txId,
            network_fee: swap.network_fee,
        }
    }

    async GetAssetsAndLiabilities(req: Types.AssetsAndLiabilitiesReq): Promise<Types.AssetsAndLiabilities> {
        const providers = await this.storage.liquidityStorage.GetTrackedProviders()

        const lnds: Types.LndAssetProvider[] = []
        const liquidityProviders: Types.LiquidityAssetProvider[] = []
        for (const provider of providers) {
            if (provider.provider_type === 'lnd') {
                const lndEntry = await this.GetLndAssetsAndLiabilities(req, provider)
                lnds.push(lndEntry)
            } else if (provider.provider_type === 'lnPub') {
                const liquidityEntry = await this.GetProviderAssetsAndLiabilities(req, provider)
                liquidityProviders.push(liquidityEntry)
            }
        }
        const usersBalance = await this.storage.paymentStorage.GetTotalUsersBalance()
        return {
            users_balance: usersBalance,
            lnds,
            liquidity_providers: liquidityProviders,
        }
    }

    async GetProviderAssetsAndLiabilities(req: Types.AssetsAndLiabilitiesReq, provider: TrackedProvider): Promise<Types.LiquidityAssetProvider> {
        if (!this.liquidityProvider) {
            throw new Error("liquidity provider not attached")
        }
        if (this.liquidityProvider.GetProviderPubkey() !== provider.provider_pubkey) {
            return { pubkey: provider.provider_pubkey, tracked: undefined }
        }
        const providerOps = await this.liquidityProvider.GetOperations(req.limit_providers || 100)
        // we only care about invoices cuz they are the only ops we can generate with a provider
        const invoices: Types.AssetOperation[] = []
        const payments: Types.AssetOperation[] = []
        for (const op of providerOps.latestIncomingInvoiceOperations.operations) {
            const assetOp = await this.GetProviderInvoiceAssetOperation(op)
            invoices.push(assetOp)
        }
        for (const op of providerOps.latestOutgoingInvoiceOperations.operations) {
            const assetOp = await this.GetProviderPaymentAssetOperation(op)
            payments.push(assetOp)
        }
        const balance = await this.liquidityProvider.GetUserState()
        return {
            pubkey: provider.provider_pubkey,
            tracked: {
                balance: balance.status === 'OK' ? balance.balance : 0,
                payments,
                invoices,
            }
        }
    }

    async GetProviderInvoiceAssetOperation(op: Types.UserOperation): Promise<Types.AssetOperation> {
        const ts = Number(op.paidAtUnix)
        const amount = Number(op.amount)
        const invoice = op.identifier
        const userInvoice = await this.storage.paymentStorage.GetInvoiceOwner(invoice)
        if (userInvoice) {
            const tracked: Types.TrackedOperation = { ts: userInvoice.paid_at_unix, amount: userInvoice.paid_amount, type: USER_OP }
            return { ts, amount, tracked }
        }
        const rootOp = await this.storage.metricsStorage.GetRootOperation("invoice", invoice)
        if (rootOp) {
            const tracked: Types.TrackedOperation = { ts: rootOp.at_unix, amount: rootOp.operation_amount, type: ROOT_OP }
            return { ts, amount, tracked }
        }
        return { ts, amount, tracked: undefined }
    }

    async GetProviderPaymentAssetOperation(op: Types.UserOperation): Promise<Types.AssetOperation> {
        const ts = Number(op.paidAtUnix)
        const amount = Number(op.amount)
        const invoice = op.identifier
        const userInvoice = await this.storage.paymentStorage.GetPaymentOwner(invoice)
        if (userInvoice) {
            const tracked: Types.TrackedOperation = { ts: userInvoice.paid_at_unix, amount: userInvoice.paid_amount, type: USER_OP }
            return { ts, amount, tracked }
        }
        const rootOp = await this.storage.metricsStorage.GetRootOperation("invoice_payment", invoice)
        if (rootOp) {
            const tracked: Types.TrackedOperation = { ts: rootOp.at_unix, amount: rootOp.operation_amount, type: ROOT_OP }
            return { ts, amount, tracked }
        }
        return { ts, amount, tracked: undefined }
    }

    async GetLndAssetsAndLiabilities(req: Types.AssetsAndLiabilitiesReq, provider: TrackedProvider): Promise<Types.LndAssetProvider> {
        const info = await this.lnd.GetInfo()
        if (provider.provider_pubkey !== info.identityPubkey) {
            return { pubkey: provider.provider_pubkey, tracked: undefined }
        }

        const latestLndPayments = await this.lnd.GetAllPayments(req.limit_payments || 50)
        const payments: Types.AssetOperation[] = []
        for (const payment of latestLndPayments.payments) {
            if (payment.status !== Payment_PaymentStatus.SUCCEEDED) {
                continue
            }
            const assetOp = await this.GetPaymentAssetOperation(payment)
            payments.push(assetOp)
        }
        const invoices: Types.AssetOperation[] = []
        const paidInvoices = await this.lnd.GetAllInvoices(req.limit_invoices || 100)
        for (const invoiceEntry of paidInvoices.invoices) {
            if (invoiceEntry.state !== Invoice_InvoiceState.SETTLED) {
                continue
            }
            const assetOp = await this.GetInvoiceAssetOperation(invoiceEntry)
            invoices.push(assetOp)
        }
        const latestLndTransactions = await this.lnd.GetTransactions(info.blockHeight)
        const txOuts: Types.AssetOperation[] = []
        const txIns: Types.AssetOperation[] = []
        for (const transaction of latestLndTransactions.transactions) {
            for (const output of transaction.outputDetails) {
                if (output.isOurAddress) {
                    const assetOp = await this.GetTxOutAssetOperation(transaction, output)
                    txOuts.push(assetOp)
                }
            }
            // we only produce TXs with a single output
            const input = transaction.previousOutpoints.find(p => p.isOurOutput)
            if (input) {
                const assetOp = await this.GetTxInAssetOperation(transaction)
                txIns.push(assetOp)
            }
        }
        const balance = await this.lnd.GetBalance()
        const channelsBalance = balance.channelsBalance.reduce((acc, c) => acc + Number(c.localBalanceSats), 0)
        return {
            pubkey: provider.provider_pubkey,
            tracked: {
                confirmed_balance: Number(balance.confirmedBalance),
                unconfirmed_balance: Number(balance.unconfirmedBalance),
                channels_balance: channelsBalance,
                payments,
                invoices,
                incoming_tx: txOuts, // tx outputs, are incoming sats
                outgoing_tx: txIns, // tx inputs, are outgoing sats
            }
        }
    }

    async GetPaymentAssetOperation(payment: Payment): Promise<Types.AssetOperation> {
        const invoice = payment.paymentRequest
        const userInvoice = await this.storage.paymentStorage.GetPaymentOwner(invoice)
        const ts = Number(payment.creationTimeNs / (BigInt(1000_000_000)))
        const amount = Number(payment.valueSat)
        if (userInvoice) {
            const tracked: Types.TrackedOperation = { ts: userInvoice.paid_at_unix, amount: userInvoice.paid_amount, type: USER_OP }
            return { ts, amount, tracked }
        }
        const rootOp = await this.storage.metricsStorage.GetRootOperation("invoice_payment", invoice)
        if (rootOp) {
            const tracked: Types.TrackedOperation = { ts: rootOp.at_unix, amount: rootOp.operation_amount, type: ROOT_OP }
            return { ts, amount, tracked }
        }
        return { ts, amount, tracked: undefined }
    }

    async GetInvoiceAssetOperation(invoiceEntry: Invoice): Promise<Types.AssetOperation> {
        const invoice = invoiceEntry.paymentRequest
        const ts = Number(invoiceEntry.settleDate)
        const amount = Number(invoiceEntry.amtPaidSat)
        const userInvoice = await this.storage.paymentStorage.GetInvoiceOwner(invoice)
        if (userInvoice) {
            const tracked: Types.TrackedOperation = { ts: userInvoice.paid_at_unix, amount: userInvoice.paid_amount, type: USER_OP }
            return { ts, amount, tracked }
        }
        const rootOp = await this.storage.metricsStorage.GetRootOperation("invoice", invoice)
        if (rootOp) {
            const tracked: Types.TrackedOperation = { ts: rootOp.at_unix, amount: rootOp.operation_amount, type: ROOT_OP }
            return { ts, amount, tracked }
        }
        return { ts, amount, tracked: undefined }
    }

    async GetTxInAssetOperation(tx: Transaction): Promise<Types.AssetOperation> {
        const ts = Number(tx.timeStamp)
        const amount = Number(tx.amount)
        const userOp = await this.storage.paymentStorage.GetTxHashPaymentOwner(tx.txHash)
        if (userOp) {
            // user transaction payments are actually deprecated from lnd, but we keep this for consstency
            const tracked: Types.TrackedOperation = { ts: userOp.paid_at_unix, amount: userOp.paid_amount, type: USER_OP }
            return { ts, amount, tracked }
        }
        const rootOp = await this.storage.metricsStorage.GetRootOperation("chain_payment", tx.txHash)
        if (rootOp) {
            const tracked: Types.TrackedOperation = { ts: rootOp.at_unix, amount: rootOp.operation_amount, type: ROOT_OP }
            return { ts, amount, tracked }
        }
        return { ts, amount, tracked: undefined }
    }

    async GetTxOutAssetOperation(tx: Transaction, output: OutputDetail): Promise<Types.AssetOperation> {
        const ts = Number(tx.timeStamp)
        const amount = Number(output.amount)
        const outputIndex = Number(output.outputIndex)
        const userOp = await this.storage.paymentStorage.GetAddressReceivingTransactionOwner(output.address, tx.txHash)
        if (userOp) {
            const tracked: Types.TrackedOperation = { ts: userOp.paid_at_unix, amount: userOp.paid_amount, type: USER_OP }
            return { ts, amount, tracked }
        }
        const rootOp = await this.storage.metricsStorage.GetRootAddressTransaction(output.address, tx.txHash, outputIndex)
        if (rootOp) {
            const tracked: Types.TrackedOperation = { ts: rootOp.at_unix, amount: rootOp.operation_amount, type: ROOT_OP }
            return { ts, amount, tracked }
        }
        return { ts, amount, tracked: undefined }
    }

}

const getDataPath = (dataDir: string, dataPath: string) => {
    return dataDir !== "" ? `${dataDir}/${dataPath}` : dataPath
}