import jwt from 'jsonwebtoken'
import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'

import ApplicationManager from './applicationManager.js'
import { OfferPriceType, ndebitEncode, nmanageEncode, nofferEncode } from '@shocknet/clink-sdk'
import { getLogger } from '../helpers/logger.js'
import SettingsManager from './settingsManager.js'
export default class {

    storage: Storage
    settings: SettingsManager
    applicationManager: ApplicationManager
    log = getLogger({ component: 'AppUserManager' })
    constructor(storage: Storage, settings: SettingsManager, applicationManager: ApplicationManager) {
        this.storage = storage
        this.settings = settings
        this.applicationManager = applicationManager
    }
    SignUserToken(userId: string, appId: string, userIdentifier: string): string {
        return jwt.sign({ user_id: userId, app_id: appId, app_user_id: userIdentifier }, this.settings.getStorageSettings().jwtSecret);
    }

    DecodeUserToken(token?: string): { user_id: string, app_id: string, app_user_id: string } {
        if (!token) throw new Error("empty user token provided")
        let t = token
        if (token.startsWith("Bearer ")) {
            t = token.substring("Bearer ".length)
        }
        if (!t) throw new Error("no user token provided")
        const decoded = jwt.verify(token, this.settings.getStorageSettings().jwtSecret) as { user_id: string, app_id: string, app_user_id: string }
        if (!decoded.user_id || !decoded.app_id || !decoded.app_user_id) {
            throw new Error("the provided token is not a valid app user token token")
        }
        this.storage.userStorage.UpsertUserAccess(decoded.user_id, Math.floor(Date.now() / 1000))
        return decoded
    }

    GetHttpCreds(ctx: Types.UserContext): Types.HttpCreds {
        if (!this.settings.getSettings().serviceSettings.allowHttpUpgrade) {
            throw new Error("http upgrade not allowed")
        }
        return {
            url: this.settings.getSettings().serviceSettings.serviceUrl,
            token: this.SignUserToken(ctx.user_id, ctx.app_id, ctx.app_user_id)
        }
    }

    async BanUser(userId: string): Promise<Types.BanUserResponse> {
        const banned = await this.storage.userStorage.BanUser(userId)
        const appUsers = await this.storage.applicationStorage.GetAllAppUsersFromUser(userId)
        return {
            balance_sats: banned.balance_sats,
            banned_app_users: appUsers.map(appUser => ({
                app_id: appUser.application.app_id,
                app_name: appUser.application.name,
                user_identifier: appUser.identifier,
                nostr_pub: appUser.nostr_public_key || ""
            }))
        }
    }

    async GetUserInfo(ctx: Types.UserContext): Promise<Types.UserInfo> {
        const user = await this.storage.userStorage.GetUser(ctx.user_id)
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        const appUser = await this.storage.applicationStorage.GetAppUserFromUser(app, user.user_id)

        if (!appUser) {
            throw new Error(`app user ${ctx.user_id} not found`) // TODO: fix logs doxing
        }
        const nostrSettings = this.settings.getSettings().nostrRelaySettings
        return {
            userId: ctx.user_id,
            balance: user.balance_sats,
            max_withdrawable: this.applicationManager.paymentManager.GetMaxPayableInvoice(user.balance_sats, true),
            user_identifier: appUser.identifier,
            network_max_fee_bps: this.settings.getSettings().lndSettings.feeRateBps,
            network_max_fee_fixed: this.settings.getSettings().lndSettings.feeFixedLimit,
            service_fee_bps: this.settings.getSettings().serviceFeeSettings.outgoingAppUserInvoiceFeeBps,
            noffer: nofferEncode({ pubkey: app.nostr_public_key!, offer: appUser.identifier, priceType: OfferPriceType.Spontaneous, relay: nostrSettings.relays[0] }),
            ndebit: ndebitEncode({ pubkey: app.nostr_public_key!, pointer: appUser.identifier, relay: nostrSettings.relays[0] }),
            nmanage: nmanageEncode({ pubkey: app.nostr_public_key!, pointer: appUser.identifier, relay: nostrSettings.relays[0] }),
            callback_url: appUser.callback_url,
            bridge_url: this.settings.getSettings().serviceSettings.bridgeUrl
        }
    }

    async UpdateCallbackUrl(ctx: Types.UserContext, req: Types.CallbackUrl): Promise<Types.CallbackUrl> {
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id)
        await this.storage.applicationStorage.UpdateUserCallbackUrl(app, ctx.app_user_id, req.url)
        return { url: req.url }
    }

    async NewInvoice(ctx: Types.UserContext, req: Types.NewInvoiceRequest): Promise<Types.NewInvoiceResponse> {
        return this.applicationManager.AddAppUserInvoice(ctx.app_id, {
            http_callback_url: "",
            invoice_req: req,
            payer_identifier: ctx.app_user_id,
            receiver_identifier: ctx.app_user_id
        })
    }

    async PayInvoice(ctx: Types.UserContext, req: Types.PayInvoiceRequest): Promise<Types.PayInvoiceResponse> {
        return this.applicationManager.PayAppUserInvoice(ctx.app_id, {
            amount: req.amount,
            invoice: req.invoice,
            user_identifier: ctx.app_user_id
        })
    }
    async PayAddress(ctx: Types.UserContext, req: Types.PayInvoiceRequest): Promise<Types.PayInvoiceResponse> {
        return this.applicationManager.PayAppUserInvoice(ctx.app_id, {
            amount: req.amount,
            invoice: req.invoice,
            user_identifier: ctx.app_user_id
        })
    }

    async EnrollMessagingToken(ctx: Types.UserContext, req: Types.MessagingToken): Promise<void> {
        const app = await this.storage.applicationStorage.GetApplication(ctx.app_id);
        const user = await this.storage.applicationStorage.GetApplicationUser(app, ctx.app_user_id);
        await this.storage.applicationStorage.UpdateAppUserMessagingToken(user.identifier, req.device_id, req.firebase_messaging_token);
    }

    async CleanupInactiveUsers() {
        this.log("Cleaning up inactive users")
        const inactiveUsers = await this.storage.userStorage.GetInactiveUsers(365)
        const toDelete: { userId: string, appUserIds: string[] }[] = []
        for (const u of inactiveUsers) {
            const user = await this.storage.userStorage.GetUser(u.user_id)
            if (user.balance_sats > 10_000) {
                continue
            }
            const appUsers = await this.storage.applicationStorage.GetAllAppUsersFromUser(u.user_id)
            toDelete.push({ userId: u.user_id, appUserIds: appUsers.map(a => a.identifier) })
        }

        this.log("Found", toDelete.length, "inactive users to delete")
        // await this.RemoveUsers(toDelete)
    }

    async CleanupNeverActiveUsers() {
        this.log("Cleaning up never active users")
        const inactiveUsers = await this.storage.userStorage.GetInactiveUsers(30)
        const toDelete: { userId: string, appUserIds: string[] }[] = []
        for (const u of inactiveUsers) {
            const user = await this.storage.userStorage.GetUser(u.user_id)
            if (user.balance_sats > 0) {
                continue
            }
            const txs = await this.storage.paymentStorage.GetUserReceivingTransactions(u.user_id, 0, 1)
            if (txs.length > 0) {
                continue
            }
            const invoices = await this.storage.paymentStorage.GetUserInvoicesFlaggedAsPaid(user.serial_id, 0, 0, 1)
            if (invoices.length > 0) {
                continue
            }
            const userToUser = await this.storage.paymentStorage.GetUserToUserReceivedPayments(u.user_id, 0, 1)
            if (userToUser.length > 0) {
                continue
            }
            const appUsers = await this.storage.applicationStorage.GetAllAppUsersFromUser(u.user_id)
            toDelete.push({ userId: u.user_id, appUserIds: appUsers.map(a => a.identifier) })
        }

        this.log("Found", toDelete.length, "never active users to delete")
        // await this.RemoveUsers(toDelete) TODO: activate deletion
    }

    async RemoveUsers(toDelete: { userId: string, appUserIds: string[] }[]) {
        this.log("Deleting", toDelete.length, "inactive users")
        for (let i = 0; i < toDelete.length; i++) {
            const { userId, appUserIds } = toDelete[i]
            this.log("Deleting user", userId, "progress", i + 1, "/", toDelete.length)
            await this.storage.StartTransaction(async tx => {
                for (const appUserId of appUserIds) {
                    await this.storage.managementStorage.removeUserGrants(appUserId, tx)
                    await this.storage.offerStorage.DeleteUserOffers(appUserId, tx)
                    await this.storage.debitStorage.RemoveUserDebitAccess(appUserId, tx)
                    await this.storage.applicationStorage.RemoveAppUserDevices(appUserId, tx)

                }
                await this.storage.paymentStorage.RemoveUserInvoices(userId, tx)
                await this.storage.productStorage.RemoveUserProducts(userId, tx)
                await this.storage.paymentStorage.RemoveUserEphemeralKeys(userId, tx)
            })
        }
        this.log("Cleaned up inactive users")
    }
}