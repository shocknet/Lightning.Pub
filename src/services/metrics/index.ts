import fs from 'fs'
import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { Application } from '../storage/entity/Application.js'
import { HtlcEvent, HtlcEvent_EventType } from '../../../proto/lnd/router.js'
import { BalanceInfo } from '../lnd/settings.js'
import { BalanceEvent } from '../storage/entity/BalanceEvent.js'
import { ChannelBalanceEvent } from '../storage/entity/ChannelsBalanceEvent.js'
import LND from '../lnd/lnd.js'
import HtlcTracker from './htlcTracker.js'
import { MainSettings } from '../main/settings.js'
import { getLogger } from '../helpers/logger.js'
import { encodeTLV, usageMetricsToTlv } from '../helpers/tlv.js'
import { ChannelCloseSummary_ClosureType } from '../../../proto/lnd/lightning.js'


export default class Handler {

    storage: Storage
    lnd: LND
    htlcTracker: HtlcTracker
    logger = getLogger({ component: "metrics" })
    constructor(storage: Storage, lnd: LND) {
        this.storage = storage
        this.lnd = lnd
        this.htlcTracker = new HtlcTracker(this.storage)

    }



    async HtlcCb(htlc: HtlcEvent) {
        await this.htlcTracker.onHtlcEvent(htlc)
    }

    async NewBlockCb(height: number, balanceInfo: BalanceInfo) {
        const providers = await this.storage.liquidityStorage.GetTrackedProviders()
        const channels = await this.lnd.GetChannelBalance()
        let providerTotal = 0
        providers.forEach(p => {
            if (p.provider_type === 'lnPub') {
                providerTotal += p.latest_balance
            }
        })
        const balanceEvent: Partial<BalanceEvent> = {
            block_height: height,
            confirmed_chain_balance: balanceInfo.confirmedBalance,
            unconfirmed_chain_balance: balanceInfo.unconfirmedBalance,
            total_chain_balance: balanceInfo.totalBalance,
            channels_balance: Number(channels.localBalance?.sat) || 0,
            external_balance: providerTotal
        }
        const channelsEvents: Partial<ChannelBalanceEvent>[] = balanceInfo.channelsBalance.map(c => ({
            channel_id: c.channelId,
            local_balance_sats: c.localBalanceSats,
            remote_balance_sats: c.remoteBalanceSats,
        }))
        await this.storage.metricsStorage.SaveBalanceEvents(balanceEvent, channelsEvents)
        await this.FetchLatestForwardingEvents()
    }

    async FetchLatestForwardingEvents() {
        const latestIndex = await this.storage.metricsStorage.GetLatestForwardingIndexOffset()
        const res = await this.lnd.GetForwardingHistory(latestIndex)
        const forwards = res.forwardingEvents.map(e => ({ fee: Number(e.fee), chanIdIn: e.chanIdIn, chanIdOut: e.chanIdOut, timestampNs: e.timestampNs.toString(), offset: res.lastOffsetIndex }))
        await Promise.all(forwards.map(async f => {
            await this.storage.metricsStorage.IncrementChannelRouting(f.chanIdIn, { forward_fee_as_input: f.fee, latest_index_offset: f.offset, events_as_input: 1 })
            await this.storage.metricsStorage.IncrementChannelRouting(f.chanIdOut, { forward_fee_as_output: f.fee, latest_index_offset: f.offset, events_as_output: 1 })
        }))
    }

    async GetUsageMetrics(req: Types.UsageMetricReq): Promise<Types.UsageMetrics> {
        if (!req.metrics_file) {
            return this.storage.metricsEventStorage.LoadLatestMetrics(req.limit)
        }
        return this.storage.metricsEventStorage.LoadMetricsFile(req.metrics_file.app_id, req.metrics_file.metrics_name, req.metrics_file.page)
    }

    async GetErrorStats(): Promise<Types.ErrorStats> {
        const last24h = this.storage.metricsEventStorage.getlast24hCache()
        const nowUnix = Math.floor(Date.now() / 1000)
        const stats: Types.ErrorStats = {
            past24h: { errors: 0, total: 0, from_unix: nowUnix - 60 * 60 * 24 },
            past6h: { errors: 0, total: 0, from_unix: nowUnix - 60 * 60 * 6 },
            past1h: { errors: 0, total: 0, from_unix: nowUnix - 60 * 60 },
            past10m: { errors: 0, total: 0, from_unix: nowUnix - 60 * 10 },
            past1m: { errors: 0, total: 0, from_unix: nowUnix - 60 },
        }
        for (let i = last24h.length - 1; i >= 0; i--) {
            const e = last24h[i]
            if (e.ts < stats.past24h.from_unix) {
                break
            }

            stats.past24h.total += e.ok + e.fail
            stats.past24h.errors += e.fail

            if (e.ts >= stats.past6h.from_unix) {
                stats.past6h.total += e.ok + e.fail
                stats.past6h.errors += e.fail
            }

            if (e.ts >= stats.past1h.from_unix) {
                stats.past1h.total += e.ok + e.fail
                stats.past1h.errors += e.fail
            }

            if (e.ts >= stats.past10m.from_unix) {
                stats.past10m.total += e.ok + e.fail
                stats.past10m.errors += e.fail
            }

            if (e.ts >= stats.past1m.from_unix) {
                stats.past1m.total += e.ok + e.fail
                stats.past1m.errors += e.fail
            }
        }
        return stats
    }



    AddMetrics(newMetrics: (Types.RequestMetric & { app_id?: string })[]) {
        newMetrics.forEach(m => {
            const appId = m.app_id || "_root"
            const um: Types.UsageMetric = {
                rpc_name: m.rpcName,
                batch: m.batch,
                nostr: m.nostr,
                batch_size: m.batchSize,
                parsed_in_nano: Number(m.parse - m.start),
                auth_in_nano: Number(m.guard - m.parse),
                validate_in_nano: Number(m.validate - m.guard),
                handle_in_nano: Number(m.handle - m.validate),
                success: !m.error,
                app_id: m.app_id ? m.app_id : "",
                processed_at_ms: m.startMs
            }
            const tlv = usageMetricsToTlv(um)
            this.storage.metricsEventStorage.AddMetricEvent(appId, m.rpcName, encodeTLV(tlv), !m.error)
        })
    }



    /*     addTrackedMetric = (appId: string, method: string, metric: Uint8Array) => {
            if (!this.metaReady) {
                throw new Error("meta metrics not ready")
            }
            const tlvString = Buffer.from(metric).toString("base64")
            if (!this.metrics[appId]) {
                this.metrics[appId] = { app_metrics: {} }
            }
            if (!this.metrics[appId].app_metrics[method]) {
                this.metrics[appId].app_metrics[method] = { base_64_tlvs: [] }
            }
            const len = this.metrics[appId].app_metrics[method].base_64_tlvs.push(tlvString)
            if (len > maxEvents) {
                this.metrics[appId].app_metrics[method].base_64_tlvs.splice(0, len - maxEvents)
            }
        } */

    async GetAppsMetrics(req: Types.AppsMetricsRequest): Promise<Types.AppsMetrics> {
        const dbApps = await this.storage.applicationStorage.GetApplications()
        const apps = await Promise.all(dbApps.map(app => this.GetAppMetrics(req, app)))
        const unlinked = await this.GetAppMetrics(req, null)
        apps.push(unlinked)
        return {
            apps
        }
    }

    async GetAppMetrics(req: Types.AppsMetricsRequest, app: Application | null): Promise<Types.AppMetrics> {
        const totalFees = await this.storage.paymentStorage.GetTotalFeesPaidInApp(app)
        const { receivingInvoices, receivingTransactions, outgoingInvoices, outgoingTransactions, receivingAddresses, userToUser } = await this.storage.paymentStorage.GetAppOperations(app, { from: req.from_unix, to: req.to_unix })
        let totalReceived = 0
        let totalSpent = 0
        let unpaidInvoices = 0
        let feesInRange = 0
        const operations: Types.UserOperation[] = []
        receivingInvoices.forEach(i => {
            if (i.paid_at_unix > 0) {
                totalReceived += i.paid_amount
                feesInRange += i.service_fee
                if (req.include_operations) operations.push({ type: Types.UserOperationType.INCOMING_INVOICE, amount: i.paid_amount, inbound: true, paidAtUnix: i.paid_at_unix, confirmed: true, service_fee: i.service_fee, network_fee: 0, identifier: "", operationId: "", tx_hash: "", internal: i.internal })
            } else {
                unpaidInvoices++
            }
        })
        receivingTransactions.forEach(txs => {
            txs.forEach(tx => {
                if (req.include_operations) operations.push({ type: Types.UserOperationType.INCOMING_TX, amount: tx.paid_amount, inbound: true, paidAtUnix: tx.paid_at_unix, confirmed: tx.confs > 1, service_fee: tx.service_fee, network_fee: 0, identifier: "", operationId: "", tx_hash: tx.tx_hash, internal: tx.internal })
                if (tx.confs > 1) {
                    feesInRange += tx.service_fee
                    totalReceived += tx.paid_amount
                }
            })
        })
        outgoingInvoices.forEach(i => {
            if (req.include_operations) operations.push({ type: Types.UserOperationType.OUTGOING_INVOICE, amount: i.paid_amount, inbound: false, paidAtUnix: i.paid_at_unix, confirmed: true, service_fee: i.service_fees, network_fee: i.routing_fees, identifier: "", operationId: "", tx_hash: "", internal: i.internal })
            totalSpent += i.paid_amount
            feesInRange += i.service_fees
        })
        outgoingTransactions.forEach(tx => {
            if (req.include_operations) operations.push({ type: Types.UserOperationType.OUTGOING_TX, amount: tx.paid_amount, inbound: false, paidAtUnix: tx.paid_at_unix, confirmed: tx.confs > 1, service_fee: tx.service_fees, network_fee: tx.chain_fees, identifier: "", operationId: "", tx_hash: tx.tx_hash, internal: tx.internal })
            totalSpent += tx.paid_amount
            feesInRange += tx.service_fees
        })

        userToUser.forEach(op => {
            if (req.include_operations) operations.push({ type: Types.UserOperationType.INCOMING_USER_TO_USER, amount: op.paid_amount, inbound: true, paidAtUnix: op.paid_at_unix, confirmed: true, service_fee: op.service_fees, network_fee: 0, identifier: "", operationId: "", tx_hash: "", internal: true })
            feesInRange += op.service_fees
        })

        const users = await this.storage.applicationStorage.GetApplicationUsers(app, { from: req.from_unix, to: req.to_unix })

        let totalUserWithBalance = 0
        let totalUserWithNoBalance = 0
        let totalUsersWithNegativeBalance = 0
        let totalAlwaysBeenInactive = 0
        let balanceSum = 0
        let minBalance = Number.MAX_SAFE_INTEGER
        let maxBalance = 0
        await Promise.all(users.map(async u => {
            if (u.user.balance_sats < 0) {
                totalUsersWithNegativeBalance++
            } else if (u.user.balance_sats === 0) {
                const wasActive = await this.storage.paymentStorage.UserHasOutgoingOperation(u.user.user_id)
                totalUserWithNoBalance++
                if (!wasActive) {
                    totalAlwaysBeenInactive++
                }
            } else {
                balanceSum += u.user.balance_sats
                totalUserWithBalance++
                if (u.user.balance_sats < minBalance) {
                    minBalance = u.user.balance_sats
                }
                if (u.user.balance_sats > maxBalance) {
                    maxBalance = u.user.balance_sats
                }
            }
        }))
        return {
            app: {
                name: app ? app.name : "unlinked to app",
                id: app ? app.app_id : "unlinked",
                npub: app ? (app.nostr_public_key || "") : "",
                balance: app ? app.owner.balance_sats : 0,
            },
            users: {
                total: users.length,
                always_been_inactive: totalAlwaysBeenInactive,
                balance_avg: Math.round(balanceSum / totalUserWithBalance),
                balance_median: Math.round((maxBalance + minBalance) / 2),
                no_balance: totalUserWithNoBalance,
                negative_balance: totalUsersWithNegativeBalance,
            },

            received: totalReceived,
            spent: totalSpent,
            available: balanceSum,
            fees: feesInRange,
            total_fees: totalFees,
            invoices: receivingInvoices.length,

            operations: []
        }
    }

    async GetChannelsInfo() {
        const { channels } = await this.lnd.ListChannels()
        let totalActive = 0
        let totalInactive = 0
        channels.forEach(c => {
            if (c.active) {
                totalActive++
            } else {
                totalInactive++
            }
        })
        return {
            totalActive, totalInactive, openChannels: channels
        }
    }
    async GetPendingChannelsInfo() {
        const { pendingForceClosingChannels, pendingOpenChannels } = await this.lnd.ListPendingChannels()
        return { totalPendingClose: pendingForceClosingChannels.length, totalPendingOpen: pendingOpenChannels.length }

    }


    async GetLndMetrics(req: Types.LndMetricsRequest): Promise<Types.LndMetrics> {
        const [chansInfo, pendingChansInfo, closedChansInfo, routing, rootOps] = await Promise.all([
            this.GetChannelsInfo(),
            this.GetPendingChannelsInfo(),
            this.lnd.ListClosedChannels(),
            this.storage.metricsStorage.GetChannelRouting({ from: req.from_unix, to: req.to_unix }),
            this.storage.metricsStorage.GetRootOperations({ from: req.from_unix, to: req.to_unix })
        ])
        const { openChannels, totalActive, totalInactive } = chansInfo
        const { totalPendingOpen, totalPendingClose } = pendingChansInfo
        const { channels: closedChannels } = closedChansInfo
        const rawRouting = routing
        let totalEvents = 0
        let totalFees = 0
        rawRouting.forEach(r => {
            totalEvents += r.events_as_input
            totalFees += r.forward_fee_as_input
        })
        const { chainBalanceEvents } = await this.storage.metricsStorage.GetBalanceEvents({ from: req.from_unix, to: req.to_unix })
        const chainBalance: Types.GraphPoint[] = []
        const chansBalance: Types.GraphPoint[] = []
        const externalBalance: Types.GraphPoint[] = []
        chainBalanceEvents.forEach(e => {
            if (chainBalance.length === 0 || chainBalance[chainBalance.length - 1].y !== e.total_chain_balance) {
                chainBalance.push({ x: e.block_height, y: e.total_chain_balance })
            }

            if (chansBalance.length === 0 || chansBalance[chansBalance.length - 1].y !== e.channels_balance) {
                chansBalance.push({ x: e.block_height, y: e.channels_balance })
            }

            if (externalBalance.length === 0 || externalBalance[externalBalance.length - 1].y !== e.external_balance) {
                externalBalance.push({ x: e.block_height, y: e.external_balance })
            }
        })
        const closed = await Promise.all(closedChannels.filter(c => c.closeType !== ChannelCloseSummary_ClosureType.FUNDING_CANCELED).map(async c => {
            const tx = await this.lnd.GetTx(c.closingTxHash)
            return { capacity: Number(c.capacity), channel_id: c.chanId, closed_height: c.closeHeight, close_tx_timestamp: Number(tx.timeStamp) }
        }))
        return {
            nodes: [{
                chain_balance: chainBalance,
                channel_balance: chansBalance,
                external_balance: externalBalance,
                closing_channels: totalPendingClose,
                pending_channels: totalPendingOpen,
                offline_channels: totalInactive,
                online_channels: totalActive,
                closed_channels: closed,
                open_channels: openChannels.map(c => ({ channel_point: c.channelPoint, active: c.active, capacity: Number(c.capacity), channel_id: c.chanId, lifetime: Number(c.lifetime), local_balance: Number(c.localBalance), remote_balance: Number(c.remoteBalance), label: c.peerAlias })),
                forwarding_events: totalEvents,
                forwarding_fees: totalFees,
                root_ops: rootOps.map(r => ({ amount: r.operation_amount, created_at_unix: r.created_at.getTime(), op_id: r.operation_identifier, op_type: mapRootOpType(r.operation_type) })),
            }],
        }
    }

    async AddRootAddressPaid(address: string, txOutput: { hash: string; index: number }, amount: number) {
        await this.storage.metricsStorage.AddRootOperation("chain", `${address}:${txOutput.hash}:${txOutput.index}`, amount)
    }

    async AddRootInvoicePaid(paymentRequest: string, amount: number) {
        await this.storage.metricsStorage.AddRootOperation("invoice", paymentRequest, amount)
    }
}

const mapRootOpType = (opType: string): Types.OperationType => {
    switch (opType) {
        case "chain": return Types.OperationType.CHAIN_OP
        case "invoice": return Types.OperationType.INVOICE_OP
        default: throw new Error("Unknown operation type")
    }
}