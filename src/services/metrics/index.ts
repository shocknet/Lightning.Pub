import Storage from '../storage/index.js'
import * as Types from '../../../proto/autogenerated/ts/types.js'
import { Application } from '../storage/entity/Application.js'
const maxEvents = 100_000
export default class Handler {
    storage: Storage
    metrics: Types.UsageMetric[] = []
    constructor(storage: Storage) {
        this.storage = storage
    }
    AddMetrics(newMetrics: (Types.RequestMetric & { app_id?: string })[]) {
        const parsed: Types.UsageMetric[] = newMetrics.map(m => ({
            rpc_name: m.rpcName,
            processed_at_nano: m.start.toString(),
            batch: m.batch,
            nostr: m.nostr,
            batch_size: m.batchSize,
            parsed_in_nano: Number(m.parse - m.start),
            auth_in_nano: Number(m.guard - m.parse),
            validate_in_nano: Number(m.validate - m.guard),
            handle_in_nano: Number(m.handle - m.validate),
            success: !m.error,
            app_id: m.app_id ? m.app_id : ""
        }))
        const len = this.metrics.push(...parsed)
        if (len > maxEvents) {
            this.metrics.splice(0, len - maxEvents)
        }
    }
    async GetUsageMetrics(): Promise<Types.UsageMetrics> {
        return {
            metrics: this.metrics
        }
    }
    async GetAppsMetrics(req: Types.AppsMetricsRequest): Promise<Types.AppsMetrics> {
        const dbApps = await this.storage.applicationStorage.GetApplications()
        const apps = await Promise.all(dbApps.map(app => this.GetAppMetrics(req, app)))
        const unlinked = await this.GetAppMetrics(req, null)
        apps.push(unlinked)
        return {
            apps
        }
    }

    async GetAppMetrics(req: Types.AppsMetricsRequest, app: Application | null): Promise<Types.AppMetrics> {
        const { receivingInvoices, receivingTransactions, outgoingInvoices, outgoingTransactions, receivingAddresses, userToUser } = await this.storage.paymentStorage.GetAppOperations(app, { from: req.from_unix, to: req.to_unix })
        const bigUser = req.big_user_sats ? req.big_user_sats : 10_000
        const hugeUser = req.big_user_sats ? req.big_user_sats : 500_000
        let totalReceived = 0
        let totalSpent = 0
        let totalAvailable = 0
        let totalBigUsers = 0
        let totalHugeUsers = 0
        let unpaidInvoices = 0
        const operations: Types.UserOperation[] = []
        receivingInvoices.forEach(i => {
            if (i.paid_at_unix > 0) {
                totalReceived += i.paid_amount
                operations.push({ type: Types.UserOperationType.INCOMING_INVOICE, amount: i.paid_amount, inbound: true, paidAtUnix: i.paid_at_unix, confirmed: true, service_fee: i.service_fee, network_fee: 0, identifier: "", operationId: "" })
            } else {
                unpaidInvoices++
            }
        })
        receivingTransactions.forEach(txs => {
            txs.forEach(tx => {
                operations.push({ type: Types.UserOperationType.INCOMING_TX, amount: tx.paid_amount, inbound: true, paidAtUnix: tx.paid_at_unix, confirmed: tx.confs > 1, service_fee: tx.service_fee, network_fee: 0, identifier: "", operationId: "" })
                if (tx.confs > 1) {
                    totalReceived += tx.paid_amount
                }
            })
        })
        outgoingInvoices.forEach(i => {
            operations.push({ type: Types.UserOperationType.OUTGOING_INVOICE, amount: i.paid_amount, inbound: false, paidAtUnix: i.paid_at_unix, confirmed: true, service_fee: i.service_fees, network_fee: i.routing_fees, identifier: "", operationId: "" })
            totalSpent += i.paid_amount
        })
        outgoingTransactions.forEach(tx => {
            operations.push({ type: Types.UserOperationType.OUTGOING_TX, amount: tx.paid_amount, inbound: false, paidAtUnix: tx.paid_at_unix, confirmed: tx.confs > 1, service_fee: tx.service_fees, network_fee: tx.chain_fees, identifier: "", operationId: "" })
            totalSpent += tx.paid_amount
        })

        userToUser.forEach(op => {
            operations.push({ type: Types.UserOperationType.INCOMING_USER_TO_USER, amount: op.paid_amount, inbound: true, paidAtUnix: op.paid_at_unix, confirmed: true, service_fee: op.service_fees, network_fee: 0, identifier: "", operationId: "" })
        })

        const users = await this.storage.applicationStorage.GetApplicationUsers(app, { from: req.from_unix, to: req.to_unix })

        users.forEach(u => {
            totalAvailable += u.user.balance_sats
            if (u.user.balance_sats > bigUser) {
                totalBigUsers++
            }
            if (u.user.balance_sats > hugeUser) {
                totalHugeUsers++
            }
        })
        return {
            app_name: app ? app.name : "unlinked to app",
            app_id: app ? app.app_id : "unlinked",
            app_npub: app ? (app.nostr_public_key || "") : "",
            app_balance: app ? app.owner.balance_sats : 0,

            total_received: totalReceived,
            total_spent: totalSpent,
            total_available: totalAvailable,

            total_users: users.length,
            total_big_users: totalBigUsers,
            total_huge_users: totalHugeUsers,

            unpaid_invoices: unpaidInvoices,

            operations
        }
    }
}