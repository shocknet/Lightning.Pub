import 'dotenv/config' // TODO - test env
import { generatePrivateKey, getPublicKey } from 'nostr-tools';
import NewServer from '../proto/autogenerated/ts/express_server.js'
import NewClient from '../proto/autogenerated/ts/http_client.js'
import serverOptions from './auth.js';
import GetServerMethods from './services/serverMethods/index.js'
import Main, { LoadMainSettingsFromEnv } from './services/main/index.js'
import * as Types from '../proto/autogenerated/ts/types.js';
import nostrMiddleware from './nostrMiddleware.js'
import { LoadNosrtSettingsFromEnv } from './services/nostr/index.js';
import { expect } from 'chai';
import NostrHandler from './services/nostr/index.js'


const settings = LoadNosrtSettingsFromEnv(true)

const clientPrivateKey = generatePrivateKey()
const clientPublicKey = getPublicKey(Buffer.from(clientPrivateKey, "hex"))

const serverPrivateKey = generatePrivateKey()
const serverPublicKey = getPublicKey(Buffer.from(serverPrivateKey, "hex"))

const testPort = 4000
var userAuthHeader = ""
const client = NewClient({
    baseUrl: `http://localhost:${testPort}`,
    retrieveAdminAuth: async () => (""),
    retrieveGuestAuth: async () => (""),
    retrieveUserAuth: async () => userAuthHeader,
    decryptCallback: async (b) => b,
    encryptCallback: async (b) => b,
    deviceId: "device0"
})
const clientNostr = new NostrHandler({
    allowedPubs: [],
    privateKey: clientPrivateKey,
    publicKey: clientPublicKey,
    relays: settings.relays
}, (event) => {
    console.log(event.content)
})
const mainSettings = LoadMainSettingsFromEnv(true)
const mainHandler = new Main(mainSettings) // TODO - test env file
const serverMethods = GetServerMethods(mainHandler)
const serverNostr = nostrMiddleware(serverMethods, mainHandler, {
    allowedPubs: [clientPublicKey],
    privateKey: serverPrivateKey,
    publicKey: serverPublicKey,
    relays: settings.relays
})
const server = NewServer(serverMethods, { ...serverOptions(mainHandler), throwErrors: true })
export const ignore = false

export const setup = async () => {
    await mainHandler.storage.Connect()
    await mainHandler.lnd.Warmup()
    server.Listen(testPort)
}
export const teardown = async () => {
    clientNostr.Stop()
    serverNostr.Stop()
    mainHandler.lnd.Stop()
    server.Close()
}


export default async (d: (message: string, failure?: boolean) => void) => {
    await client.Health()
    d("health ok")

    console.log(await client.LndGetInfo({ nodeId: 0 }))
    d("lnd info ok")

    const res = await client.AddUser({ name: "test", callbackUrl: "http://...", secret: "shhhhhht" })
    if (res.status === 'ERROR') throw new Error(res.reason)
    console.log(res)
    const user = await mainHandler.storage.GetUser(res.userId)
    console.log(user)
    userAuthHeader = res.authToken
    d("create user ok")

    console.log(await client.NewAddress({ addressType: Types.AddressType.WITNESS_PUBKEY_HASH }))
    d("new address ok")
    await new Promise(res => setTimeout(res, 2000))
    clientNostr.Send(serverPublicKey, JSON.stringify({ requestId: "a", method: '/api/user/chain/new', body: { address_type: 'WITNESS_PUBKEY_HASH' } }))

    const lnurlWithdrawLink = await client.GetLnurlWithdrawLink()
    if (lnurlWithdrawLink.status === 'ERROR') throw new Error(lnurlWithdrawLink.reason)
    const lnurlWithdrawInfo = await client.GetLnurlWithdrawInfo({ k1: lnurlWithdrawLink.k1 })
    const expectedInfo: Partial<Types.LnurlWithdrawInfoResponse> & { status: 'OK' } = {
        status: 'OK',
        tag: "withdrawRequest",
        defaultDescription: "lnurl withdraw from lightning.pub",
        maxWithdrawable: 0,
        minWithdrawable: 0,
    }
    expect(lnurlWithdrawInfo).to.deep.include(expectedInfo)
    d("lnurl info ok")

}
