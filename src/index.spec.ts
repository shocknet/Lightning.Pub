import 'dotenv/config' // TODO - test env
import crypto from 'crypto';
import { generatePrivateKey, getPublicKey } from 'nostr-tools';
import NewServer from '../proto/autogenerated/ts/express_server.js'
import NewClient from '../proto/autogenerated/ts/http_client.js'
import serverOptions from './auth.js';
import GetServerMethods from './services/serverMethods/index.js'
import Main, { LoadMainSettingsFromEnv } from './services/main/index.js'
import * as Types from '../proto/autogenerated/ts/types.js';
import nostrMiddleware from './nostrMiddleware.js'
import { LoadNosrtSettingsFromEnv } from './services/nostr/index.js';
import { expect } from 'chai';
import NostrHandler from './services/nostr/index.js'
import NewNostrClient from '../proto/autogenerated/ts/nostr_client.js'
import { NostrRequest } from '../proto/autogenerated/ts/nostr_transport.js';


const settings = LoadNosrtSettingsFromEnv(true)

const clientPrivateKey = generatePrivateKey()
const clientPublicKey = getPublicKey(clientPrivateKey)

const serverPrivateKey = generatePrivateKey()
const serverPublicKey = getPublicKey(serverPrivateKey)

const testPort = 4000
var userAuthHeader = ""
const client = NewClient({
    baseUrl: `http://localhost:${testPort}`,
    retrieveAdminAuth: async () => (""),
    retrieveGuestAuth: async () => (""),
    retrieveUserAuth: async () => userAuthHeader,
    retrieveAppAuth: async () => (""),
    decryptCallback: async (b) => b,
    encryptCallback: async (b) => b,
    deviceId: "device0"
})
const clientCbs: Record<string, (res: any) => void> = {}
const clientNostrHandler = new NostrHandler({
    allowedPubs: [],
    privateKey: clientPrivateKey,
    publicKey: clientPublicKey,
    relays: settings.relays
}, (e) => {
    const res = JSON.parse(e.content) as { requestId: string }
    if (clientCbs[res.requestId]) {
        const cb = clientCbs[res.requestId]
        cb(res)
        delete clientCbs[res.requestId]
    }
})
const clientSend = (to: string, message: NostrRequest): Promise<any> => {
    console.log("sending", message)
    if (!message.requestId) {
        message.requestId = crypto.randomBytes(20).toString('hex')
    }
    const reqId = message.requestId
    if (clientCbs[reqId]) {
        throw new Error("request was already sent")
    }
    clientNostrHandler.Send(to, JSON.stringify(message))
    return new Promise(res => {
        clientCbs[reqId] = (response: any) => {
            res(response)
        }
    })
}
const clientNostr = NewNostrClient({
    pubDestination: serverPublicKey,
    retrieveNostrUserAuth: async () => { return clientPublicKey }
}, clientSend)
/* new NostrHandler({
    allowedPubs: [],
    privateKey: clientPrivateKey,
    publicKey: clientPublicKey,
    relays: settings.relays
}, (event) => {
    console.log(event.content)
})*/
const mainSettings = LoadMainSettingsFromEnv(true)
const mainHandler = new Main(mainSettings) // TODO - test env file
const serverMethods = GetServerMethods(mainHandler)
const serverNostr = nostrMiddleware(serverMethods, mainHandler, {
    allowedPubs: [clientPublicKey],
    privateKey: serverPrivateKey,
    publicKey: serverPublicKey,
    relays: settings.relays
})
const server = NewServer(serverMethods, { ...serverOptions(mainHandler), throwErrors: true })
export const ignore = false

export const setup = async () => {
    await mainHandler.storage.Connect()
    await mainHandler.lnd.Warmup()
    server.Listen(testPort)
}
export const teardown = async () => {
    clientNostrHandler.Stop()
    serverNostr.Stop()
    mainHandler.lnd.Stop()
    server.Close()
}


export default async (d: (message: string, failure?: boolean) => void) => {
    await client.Health()
    d("health ok")

    console.log(await client.LndGetInfo({ nodeId: 0 }))
    d("lnd info ok")

    const res = await client.AddUser({ name: "test", callbackUrl: "http://...", secret: "shhhhhht" })
    if (res.status === 'ERROR') throw new Error(res.reason)
    console.log(res)
    const user = await mainHandler.storage.userStorage.GetUser(res.userId)
    console.log(user)
    userAuthHeader = res.authToken
    d("create user ok")

    console.log(await client.NewAddress({ addressType: Types.AddressType.WITNESS_PUBKEY_HASH }))
    d("new address ok")
    await new Promise(res => setTimeout(res, 2000))
    //clientNostr.Send(serverPublicKey, JSON.stringify({ requestId: "a", method: '/api/user/chain/new', body: { address_type: 'WITNESS_PUBKEY_HASH' } }))
    const nostrRes = await clientNostr.NewAddress({ addressType: Types.AddressType.WITNESS_PUBKEY_HASH })
    console.log(nostrRes)
    d("nostr ok")
    const lnurlWithdrawLink = await client.GetLnurlWithdrawLink()
    if (lnurlWithdrawLink.status === 'ERROR') throw new Error(lnurlWithdrawLink.reason)
    const lnurlWithdrawInfo = await client.GetLnurlWithdrawInfo({ k1: lnurlWithdrawLink.k1 })
    const expectedInfo: Partial<Types.LnurlWithdrawInfoResponse> & { status: 'OK' } = {
        status: 'OK',
        tag: "withdrawRequest",
        defaultDescription: "lnurl withdraw from lightning.pub",
        maxWithdrawable: 0,
        minWithdrawable: 0,
    }
    expect(lnurlWithdrawInfo).to.deep.include(expectedInfo)
    d("lnurl info ok")

}
