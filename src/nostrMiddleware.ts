import Main from "./services/main/index.js"
import Nostr from "./services/nostr/index.js"
import { NostrEvent, NostrSend, NostrSettings } from "./services/nostr/handler.js"
import * as Types from '../proto/autogenerated/ts/types.js'
import NewNostrTransport, { NostrRequest } from '../proto/autogenerated/ts/nostr_transport.js';
import { ERROR, getLogger } from "./services/helpers/logger.js";
import { UnsignedEvent } from "./services/nostr/tools/event.js";
import { defaultInvoiceExpiry } from "./services/storage/paymentStorage.js";
import { Application } from "./services/storage/entity/Application.js";

export default (serverMethods: Types.ServerMethods, mainHandler: Main, nostrSettings: NostrSettings, onClientEvent: (e: { requestId: string }, fromPub: string) => void): { Stop: () => void, Send: NostrSend } => {
    const log = getLogger({})
    const nostrTransport = NewNostrTransport(serverMethods, {
        NostrUserAuthGuard: async (appId, pub) => {
            const app = await mainHandler.storage.applicationStorage.GetApplication(appId || "")
            const nostrUser = await mainHandler.storage.applicationStorage.GetOrCreateNostrAppUser(app, pub || "")
            return { user_id: nostrUser.user.user_id, app_user_id: nostrUser.identifier, app_id: appId || "" }
        },
        NostrAdminAuthGuard: async (appId, pub) => {
            const adminNpub = mainHandler.adminManager.GetAdminNpub()
            if (!adminNpub) { throw new Error("admin access not configured") }
            if (pub !== adminNpub) { throw new Error("admin access denied") }
            log("admin access from", pub)
            return { admin_id: pub }
        },
        NostrMetricsAuthGuard: async (appId, pub) => {
            const adminNpub = mainHandler.adminManager.GetAdminNpub()
            if (!adminNpub) { throw new Error("admin access not configured") }
            if (pub !== adminNpub) { throw new Error("Metrics unavailable") }
            log("operator access from", pub)
            return { operator_id: pub }
        },
        metricsCallback: metrics => mainHandler.settings.recordPerformance ? mainHandler.metricsManager.AddMetrics(metrics) : null,
        NostrGuestWithPubAuthGuard: async (appId, pub) => {
            if (!pub || !appId) {
                throw new Error("Unknown error occured")
            }
            return { pub, app_id: appId }
        },
        logger: { log: console.log, error: err => log(ERROR, err) },
    })
    const nostr = new Nostr(nostrSettings, event => {
        let j: NostrRequest
        try {
            j = JSON.parse(event.content)
            //log("nostr event", j.rpcName || 'no rpc name') 
        } catch {
            log(ERROR, "invalid json event received", event.content)
            return
        }
        if (event.kind === 21001) {
            const offerReq = j as { offer: string }
            handleNofferEvent(mainHandler, offerReq, event)
                .then(e => nostr.Send({ type: 'app', appId: event.appId }, { type: 'event', event: e, encrypt: { toPub: event.pub } }))
            return
        }
        if (!j.rpcName) {
            onClientEvent(j as { requestId: string }, event.pub)
            return
        }
        if (j.authIdentifier !== event.pub) {
            log(ERROR, "authIdentifier does not match", j.authIdentifier || "--", event.pub)
            return
        }
        nostrTransport({ ...j, appId: event.appId }, res => {
            nostr.Send({ type: 'app', appId: event.appId }, { type: 'content', pub: event.pub, content: JSON.stringify({ ...res, requestId: j.requestId }) })
        }, event.startAtNano, event.startAtMs)
    })
    return { Stop: () => nostr.Stop, Send: (...args) => nostr.Send(...args) }
}

// TODO: move this to paymentManager
const handleNofferEvent = async (mainHandler: Main, offerReq: { offer: string }, event: NostrEvent): Promise<UnsignedEvent> => {
    const app = await mainHandler.storage.applicationStorage.GetApplication(event.appId)
    try {
        const offer = offerReq.offer
        let invoice: string
        const split = offer.split(':')
        if (split.length === 1) {
            const user = await mainHandler.storage.applicationStorage.GetApplicationUser(app, split[0])
            //TODO: add prop def for amount
            const userInvoice = await mainHandler.paymentManager.NewInvoice(user.user.user_id, { amountSats: 1000, memo: "free offer" }, { expiry: defaultInvoiceExpiry, linkedApplication: app })
            invoice = userInvoice.invoice
        } else if (split[0] === 'p') {
            const product = await mainHandler.productManager.NewProductInvoice(split[1])
            invoice = product.invoice
        } else {
            return newNofferResponse(JSON.stringify({ code: 1, message: 'Invalid Offer' }), app, event)
        }
        return newNofferResponse(JSON.stringify({ bolt11: invoice }), app, event)
    } catch (e: any) {
        getLogger({ component: "noffer" })(ERROR, e.message || e)
        return newNofferResponse(JSON.stringify({ code: 1, message: 'Invalid Offer' }), app, event)
    }
}

const newNofferResponse = (content: string, app: Application, event: NostrEvent): UnsignedEvent => {
    return {
        content,
        created_at: Math.floor(Date.now() / 1000),
        kind: 21001,
        pubkey: app.nostr_public_key!,
        tags: [
            ['p', event.pub],
            ['e', event.id],
        ],
    }
}
