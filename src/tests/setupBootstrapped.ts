import { getLogger } from '../services/helpers/logger.js'
import { initMainHandler } from '../services/main/init.js'
import { LoadTestSettingsFromEnv } from '../services/main/settings.js'
import { SendData } from '../services/nostr/handler.js'
import { TestBase, TestUserData } from './testBase.js'
import * as Types from '../../proto/autogenerated/ts/types.js'

export const initBootstrappedInstance = async (T: TestBase) => {
    const settings = LoadTestSettingsFromEnv()
    settings.liquiditySettings.useOnlyLiquidityProvider = true
    settings.liquiditySettings.liquidityProviderPub = T.app.publicKey
    settings.lndSettings.mainNode = settings.lndSettings.thirdNode
    const initialized = await initMainHandler(getLogger({ component: "bootstrapped" }), settings)
    if (!initialized) {
        throw new Error("failed to initialize bootstrapped main handler")
    }
    const { mainHandler: bootstrapped, liquidityProviderInfo, liquidityProviderApp } = initialized
    T.main.attachNostrSend(async (_, data, r) => {
        if (data.type === 'event') {
            throw new Error("unsupported event type")
        }
        if (data.pub !== liquidityProviderInfo.publicKey) {
            throw new Error("invalid pub " + data.pub + " expected " + liquidityProviderInfo.publicKey)
        }
        const j = JSON.parse(data.content) as { requestId: string }
        console.log("sending new operation to provider")
        bootstrapped.liquidityProvider.onEvent(j, T.app.publicKey)
    })
    bootstrapped.liquidityProvider.attachNostrSend(async (_, data, r) => {
        const res = await handleSend(T, data)
        if (data.type === 'event') {
            throw new Error("unsupported event type")
        }
        if (!res) {
            return
        }
        bootstrapped.liquidityProvider.onEvent(res, data.pub)
    })
    bootstrapped.liquidityProvider.setNostrInfo({ clientId: liquidityProviderInfo.clientId, myPub: liquidityProviderInfo.publicKey })
    await new Promise<void>(res => {
        const interval = setInterval(async () => {
            const canHandle = await bootstrapped.liquidityProvider.CanProviderHandle({ action: 'receive', amount: 2000 })
            if (canHandle) {
                clearInterval(interval)
                res()
            } else {
                console.log("waiting for provider to be able to handle the request")
            }
        }, 500)
    })
    const bUser = await bootstrapped.applicationManager.AddAppUser(liquidityProviderApp.appId, { identifier: "user1_bootstrapped", balance: 0, fail_if_exists: true })
    const bootstrappedUser: TestUserData = { userId: bUser.info.userId, appUserIdentifier: bUser.identifier, appId: liquidityProviderApp.appId }
    return {
        bootstrapped, liquidityProviderInfo, liquidityProviderApp, bootstrappedUser, stop: () => {
            bootstrapped.Stop()
        }
    }
}
type TransportRequest = { requestId: string, authIdentifier: string } & (
    { rpcName: 'GetUserInfo' } |
    { rpcName: 'NewInvoice', body: Types.NewInvoiceRequest } |
    { rpcName: 'PayInvoice', body: Types.PayInvoiceRequest } |
    { rpcName: 'GetLiveUserOperations' } |
    { rpcName: "" }
)
const handleSend = async (T: TestBase, data: SendData) => {
    if (data.type === 'event') {
        throw new Error("unsupported event type")
    }
    if (data.pub !== T.app.publicKey) {
        throw new Error("invalid pub")
    }
    const j = JSON.parse(data.content) as TransportRequest
    const app = await T.main.storage.applicationStorage.GetApplication(T.app.appId)
    const nostrUser = await T.main.storage.applicationStorage.GetOrCreateNostrAppUser(app, j.authIdentifier)
    const userCtx = { app_id: app.app_id, user_id: nostrUser.user.user_id, app_user_id: nostrUser.identifier }
    switch (j.rpcName) {
        case 'GetUserInfo':
            const infoRes = await T.main.appUserManager.GetUserInfo(userCtx)
            return { ...infoRes, status: "OK", requestId: j.requestId }
        case 'NewInvoice':
            const genInvoiceRes = await T.main.appUserManager.NewInvoice(userCtx, j.body)
            return { ...genInvoiceRes, status: "OK", requestId: j.requestId }
        case 'PayInvoice':
            const payRes = await T.main.appUserManager.PayInvoice(userCtx, j.body)
            return { ...payRes, status: "OK", requestId: j.requestId }
        case 'GetLiveUserOperations':
            return
        default:
            console.log(data)
            throw new Error("unsupported rpcName " + j.rpcName)
    }
}