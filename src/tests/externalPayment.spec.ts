import { defaultInvoiceExpiry } from '../services/storage/paymentStorage.js'
import { Describe, expect, expectThrowsAsync, runSanityCheck, safelySetUserBalance, TestBase } from './testBase.js'
import * as Types from '../../proto/autogenerated/ts/types.js'
export const ignore = false
export const dev = false
export default async (T: TestBase) => {
    await safelySetUserBalance(T, T.user1, 2000)
    await testSuccessfulExternalPayment(T)
    await testFailedExternalPayment(T)
    await testSuccesfulReceivedExternalChainPayment(T)
    await runSanityCheck(T)
}


const testSuccessfulExternalPayment = async (T: TestBase) => {
    T.d("starting testSuccessfulExternalPayment")
    const application = await T.main.storage.applicationStorage.GetApplication(T.app.appId)
    const invoice = await T.externalAccessToOtherLnd.NewInvoice(500, "test", defaultInvoiceExpiry, { from: 'system', useProvider: false })
    expect(invoice.payRequest).to.startWith("lnbcrt5u")
    T.d("generated 500 sats invoice for external node")

    const pay = await T.main.paymentManager.PayInvoice(T.user1.userId, { invoice: invoice.payRequest, amount: 0 }, application)
    expect(pay.amount_paid).to.be.equal(500)
    T.d("paid 500 sats invoice from user1")
    const u1 = await T.main.storage.userStorage.GetUser(T.user1.userId)
    const owner = await T.main.storage.userStorage.GetUser(application.owner.user_id)
    expect(u1.balance_sats).to.be.equal(1490)
    T.d("user1 balance is now 1490 (2000 - (500 + 10fee))")
    expect(owner.balance_sats).to.be.equal(9)
    T.d("app balance is 9 sats")
}

const testFailedExternalPayment = async (T: TestBase) => {
    T.d("starting testFailedExternalPayment")
    const application = await T.main.storage.applicationStorage.GetApplication(T.app.appId)
    const invoice = await T.externalAccessToOtherLnd.NewInvoice(1500, "test", defaultInvoiceExpiry, { from: 'system', useProvider: false })
    expect(invoice.payRequest).to.startWith("lnbcrt15u")
    T.d("generated 1500 sats invoice for external node")

    await expectThrowsAsync(T.main.paymentManager.PayInvoice(T.user1.userId, { invoice: invoice.payRequest, amount: 0 }, application), "not enough balance to decrement")
    T.d("payment failed as expected, with the expected error message")
    const u1 = await T.main.storage.userStorage.GetUser(T.user1.userId)
    expect(u1.balance_sats).to.be.equal(1490)
    T.d("user1 balance is still 1490")
    const owner = await T.main.storage.userStorage.GetUser(application.owner.user_id)
    expect(owner.balance_sats).to.be.equal(9)
    T.d("app balance is still 9 sats")
}

const testSuccesfulReceivedExternalChainPayment = async (T: TestBase) => {
    T.d("starting testSuccesfulReceivedExternalChainPayment")
    /*     const balanceBefore = await T.main.storage.userStorage.GetUser(T.user1.userId)
        expect(balanceBefore.balance_sats).to.be.equal(0) */
    const user2Address = await T.main.paymentManager.NewAddress({ app_id: T.app.appId, app_user_id: T.user2.appUserIdentifier, user_id: T.user2.userId }, { addressType: Types.AddressType.WITNESS_PUBKEY_HASH })
    expect(user2Address.address).to.startWith("bcrt1")
    T.d("generated external chain address for user2")
    const payment = await T.externalAccessToOtherLnd.PayAddress(user2Address.address, 1000, 3, "test", { from: 'system', useProvider: false })
    expect(payment.txid).to.not.be.undefined
    T.d("paid 1000 sats to user2's external chain address")
    await T.chainTools.mine(1)
    await new Promise(resolve => setTimeout(resolve, 100))
    T.d("mined 1 blocks to confirm the payment")
    const u2 = await T.main.storage.userStorage.GetUser(T.user2.userId)
    expect(u2.balance_sats).to.be.equal(1000)
    T.d("user2 balance is now 1000")
    const payment2 = await T.externalAccessToOtherLnd.PayAddress(user2Address.address, 1000, 3, "test", { from: 'system', useProvider: false })
    expect(payment2.txid).to.not.be.undefined
    T.d("paid 1000 sats to user2's external chain address again")
    await T.chainTools.mine(1)
    await new Promise(resolve => setTimeout(resolve, 100))
    T.d("mined 1 blocks to confirm the payment")
    const u2_2 = await T.main.storage.userStorage.GetUser(T.user2.userId)
    expect(u2_2.balance_sats).to.be.equal(2000)
    T.d("user2 balance is now 2000")
}
