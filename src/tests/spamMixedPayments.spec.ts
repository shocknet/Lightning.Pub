import { disableLoggers } from '../services/helpers/logger.js'
import { defaultInvoiceExpiry } from '../services/storage/paymentStorage.js'
import { Describe, expect, expectThrowsAsync, runSanityCheck, safelySetUserBalance, SetupTest, TestBase } from './testBase.js'
import * as Types from '../../proto/autogenerated/ts/types.js'
export const ignore = false

export default async (T: TestBase) => {
    disableLoggers(["EventsLogManager", "htlcTracker", "watchdog"])
    await safelySetUserBalance(T, T.user1, 2000)
    await testSpamExternalPayment(T)
    await runSanityCheck(T)
}


const testSpamExternalPayment = async (T: TestBase) => {
    T.d("starting testSpamExternalPayment")
    const application = await T.main.storage.applicationStorage.GetApplication(T.app.appId)
    const invoicesForExternal = await Promise.all(new Array(5).fill(0).map(() => T.externalAccessToOtherLnd.NewInvoice(500, "test", defaultInvoiceExpiry)))
    const invoicesForUser2 = await Promise.all(new Array(5).fill(0).map(() => T.main.paymentManager.NewInvoice(T.user2.userId, { amountSats: 500, memo: "test" }, { linkedApplication: application, expiry: defaultInvoiceExpiry })))
    const invoices = invoicesForExternal.map(i => i.payRequest).concat(invoicesForUser2.map(i => i.invoice))
    T.d("generated 10 500 sats mixed invoices between external node and user 2")
    const res = await Promise.all(invoices.map(async (invoice, i) => {
        try {
            const result = await T.main.paymentManager.PayInvoice(T.user1.userId, { invoice: invoice, amount: 0 }, application)
            return { success: true, result }
        } catch (e: any) {
            return { success: false, err: e }
        }
    }))

    const successfulPayments = res.filter(r => r.success) as { success: true, result: Types.PayInvoiceResponse }[]
    const failedPayments = res.filter(r => !r.success)
    failedPayments.forEach(f => expect(f.err).to.be.equal("not enough balance to decrement"))
    expect(successfulPayments.length).to.be.equal(3)
    expect(failedPayments.length).to.be.equal(7)
    T.d("3 payments succeeded, 7 failed as expected")
    const networkPayments = successfulPayments.filter(s => s.result.network_fee > 0)
    const internalPayments = successfulPayments.filter(s => s.result.network_fee === 0)
    expect(networkPayments.length).to.be.equal(1)
    expect(internalPayments.length).to.be.equal(2)
    networkPayments.forEach(s => expect(s.result).to.contain({ amount_paid: 500, service_fee: 3, network_fee: 1 }))
    internalPayments.forEach(s => expect(s.result).to.contain({ amount_paid: 500, service_fee: 3 }))
    const u = await T.main.storage.userStorage.GetUser(T.user1.userId)
    const owner = await T.main.storage.userStorage.GetUser(application.owner.user_id)
    expect(u.balance_sats).to.be.equal(490)
    T.d("user1 balance is now 490 (2000 - (500 + 3 fee + 1 routing + (500 + 3fee) * 2))")
    expect(owner.balance_sats).to.be.equal(9)
    T.d("app balance is 9 sats")

}

