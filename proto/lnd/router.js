// @generated by protobuf-ts 2.8.1 with parameter long_type_number,output_javascript
// @generated from protobuf file "router.proto" (package "routerrpc", syntax proto3)
// tslint:disable
// @generated by protobuf-ts 2.8.1 with parameter long_type_number,output_javascript
// @generated from protobuf file "router.proto" (package "routerrpc", syntax proto3)
// tslint:disable
import { Payment } from "./lightning.js";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ChannelPoint } from "./lightning.js";
import { HTLCAttempt } from "./lightning.js";
import { Failure_FailureCode } from "./lightning.js";
import { Failure } from "./lightning.js";
import { Route } from "./lightning.js";
import { FeatureBit } from "./lightning.js";
import { RouteHint } from "./lightning.js";
/**
 * @generated from protobuf enum routerrpc.HtlcEvent.EventType
 */
export var HtlcEvent_EventType;
(function (HtlcEvent_EventType) {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * @generated from protobuf enum value: SEND = 1;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["SEND"] = 1] = "SEND";
    /**
     * @generated from protobuf enum value: RECEIVE = 2;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["RECEIVE"] = 2] = "RECEIVE";
    /**
     * @generated from protobuf enum value: FORWARD = 3;
     */
    HtlcEvent_EventType[HtlcEvent_EventType["FORWARD"] = 3] = "FORWARD";
})(HtlcEvent_EventType || (HtlcEvent_EventType = {}));
/**
 * @generated from protobuf enum routerrpc.FailureDetail
 */
export var FailureDetail;
(function (FailureDetail) {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    FailureDetail[FailureDetail["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * @generated from protobuf enum value: NO_DETAIL = 1;
     */
    FailureDetail[FailureDetail["NO_DETAIL"] = 1] = "NO_DETAIL";
    /**
     * @generated from protobuf enum value: ONION_DECODE = 2;
     */
    FailureDetail[FailureDetail["ONION_DECODE"] = 2] = "ONION_DECODE";
    /**
     * @generated from protobuf enum value: LINK_NOT_ELIGIBLE = 3;
     */
    FailureDetail[FailureDetail["LINK_NOT_ELIGIBLE"] = 3] = "LINK_NOT_ELIGIBLE";
    /**
     * @generated from protobuf enum value: ON_CHAIN_TIMEOUT = 4;
     */
    FailureDetail[FailureDetail["ON_CHAIN_TIMEOUT"] = 4] = "ON_CHAIN_TIMEOUT";
    /**
     * @generated from protobuf enum value: HTLC_EXCEEDS_MAX = 5;
     */
    FailureDetail[FailureDetail["HTLC_EXCEEDS_MAX"] = 5] = "HTLC_EXCEEDS_MAX";
    /**
     * @generated from protobuf enum value: INSUFFICIENT_BALANCE = 6;
     */
    FailureDetail[FailureDetail["INSUFFICIENT_BALANCE"] = 6] = "INSUFFICIENT_BALANCE";
    /**
     * @generated from protobuf enum value: INCOMPLETE_FORWARD = 7;
     */
    FailureDetail[FailureDetail["INCOMPLETE_FORWARD"] = 7] = "INCOMPLETE_FORWARD";
    /**
     * @generated from protobuf enum value: HTLC_ADD_FAILED = 8;
     */
    FailureDetail[FailureDetail["HTLC_ADD_FAILED"] = 8] = "HTLC_ADD_FAILED";
    /**
     * @generated from protobuf enum value: FORWARDS_DISABLED = 9;
     */
    FailureDetail[FailureDetail["FORWARDS_DISABLED"] = 9] = "FORWARDS_DISABLED";
    /**
     * @generated from protobuf enum value: INVOICE_CANCELED = 10;
     */
    FailureDetail[FailureDetail["INVOICE_CANCELED"] = 10] = "INVOICE_CANCELED";
    /**
     * @generated from protobuf enum value: INVOICE_UNDERPAID = 11;
     */
    FailureDetail[FailureDetail["INVOICE_UNDERPAID"] = 11] = "INVOICE_UNDERPAID";
    /**
     * @generated from protobuf enum value: INVOICE_EXPIRY_TOO_SOON = 12;
     */
    FailureDetail[FailureDetail["INVOICE_EXPIRY_TOO_SOON"] = 12] = "INVOICE_EXPIRY_TOO_SOON";
    /**
     * @generated from protobuf enum value: INVOICE_NOT_OPEN = 13;
     */
    FailureDetail[FailureDetail["INVOICE_NOT_OPEN"] = 13] = "INVOICE_NOT_OPEN";
    /**
     * @generated from protobuf enum value: MPP_INVOICE_TIMEOUT = 14;
     */
    FailureDetail[FailureDetail["MPP_INVOICE_TIMEOUT"] = 14] = "MPP_INVOICE_TIMEOUT";
    /**
     * @generated from protobuf enum value: ADDRESS_MISMATCH = 15;
     */
    FailureDetail[FailureDetail["ADDRESS_MISMATCH"] = 15] = "ADDRESS_MISMATCH";
    /**
     * @generated from protobuf enum value: SET_TOTAL_MISMATCH = 16;
     */
    FailureDetail[FailureDetail["SET_TOTAL_MISMATCH"] = 16] = "SET_TOTAL_MISMATCH";
    /**
     * @generated from protobuf enum value: SET_TOTAL_TOO_LOW = 17;
     */
    FailureDetail[FailureDetail["SET_TOTAL_TOO_LOW"] = 17] = "SET_TOTAL_TOO_LOW";
    /**
     * @generated from protobuf enum value: SET_OVERPAID = 18;
     */
    FailureDetail[FailureDetail["SET_OVERPAID"] = 18] = "SET_OVERPAID";
    /**
     * @generated from protobuf enum value: UNKNOWN_INVOICE = 19;
     */
    FailureDetail[FailureDetail["UNKNOWN_INVOICE"] = 19] = "UNKNOWN_INVOICE";
    /**
     * @generated from protobuf enum value: INVALID_KEYSEND = 20;
     */
    FailureDetail[FailureDetail["INVALID_KEYSEND"] = 20] = "INVALID_KEYSEND";
    /**
     * @generated from protobuf enum value: MPP_IN_PROGRESS = 21;
     */
    FailureDetail[FailureDetail["MPP_IN_PROGRESS"] = 21] = "MPP_IN_PROGRESS";
    /**
     * @generated from protobuf enum value: CIRCULAR_ROUTE = 22;
     */
    FailureDetail[FailureDetail["CIRCULAR_ROUTE"] = 22] = "CIRCULAR_ROUTE";
})(FailureDetail || (FailureDetail = {}));
/**
 * @generated from protobuf enum routerrpc.PaymentState
 */
export var PaymentState;
(function (PaymentState) {
    /**
     *
     * Payment is still in flight.
     *
     * @generated from protobuf enum value: IN_FLIGHT = 0;
     */
    PaymentState[PaymentState["IN_FLIGHT"] = 0] = "IN_FLIGHT";
    /**
     *
     * Payment completed successfully.
     *
     * @generated from protobuf enum value: SUCCEEDED = 1;
     */
    PaymentState[PaymentState["SUCCEEDED"] = 1] = "SUCCEEDED";
    /**
     *
     * There are more routes to try, but the payment timeout was exceeded.
     *
     * @generated from protobuf enum value: FAILED_TIMEOUT = 2;
     */
    PaymentState[PaymentState["FAILED_TIMEOUT"] = 2] = "FAILED_TIMEOUT";
    /**
     *
     * All possible routes were tried and failed permanently. Or were no
     * routes to the destination at all.
     *
     * @generated from protobuf enum value: FAILED_NO_ROUTE = 3;
     */
    PaymentState[PaymentState["FAILED_NO_ROUTE"] = 3] = "FAILED_NO_ROUTE";
    /**
     *
     * A non-recoverable error has occurred.
     *
     * @generated from protobuf enum value: FAILED_ERROR = 4;
     */
    PaymentState[PaymentState["FAILED_ERROR"] = 4] = "FAILED_ERROR";
    /**
     *
     * Payment details incorrect (unknown hash, invalid amt or
     * invalid final cltv delta)
     *
     * @generated from protobuf enum value: FAILED_INCORRECT_PAYMENT_DETAILS = 5;
     */
    PaymentState[PaymentState["FAILED_INCORRECT_PAYMENT_DETAILS"] = 5] = "FAILED_INCORRECT_PAYMENT_DETAILS";
    /**
     *
     * Insufficient local balance.
     *
     * @generated from protobuf enum value: FAILED_INSUFFICIENT_BALANCE = 6;
     */
    PaymentState[PaymentState["FAILED_INSUFFICIENT_BALANCE"] = 6] = "FAILED_INSUFFICIENT_BALANCE";
})(PaymentState || (PaymentState = {}));
/**
 * @generated from protobuf enum routerrpc.ResolveHoldForwardAction
 */
export var ResolveHoldForwardAction;
(function (ResolveHoldForwardAction) {
    /**
     * @generated from protobuf enum value: SETTLE = 0;
     */
    ResolveHoldForwardAction[ResolveHoldForwardAction["SETTLE"] = 0] = "SETTLE";
    /**
     * @generated from protobuf enum value: FAIL = 1;
     */
    ResolveHoldForwardAction[ResolveHoldForwardAction["FAIL"] = 1] = "FAIL";
    /**
     * @generated from protobuf enum value: RESUME = 2;
     */
    ResolveHoldForwardAction[ResolveHoldForwardAction["RESUME"] = 2] = "RESUME";
})(ResolveHoldForwardAction || (ResolveHoldForwardAction = {}));
/**
 * @generated from protobuf enum routerrpc.ChanStatusAction
 */
export var ChanStatusAction;
(function (ChanStatusAction) {
    /**
     * @generated from protobuf enum value: ENABLE = 0;
     */
    ChanStatusAction[ChanStatusAction["ENABLE"] = 0] = "ENABLE";
    /**
     * @generated from protobuf enum value: DISABLE = 1;
     */
    ChanStatusAction[ChanStatusAction["DISABLE"] = 1] = "DISABLE";
    /**
     * @generated from protobuf enum value: AUTO = 2;
     */
    ChanStatusAction[ChanStatusAction["AUTO"] = 2] = "AUTO";
})(ChanStatusAction || (ChanStatusAction = {}));
// @generated message type with reflection information, may provide speed optimized methods
class SendPaymentRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.SendPaymentRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "amt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 12, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "timeout_seconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "fee_limit_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 13, name: "fee_limit_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 19, name: "outgoing_chan_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 14, name: "last_hop_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "cltv_limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "route_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteHint },
            { no: 11, name: "dest_custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 15, name: "allow_self_payment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "dest_features", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["lnrpc.FeatureBit", FeatureBit] },
            { no: 17, name: "max_parts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "max_shard_size_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 22, name: "amp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "time_pref", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { dest: new Uint8Array(0), amt: 0, amtMsat: 0, paymentHash: new Uint8Array(0), finalCltvDelta: 0, paymentAddr: new Uint8Array(0), paymentRequest: "", timeoutSeconds: 0, feeLimitSat: 0, feeLimitMsat: 0, outgoingChanId: "0", outgoingChanIds: [], lastHopPubkey: new Uint8Array(0), cltvLimit: 0, routeHints: [], destCustomRecords: {}, allowSelfPayment: false, destFeatures: [], maxParts: 0, noInflightUpdates: false, maxShardSizeMsat: 0, amp: false, timePref: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* int64 amt */ 2:
                    message.amt = reader.int64().toNumber();
                    break;
                case /* int64 amt_msat */ 12:
                    message.amtMsat = reader.int64().toNumber();
                    break;
                case /* bytes payment_hash */ 3:
                    message.paymentHash = reader.bytes();
                    break;
                case /* int32 final_cltv_delta */ 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* bytes payment_addr */ 20:
                    message.paymentAddr = reader.bytes();
                    break;
                case /* string payment_request */ 5:
                    message.paymentRequest = reader.string();
                    break;
                case /* int32 timeout_seconds */ 6:
                    message.timeoutSeconds = reader.int32();
                    break;
                case /* int64 fee_limit_sat */ 7:
                    message.feeLimitSat = reader.int64().toNumber();
                    break;
                case /* int64 fee_limit_msat */ 13:
                    message.feeLimitMsat = reader.int64().toNumber();
                    break;
                case /* uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING];*/ 8:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* repeated uint64 outgoing_chan_ids */ 19:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.outgoingChanIds.push(reader.uint64().toNumber());
                    else
                        message.outgoingChanIds.push(reader.uint64().toNumber());
                    break;
                case /* bytes last_hop_pubkey */ 14:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case /* int32 cltv_limit */ 9:
                    message.cltvLimit = reader.int32();
                    break;
                case /* repeated lnrpc.RouteHint route_hints */ 10:
                    message.routeHints.push(RouteHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint64, bytes> dest_custom_records */ 11:
                    this.binaryReadMap11(message.destCustomRecords, reader, options);
                    break;
                case /* bool allow_self_payment */ 15:
                    message.allowSelfPayment = reader.bool();
                    break;
                case /* repeated lnrpc.FeatureBit dest_features */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.destFeatures.push(reader.int32());
                    else
                        message.destFeatures.push(reader.int32());
                    break;
                case /* uint32 max_parts */ 17:
                    message.maxParts = reader.uint32();
                    break;
                case /* bool no_inflight_updates */ 18:
                    message.noInflightUpdates = reader.bool();
                    break;
                case /* uint64 max_shard_size_msat */ 21:
                    message.maxShardSizeMsat = reader.uint64().toNumber();
                    break;
                case /* bool amp */ 22:
                    message.amp = reader.bool();
                    break;
                case /* double time_pref */ 23:
                    message.timePref = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap11(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field routerrpc.SendPaymentRequest.dest_custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.dest);
        /* int64 amt = 2; */
        if (message.amt !== 0)
            writer.tag(2, WireType.Varint).int64(message.amt);
        /* int64 amt_msat = 12; */
        if (message.amtMsat !== 0)
            writer.tag(12, WireType.Varint).int64(message.amtMsat);
        /* bytes payment_hash = 3; */
        if (message.paymentHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.paymentHash);
        /* int32 final_cltv_delta = 4; */
        if (message.finalCltvDelta !== 0)
            writer.tag(4, WireType.Varint).int32(message.finalCltvDelta);
        /* bytes payment_addr = 20; */
        if (message.paymentAddr.length)
            writer.tag(20, WireType.LengthDelimited).bytes(message.paymentAddr);
        /* string payment_request = 5; */
        if (message.paymentRequest !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paymentRequest);
        /* int32 timeout_seconds = 6; */
        if (message.timeoutSeconds !== 0)
            writer.tag(6, WireType.Varint).int32(message.timeoutSeconds);
        /* int64 fee_limit_sat = 7; */
        if (message.feeLimitSat !== 0)
            writer.tag(7, WireType.Varint).int64(message.feeLimitSat);
        /* int64 fee_limit_msat = 13; */
        if (message.feeLimitMsat !== 0)
            writer.tag(13, WireType.Varint).int64(message.feeLimitMsat);
        /* uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(8, WireType.Varint).uint64(message.outgoingChanId);
        /* repeated uint64 outgoing_chan_ids = 19; */
        if (message.outgoingChanIds.length) {
            writer.tag(19, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.outgoingChanIds.length; i++)
                writer.uint64(message.outgoingChanIds[i]);
            writer.join();
        }
        /* bytes last_hop_pubkey = 14; */
        if (message.lastHopPubkey.length)
            writer.tag(14, WireType.LengthDelimited).bytes(message.lastHopPubkey);
        /* int32 cltv_limit = 9; */
        if (message.cltvLimit !== 0)
            writer.tag(9, WireType.Varint).int32(message.cltvLimit);
        /* repeated lnrpc.RouteHint route_hints = 10; */
        for (let i = 0; i < message.routeHints.length; i++)
            RouteHint.internalBinaryWrite(message.routeHints[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* map<uint64, bytes> dest_custom_records = 11; */
        for (let k of Object.keys(message.destCustomRecords))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.destCustomRecords[k]).join();
        /* bool allow_self_payment = 15; */
        if (message.allowSelfPayment !== false)
            writer.tag(15, WireType.Varint).bool(message.allowSelfPayment);
        /* repeated lnrpc.FeatureBit dest_features = 16; */
        if (message.destFeatures.length) {
            writer.tag(16, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.destFeatures.length; i++)
                writer.int32(message.destFeatures[i]);
            writer.join();
        }
        /* uint32 max_parts = 17; */
        if (message.maxParts !== 0)
            writer.tag(17, WireType.Varint).uint32(message.maxParts);
        /* bool no_inflight_updates = 18; */
        if (message.noInflightUpdates !== false)
            writer.tag(18, WireType.Varint).bool(message.noInflightUpdates);
        /* uint64 max_shard_size_msat = 21; */
        if (message.maxShardSizeMsat !== 0)
            writer.tag(21, WireType.Varint).uint64(message.maxShardSizeMsat);
        /* bool amp = 22; */
        if (message.amp !== false)
            writer.tag(22, WireType.Varint).bool(message.amp);
        /* double time_pref = 23; */
        if (message.timePref !== 0)
            writer.tag(23, WireType.Bit64).double(message.timePref);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendPaymentRequest
 */
export const SendPaymentRequest = new SendPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPaymentRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.TrackPaymentRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { paymentHash: new Uint8Array(0), noInflightUpdates: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* bool no_inflight_updates */ 2:
                    message.noInflightUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paymentHash);
        /* bool no_inflight_updates = 2; */
        if (message.noInflightUpdates !== false)
            writer.tag(2, WireType.Varint).bool(message.noInflightUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentRequest
 */
export const TrackPaymentRequest = new TrackPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPaymentsRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.TrackPaymentsRequest", [
            { no: 1, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { noInflightUpdates: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool no_inflight_updates */ 1:
                    message.noInflightUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool no_inflight_updates = 1; */
        if (message.noInflightUpdates !== false)
            writer.tag(1, WireType.Varint).bool(message.noInflightUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentsRequest
 */
export const TrackPaymentsRequest = new TrackPaymentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteFeeRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.RouteFeeRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { dest: new Uint8Array(0), amtSat: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* int64 amt_sat */ 2:
                    message.amtSat = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.dest);
        /* int64 amt_sat = 2; */
        if (message.amtSat !== 0)
            writer.tag(2, WireType.Varint).int64(message.amtSat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeRequest
 */
export const RouteFeeRequest = new RouteFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteFeeResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.RouteFeeResponse", [
            { no: 1, name: "routing_fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "time_lock_delay", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { routingFeeMsat: 0, timeLockDelay: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 routing_fee_msat */ 1:
                    message.routingFeeMsat = reader.int64().toNumber();
                    break;
                case /* int64 time_lock_delay */ 2:
                    message.timeLockDelay = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 routing_fee_msat = 1; */
        if (message.routingFeeMsat !== 0)
            writer.tag(1, WireType.Varint).int64(message.routingFeeMsat);
        /* int64 time_lock_delay = 2; */
        if (message.timeLockDelay !== 0)
            writer.tag(2, WireType.Varint).int64(message.timeLockDelay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeResponse
 */
export const RouteFeeResponse = new RouteFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.SendToRouteRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "route", kind: "message", T: () => Route },
            { no: 3, name: "skip_temp_err", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { paymentHash: new Uint8Array(0), skipTempErr: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* lnrpc.Route route */ 2:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                case /* bool skip_temp_err */ 3:
                    message.skipTempErr = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paymentHash);
        /* lnrpc.Route route = 2; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_temp_err = 3; */
        if (message.skipTempErr !== false)
            writer.tag(3, WireType.Varint).bool(message.skipTempErr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteRequest
 */
export const SendToRouteRequest = new SendToRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.SendToRouteResponse", [
            { no: 1, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "failure", kind: "message", T: () => Failure }
        ]);
    }
    create(value) {
        const message = { preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes preimage */ 1:
                    message.preimage = reader.bytes();
                    break;
                case /* lnrpc.Failure failure */ 2:
                    message.failure = Failure.internalBinaryRead(reader, reader.uint32(), options, message.failure);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes preimage = 1; */
        if (message.preimage.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preimage);
        /* lnrpc.Failure failure = 2; */
        if (message.failure)
            Failure.internalBinaryWrite(message.failure, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteResponse
 */
export const SendToRouteResponse = new SendToRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetMissionControlRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.ResetMissionControlRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlRequest
 */
export const ResetMissionControlRequest = new ResetMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetMissionControlResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.ResetMissionControlResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlResponse
 */
export const ResetMissionControlResponse = new ResetMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMissionControlRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.QueryMissionControlRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlRequest
 */
export const QueryMissionControlRequest = new QueryMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMissionControlResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.QueryMissionControlResponse", [
            { no: 2, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PairHistory }
        ]);
    }
    create(value) {
        const message = { pairs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routerrpc.PairHistory pairs */ 2:
                    message.pairs.push(PairHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated routerrpc.PairHistory pairs = 2; */
        for (let i = 0; i < message.pairs.length; i++)
            PairHistory.internalBinaryWrite(message.pairs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlResponse
 */
export const QueryMissionControlResponse = new QueryMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XImportMissionControlRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.XImportMissionControlRequest", [
            { no: 1, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PairHistory },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { pairs: [], force: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routerrpc.PairHistory pairs */ 1:
                    message.pairs.push(PairHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated routerrpc.PairHistory pairs = 1; */
        for (let i = 0; i < message.pairs.length; i++)
            PairHistory.internalBinaryWrite(message.pairs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlRequest
 */
export const XImportMissionControlRequest = new XImportMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XImportMissionControlResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.XImportMissionControlResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlResponse
 */
export const XImportMissionControlResponse = new XImportMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PairHistory$Type extends MessageType {
    constructor() {
        super("routerrpc.PairHistory", [
            { no: 1, name: "node_from", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "node_to", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "history", kind: "message", T: () => PairData }
        ]);
    }
    create(value) {
        const message = { nodeFrom: new Uint8Array(0), nodeTo: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes node_from */ 1:
                    message.nodeFrom = reader.bytes();
                    break;
                case /* bytes node_to */ 2:
                    message.nodeTo = reader.bytes();
                    break;
                case /* routerrpc.PairData history */ 7:
                    message.history = PairData.internalBinaryRead(reader, reader.uint32(), options, message.history);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes node_from = 1; */
        if (message.nodeFrom.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nodeFrom);
        /* bytes node_to = 2; */
        if (message.nodeTo.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.nodeTo);
        /* routerrpc.PairData history = 7; */
        if (message.history)
            PairData.internalBinaryWrite(message.history, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PairHistory
 */
export const PairHistory = new PairHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PairData$Type extends MessageType {
    constructor() {
        super("routerrpc.PairData", [
            { no: 1, name: "fail_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "fail_amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "fail_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "success_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "success_amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 7, name: "success_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { failTime: 0, failAmtSat: 0, failAmtMsat: 0, successTime: 0, successAmtSat: 0, successAmtMsat: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 fail_time */ 1:
                    message.failTime = reader.int64().toNumber();
                    break;
                case /* int64 fail_amt_sat */ 2:
                    message.failAmtSat = reader.int64().toNumber();
                    break;
                case /* int64 fail_amt_msat */ 4:
                    message.failAmtMsat = reader.int64().toNumber();
                    break;
                case /* int64 success_time */ 5:
                    message.successTime = reader.int64().toNumber();
                    break;
                case /* int64 success_amt_sat */ 6:
                    message.successAmtSat = reader.int64().toNumber();
                    break;
                case /* int64 success_amt_msat */ 7:
                    message.successAmtMsat = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 fail_time = 1; */
        if (message.failTime !== 0)
            writer.tag(1, WireType.Varint).int64(message.failTime);
        /* int64 fail_amt_sat = 2; */
        if (message.failAmtSat !== 0)
            writer.tag(2, WireType.Varint).int64(message.failAmtSat);
        /* int64 fail_amt_msat = 4; */
        if (message.failAmtMsat !== 0)
            writer.tag(4, WireType.Varint).int64(message.failAmtMsat);
        /* int64 success_time = 5; */
        if (message.successTime !== 0)
            writer.tag(5, WireType.Varint).int64(message.successTime);
        /* int64 success_amt_sat = 6; */
        if (message.successAmtSat !== 0)
            writer.tag(6, WireType.Varint).int64(message.successAmtSat);
        /* int64 success_amt_msat = 7; */
        if (message.successAmtMsat !== 0)
            writer.tag(7, WireType.Varint).int64(message.successAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PairData
 */
export const PairData = new PairData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMissionControlConfigRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.GetMissionControlConfigRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigRequest
 */
export const GetMissionControlConfigRequest = new GetMissionControlConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMissionControlConfigResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.GetMissionControlConfigResponse", [
            { no: 1, name: "config", kind: "message", T: () => MissionControlConfig }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.MissionControlConfig config */ 1:
                    message.config = MissionControlConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.MissionControlConfig config = 1; */
        if (message.config)
            MissionControlConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigResponse
 */
export const GetMissionControlConfigResponse = new GetMissionControlConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMissionControlConfigRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.SetMissionControlConfigRequest", [
            { no: 1, name: "config", kind: "message", T: () => MissionControlConfig }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.MissionControlConfig config */ 1:
                    message.config = MissionControlConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.MissionControlConfig config = 1; */
        if (message.config)
            MissionControlConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigRequest
 */
export const SetMissionControlConfigRequest = new SetMissionControlConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMissionControlConfigResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.SetMissionControlConfigResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigResponse
 */
export const SetMissionControlConfigResponse = new SetMissionControlConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionControlConfig$Type extends MessageType {
    constructor() {
        super("routerrpc.MissionControlConfig", [
            { no: 1, name: "half_life_seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "hop_probability", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "maximum_payment_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "minimum_failure_relax_interval", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { halfLifeSeconds: 0, hopProbability: 0, weight: 0, maximumPaymentResults: 0, minimumFailureRelaxInterval: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 half_life_seconds */ 1:
                    message.halfLifeSeconds = reader.uint64().toNumber();
                    break;
                case /* float hop_probability */ 2:
                    message.hopProbability = reader.float();
                    break;
                case /* float weight */ 3:
                    message.weight = reader.float();
                    break;
                case /* uint32 maximum_payment_results */ 4:
                    message.maximumPaymentResults = reader.uint32();
                    break;
                case /* uint64 minimum_failure_relax_interval */ 5:
                    message.minimumFailureRelaxInterval = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 half_life_seconds = 1; */
        if (message.halfLifeSeconds !== 0)
            writer.tag(1, WireType.Varint).uint64(message.halfLifeSeconds);
        /* float hop_probability = 2; */
        if (message.hopProbability !== 0)
            writer.tag(2, WireType.Bit32).float(message.hopProbability);
        /* float weight = 3; */
        if (message.weight !== 0)
            writer.tag(3, WireType.Bit32).float(message.weight);
        /* uint32 maximum_payment_results = 4; */
        if (message.maximumPaymentResults !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maximumPaymentResults);
        /* uint64 minimum_failure_relax_interval = 5; */
        if (message.minimumFailureRelaxInterval !== 0)
            writer.tag(5, WireType.Varint).uint64(message.minimumFailureRelaxInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.MissionControlConfig
 */
export const MissionControlConfig = new MissionControlConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryProbabilityRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.QueryProbabilityRequest", [
            { no: 1, name: "from_node", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "to_node", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { fromNode: new Uint8Array(0), toNode: new Uint8Array(0), amtMsat: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes from_node */ 1:
                    message.fromNode = reader.bytes();
                    break;
                case /* bytes to_node */ 2:
                    message.toNode = reader.bytes();
                    break;
                case /* int64 amt_msat */ 3:
                    message.amtMsat = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes from_node = 1; */
        if (message.fromNode.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fromNode);
        /* bytes to_node = 2; */
        if (message.toNode.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.toNode);
        /* int64 amt_msat = 3; */
        if (message.amtMsat !== 0)
            writer.tag(3, WireType.Varint).int64(message.amtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityRequest
 */
export const QueryProbabilityRequest = new QueryProbabilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryProbabilityResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.QueryProbabilityResponse", [
            { no: 1, name: "probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "history", kind: "message", T: () => PairData }
        ]);
    }
    create(value) {
        const message = { probability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double probability */ 1:
                    message.probability = reader.double();
                    break;
                case /* routerrpc.PairData history */ 2:
                    message.history = PairData.internalBinaryRead(reader, reader.uint32(), options, message.history);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double probability = 1; */
        if (message.probability !== 0)
            writer.tag(1, WireType.Bit64).double(message.probability);
        /* routerrpc.PairData history = 2; */
        if (message.history)
            PairData.internalBinaryWrite(message.history, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityResponse
 */
export const QueryProbabilityResponse = new QueryProbabilityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildRouteRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.BuildRouteRequest", [
            { no: 1, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "hop_pubkeys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { amtMsat: 0, finalCltvDelta: 0, outgoingChanId: "0", hopPubkeys: [], paymentAddr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 amt_msat */ 1:
                    message.amtMsat = reader.int64().toNumber();
                    break;
                case /* int32 final_cltv_delta */ 2:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* uint64 outgoing_chan_id = 3 [jstype = JS_STRING];*/ 3:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* repeated bytes hop_pubkeys */ 4:
                    message.hopPubkeys.push(reader.bytes());
                    break;
                case /* bytes payment_addr */ 5:
                    message.paymentAddr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 amt_msat = 1; */
        if (message.amtMsat !== 0)
            writer.tag(1, WireType.Varint).int64(message.amtMsat);
        /* int32 final_cltv_delta = 2; */
        if (message.finalCltvDelta !== 0)
            writer.tag(2, WireType.Varint).int32(message.finalCltvDelta);
        /* uint64 outgoing_chan_id = 3 [jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(3, WireType.Varint).uint64(message.outgoingChanId);
        /* repeated bytes hop_pubkeys = 4; */
        for (let i = 0; i < message.hopPubkeys.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hopPubkeys[i]);
        /* bytes payment_addr = 5; */
        if (message.paymentAddr.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.paymentAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteRequest
 */
export const BuildRouteRequest = new BuildRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildRouteResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.BuildRouteResponse", [
            { no: 1, name: "route", kind: "message", T: () => Route }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.Route route */ 1:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* lnrpc.Route route = 1; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteResponse
 */
export const BuildRouteResponse = new BuildRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHtlcEventsRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.SubscribeHtlcEventsRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribeHtlcEventsRequest
 */
export const SubscribeHtlcEventsRequest = new SubscribeHtlcEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HtlcEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.HtlcEvent", [
            { no: 1, name: "incoming_channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "outgoing_channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "incoming_htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "outgoing_htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "event_type", kind: "enum", T: () => ["routerrpc.HtlcEvent.EventType", HtlcEvent_EventType] },
            { no: 7, name: "forward_event", kind: "message", oneof: "event", T: () => ForwardEvent },
            { no: 8, name: "forward_fail_event", kind: "message", oneof: "event", T: () => ForwardFailEvent },
            { no: 9, name: "settle_event", kind: "message", oneof: "event", T: () => SettleEvent },
            { no: 10, name: "link_fail_event", kind: "message", oneof: "event", T: () => LinkFailEvent },
            { no: 11, name: "subscribed_event", kind: "message", oneof: "event", T: () => SubscribedEvent },
            { no: 12, name: "final_htlc_event", kind: "message", oneof: "event", T: () => FinalHtlcEvent }
        ]);
    }
    create(value) {
        const message = { incomingChannelId: 0, outgoingChannelId: 0, incomingHtlcId: 0, outgoingHtlcId: 0, timestampNs: 0, eventType: 0, event: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 incoming_channel_id */ 1:
                    message.incomingChannelId = reader.uint64().toNumber();
                    break;
                case /* uint64 outgoing_channel_id */ 2:
                    message.outgoingChannelId = reader.uint64().toNumber();
                    break;
                case /* uint64 incoming_htlc_id */ 3:
                    message.incomingHtlcId = reader.uint64().toNumber();
                    break;
                case /* uint64 outgoing_htlc_id */ 4:
                    message.outgoingHtlcId = reader.uint64().toNumber();
                    break;
                case /* uint64 timestamp_ns */ 5:
                    message.timestampNs = reader.uint64().toNumber();
                    break;
                case /* routerrpc.HtlcEvent.EventType event_type */ 6:
                    message.eventType = reader.int32();
                    break;
                case /* routerrpc.ForwardEvent forward_event */ 7:
                    message.event = {
                        oneofKind: "forwardEvent",
                        forwardEvent: ForwardEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.forwardEvent)
                    };
                    break;
                case /* routerrpc.ForwardFailEvent forward_fail_event */ 8:
                    message.event = {
                        oneofKind: "forwardFailEvent",
                        forwardFailEvent: ForwardFailEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.forwardFailEvent)
                    };
                    break;
                case /* routerrpc.SettleEvent settle_event */ 9:
                    message.event = {
                        oneofKind: "settleEvent",
                        settleEvent: SettleEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.settleEvent)
                    };
                    break;
                case /* routerrpc.LinkFailEvent link_fail_event */ 10:
                    message.event = {
                        oneofKind: "linkFailEvent",
                        linkFailEvent: LinkFailEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.linkFailEvent)
                    };
                    break;
                case /* routerrpc.SubscribedEvent subscribed_event */ 11:
                    message.event = {
                        oneofKind: "subscribedEvent",
                        subscribedEvent: SubscribedEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.subscribedEvent)
                    };
                    break;
                case /* routerrpc.FinalHtlcEvent final_htlc_event */ 12:
                    message.event = {
                        oneofKind: "finalHtlcEvent",
                        finalHtlcEvent: FinalHtlcEvent.internalBinaryRead(reader, reader.uint32(), options, message.event.finalHtlcEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 incoming_channel_id = 1; */
        if (message.incomingChannelId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.incomingChannelId);
        /* uint64 outgoing_channel_id = 2; */
        if (message.outgoingChannelId !== 0)
            writer.tag(2, WireType.Varint).uint64(message.outgoingChannelId);
        /* uint64 incoming_htlc_id = 3; */
        if (message.incomingHtlcId !== 0)
            writer.tag(3, WireType.Varint).uint64(message.incomingHtlcId);
        /* uint64 outgoing_htlc_id = 4; */
        if (message.outgoingHtlcId !== 0)
            writer.tag(4, WireType.Varint).uint64(message.outgoingHtlcId);
        /* uint64 timestamp_ns = 5; */
        if (message.timestampNs !== 0)
            writer.tag(5, WireType.Varint).uint64(message.timestampNs);
        /* routerrpc.HtlcEvent.EventType event_type = 6; */
        if (message.eventType !== 0)
            writer.tag(6, WireType.Varint).int32(message.eventType);
        /* routerrpc.ForwardEvent forward_event = 7; */
        if (message.event.oneofKind === "forwardEvent")
            ForwardEvent.internalBinaryWrite(message.event.forwardEvent, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ForwardFailEvent forward_fail_event = 8; */
        if (message.event.oneofKind === "forwardFailEvent")
            ForwardFailEvent.internalBinaryWrite(message.event.forwardFailEvent, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.SettleEvent settle_event = 9; */
        if (message.event.oneofKind === "settleEvent")
            SettleEvent.internalBinaryWrite(message.event.settleEvent, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.LinkFailEvent link_fail_event = 10; */
        if (message.event.oneofKind === "linkFailEvent")
            LinkFailEvent.internalBinaryWrite(message.event.linkFailEvent, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.SubscribedEvent subscribed_event = 11; */
        if (message.event.oneofKind === "subscribedEvent")
            SubscribedEvent.internalBinaryWrite(message.event.subscribedEvent, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.FinalHtlcEvent final_htlc_event = 12; */
        if (message.event.oneofKind === "finalHtlcEvent")
            FinalHtlcEvent.internalBinaryWrite(message.event.finalHtlcEvent, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcEvent
 */
export const HtlcEvent = new HtlcEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HtlcInfo$Type extends MessageType {
    constructor() {
        super("routerrpc.HtlcInfo", [
            { no: 1, name: "incoming_timelock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "outgoing_timelock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "incoming_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "outgoing_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { incomingTimelock: 0, outgoingTimelock: 0, incomingAmtMsat: 0, outgoingAmtMsat: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 incoming_timelock */ 1:
                    message.incomingTimelock = reader.uint32();
                    break;
                case /* uint32 outgoing_timelock */ 2:
                    message.outgoingTimelock = reader.uint32();
                    break;
                case /* uint64 incoming_amt_msat */ 3:
                    message.incomingAmtMsat = reader.uint64().toNumber();
                    break;
                case /* uint64 outgoing_amt_msat */ 4:
                    message.outgoingAmtMsat = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 incoming_timelock = 1; */
        if (message.incomingTimelock !== 0)
            writer.tag(1, WireType.Varint).uint32(message.incomingTimelock);
        /* uint32 outgoing_timelock = 2; */
        if (message.outgoingTimelock !== 0)
            writer.tag(2, WireType.Varint).uint32(message.outgoingTimelock);
        /* uint64 incoming_amt_msat = 3; */
        if (message.incomingAmtMsat !== 0)
            writer.tag(3, WireType.Varint).uint64(message.incomingAmtMsat);
        /* uint64 outgoing_amt_msat = 4; */
        if (message.outgoingAmtMsat !== 0)
            writer.tag(4, WireType.Varint).uint64(message.outgoingAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcInfo
 */
export const HtlcInfo = new HtlcInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.ForwardEvent", [
            { no: 1, name: "info", kind: "message", T: () => HtlcInfo }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.HtlcInfo info */ 1:
                    message.info = HtlcInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.HtlcInfo info = 1; */
        if (message.info)
            HtlcInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardEvent
 */
export const ForwardEvent = new ForwardEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardFailEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.ForwardFailEvent", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardFailEvent
 */
export const ForwardFailEvent = new ForwardFailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettleEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.SettleEvent", [
            { no: 1, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes preimage */ 1:
                    message.preimage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes preimage = 1; */
        if (message.preimage.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preimage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SettleEvent
 */
export const SettleEvent = new SettleEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalHtlcEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.FinalHtlcEvent", [
            { no: 1, name: "settled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "offchain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { settled: false, offchain: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool settled */ 1:
                    message.settled = reader.bool();
                    break;
                case /* bool offchain */ 2:
                    message.offchain = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool settled = 1; */
        if (message.settled !== false)
            writer.tag(1, WireType.Varint).bool(message.settled);
        /* bool offchain = 2; */
        if (message.offchain !== false)
            writer.tag(2, WireType.Varint).bool(message.offchain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.FinalHtlcEvent
 */
export const FinalHtlcEvent = new FinalHtlcEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribedEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.SubscribedEvent", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribedEvent
 */
export const SubscribedEvent = new SubscribedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkFailEvent$Type extends MessageType {
    constructor() {
        super("routerrpc.LinkFailEvent", [
            { no: 1, name: "info", kind: "message", T: () => HtlcInfo },
            { no: 2, name: "wire_failure", kind: "enum", T: () => ["lnrpc.Failure.FailureCode", Failure_FailureCode] },
            { no: 3, name: "failure_detail", kind: "enum", T: () => ["routerrpc.FailureDetail", FailureDetail] },
            { no: 4, name: "failure_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { wireFailure: 0, failureDetail: 0, failureString: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.HtlcInfo info */ 1:
                    message.info = HtlcInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* lnrpc.Failure.FailureCode wire_failure */ 2:
                    message.wireFailure = reader.int32();
                    break;
                case /* routerrpc.FailureDetail failure_detail */ 3:
                    message.failureDetail = reader.int32();
                    break;
                case /* string failure_string */ 4:
                    message.failureString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.HtlcInfo info = 1; */
        if (message.info)
            HtlcInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Failure.FailureCode wire_failure = 2; */
        if (message.wireFailure !== 0)
            writer.tag(2, WireType.Varint).int32(message.wireFailure);
        /* routerrpc.FailureDetail failure_detail = 3; */
        if (message.failureDetail !== 0)
            writer.tag(3, WireType.Varint).int32(message.failureDetail);
        /* string failure_string = 4; */
        if (message.failureString !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.failureString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.LinkFailEvent
 */
export const LinkFailEvent = new LinkFailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaymentStatus$Type extends MessageType {
    constructor() {
        super("routerrpc.PaymentStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["routerrpc.PaymentState", PaymentState] },
            { no: 2, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HTLCAttempt }
        ]);
    }
    create(value) {
        const message = { state: 0, preimage: new Uint8Array(0), htlcs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.PaymentState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* bytes preimage */ 2:
                    message.preimage = reader.bytes();
                    break;
                case /* repeated lnrpc.HTLCAttempt htlcs */ 4:
                    message.htlcs.push(HTLCAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.PaymentState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* bytes preimage = 2; */
        if (message.preimage.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.preimage);
        /* repeated lnrpc.HTLCAttempt htlcs = 4; */
        for (let i = 0; i < message.htlcs.length; i++)
            HTLCAttempt.internalBinaryWrite(message.htlcs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PaymentStatus
 */
export const PaymentStatus = new PaymentStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CircuitKey$Type extends MessageType {
    constructor() {
        super("routerrpc.CircuitKey", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value) {
        const message = { chanId: 0, htlcId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id */ 1:
                    message.chanId = reader.uint64().toNumber();
                    break;
                case /* uint64 htlc_id */ 2:
                    message.htlcId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 chan_id = 1; */
        if (message.chanId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* uint64 htlc_id = 2; */
        if (message.htlcId !== 0)
            writer.tag(2, WireType.Varint).uint64(message.htlcId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.CircuitKey
 */
export const CircuitKey = new CircuitKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardHtlcInterceptRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.ForwardHtlcInterceptRequest", [
            { no: 1, name: "incoming_circuit_key", kind: "message", T: () => CircuitKey },
            { no: 5, name: "incoming_amount_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "incoming_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "outgoing_requested_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "outgoing_amount_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "outgoing_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 9, name: "onion_blob", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "auto_fail_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { incomingAmountMsat: 0, incomingExpiry: 0, paymentHash: new Uint8Array(0), outgoingRequestedChanId: 0, outgoingAmountMsat: 0, outgoingExpiry: 0, customRecords: {}, onionBlob: new Uint8Array(0), autoFailHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.CircuitKey incoming_circuit_key */ 1:
                    message.incomingCircuitKey = CircuitKey.internalBinaryRead(reader, reader.uint32(), options, message.incomingCircuitKey);
                    break;
                case /* uint64 incoming_amount_msat */ 5:
                    message.incomingAmountMsat = reader.uint64().toNumber();
                    break;
                case /* uint32 incoming_expiry */ 6:
                    message.incomingExpiry = reader.uint32();
                    break;
                case /* bytes payment_hash */ 2:
                    message.paymentHash = reader.bytes();
                    break;
                case /* uint64 outgoing_requested_chan_id */ 7:
                    message.outgoingRequestedChanId = reader.uint64().toNumber();
                    break;
                case /* uint64 outgoing_amount_msat */ 3:
                    message.outgoingAmountMsat = reader.uint64().toNumber();
                    break;
                case /* uint32 outgoing_expiry */ 4:
                    message.outgoingExpiry = reader.uint32();
                    break;
                case /* map<uint64, bytes> custom_records */ 8:
                    this.binaryReadMap8(message.customRecords, reader, options);
                    break;
                case /* bytes onion_blob */ 9:
                    message.onionBlob = reader.bytes();
                    break;
                case /* int32 auto_fail_height */ 10:
                    message.autoFailHeight = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap8(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field routerrpc.ForwardHtlcInterceptRequest.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.CircuitKey incoming_circuit_key = 1; */
        if (message.incomingCircuitKey)
            CircuitKey.internalBinaryWrite(message.incomingCircuitKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 incoming_amount_msat = 5; */
        if (message.incomingAmountMsat !== 0)
            writer.tag(5, WireType.Varint).uint64(message.incomingAmountMsat);
        /* uint32 incoming_expiry = 6; */
        if (message.incomingExpiry !== 0)
            writer.tag(6, WireType.Varint).uint32(message.incomingExpiry);
        /* bytes payment_hash = 2; */
        if (message.paymentHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.paymentHash);
        /* uint64 outgoing_requested_chan_id = 7; */
        if (message.outgoingRequestedChanId !== 0)
            writer.tag(7, WireType.Varint).uint64(message.outgoingRequestedChanId);
        /* uint64 outgoing_amount_msat = 3; */
        if (message.outgoingAmountMsat !== 0)
            writer.tag(3, WireType.Varint).uint64(message.outgoingAmountMsat);
        /* uint32 outgoing_expiry = 4; */
        if (message.outgoingExpiry !== 0)
            writer.tag(4, WireType.Varint).uint32(message.outgoingExpiry);
        /* map<uint64, bytes> custom_records = 8; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        /* bytes onion_blob = 9; */
        if (message.onionBlob.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.onionBlob);
        /* int32 auto_fail_height = 10; */
        if (message.autoFailHeight !== 0)
            writer.tag(10, WireType.Varint).int32(message.autoFailHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptRequest
 */
export const ForwardHtlcInterceptRequest = new ForwardHtlcInterceptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardHtlcInterceptResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.ForwardHtlcInterceptResponse", [
            { no: 1, name: "incoming_circuit_key", kind: "message", T: () => CircuitKey },
            { no: 2, name: "action", kind: "enum", T: () => ["routerrpc.ResolveHoldForwardAction", ResolveHoldForwardAction] },
            { no: 3, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "failure_message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "failure_code", kind: "enum", T: () => ["lnrpc.Failure.FailureCode", Failure_FailureCode] }
        ]);
    }
    create(value) {
        const message = { action: 0, preimage: new Uint8Array(0), failureMessage: new Uint8Array(0), failureCode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.CircuitKey incoming_circuit_key */ 1:
                    message.incomingCircuitKey = CircuitKey.internalBinaryRead(reader, reader.uint32(), options, message.incomingCircuitKey);
                    break;
                case /* routerrpc.ResolveHoldForwardAction action */ 2:
                    message.action = reader.int32();
                    break;
                case /* bytes preimage */ 3:
                    message.preimage = reader.bytes();
                    break;
                case /* bytes failure_message */ 4:
                    message.failureMessage = reader.bytes();
                    break;
                case /* lnrpc.Failure.FailureCode failure_code */ 5:
                    message.failureCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* routerrpc.CircuitKey incoming_circuit_key = 1; */
        if (message.incomingCircuitKey)
            CircuitKey.internalBinaryWrite(message.incomingCircuitKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ResolveHoldForwardAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        /* bytes preimage = 3; */
        if (message.preimage.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.preimage);
        /* bytes failure_message = 4; */
        if (message.failureMessage.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.failureMessage);
        /* lnrpc.Failure.FailureCode failure_code = 5; */
        if (message.failureCode !== 0)
            writer.tag(5, WireType.Varint).int32(message.failureCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptResponse
 */
export const ForwardHtlcInterceptResponse = new ForwardHtlcInterceptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateChanStatusRequest$Type extends MessageType {
    constructor() {
        super("routerrpc.UpdateChanStatusRequest", [
            { no: 1, name: "chan_point", kind: "message", T: () => ChannelPoint },
            { no: 2, name: "action", kind: "enum", T: () => ["routerrpc.ChanStatusAction", ChanStatusAction] }
        ]);
    }
    create(value) {
        const message = { action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint chan_point */ 1:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* routerrpc.ChanStatusAction action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* lnrpc.ChannelPoint chan_point = 1; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ChanStatusAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusRequest
 */
export const UpdateChanStatusRequest = new UpdateChanStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateChanStatusResponse$Type extends MessageType {
    constructor() {
        super("routerrpc.UpdateChanStatusResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusResponse
 */
export const UpdateChanStatusResponse = new UpdateChanStatusResponse$Type();
/**
 * @generated ServiceType for protobuf service routerrpc.Router
 */
export const Router = new ServiceType("routerrpc.Router", [
    { name: "SendPaymentV2", serverStreaming: true, options: {}, I: SendPaymentRequest, O: Payment },
    { name: "TrackPaymentV2", serverStreaming: true, options: {}, I: TrackPaymentRequest, O: Payment },
    { name: "TrackPayments", serverStreaming: true, options: {}, I: TrackPaymentsRequest, O: Payment },
    { name: "EstimateRouteFee", options: {}, I: RouteFeeRequest, O: RouteFeeResponse },
    { name: "SendToRoute", options: {}, I: SendToRouteRequest, O: SendToRouteResponse },
    { name: "SendToRouteV2", options: {}, I: SendToRouteRequest, O: HTLCAttempt },
    { name: "ResetMissionControl", options: {}, I: ResetMissionControlRequest, O: ResetMissionControlResponse },
    { name: "QueryMissionControl", options: {}, I: QueryMissionControlRequest, O: QueryMissionControlResponse },
    { name: "XImportMissionControl", options: {}, I: XImportMissionControlRequest, O: XImportMissionControlResponse },
    { name: "GetMissionControlConfig", options: {}, I: GetMissionControlConfigRequest, O: GetMissionControlConfigResponse },
    { name: "SetMissionControlConfig", options: {}, I: SetMissionControlConfigRequest, O: SetMissionControlConfigResponse },
    { name: "QueryProbability", options: {}, I: QueryProbabilityRequest, O: QueryProbabilityResponse },
    { name: "BuildRoute", options: {}, I: BuildRouteRequest, O: BuildRouteResponse },
    { name: "SubscribeHtlcEvents", serverStreaming: true, options: {}, I: SubscribeHtlcEventsRequest, O: HtlcEvent },
    { name: "SendPayment", serverStreaming: true, options: {}, I: SendPaymentRequest, O: PaymentStatus },
    { name: "TrackPayment", serverStreaming: true, options: {}, I: TrackPaymentRequest, O: PaymentStatus },
    { name: "HtlcInterceptor", serverStreaming: true, clientStreaming: true, options: {}, I: ForwardHtlcInterceptResponse, O: ForwardHtlcInterceptRequest },
    { name: "UpdateChanStatus", options: {}, I: UpdateChanStatusRequest, O: UpdateChanStatusResponse }
]);
