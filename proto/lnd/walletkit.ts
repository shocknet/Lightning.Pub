// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "walletkit.proto" (package "walletrpc", syntax proto3)
// tslint:disable
import { Transaction as Transaction$ } from "./lightning";
import { KeyLocator } from "./signer";
import { KeyDescriptor } from "./signer";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TransactionDetails } from "./lightning";
import { ChannelPoint } from "./lightning";
import { CoinSelectionStrategy } from "./lightning";
import { TxOut } from "./signer";
import { OutPoint } from "./lightning";
import { Utxo } from "./lightning";
/**
 * @generated from protobuf message walletrpc.ListUnspentRequest
 */
export interface ListUnspentRequest {
    /**
     * The minimum number of confirmations to be included.
     *
     * @generated from protobuf field: int32 min_confs = 1;
     */
    minConfs: number;
    /**
     * The maximum number of confirmations to be included.
     *
     * @generated from protobuf field: int32 max_confs = 2;
     */
    maxConfs: number;
    /**
     * An optional filter to only include outputs belonging to an account.
     *
     * @generated from protobuf field: string account = 3;
     */
    account: string;
    /**
     *
     * When min_confs and max_confs are zero, setting false implicitly
     * overrides max_confs to be MaxInt32, otherwise max_confs remains
     * zero. An error is returned if the value is true and both min_confs
     * and max_confs are non-zero. (default: false)
     *
     * @generated from protobuf field: bool unconfirmed_only = 4;
     */
    unconfirmedOnly: boolean;
}
/**
 * @generated from protobuf message walletrpc.ListUnspentResponse
 */
export interface ListUnspentResponse {
    /**
     * A list of utxos satisfying the specified number of confirmations.
     *
     * @generated from protobuf field: repeated lnrpc.Utxo utxos = 1;
     */
    utxos: Utxo[];
}
/**
 * @generated from protobuf message walletrpc.LeaseOutputRequest
 */
export interface LeaseOutputRequest {
    /**
     *
     * An ID of 32 random bytes that must be unique for each distinct application
     * using this RPC which will be used to bound the output lease to.
     *
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * The identifying outpoint of the output being leased.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 2;
     */
    outpoint?: OutPoint;
    /**
     * The time in seconds before the lock expires. If set to zero, the default
     * lock duration is used.
     *
     * @generated from protobuf field: uint64 expiration_seconds = 3;
     */
    expirationSeconds: bigint;
}
/**
 * @generated from protobuf message walletrpc.LeaseOutputResponse
 */
export interface LeaseOutputResponse {
    /**
     *
     * The absolute expiration of the output lease represented as a unix timestamp.
     *
     * @generated from protobuf field: uint64 expiration = 1;
     */
    expiration: bigint;
}
/**
 * @generated from protobuf message walletrpc.ReleaseOutputRequest
 */
export interface ReleaseOutputRequest {
    /**
     * The unique ID that was used to lock the output.
     *
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * The identifying outpoint of the output being released.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 2;
     */
    outpoint?: OutPoint;
}
/**
 * @generated from protobuf message walletrpc.ReleaseOutputResponse
 */
export interface ReleaseOutputResponse {
    /**
     * The status of the release operation.
     *
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message walletrpc.KeyReq
 */
export interface KeyReq {
    /**
     *
     * Is the key finger print of the root pubkey that this request is targeting.
     * This allows the WalletKit to possibly serve out keys for multiple HD chains
     * via public derivation.
     *
     * @generated from protobuf field: int32 key_finger_print = 1;
     */
    keyFingerPrint: number;
    /**
     *
     * The target key family to derive a key from. In other contexts, this is
     * known as the "account".
     *
     * @generated from protobuf field: int32 key_family = 2;
     */
    keyFamily: number;
}
/**
 * @generated from protobuf message walletrpc.AddrRequest
 */
export interface AddrRequest {
    /**
     *
     * The name of the account to retrieve the next address of. If empty, the
     * default wallet account is used.
     *
     * @generated from protobuf field: string account = 1;
     */
    account: string;
    /**
     *
     * The type of address to derive.
     *
     * @generated from protobuf field: walletrpc.AddressType type = 2;
     */
    type: AddressType;
    /**
     *
     * Whether a change address should be derived.
     *
     * @generated from protobuf field: bool change = 3;
     */
    change: boolean;
}
/**
 * @generated from protobuf message walletrpc.AddrResponse
 */
export interface AddrResponse {
    /**
     *
     * The address encoded using a bech32 format.
     *
     * @generated from protobuf field: string addr = 1;
     */
    addr: string;
}
/**
 * @generated from protobuf message walletrpc.Account
 */
export interface Account {
    /**
     * The name used to identify the account.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The type of addresses the account supports.
     *
     * @generated from protobuf field: walletrpc.AddressType address_type = 2;
     */
    addressType: AddressType;
    /**
     *
     * The public key backing the account that all keys are derived from
     * represented as an extended key. This will always be empty for the default
     * imported account in which single public keys are imported into.
     *
     * @generated from protobuf field: string extended_public_key = 3;
     */
    extendedPublicKey: string;
    /**
     *
     * The fingerprint of the root key from which the account public key was
     * derived from. This will always be zero for the default imported account in
     * which single public keys are imported into. The bytes are in big-endian
     * order.
     *
     * @generated from protobuf field: bytes master_key_fingerprint = 4;
     */
    masterKeyFingerprint: Uint8Array;
    /**
     *
     * The derivation path corresponding to the account public key. This will
     * always be empty for the default imported account in which single public keys
     * are imported into.
     *
     * @generated from protobuf field: string derivation_path = 5;
     */
    derivationPath: string;
    /**
     *
     * The number of keys derived from the external branch of the account public
     * key. This will always be zero for the default imported account in which
     * single public keys are imported into.
     *
     * @generated from protobuf field: uint32 external_key_count = 6;
     */
    externalKeyCount: number;
    /**
     *
     * The number of keys derived from the internal branch of the account public
     * key. This will always be zero for the default imported account in which
     * single public keys are imported into.
     *
     * @generated from protobuf field: uint32 internal_key_count = 7;
     */
    internalKeyCount: number;
    /**
     * Whether the wallet stores private keys for the account.
     *
     * @generated from protobuf field: bool watch_only = 8;
     */
    watchOnly: boolean;
}
/**
 * @generated from protobuf message walletrpc.AddressProperty
 */
export interface AddressProperty {
    /**
     *
     * The address encoded using the appropriate format depending on the
     * address type (base58, bech32, bech32m).
     *
     * Note that lnd's internal/custom keys for channels and other
     * functionality are derived from the same scope. Since they
     * aren't really used as addresses and will never have an
     * on-chain balance, we'll show the public key instead (only if
     * the show_custom_accounts flag is provided).
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * Denotes if the address is a change address.
     *
     * @generated from protobuf field: bool is_internal = 2;
     */
    isInternal: boolean;
    /**
     * The balance of the address.
     *
     * @generated from protobuf field: int64 balance = 3;
     */
    balance: bigint;
    /**
     * The full derivation path of the address. This will be empty for imported
     * addresses.
     *
     * @generated from protobuf field: string derivation_path = 4;
     */
    derivationPath: string;
    /**
     * The public key of the address. This will be empty for imported addresses.
     *
     * @generated from protobuf field: bytes public_key = 5;
     */
    publicKey: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.AccountWithAddresses
 */
export interface AccountWithAddresses {
    /**
     * The name used to identify the account.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The type of addresses the account supports.
     *
     * @generated from protobuf field: walletrpc.AddressType address_type = 2;
     */
    addressType: AddressType;
    /**
     *
     * The derivation path corresponding to the account public key. This will
     * always be empty for the default imported account in which single public keys
     * are imported into.
     *
     * @generated from protobuf field: string derivation_path = 3;
     */
    derivationPath: string;
    /**
     *
     * List of address, its type internal/external & balance.
     * Note that the order of addresses will be random and not according to the
     * derivation index, since that information is not stored by the underlying
     * wallet.
     *
     * @generated from protobuf field: repeated walletrpc.AddressProperty addresses = 4;
     */
    addresses: AddressProperty[];
}
/**
 * @generated from protobuf message walletrpc.ListAccountsRequest
 */
export interface ListAccountsRequest {
    /**
     * An optional filter to only return accounts matching this name.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * An optional filter to only return accounts matching this address type.
     *
     * @generated from protobuf field: walletrpc.AddressType address_type = 2;
     */
    addressType: AddressType;
}
/**
 * @generated from protobuf message walletrpc.ListAccountsResponse
 */
export interface ListAccountsResponse {
    /**
     * @generated from protobuf field: repeated walletrpc.Account accounts = 1;
     */
    accounts: Account[];
}
/**
 * @generated from protobuf message walletrpc.RequiredReserveRequest
 */
export interface RequiredReserveRequest {
    /**
     * The number of additional channels the user would like to open.
     *
     * @generated from protobuf field: uint32 additional_public_channels = 1;
     */
    additionalPublicChannels: number;
}
/**
 * @generated from protobuf message walletrpc.RequiredReserveResponse
 */
export interface RequiredReserveResponse {
    /**
     * The amount of reserve required.
     *
     * @generated from protobuf field: int64 required_reserve = 1;
     */
    requiredReserve: bigint;
}
/**
 * @generated from protobuf message walletrpc.ListAddressesRequest
 */
export interface ListAddressesRequest {
    /**
     * An optional filter to only return addresses matching this account.
     *
     * @generated from protobuf field: string account_name = 1;
     */
    accountName: string;
    /**
     * An optional flag to return LND's custom accounts (Purpose=1017)
     * public key along with other addresses.
     *
     * @generated from protobuf field: bool show_custom_accounts = 2;
     */
    showCustomAccounts: boolean;
}
/**
 * @generated from protobuf message walletrpc.ListAddressesResponse
 */
export interface ListAddressesResponse {
    /**
     * A list of all the accounts and their addresses.
     *
     * @generated from protobuf field: repeated walletrpc.AccountWithAddresses account_with_addresses = 1;
     */
    accountWithAddresses: AccountWithAddresses[];
}
/**
 * @generated from protobuf message walletrpc.GetTransactionRequest
 */
export interface GetTransactionRequest {
    /**
     * The txid of the transaction.
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message walletrpc.SignMessageWithAddrRequest
 */
export interface SignMessageWithAddrRequest {
    /**
     * The message to be signed. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     * The address which will be used to look up the private key and sign the
     * corresponding message.
     *
     * @generated from protobuf field: string addr = 2;
     */
    addr: string;
}
/**
 * @generated from protobuf message walletrpc.SignMessageWithAddrResponse
 */
export interface SignMessageWithAddrResponse {
    /**
     * The compact ECDSA signature for the given message encoded in base64.
     *
     * @generated from protobuf field: string signature = 1;
     */
    signature: string;
}
/**
 * @generated from protobuf message walletrpc.VerifyMessageWithAddrRequest
 */
export interface VerifyMessageWithAddrRequest {
    /**
     * The message to be signed. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     * The compact ECDSA signature to be verified over the given message
     * ecoded in base64.
     *
     * @generated from protobuf field: string signature = 2;
     */
    signature: string;
    /**
     * The address which will be used to look up the public key and verify the
     * the signature.
     *
     * @generated from protobuf field: string addr = 3;
     */
    addr: string;
}
/**
 * @generated from protobuf message walletrpc.VerifyMessageWithAddrResponse
 */
export interface VerifyMessageWithAddrResponse {
    /**
     * Whether the signature was valid over the given message.
     *
     * @generated from protobuf field: bool valid = 1;
     */
    valid: boolean;
    /**
     * The pubkey recovered from the signature.
     *
     * @generated from protobuf field: bytes pubkey = 2;
     */
    pubkey: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.ImportAccountRequest
 */
export interface ImportAccountRequest {
    /**
     * A name to identify the account with.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     *
     * A public key that corresponds to a wallet account represented as an extended
     * key. It must conform to a derivation path of the form
     * m/purpose'/coin_type'/account'.
     *
     * @generated from protobuf field: string extended_public_key = 2;
     */
    extendedPublicKey: string;
    /**
     *
     * The fingerprint of the root key (also known as the key with derivation path
     * m/) from which the account public key was derived from. This may be required
     * by some hardware wallets for proper identification and signing. The bytes
     * must be in big-endian order.
     *
     * @generated from protobuf field: bytes master_key_fingerprint = 3;
     */
    masterKeyFingerprint: Uint8Array;
    /**
     *
     * An address type is only required when the extended account public key has a
     * legacy version (xpub, tpub, etc.), such that the wallet cannot detect what
     * address scheme it belongs to.
     *
     * @generated from protobuf field: walletrpc.AddressType address_type = 4;
     */
    addressType: AddressType;
    /**
     *
     * Whether a dry run should be attempted when importing the account. This
     * serves as a way to confirm whether the account is being imported correctly
     * by returning the first N addresses for the external and internal branches of
     * the account. If these addresses match as expected, then it should be safe to
     * import the account as is.
     *
     * @generated from protobuf field: bool dry_run = 5;
     */
    dryRun: boolean;
}
/**
 * @generated from protobuf message walletrpc.ImportAccountResponse
 */
export interface ImportAccountResponse {
    /**
     * The details of the imported account.
     *
     * @generated from protobuf field: walletrpc.Account account = 1;
     */
    account?: Account;
    /**
     *
     * The first N addresses that belong to the external branch of the account.
     * The external branch is typically used for external non-change addresses.
     * These are only returned if a dry run was specified within the request.
     *
     * @generated from protobuf field: repeated string dry_run_external_addrs = 2;
     */
    dryRunExternalAddrs: string[];
    /**
     *
     * The first N addresses that belong to the internal branch of the account.
     * The internal branch is typically used for change addresses. These are only
     * returned if a dry run was specified within the request.
     *
     * @generated from protobuf field: repeated string dry_run_internal_addrs = 3;
     */
    dryRunInternalAddrs: string[];
}
/**
 * @generated from protobuf message walletrpc.ImportPublicKeyRequest
 */
export interface ImportPublicKeyRequest {
    /**
     * A compressed public key represented as raw bytes.
     *
     * @generated from protobuf field: bytes public_key = 1;
     */
    publicKey: Uint8Array;
    /**
     * The type of address that will be generated from the public key.
     *
     * @generated from protobuf field: walletrpc.AddressType address_type = 2;
     */
    addressType: AddressType;
}
/**
 * @generated from protobuf message walletrpc.ImportPublicKeyResponse
 */
export interface ImportPublicKeyResponse {
    /**
     * The status of the import operation.
     *
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message walletrpc.ImportTapscriptRequest
 */
export interface ImportTapscriptRequest {
    /**
     *
     * The internal public key, serialized as 32-byte x-only public key.
     *
     * @generated from protobuf field: bytes internal_public_key = 1;
     */
    internalPublicKey: Uint8Array;
    /**
     * @generated from protobuf oneof: script
     */
    script: {
        oneofKind: "fullTree";
        /**
         *
         * The full script tree with all individual leaves is known and the root
         * hash can be constructed from the full tree directly.
         *
         * @generated from protobuf field: walletrpc.TapscriptFullTree full_tree = 2;
         */
        fullTree: TapscriptFullTree;
    } | {
        oneofKind: "partialReveal";
        /**
         *
         * Only a single script leaf is known. To construct the root hash, the full
         * inclusion proof must also be provided.
         *
         * @generated from protobuf field: walletrpc.TapscriptPartialReveal partial_reveal = 3;
         */
        partialReveal: TapscriptPartialReveal;
    } | {
        oneofKind: "rootHashOnly";
        /**
         *
         * Only the root hash of the Taproot script tree (or other form of Taproot
         * commitment) is known.
         *
         * @generated from protobuf field: bytes root_hash_only = 4;
         */
        rootHashOnly: Uint8Array;
    } | {
        oneofKind: "fullKeyOnly";
        /**
         *
         * Only the final, tweaked Taproot key is known and no additional
         * information about the internal key or type of tweak that was used to
         * derive it. When this is set, the wallet treats the key in
         * internal_public_key as the Taproot key directly. This can be useful for
         * tracking arbitrary Taproot outputs without the goal of ever being able
         * to spend from them through the internal wallet.
         *
         * @generated from protobuf field: bool full_key_only = 5;
         */
        fullKeyOnly: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message walletrpc.TapscriptFullTree
 */
export interface TapscriptFullTree {
    /**
     *
     * The complete, ordered list of all tap leaves of the tree.
     *
     * @generated from protobuf field: repeated walletrpc.TapLeaf all_leaves = 1;
     */
    allLeaves: TapLeaf[];
}
/**
 * @generated from protobuf message walletrpc.TapLeaf
 */
export interface TapLeaf {
    /**
     * The leaf version. Should be 0xc0 (192) in case of a SegWit v1 script.
     *
     * @generated from protobuf field: uint32 leaf_version = 1;
     */
    leafVersion: number;
    /**
     * The script of the tap leaf.
     *
     * @generated from protobuf field: bytes script = 2;
     */
    script: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.TapscriptPartialReveal
 */
export interface TapscriptPartialReveal {
    /**
     * The tap leaf that is known and will be revealed.
     *
     * @generated from protobuf field: walletrpc.TapLeaf revealed_leaf = 1;
     */
    revealedLeaf?: TapLeaf;
    /**
     * The BIP-0341 serialized inclusion proof that is required to prove that
     * the revealed leaf is part of the tree. This contains 0..n blocks of 32
     * bytes. If the tree only contained a single leaf (which is the revealed
     * leaf), this can be empty.
     *
     * @generated from protobuf field: bytes full_inclusion_proof = 2;
     */
    fullInclusionProof: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.ImportTapscriptResponse
 */
export interface ImportTapscriptResponse {
    /**
     *
     * The resulting pay-to-Taproot address that represents the imported internal
     * key with the script committed to it.
     *
     * @generated from protobuf field: string p2tr_address = 1 [json_name = "p2trAddress"];
     */
    p2TrAddress: string;
}
/**
 * @generated from protobuf message walletrpc.Transaction
 */
export interface Transaction {
    /**
     *
     * The raw serialized transaction. Despite the field name, this does need to be
     * specified in raw bytes (or base64 encoded when using REST) and not in hex.
     * To not break existing software, the field can't simply be renamed.
     *
     * @generated from protobuf field: bytes tx_hex = 1;
     */
    txHex: Uint8Array;
    /**
     *
     * An optional label to save with the transaction. Limited to 500 characters.
     *
     * @generated from protobuf field: string label = 2;
     */
    label: string;
}
/**
 * @generated from protobuf message walletrpc.PublishResponse
 */
export interface PublishResponse {
    /**
     *
     * If blank, then no error occurred and the transaction was successfully
     * published. If not the empty string, then a string representation of the
     * broadcast error.
     *
     * TODO(roasbeef): map to a proper enum type
     *
     * @generated from protobuf field: string publish_error = 1;
     */
    publishError: string;
}
/**
 * @generated from protobuf message walletrpc.RemoveTransactionResponse
 */
export interface RemoveTransactionResponse {
    /**
     * The status of the remove transaction operation.
     *
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message walletrpc.SendOutputsRequest
 */
export interface SendOutputsRequest {
    /**
     *
     * The number of satoshis per kilo weight that should be used when crafting
     * this transaction.
     *
     * @generated from protobuf field: int64 sat_per_kw = 1;
     */
    satPerKw: bigint;
    /**
     *
     * A slice of the outputs that should be created in the transaction produced.
     *
     * @generated from protobuf field: repeated signrpc.TxOut outputs = 2;
     */
    outputs: TxOut[];
    /**
     * An optional label for the transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 3;
     */
    label: string;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 4;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 5;
     */
    spendUnconfirmed: boolean;
    /**
     * The strategy to use for selecting coins during sending the outputs.
     *
     * @generated from protobuf field: lnrpc.CoinSelectionStrategy coin_selection_strategy = 6;
     */
    coinSelectionStrategy: CoinSelectionStrategy;
}
/**
 * @generated from protobuf message walletrpc.SendOutputsResponse
 */
export interface SendOutputsResponse {
    /**
     *
     * The serialized transaction sent out on the network.
     *
     * @generated from protobuf field: bytes raw_tx = 1;
     */
    rawTx: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.EstimateFeeRequest
 */
export interface EstimateFeeRequest {
    /**
     *
     * The number of confirmations to shoot for when estimating the fee.
     *
     * @generated from protobuf field: int32 conf_target = 1;
     */
    confTarget: number;
}
/**
 * @generated from protobuf message walletrpc.EstimateFeeResponse
 */
export interface EstimateFeeResponse {
    /**
     *
     * The amount of satoshis per kw that should be used in order to reach the
     * confirmation target in the request.
     *
     * @generated from protobuf field: int64 sat_per_kw = 1;
     */
    satPerKw: bigint;
    /**
     * The current minimum relay fee based on our chain backend in sat/kw.
     *
     * @generated from protobuf field: int64 min_relay_fee_sat_per_kw = 2;
     */
    minRelayFeeSatPerKw: bigint;
}
/**
 * @generated from protobuf message walletrpc.PendingSweep
 */
export interface PendingSweep {
    /**
     * The outpoint of the output we're attempting to sweep.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 1;
     */
    outpoint?: OutPoint;
    /**
     * The witness type of the output we're attempting to sweep.
     *
     * @generated from protobuf field: walletrpc.WitnessType witness_type = 2;
     */
    witnessType: WitnessType;
    /**
     * The value of the output we're attempting to sweep.
     *
     * @generated from protobuf field: uint32 amount_sat = 3;
     */
    amountSat: number;
    /**
     *
     * Deprecated, use sat_per_vbyte.
     * The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee
     * rate is only determined once a sweeping transaction for the output is
     * created, so it's possible for this to be 0 before this.
     *
     * @deprecated
     * @generated from protobuf field: uint32 sat_per_byte = 4 [deprecated = true];
     */
    satPerByte: number;
    /**
     * The number of broadcast attempts we've made to sweep the output.
     *
     * @generated from protobuf field: uint32 broadcast_attempts = 5;
     */
    broadcastAttempts: number;
    /**
     *
     * Deprecated.
     * The next height of the chain at which we'll attempt to broadcast the
     * sweep transaction of the output.
     *
     * @deprecated
     * @generated from protobuf field: uint32 next_broadcast_height = 6 [deprecated = true];
     */
    nextBroadcastHeight: number;
    /**
     *
     * Deprecated, use immediate.
     * Whether this input must be force-swept. This means that it is swept
     * immediately.
     *
     * @deprecated
     * @generated from protobuf field: bool force = 7 [deprecated = true];
     */
    force: boolean;
    /**
     *
     * Deprecated, use deadline.
     * The requested confirmation target for this output, which is the deadline
     * used by the sweeper.
     *
     * @deprecated
     * @generated from protobuf field: uint32 requested_conf_target = 8 [deprecated = true];
     */
    requestedConfTarget: number;
    /**
     * Deprecated, use requested_sat_per_vbyte.
     * The requested fee rate, expressed in sat/vbyte, for this output.
     *
     * @deprecated
     * @generated from protobuf field: uint32 requested_sat_per_byte = 9 [deprecated = true];
     */
    requestedSatPerByte: number;
    /**
     *
     * The current fee rate we'll use to sweep the output, expressed in sat/vbyte.
     * The fee rate is only determined once a sweeping transaction for the output
     * is created, so it's possible for this to be 0 before this.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 10;
     */
    satPerVbyte: bigint;
    /**
     * The requested starting fee rate, expressed in sat/vbyte, for this
     * output. When not requested, this field will be 0.
     *
     * @generated from protobuf field: uint64 requested_sat_per_vbyte = 11;
     */
    requestedSatPerVbyte: bigint;
    /**
     *
     * Whether this input will be swept immediately.
     *
     * @generated from protobuf field: bool immediate = 12;
     */
    immediate: boolean;
    /**
     *
     * The budget for this sweep, expressed in satoshis. This is the maximum amount
     * that can be spent as fees to sweep this output.
     *
     * @generated from protobuf field: uint64 budget = 13;
     */
    budget: bigint;
    /**
     *
     * The deadline height used for this output when perform fee bumping.
     *
     * @generated from protobuf field: uint32 deadline_height = 14;
     */
    deadlineHeight: number;
}
/**
 * @generated from protobuf message walletrpc.PendingSweepsRequest
 */
export interface PendingSweepsRequest {
}
/**
 * @generated from protobuf message walletrpc.PendingSweepsResponse
 */
export interface PendingSweepsResponse {
    /**
     *
     * The set of outputs currently being swept by lnd's central batching engine.
     *
     * @generated from protobuf field: repeated walletrpc.PendingSweep pending_sweeps = 1;
     */
    pendingSweeps: PendingSweep[];
}
/**
 * @generated from protobuf message walletrpc.BumpFeeRequest
 */
export interface BumpFeeRequest {
    /**
     * The input we're attempting to bump the fee of.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 1;
     */
    outpoint?: OutPoint;
    /**
     * Optional. The deadline in number of blocks that the input should be spent
     * within. When not set, for new inputs, the default value (1008) is used;
     * for existing inputs, their current values will be retained.
     *
     * @generated from protobuf field: uint32 target_conf = 2;
     */
    targetConf: number;
    /**
     *
     * Deprecated, use sat_per_vbyte.
     * The fee rate, expressed in sat/vbyte, that should be used to spend the input
     * with.
     *
     * @deprecated
     * @generated from protobuf field: uint32 sat_per_byte = 3 [deprecated = true];
     */
    satPerByte: number;
    /**
     *
     * Deprecated, use immediate.
     * Whether this input must be force-swept. This means that it is swept
     * immediately.
     *
     * @deprecated
     * @generated from protobuf field: bool force = 4 [deprecated = true];
     */
    force: boolean;
    /**
     *
     * Optional. The starting fee rate, expressed in sat/vbyte, that will be used
     * to spend the input with initially. This value will be used by the sweeper's
     * fee function as its starting fee rate. When not set, the sweeper will use
     * the estimated fee rate using the `target_conf` as the starting fee rate.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 5;
     */
    satPerVbyte: bigint;
    /**
     *
     * Optional. Whether this input will be swept immediately. When set to true,
     * the sweeper will sweep this input without waiting for the next batch.
     *
     * @generated from protobuf field: bool immediate = 6;
     */
    immediate: boolean;
    /**
     *
     * Optional. The max amount in sats that can be used as the fees. Setting this
     * value greater than the input's value may result in CPFP - one or more wallet
     * utxos will be used to pay the fees specified by the budget. If not set, for
     * new inputs, by default 50% of the input's value will be treated as the
     * budget for fee bumping; for existing inputs, their current budgets will be
     * retained.
     *
     * @generated from protobuf field: uint64 budget = 7;
     */
    budget: bigint;
}
/**
 * @generated from protobuf message walletrpc.BumpFeeResponse
 */
export interface BumpFeeResponse {
    /**
     * The status of the bump fee operation.
     *
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message walletrpc.BumpForceCloseFeeRequest
 */
export interface BumpForceCloseFeeRequest {
    /**
     * The channel point which force close transaction we are attempting to
     * bump the fee rate for.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
    /**
     * Optional. The deadline delta in number of blocks that the anchor output
     * should be spent within to bump the closing transaction.
     *
     * @generated from protobuf field: uint32 deadline_delta = 2;
     */
    deadlineDelta: number;
    /**
     *
     * Optional. The starting fee rate, expressed in sat/vbyte. This value will be
     * used by the sweeper's fee function as its starting fee rate. When not set,
     * the sweeper will use the estimated fee rate using the target_conf as the
     * starting fee rate.
     *
     * @generated from protobuf field: uint64 starting_feerate = 3;
     */
    startingFeerate: bigint;
    /**
     *
     * Optional. Whether this cpfp transaction will be triggered immediately. When
     * set to true, the sweeper will consider all currently registered sweeps and
     * trigger new batch transactions including the sweeping of the anchor output
     * related to the selected force close transaction.
     *
     * @generated from protobuf field: bool immediate = 4;
     */
    immediate: boolean;
    /**
     *
     * Optional. The max amount in sats that can be used as the fees. For already
     * registered anchor outputs if not set explicitly the old value will be used.
     * For channel force closes which have no HTLCs in their commitment transaction
     * this value has to be set to an appropriate amount to pay for the cpfp
     * transaction of the force closed channel otherwise the fee bumping will fail.
     *
     * @generated from protobuf field: uint64 budget = 5;
     */
    budget: bigint;
}
/**
 * @generated from protobuf message walletrpc.BumpForceCloseFeeResponse
 */
export interface BumpForceCloseFeeResponse {
    /**
     * The status of the force close fee bump operation.
     *
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message walletrpc.ListSweepsRequest
 */
export interface ListSweepsRequest {
    /**
     *
     * Retrieve the full sweep transaction details. If false, only the sweep txids
     * will be returned. Note that some sweeps that LND publishes will have been
     * replaced-by-fee, so will not be included in this output.
     *
     * @generated from protobuf field: bool verbose = 1;
     */
    verbose: boolean;
    /**
     *
     * The start height to use when fetching sweeps. If not specified (0), the
     * result will start from the earliest sweep. If set to -1 the result will
     * only include unconfirmed sweeps (at the time of the call).
     *
     * @generated from protobuf field: int32 start_height = 2;
     */
    startHeight: number;
}
/**
 * @generated from protobuf message walletrpc.ListSweepsResponse
 */
export interface ListSweepsResponse {
    /**
     * @generated from protobuf oneof: sweeps
     */
    sweeps: {
        oneofKind: "transactionDetails";
        /**
         * @generated from protobuf field: lnrpc.TransactionDetails transaction_details = 1;
         */
        transactionDetails: TransactionDetails;
    } | {
        oneofKind: "transactionIds";
        /**
         * @generated from protobuf field: walletrpc.ListSweepsResponse.TransactionIDs transaction_ids = 2;
         */
        transactionIds: ListSweepsResponse_TransactionIDs;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message walletrpc.ListSweepsResponse.TransactionIDs
 */
export interface ListSweepsResponse_TransactionIDs {
    /**
     *
     * Reversed, hex-encoded string representing the transaction ids of the
     * sweeps that our node has broadcast. Note that these transactions may
     * not have confirmed yet, we record sweeps on broadcast, not confirmation.
     *
     * @generated from protobuf field: repeated string transaction_ids = 1;
     */
    transactionIds: string[];
}
/**
 * @generated from protobuf message walletrpc.LabelTransactionRequest
 */
export interface LabelTransactionRequest {
    /**
     * The txid of the transaction to label. Note: When using gRPC, the bytes
     * must be in little-endian (reverse) order.
     *
     * @generated from protobuf field: bytes txid = 1;
     */
    txid: Uint8Array;
    /**
     * The label to add to the transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * Whether to overwrite the existing label, if it is present.
     *
     * @generated from protobuf field: bool overwrite = 3;
     */
    overwrite: boolean;
}
/**
 * @generated from protobuf message walletrpc.LabelTransactionResponse
 */
export interface LabelTransactionResponse {
    /**
     * The status of the label operation.
     *
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message walletrpc.FundPsbtRequest
 */
export interface FundPsbtRequest {
    /**
     * @generated from protobuf oneof: template
     */
    template: {
        oneofKind: "psbt";
        /**
         *
         * Use an existing PSBT packet as the template for the funded PSBT.
         *
         * The packet must contain at least one non-dust output. If one or more
         * inputs are specified, no coin selection is performed. In that case every
         * input must be an UTXO known to the wallet that has not been locked
         * before. The sum of all inputs must be sufficiently greater than the sum
         * of all outputs to pay a miner fee with the specified fee rate. A change
         * output is added to the PSBT if necessary.
         *
         * @generated from protobuf field: bytes psbt = 1;
         */
        psbt: Uint8Array;
    } | {
        oneofKind: "raw";
        /**
         *
         * Use the outputs and optional inputs from this raw template.
         *
         * @generated from protobuf field: walletrpc.TxTemplate raw = 2;
         */
        raw: TxTemplate;
    } | {
        oneofKind: "coinSelect";
        /**
         *
         * Use an existing PSBT packet as the template for the funded PSBT.
         *
         * The difference to the pure PSBT template above is that coin selection is
         * performed even if inputs are specified. The output amounts are summed up
         * and used as the target amount for coin selection. A change output must
         * either already exist in the PSBT and be marked as such, otherwise a new
         * change output of the specified output type will be added. Any inputs
         * already specified in the PSBT must already be locked (if they belong to
         * this node), only newly added inputs will be locked by this RPC.
         *
         * In case the sum of the already provided inputs exceeds the required
         * output amount, no new coins are selected. Instead only the fee and
         * change amount calculation is performed (e.g. a change output is added if
         * requested or the change is added to the specified existing change
         * output, given there is any non-dust change). This can be identified by
         * the returned locked UTXOs being empty.
         *
         * @generated from protobuf field: walletrpc.PsbtCoinSelect coin_select = 9;
         */
        coinSelect: PsbtCoinSelect;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: fees
     */
    fees: {
        oneofKind: "targetConf";
        /**
         *
         * The target number of blocks that the transaction should be confirmed in.
         *
         * @generated from protobuf field: uint32 target_conf = 3;
         */
        targetConf: number;
    } | {
        oneofKind: "satPerVbyte";
        /**
         *
         * The fee rate, expressed in sat/vbyte, that should be used to spend the
         * input with.
         *
         * @generated from protobuf field: uint64 sat_per_vbyte = 4;
         */
        satPerVbyte: bigint;
    } | {
        oneofKind: "satPerKw";
        /**
         *
         * The fee rate, expressed in sat/kWU, that should be used to spend the
         * input with.
         *
         * @generated from protobuf field: uint64 sat_per_kw = 11;
         */
        satPerKw: bigint;
    } | {
        oneofKind: undefined;
    };
    /**
     *
     * The name of the account to fund the PSBT with. If empty, the default wallet
     * account is used.
     *
     * @generated from protobuf field: string account = 5;
     */
    account: string;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 6;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 7;
     */
    spendUnconfirmed: boolean;
    /**
     * The address type for the change. If empty, P2WPKH addresses will be used
     * for default accounts and single imported public keys. For custom
     * accounts, no change type should be provided as the coin selection key
     * scope will always be used to generate the change address.
     *
     * @generated from protobuf field: walletrpc.ChangeAddressType change_type = 8;
     */
    changeType: ChangeAddressType;
    /**
     * The strategy to use for selecting coins during funding the PSBT.
     *
     * @generated from protobuf field: lnrpc.CoinSelectionStrategy coin_selection_strategy = 10;
     */
    coinSelectionStrategy: CoinSelectionStrategy;
    /**
     * The max fee to total output amount ratio that this psbt should adhere to.
     *
     * @generated from protobuf field: double max_fee_ratio = 12;
     */
    maxFeeRatio: number;
}
/**
 * @generated from protobuf message walletrpc.FundPsbtResponse
 */
export interface FundPsbtResponse {
    /**
     *
     * The funded but not yet signed PSBT packet.
     *
     * @generated from protobuf field: bytes funded_psbt = 1;
     */
    fundedPsbt: Uint8Array;
    /**
     *
     * The index of the added change output or -1 if no change was left over.
     *
     * @generated from protobuf field: int32 change_output_index = 2;
     */
    changeOutputIndex: number;
    /**
     *
     * The list of lock leases that were acquired for the inputs in the funded PSBT
     * packet. Only inputs added to the PSBT by this RPC are locked, inputs that
     * were already present in the PSBT are not locked.
     *
     * @generated from protobuf field: repeated walletrpc.UtxoLease locked_utxos = 3;
     */
    lockedUtxos: UtxoLease[];
}
/**
 * @generated from protobuf message walletrpc.TxTemplate
 */
export interface TxTemplate {
    /**
     *
     * An optional list of inputs to use. Every input must be an UTXO known to the
     * wallet that has not been locked before. The sum of all inputs must be
     * sufficiently greater than the sum of all outputs to pay a miner fee with the
     * fee rate specified in the parent message.
     *
     * If no inputs are specified, coin selection will be performed instead and
     * inputs of sufficient value will be added to the resulting PSBT.
     *
     * @generated from protobuf field: repeated lnrpc.OutPoint inputs = 1;
     */
    inputs: OutPoint[];
    /**
     *
     * A map of all addresses and the amounts to send to in the funded PSBT.
     *
     * @generated from protobuf field: map<string, uint64> outputs = 2;
     */
    outputs: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message walletrpc.PsbtCoinSelect
 */
export interface PsbtCoinSelect {
    /**
     *
     * The template to use for the funded PSBT. The template must contain at least
     * one non-dust output. The amount to be funded is calculated by summing up the
     * amounts of all outputs in the template, subtracting all the input values of
     * the already specified inputs. The change value is added to the output that
     * is marked as such (or a new change output is added if none is marked). For
     * the input amount calculation to be correct, the template must have the
     * WitnessUtxo field set for all inputs. Any inputs already specified in the
     * PSBT must already be locked (if they belong to this node), only newly added
     * inputs will be locked by this RPC.
     *
     * @generated from protobuf field: bytes psbt = 1;
     */
    psbt: Uint8Array;
    /**
     * @generated from protobuf oneof: change_output
     */
    changeOutput: {
        oneofKind: "existingOutputIndex";
        /**
         *
         * Use the existing output within the template PSBT with the specified
         * index as the change output. Any leftover change will be added to the
         * already specified amount of that output. To add a new change output to
         * the PSBT, set the "add" field below instead. The type of change output
         * added is defined by change_type in the parent message.
         *
         * @generated from protobuf field: int32 existing_output_index = 2;
         */
        existingOutputIndex: number;
    } | {
        oneofKind: "add";
        /**
         *
         * Add a new change output to the PSBT using the change_type specified in
         * the parent message.
         *
         * @generated from protobuf field: bool add = 3;
         */
        add: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message walletrpc.UtxoLease
 */
export interface UtxoLease {
    /**
     *
     * A 32 byte random ID that identifies the lease.
     *
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * The identifying outpoint of the output being leased.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 2;
     */
    outpoint?: OutPoint;
    /**
     *
     * The absolute expiration of the output lease represented as a unix timestamp.
     *
     * @generated from protobuf field: uint64 expiration = 3;
     */
    expiration: bigint;
    /**
     *
     * The public key script of the leased output.
     *
     * @generated from protobuf field: bytes pk_script = 4;
     */
    pkScript: Uint8Array;
    /**
     *
     * The value of the leased output in satoshis.
     *
     * @generated from protobuf field: uint64 value = 5;
     */
    value: bigint;
}
/**
 * @generated from protobuf message walletrpc.SignPsbtRequest
 */
export interface SignPsbtRequest {
    /**
     *
     * The PSBT that should be signed. The PSBT must contain all required inputs,
     * outputs, UTXO data and custom fields required to identify the signing key.
     *
     * @generated from protobuf field: bytes funded_psbt = 1;
     */
    fundedPsbt: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.SignPsbtResponse
 */
export interface SignPsbtResponse {
    /**
     * The signed transaction in PSBT format.
     *
     * @generated from protobuf field: bytes signed_psbt = 1;
     */
    signedPsbt: Uint8Array;
    /**
     * The indices of signed inputs.
     *
     * @generated from protobuf field: repeated uint32 signed_inputs = 2;
     */
    signedInputs: number[];
}
/**
 * @generated from protobuf message walletrpc.FinalizePsbtRequest
 */
export interface FinalizePsbtRequest {
    /**
     *
     * A PSBT that should be signed and finalized. The PSBT must contain all
     * required inputs, outputs, UTXO data and partial signatures of all other
     * signers.
     *
     * @generated from protobuf field: bytes funded_psbt = 1;
     */
    fundedPsbt: Uint8Array;
    /**
     *
     * The name of the account to finalize the PSBT with. If empty, the default
     * wallet account is used.
     *
     * @generated from protobuf field: string account = 5;
     */
    account: string;
}
/**
 * @generated from protobuf message walletrpc.FinalizePsbtResponse
 */
export interface FinalizePsbtResponse {
    /**
     * The fully signed and finalized transaction in PSBT format.
     *
     * @generated from protobuf field: bytes signed_psbt = 1;
     */
    signedPsbt: Uint8Array;
    /**
     * The fully signed and finalized transaction in the raw wire format.
     *
     * @generated from protobuf field: bytes raw_final_tx = 2;
     */
    rawFinalTx: Uint8Array;
}
/**
 * @generated from protobuf message walletrpc.ListLeasesRequest
 */
export interface ListLeasesRequest {
}
/**
 * @generated from protobuf message walletrpc.ListLeasesResponse
 */
export interface ListLeasesResponse {
    /**
     * The list of currently leased utxos.
     *
     * @generated from protobuf field: repeated walletrpc.UtxoLease locked_utxos = 1;
     */
    lockedUtxos: UtxoLease[];
}
/**
 * @generated from protobuf enum walletrpc.AddressType
 */
export enum AddressType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: WITNESS_PUBKEY_HASH = 1;
     */
    WITNESS_PUBKEY_HASH = 1,
    /**
     * @generated from protobuf enum value: NESTED_WITNESS_PUBKEY_HASH = 2;
     */
    NESTED_WITNESS_PUBKEY_HASH = 2,
    /**
     * @generated from protobuf enum value: HYBRID_NESTED_WITNESS_PUBKEY_HASH = 3;
     */
    HYBRID_NESTED_WITNESS_PUBKEY_HASH = 3,
    /**
     * @generated from protobuf enum value: TAPROOT_PUBKEY = 4;
     */
    TAPROOT_PUBKEY = 4
}
/**
 * @generated from protobuf enum walletrpc.WitnessType
 */
export enum WitnessType {
    /**
     * @generated from protobuf enum value: UNKNOWN_WITNESS = 0;
     */
    UNKNOWN_WITNESS = 0,
    /**
     *
     * A witness that allows us to spend the output of a commitment transaction
     * after a relative lock-time lockout.
     *
     * @generated from protobuf enum value: COMMITMENT_TIME_LOCK = 1;
     */
    COMMITMENT_TIME_LOCK = 1,
    /**
     *
     * A witness that allows us to spend a settled no-delay output immediately on a
     * counterparty's commitment transaction.
     *
     * @generated from protobuf enum value: COMMITMENT_NO_DELAY = 2;
     */
    COMMITMENT_NO_DELAY = 2,
    /**
     *
     * A witness that allows us to sweep the settled output of a malicious
     * counterparty's who broadcasts a revoked commitment transaction.
     *
     * @generated from protobuf enum value: COMMITMENT_REVOKE = 3;
     */
    COMMITMENT_REVOKE = 3,
    /**
     *
     * A witness that allows us to sweep an HTLC which we offered to the remote
     * party in the case that they broadcast a revoked commitment state.
     *
     * @generated from protobuf enum value: HTLC_OFFERED_REVOKE = 4;
     */
    HTLC_OFFERED_REVOKE = 4,
    /**
     *
     * A witness that allows us to sweep an HTLC output sent to us in the case that
     * the remote party broadcasts a revoked commitment state.
     *
     * @generated from protobuf enum value: HTLC_ACCEPTED_REVOKE = 5;
     */
    HTLC_ACCEPTED_REVOKE = 5,
    /**
     *
     * A witness that allows us to sweep an HTLC output that we extended to a
     * party, but was never fulfilled.  This HTLC output isn't directly on the
     * commitment transaction, but is the result of a confirmed second-level HTLC
     * transaction. As a result, we can only spend this after a CSV delay.
     *
     * @generated from protobuf enum value: HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 6;
     */
    HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 6,
    /**
     *
     * A witness that allows us to sweep an HTLC output that was offered to us, and
     * for which we have a payment preimage. This HTLC output isn't directly on our
     * commitment transaction, but is the result of confirmed second-level HTLC
     * transaction. As a result, we can only spend this after a CSV delay.
     *
     * @generated from protobuf enum value: HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 7;
     */
    HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 7,
    /**
     *
     * A witness that allows us to sweep an HTLC that we offered to the remote
     * party which lies in the commitment transaction of the remote party. We can
     * spend this output after the absolute CLTV timeout of the HTLC as passed.
     *
     * @generated from protobuf enum value: HTLC_OFFERED_REMOTE_TIMEOUT = 8;
     */
    HTLC_OFFERED_REMOTE_TIMEOUT = 8,
    /**
     *
     * A witness that allows us to sweep an HTLC that was offered to us by the
     * remote party. We use this witness in the case that the remote party goes to
     * chain, and we know the pre-image to the HTLC. We can sweep this without any
     * additional timeout.
     *
     * @generated from protobuf enum value: HTLC_ACCEPTED_REMOTE_SUCCESS = 9;
     */
    HTLC_ACCEPTED_REMOTE_SUCCESS = 9,
    /**
     *
     * A witness that allows us to sweep an HTLC from the remote party's commitment
     * transaction in the case that the broadcast a revoked commitment, but then
     * also immediately attempt to go to the second level to claim the HTLC.
     *
     * @generated from protobuf enum value: HTLC_SECOND_LEVEL_REVOKE = 10;
     */
    HTLC_SECOND_LEVEL_REVOKE = 10,
    /**
     *
     * A witness type that allows us to spend a regular p2wkh output that's sent to
     * an output which is under complete control of the backing wallet.
     *
     * @generated from protobuf enum value: WITNESS_KEY_HASH = 11;
     */
    WITNESS_KEY_HASH = 11,
    /**
     *
     * A witness type that allows us to sweep an output that sends to a nested P2SH
     * script that pays to a key solely under our control.
     *
     * @generated from protobuf enum value: NESTED_WITNESS_KEY_HASH = 12;
     */
    NESTED_WITNESS_KEY_HASH = 12,
    /**
     *
     * A witness type that allows us to spend our anchor on the commitment
     * transaction.
     *
     * @generated from protobuf enum value: COMMITMENT_ANCHOR = 13;
     */
    COMMITMENT_ANCHOR = 13,
    /**
     *
     * A witness type that is similar to the COMMITMENT_NO_DELAY type,
     * but it omits the tweak that randomizes the key we need to
     * spend with a channel peer supplied set of randomness.
     *
     * @generated from protobuf enum value: COMMITMENT_NO_DELAY_TWEAKLESS = 14;
     */
    COMMITMENT_NO_DELAY_TWEAKLESS = 14,
    /**
     *
     * A witness type that allows us to spend our output on the counterparty's
     * commitment transaction after a confirmation.
     *
     * @generated from protobuf enum value: COMMITMENT_TO_REMOTE_CONFIRMED = 15;
     */
    COMMITMENT_TO_REMOTE_CONFIRMED = 15,
    /**
     *
     * A witness type that allows us to sweep an HTLC output that we extended
     * to a party, but was never fulfilled. This _is_ the HTLC output directly
     * on our commitment transaction, and the input to the second-level HTLC
     * timeout transaction. It can only be spent after CLTV expiry, and
     * commitment confirmation.
     *
     * @generated from protobuf enum value: HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED = 16;
     */
    HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED = 16,
    /**
     *
     * A witness type that allows us to sweep an HTLC output that was offered
     * to us, and for which we have a payment preimage. This _is_ the HTLC
     * output directly on our commitment transaction, and the input to the
     * second-level HTLC success transaction. It can only be spent after the
     * commitment has confirmed.
     *
     * @generated from protobuf enum value: HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED = 17;
     */
    HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED = 17,
    /**
     *
     * A witness type that allows us to spend our output on our local
     * commitment transaction after a relative and absolute lock-time lockout as
     * part of the script enforced lease commitment type.
     *
     * @generated from protobuf enum value: LEASE_COMMITMENT_TIME_LOCK = 18;
     */
    LEASE_COMMITMENT_TIME_LOCK = 18,
    /**
     *
     * A witness type that allows us to spend our output on the counterparty's
     * commitment transaction after a confirmation and absolute locktime as part
     * of the script enforced lease commitment type.
     *
     * @generated from protobuf enum value: LEASE_COMMITMENT_TO_REMOTE_CONFIRMED = 19;
     */
    LEASE_COMMITMENT_TO_REMOTE_CONFIRMED = 19,
    /**
     *
     * A witness type that allows us to sweep an HTLC output that we extended
     * to a party, but was never fulfilled. This HTLC output isn't directly on
     * the commitment transaction, but is the result of a confirmed second-level
     * HTLC transaction. As a result, we can only spend this after a CSV delay
     * and CLTV locktime as part of the script enforced lease commitment type.
     *
     * @generated from protobuf enum value: LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 20;
     */
    LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 20,
    /**
     *
     * A witness type that allows us to sweep an HTLC output that was offered
     * to us, and for which we have a payment preimage. This HTLC output isn't
     * directly on our commitment transaction, but is the result of confirmed
     * second-level HTLC transaction. As a result, we can only spend this after
     * a CSV delay and CLTV locktime as part of the script enforced lease
     * commitment type.
     *
     * @generated from protobuf enum value: LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 21;
     */
    LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 21,
    /**
     *
     * A witness type that allows us to spend a regular p2tr output that's sent
     * to an output which is under complete control of the backing wallet.
     *
     * @generated from protobuf enum value: TAPROOT_PUB_KEY_SPEND = 22;
     */
    TAPROOT_PUB_KEY_SPEND = 22,
    /**
     *
     * A witness type that allows us to spend our settled local commitment after a
     * CSV delay when we force close the channel.
     *
     * @generated from protobuf enum value: TAPROOT_LOCAL_COMMIT_SPEND = 23;
     */
    TAPROOT_LOCAL_COMMIT_SPEND = 23,
    /**
     *
     * A witness type that allows us to spend our settled local commitment after
     * a CSV delay when the remote party has force closed the channel.
     *
     * @generated from protobuf enum value: TAPROOT_REMOTE_COMMIT_SPEND = 24;
     */
    TAPROOT_REMOTE_COMMIT_SPEND = 24,
    /**
     *
     * A witness type that we'll use for spending our own anchor output.
     *
     * @generated from protobuf enum value: TAPROOT_ANCHOR_SWEEP_SPEND = 25;
     */
    TAPROOT_ANCHOR_SWEEP_SPEND = 25,
    /**
     *
     * A witness that allows us to timeout an HTLC we offered to the remote party
     * on our commitment transaction. We use this when we need to go on chain to
     * time out an HTLC.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 26;
     */
    TAPROOT_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 26,
    /**
     *
     * A witness type that allows us to sweep an HTLC we accepted on our commitment
     * transaction after we go to the second level on chain.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 27;
     */
    TAPROOT_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 27,
    /**
     *
     * A witness that allows us to sweep an HTLC on the revoked transaction of the
     * remote party that goes to the second level.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_SECOND_LEVEL_REVOKE = 28;
     */
    TAPROOT_HTLC_SECOND_LEVEL_REVOKE = 28,
    /**
     *
     * A witness that allows us to sweep an HTLC sent to us by the remote party
     * in the event that they broadcast a revoked state.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_ACCEPTED_REVOKE = 29;
     */
    TAPROOT_HTLC_ACCEPTED_REVOKE = 29,
    /**
     *
     * A witness that allows us to sweep an HTLC we offered to the remote party if
     * they broadcast a revoked commitment.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_OFFERED_REVOKE = 30;
     */
    TAPROOT_HTLC_OFFERED_REVOKE = 30,
    /**
     *
     * A witness that allows us to sweep an HTLC we offered to the remote party
     * that lies on the commitment transaction for the remote party. We can spend
     * this output after the absolute CLTV timeout of the HTLC as passed.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_OFFERED_REMOTE_TIMEOUT = 31;
     */
    TAPROOT_HTLC_OFFERED_REMOTE_TIMEOUT = 31,
    /**
     *
     * A witness type that allows us to sign the second level HTLC timeout
     * transaction when spending from an HTLC residing on our local commitment
     * transaction.
     * This is used by the sweeper to re-sign inputs if it needs to aggregate
     * several second level HTLCs.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_LOCAL_OFFERED_TIMEOUT = 32;
     */
    TAPROOT_HTLC_LOCAL_OFFERED_TIMEOUT = 32,
    /**
     *
     * A witness that allows us to sweep an HTLC that was offered to us by the
     * remote party for a taproot channels. We use this witness in the case that
     * the remote party goes to chain, and we know the pre-image to the HTLC. We
     * can sweep this without any additional timeout.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_ACCEPTED_REMOTE_SUCCESS = 33;
     */
    TAPROOT_HTLC_ACCEPTED_REMOTE_SUCCESS = 33,
    /**
     *
     * A witness type that allows us to sweep the HTLC offered to us on our local
     * commitment transaction. We'll use this when we need to go on chain to sweep
     * the HTLC. In this case, this is the second level HTLC success transaction.
     *
     * @generated from protobuf enum value: TAPROOT_HTLC_ACCEPTED_LOCAL_SUCCESS = 34;
     */
    TAPROOT_HTLC_ACCEPTED_LOCAL_SUCCESS = 34,
    /**
     *
     * A witness that allows us to sweep the settled output of a malicious
     * counterparty's who broadcasts a revoked taproot commitment transaction.
     *
     * @generated from protobuf enum value: TAPROOT_COMMITMENT_REVOKE = 35;
     */
    TAPROOT_COMMITMENT_REVOKE = 35
}
/**
 * The possible change address types for default accounts and single imported
 * public keys. By default, P2WPKH will be used. We don't provide the
 * possibility to choose P2PKH as it is a legacy key scope, nor NP2WPKH as
 * no key scope permits to do so. For custom accounts, no change type should
 * be provided as the coin selection key scope will always be used to generate
 * the change address.
 *
 * @generated from protobuf enum walletrpc.ChangeAddressType
 */
export enum ChangeAddressType {
    /**
     * CHANGE_ADDRESS_TYPE_UNSPECIFIED indicates that no change address type is
     * provided. We will then use P2WPKH address type for change (BIP0084 key
     * scope).
     *
     * @generated from protobuf enum value: CHANGE_ADDRESS_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * CHANGE_ADDRESS_TYPE_P2TR indicates to use P2TR address for change output
     * (BIP0086 key scope).
     *
     * @generated from protobuf enum value: CHANGE_ADDRESS_TYPE_P2TR = 1;
     */
    P2TR = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class ListUnspentRequest$Type extends MessageType<ListUnspentRequest> {
    constructor() {
        super("walletrpc.ListUnspentRequest", [
            { no: 1, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "max_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unconfirmed_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListUnspentRequest>): ListUnspentRequest {
        const message = { minConfs: 0, maxConfs: 0, account: "", unconfirmedOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUnspentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnspentRequest): ListUnspentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 min_confs */ 1:
                    message.minConfs = reader.int32();
                    break;
                case /* int32 max_confs */ 2:
                    message.maxConfs = reader.int32();
                    break;
                case /* string account */ 3:
                    message.account = reader.string();
                    break;
                case /* bool unconfirmed_only */ 4:
                    message.unconfirmedOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUnspentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 min_confs = 1; */
        if (message.minConfs !== 0)
            writer.tag(1, WireType.Varint).int32(message.minConfs);
        /* int32 max_confs = 2; */
        if (message.maxConfs !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxConfs);
        /* string account = 3; */
        if (message.account !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.account);
        /* bool unconfirmed_only = 4; */
        if (message.unconfirmedOnly !== false)
            writer.tag(4, WireType.Varint).bool(message.unconfirmedOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListUnspentRequest
 */
export const ListUnspentRequest = new ListUnspentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUnspentResponse$Type extends MessageType<ListUnspentResponse> {
    constructor() {
        super("walletrpc.ListUnspentResponse", [
            { no: 1, name: "utxos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Utxo }
        ]);
    }
    create(value?: PartialMessage<ListUnspentResponse>): ListUnspentResponse {
        const message = { utxos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUnspentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnspentResponse): ListUnspentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Utxo utxos */ 1:
                    message.utxos.push(Utxo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUnspentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Utxo utxos = 1; */
        for (let i = 0; i < message.utxos.length; i++)
            Utxo.internalBinaryWrite(message.utxos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListUnspentResponse
 */
export const ListUnspentResponse = new ListUnspentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseOutputRequest$Type extends MessageType<LeaseOutputRequest> {
    constructor() {
        super("walletrpc.LeaseOutputRequest", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 3, name: "expiration_seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LeaseOutputRequest>): LeaseOutputRequest {
        const message = { id: new Uint8Array(0), expirationSeconds: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LeaseOutputRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseOutputRequest): LeaseOutputRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* lnrpc.OutPoint outpoint */ 2:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* uint64 expiration_seconds */ 3:
                    message.expirationSeconds = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseOutputRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* lnrpc.OutPoint outpoint = 2; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 expiration_seconds = 3; */
        if (message.expirationSeconds !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.expirationSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.LeaseOutputRequest
 */
export const LeaseOutputRequest = new LeaseOutputRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseOutputResponse$Type extends MessageType<LeaseOutputResponse> {
    constructor() {
        super("walletrpc.LeaseOutputResponse", [
            { no: 1, name: "expiration", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LeaseOutputResponse>): LeaseOutputResponse {
        const message = { expiration: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LeaseOutputResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseOutputResponse): LeaseOutputResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 expiration */ 1:
                    message.expiration = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseOutputResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 expiration = 1; */
        if (message.expiration !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.expiration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.LeaseOutputResponse
 */
export const LeaseOutputResponse = new LeaseOutputResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseOutputRequest$Type extends MessageType<ReleaseOutputRequest> {
    constructor() {
        super("walletrpc.ReleaseOutputRequest", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "outpoint", kind: "message", T: () => OutPoint }
        ]);
    }
    create(value?: PartialMessage<ReleaseOutputRequest>): ReleaseOutputRequest {
        const message = { id: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReleaseOutputRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseOutputRequest): ReleaseOutputRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* lnrpc.OutPoint outpoint */ 2:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseOutputRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* lnrpc.OutPoint outpoint = 2; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ReleaseOutputRequest
 */
export const ReleaseOutputRequest = new ReleaseOutputRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseOutputResponse$Type extends MessageType<ReleaseOutputResponse> {
    constructor() {
        super("walletrpc.ReleaseOutputResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReleaseOutputResponse>): ReleaseOutputResponse {
        const message = { status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReleaseOutputResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseOutputResponse): ReleaseOutputResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseOutputResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ReleaseOutputResponse
 */
export const ReleaseOutputResponse = new ReleaseOutputResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyReq$Type extends MessageType<KeyReq> {
    constructor() {
        super("walletrpc.KeyReq", [
            { no: 1, name: "key_finger_print", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "key_family", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<KeyReq>): KeyReq {
        const message = { keyFingerPrint: 0, keyFamily: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyReq): KeyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 key_finger_print */ 1:
                    message.keyFingerPrint = reader.int32();
                    break;
                case /* int32 key_family */ 2:
                    message.keyFamily = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 key_finger_print = 1; */
        if (message.keyFingerPrint !== 0)
            writer.tag(1, WireType.Varint).int32(message.keyFingerPrint);
        /* int32 key_family = 2; */
        if (message.keyFamily !== 0)
            writer.tag(2, WireType.Varint).int32(message.keyFamily);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.KeyReq
 */
export const KeyReq = new KeyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddrRequest$Type extends MessageType<AddrRequest> {
    constructor() {
        super("walletrpc.AddrRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["walletrpc.AddressType", AddressType] },
            { no: 3, name: "change", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AddrRequest>): AddrRequest {
        const message = { account: "", type: 0, change: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddrRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddrRequest): AddrRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* walletrpc.AddressType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* bool change */ 3:
                    message.change = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddrRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* walletrpc.AddressType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* bool change = 3; */
        if (message.change !== false)
            writer.tag(3, WireType.Varint).bool(message.change);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.AddrRequest
 */
export const AddrRequest = new AddrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddrResponse$Type extends MessageType<AddrResponse> {
    constructor() {
        super("walletrpc.AddrResponse", [
            { no: 1, name: "addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddrResponse>): AddrResponse {
        const message = { addr: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddrResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddrResponse): AddrResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string addr */ 1:
                    message.addr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddrResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string addr = 1; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.AddrResponse
 */
export const AddrResponse = new AddrResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Account$Type extends MessageType<Account> {
    constructor() {
        super("walletrpc.Account", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address_type", kind: "enum", T: () => ["walletrpc.AddressType", AddressType] },
            { no: 3, name: "extended_public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "master_key_fingerprint", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "derivation_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "external_key_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "internal_key_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "watch_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Account>): Account {
        const message = { name: "", addressType: 0, extendedPublicKey: "", masterKeyFingerprint: new Uint8Array(0), derivationPath: "", externalKeyCount: 0, internalKeyCount: 0, watchOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Account>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Account): Account {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* walletrpc.AddressType address_type */ 2:
                    message.addressType = reader.int32();
                    break;
                case /* string extended_public_key */ 3:
                    message.extendedPublicKey = reader.string();
                    break;
                case /* bytes master_key_fingerprint */ 4:
                    message.masterKeyFingerprint = reader.bytes();
                    break;
                case /* string derivation_path */ 5:
                    message.derivationPath = reader.string();
                    break;
                case /* uint32 external_key_count */ 6:
                    message.externalKeyCount = reader.uint32();
                    break;
                case /* uint32 internal_key_count */ 7:
                    message.internalKeyCount = reader.uint32();
                    break;
                case /* bool watch_only */ 8:
                    message.watchOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Account, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* walletrpc.AddressType address_type = 2; */
        if (message.addressType !== 0)
            writer.tag(2, WireType.Varint).int32(message.addressType);
        /* string extended_public_key = 3; */
        if (message.extendedPublicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.extendedPublicKey);
        /* bytes master_key_fingerprint = 4; */
        if (message.masterKeyFingerprint.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.masterKeyFingerprint);
        /* string derivation_path = 5; */
        if (message.derivationPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.derivationPath);
        /* uint32 external_key_count = 6; */
        if (message.externalKeyCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.externalKeyCount);
        /* uint32 internal_key_count = 7; */
        if (message.internalKeyCount !== 0)
            writer.tag(7, WireType.Varint).uint32(message.internalKeyCount);
        /* bool watch_only = 8; */
        if (message.watchOnly !== false)
            writer.tag(8, WireType.Varint).bool(message.watchOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.Account
 */
export const Account = new Account$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddressProperty$Type extends MessageType<AddressProperty> {
    constructor() {
        super("walletrpc.AddressProperty", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_internal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "derivation_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AddressProperty>): AddressProperty {
        const message = { address: "", isInternal: false, balance: 0n, derivationPath: "", publicKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddressProperty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddressProperty): AddressProperty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* bool is_internal */ 2:
                    message.isInternal = reader.bool();
                    break;
                case /* int64 balance */ 3:
                    message.balance = reader.int64().toBigInt();
                    break;
                case /* string derivation_path */ 4:
                    message.derivationPath = reader.string();
                    break;
                case /* bytes public_key */ 5:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddressProperty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* bool is_internal = 2; */
        if (message.isInternal !== false)
            writer.tag(2, WireType.Varint).bool(message.isInternal);
        /* int64 balance = 3; */
        if (message.balance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.balance);
        /* string derivation_path = 4; */
        if (message.derivationPath !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.derivationPath);
        /* bytes public_key = 5; */
        if (message.publicKey.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.AddressProperty
 */
export const AddressProperty = new AddressProperty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountWithAddresses$Type extends MessageType<AccountWithAddresses> {
    constructor() {
        super("walletrpc.AccountWithAddresses", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address_type", kind: "enum", T: () => ["walletrpc.AddressType", AddressType] },
            { no: 3, name: "derivation_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressProperty }
        ]);
    }
    create(value?: PartialMessage<AccountWithAddresses>): AccountWithAddresses {
        const message = { name: "", addressType: 0, derivationPath: "", addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountWithAddresses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountWithAddresses): AccountWithAddresses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* walletrpc.AddressType address_type */ 2:
                    message.addressType = reader.int32();
                    break;
                case /* string derivation_path */ 3:
                    message.derivationPath = reader.string();
                    break;
                case /* repeated walletrpc.AddressProperty addresses */ 4:
                    message.addresses.push(AddressProperty.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountWithAddresses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* walletrpc.AddressType address_type = 2; */
        if (message.addressType !== 0)
            writer.tag(2, WireType.Varint).int32(message.addressType);
        /* string derivation_path = 3; */
        if (message.derivationPath !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.derivationPath);
        /* repeated walletrpc.AddressProperty addresses = 4; */
        for (let i = 0; i < message.addresses.length; i++)
            AddressProperty.internalBinaryWrite(message.addresses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.AccountWithAddresses
 */
export const AccountWithAddresses = new AccountWithAddresses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccountsRequest$Type extends MessageType<ListAccountsRequest> {
    constructor() {
        super("walletrpc.ListAccountsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address_type", kind: "enum", T: () => ["walletrpc.AddressType", AddressType] }
        ]);
    }
    create(value?: PartialMessage<ListAccountsRequest>): ListAccountsRequest {
        const message = { name: "", addressType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListAccountsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccountsRequest): ListAccountsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* walletrpc.AddressType address_type */ 2:
                    message.addressType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccountsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* walletrpc.AddressType address_type = 2; */
        if (message.addressType !== 0)
            writer.tag(2, WireType.Varint).int32(message.addressType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListAccountsRequest
 */
export const ListAccountsRequest = new ListAccountsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccountsResponse$Type extends MessageType<ListAccountsResponse> {
    constructor() {
        super("walletrpc.ListAccountsResponse", [
            { no: 1, name: "accounts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Account }
        ]);
    }
    create(value?: PartialMessage<ListAccountsResponse>): ListAccountsResponse {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListAccountsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccountsResponse): ListAccountsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated walletrpc.Account accounts */ 1:
                    message.accounts.push(Account.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated walletrpc.Account accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            Account.internalBinaryWrite(message.accounts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListAccountsResponse
 */
export const ListAccountsResponse = new ListAccountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequiredReserveRequest$Type extends MessageType<RequiredReserveRequest> {
    constructor() {
        super("walletrpc.RequiredReserveRequest", [
            { no: 1, name: "additional_public_channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RequiredReserveRequest>): RequiredReserveRequest {
        const message = { additionalPublicChannels: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequiredReserveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequiredReserveRequest): RequiredReserveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 additional_public_channels */ 1:
                    message.additionalPublicChannels = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequiredReserveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 additional_public_channels = 1; */
        if (message.additionalPublicChannels !== 0)
            writer.tag(1, WireType.Varint).uint32(message.additionalPublicChannels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.RequiredReserveRequest
 */
export const RequiredReserveRequest = new RequiredReserveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequiredReserveResponse$Type extends MessageType<RequiredReserveResponse> {
    constructor() {
        super("walletrpc.RequiredReserveResponse", [
            { no: 1, name: "required_reserve", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RequiredReserveResponse>): RequiredReserveResponse {
        const message = { requiredReserve: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequiredReserveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequiredReserveResponse): RequiredReserveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 required_reserve */ 1:
                    message.requiredReserve = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequiredReserveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 required_reserve = 1; */
        if (message.requiredReserve !== 0n)
            writer.tag(1, WireType.Varint).int64(message.requiredReserve);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.RequiredReserveResponse
 */
export const RequiredReserveResponse = new RequiredReserveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAddressesRequest$Type extends MessageType<ListAddressesRequest> {
    constructor() {
        super("walletrpc.ListAddressesRequest", [
            { no: 1, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "show_custom_accounts", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListAddressesRequest>): ListAddressesRequest {
        const message = { accountName: "", showCustomAccounts: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAddressesRequest): ListAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* bool show_custom_accounts */ 2:
                    message.showCustomAccounts = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 1; */
        if (message.accountName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* bool show_custom_accounts = 2; */
        if (message.showCustomAccounts !== false)
            writer.tag(2, WireType.Varint).bool(message.showCustomAccounts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListAddressesRequest
 */
export const ListAddressesRequest = new ListAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAddressesResponse$Type extends MessageType<ListAddressesResponse> {
    constructor() {
        super("walletrpc.ListAddressesResponse", [
            { no: 1, name: "account_with_addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccountWithAddresses }
        ]);
    }
    create(value?: PartialMessage<ListAddressesResponse>): ListAddressesResponse {
        const message = { accountWithAddresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAddressesResponse): ListAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated walletrpc.AccountWithAddresses account_with_addresses */ 1:
                    message.accountWithAddresses.push(AccountWithAddresses.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated walletrpc.AccountWithAddresses account_with_addresses = 1; */
        for (let i = 0; i < message.accountWithAddresses.length; i++)
            AccountWithAddresses.internalBinaryWrite(message.accountWithAddresses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListAddressesResponse
 */
export const ListAddressesResponse = new ListAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTransactionRequest$Type extends MessageType<GetTransactionRequest> {
    constructor() {
        super("walletrpc.GetTransactionRequest", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTransactionRequest>): GetTransactionRequest {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionRequest): GetTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.GetTransactionRequest
 */
export const GetTransactionRequest = new GetTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessageWithAddrRequest$Type extends MessageType<SignMessageWithAddrRequest> {
    constructor() {
        super("walletrpc.SignMessageWithAddrRequest", [
            { no: 1, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SignMessageWithAddrRequest>): SignMessageWithAddrRequest {
        const message = { msg: new Uint8Array(0), addr: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignMessageWithAddrRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageWithAddrRequest): SignMessageWithAddrRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msg */ 1:
                    message.msg = reader.bytes();
                    break;
                case /* string addr */ 2:
                    message.addr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignMessageWithAddrRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msg = 1; */
        if (message.msg.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.msg);
        /* string addr = 2; */
        if (message.addr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.SignMessageWithAddrRequest
 */
export const SignMessageWithAddrRequest = new SignMessageWithAddrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessageWithAddrResponse$Type extends MessageType<SignMessageWithAddrResponse> {
    constructor() {
        super("walletrpc.SignMessageWithAddrResponse", [
            { no: 1, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SignMessageWithAddrResponse>): SignMessageWithAddrResponse {
        const message = { signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignMessageWithAddrResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageWithAddrResponse): SignMessageWithAddrResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signature */ 1:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignMessageWithAddrResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signature = 1; */
        if (message.signature !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.SignMessageWithAddrResponse
 */
export const SignMessageWithAddrResponse = new SignMessageWithAddrResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyMessageWithAddrRequest$Type extends MessageType<VerifyMessageWithAddrRequest> {
    constructor() {
        super("walletrpc.VerifyMessageWithAddrRequest", [
            { no: 1, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyMessageWithAddrRequest>): VerifyMessageWithAddrRequest {
        const message = { msg: new Uint8Array(0), signature: "", addr: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyMessageWithAddrRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageWithAddrRequest): VerifyMessageWithAddrRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msg */ 1:
                    message.msg = reader.bytes();
                    break;
                case /* string signature */ 2:
                    message.signature = reader.string();
                    break;
                case /* string addr */ 3:
                    message.addr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyMessageWithAddrRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msg = 1; */
        if (message.msg.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.msg);
        /* string signature = 2; */
        if (message.signature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signature);
        /* string addr = 3; */
        if (message.addr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.VerifyMessageWithAddrRequest
 */
export const VerifyMessageWithAddrRequest = new VerifyMessageWithAddrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyMessageWithAddrResponse$Type extends MessageType<VerifyMessageWithAddrResponse> {
    constructor() {
        super("walletrpc.VerifyMessageWithAddrResponse", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyMessageWithAddrResponse>): VerifyMessageWithAddrResponse {
        const message = { valid: false, pubkey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyMessageWithAddrResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageWithAddrResponse): VerifyMessageWithAddrResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                case /* bytes pubkey */ 2:
                    message.pubkey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyMessageWithAddrResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        /* bytes pubkey = 2; */
        if (message.pubkey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pubkey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.VerifyMessageWithAddrResponse
 */
export const VerifyMessageWithAddrResponse = new VerifyMessageWithAddrResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportAccountRequest$Type extends MessageType<ImportAccountRequest> {
    constructor() {
        super("walletrpc.ImportAccountRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "extended_public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "master_key_fingerprint", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "address_type", kind: "enum", T: () => ["walletrpc.AddressType", AddressType] },
            { no: 5, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ImportAccountRequest>): ImportAccountRequest {
        const message = { name: "", extendedPublicKey: "", masterKeyFingerprint: new Uint8Array(0), addressType: 0, dryRun: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportAccountRequest): ImportAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string extended_public_key */ 2:
                    message.extendedPublicKey = reader.string();
                    break;
                case /* bytes master_key_fingerprint */ 3:
                    message.masterKeyFingerprint = reader.bytes();
                    break;
                case /* walletrpc.AddressType address_type */ 4:
                    message.addressType = reader.int32();
                    break;
                case /* bool dry_run */ 5:
                    message.dryRun = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string extended_public_key = 2; */
        if (message.extendedPublicKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.extendedPublicKey);
        /* bytes master_key_fingerprint = 3; */
        if (message.masterKeyFingerprint.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.masterKeyFingerprint);
        /* walletrpc.AddressType address_type = 4; */
        if (message.addressType !== 0)
            writer.tag(4, WireType.Varint).int32(message.addressType);
        /* bool dry_run = 5; */
        if (message.dryRun !== false)
            writer.tag(5, WireType.Varint).bool(message.dryRun);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ImportAccountRequest
 */
export const ImportAccountRequest = new ImportAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportAccountResponse$Type extends MessageType<ImportAccountResponse> {
    constructor() {
        super("walletrpc.ImportAccountResponse", [
            { no: 1, name: "account", kind: "message", T: () => Account },
            { no: 2, name: "dry_run_external_addrs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dry_run_internal_addrs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportAccountResponse>): ImportAccountResponse {
        const message = { dryRunExternalAddrs: [], dryRunInternalAddrs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportAccountResponse): ImportAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* walletrpc.Account account */ 1:
                    message.account = Account.internalBinaryRead(reader, reader.uint32(), options, message.account);
                    break;
                case /* repeated string dry_run_external_addrs */ 2:
                    message.dryRunExternalAddrs.push(reader.string());
                    break;
                case /* repeated string dry_run_internal_addrs */ 3:
                    message.dryRunInternalAddrs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* walletrpc.Account account = 1; */
        if (message.account)
            Account.internalBinaryWrite(message.account, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string dry_run_external_addrs = 2; */
        for (let i = 0; i < message.dryRunExternalAddrs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dryRunExternalAddrs[i]);
        /* repeated string dry_run_internal_addrs = 3; */
        for (let i = 0; i < message.dryRunInternalAddrs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.dryRunInternalAddrs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ImportAccountResponse
 */
export const ImportAccountResponse = new ImportAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportPublicKeyRequest$Type extends MessageType<ImportPublicKeyRequest> {
    constructor() {
        super("walletrpc.ImportPublicKeyRequest", [
            { no: 1, name: "public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "address_type", kind: "enum", T: () => ["walletrpc.AddressType", AddressType] }
        ]);
    }
    create(value?: PartialMessage<ImportPublicKeyRequest>): ImportPublicKeyRequest {
        const message = { publicKey: new Uint8Array(0), addressType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportPublicKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportPublicKeyRequest): ImportPublicKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes public_key */ 1:
                    message.publicKey = reader.bytes();
                    break;
                case /* walletrpc.AddressType address_type */ 2:
                    message.addressType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportPublicKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes public_key = 1; */
        if (message.publicKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicKey);
        /* walletrpc.AddressType address_type = 2; */
        if (message.addressType !== 0)
            writer.tag(2, WireType.Varint).int32(message.addressType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ImportPublicKeyRequest
 */
export const ImportPublicKeyRequest = new ImportPublicKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportPublicKeyResponse$Type extends MessageType<ImportPublicKeyResponse> {
    constructor() {
        super("walletrpc.ImportPublicKeyResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportPublicKeyResponse>): ImportPublicKeyResponse {
        const message = { status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportPublicKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportPublicKeyResponse): ImportPublicKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportPublicKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ImportPublicKeyResponse
 */
export const ImportPublicKeyResponse = new ImportPublicKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportTapscriptRequest$Type extends MessageType<ImportTapscriptRequest> {
    constructor() {
        super("walletrpc.ImportTapscriptRequest", [
            { no: 1, name: "internal_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "full_tree", kind: "message", oneof: "script", T: () => TapscriptFullTree },
            { no: 3, name: "partial_reveal", kind: "message", oneof: "script", T: () => TapscriptPartialReveal },
            { no: 4, name: "root_hash_only", kind: "scalar", oneof: "script", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "full_key_only", kind: "scalar", oneof: "script", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ImportTapscriptRequest>): ImportTapscriptRequest {
        const message = { internalPublicKey: new Uint8Array(0), script: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportTapscriptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportTapscriptRequest): ImportTapscriptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes internal_public_key */ 1:
                    message.internalPublicKey = reader.bytes();
                    break;
                case /* walletrpc.TapscriptFullTree full_tree */ 2:
                    message.script = {
                        oneofKind: "fullTree",
                        fullTree: TapscriptFullTree.internalBinaryRead(reader, reader.uint32(), options, (message.script as any).fullTree)
                    };
                    break;
                case /* walletrpc.TapscriptPartialReveal partial_reveal */ 3:
                    message.script = {
                        oneofKind: "partialReveal",
                        partialReveal: TapscriptPartialReveal.internalBinaryRead(reader, reader.uint32(), options, (message.script as any).partialReveal)
                    };
                    break;
                case /* bytes root_hash_only */ 4:
                    message.script = {
                        oneofKind: "rootHashOnly",
                        rootHashOnly: reader.bytes()
                    };
                    break;
                case /* bool full_key_only */ 5:
                    message.script = {
                        oneofKind: "fullKeyOnly",
                        fullKeyOnly: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportTapscriptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes internal_public_key = 1; */
        if (message.internalPublicKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.internalPublicKey);
        /* walletrpc.TapscriptFullTree full_tree = 2; */
        if (message.script.oneofKind === "fullTree")
            TapscriptFullTree.internalBinaryWrite(message.script.fullTree, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* walletrpc.TapscriptPartialReveal partial_reveal = 3; */
        if (message.script.oneofKind === "partialReveal")
            TapscriptPartialReveal.internalBinaryWrite(message.script.partialReveal, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes root_hash_only = 4; */
        if (message.script.oneofKind === "rootHashOnly")
            writer.tag(4, WireType.LengthDelimited).bytes(message.script.rootHashOnly);
        /* bool full_key_only = 5; */
        if (message.script.oneofKind === "fullKeyOnly")
            writer.tag(5, WireType.Varint).bool(message.script.fullKeyOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ImportTapscriptRequest
 */
export const ImportTapscriptRequest = new ImportTapscriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TapscriptFullTree$Type extends MessageType<TapscriptFullTree> {
    constructor() {
        super("walletrpc.TapscriptFullTree", [
            { no: 1, name: "all_leaves", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TapLeaf }
        ]);
    }
    create(value?: PartialMessage<TapscriptFullTree>): TapscriptFullTree {
        const message = { allLeaves: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TapscriptFullTree>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapscriptFullTree): TapscriptFullTree {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated walletrpc.TapLeaf all_leaves */ 1:
                    message.allLeaves.push(TapLeaf.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapscriptFullTree, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated walletrpc.TapLeaf all_leaves = 1; */
        for (let i = 0; i < message.allLeaves.length; i++)
            TapLeaf.internalBinaryWrite(message.allLeaves[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.TapscriptFullTree
 */
export const TapscriptFullTree = new TapscriptFullTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TapLeaf$Type extends MessageType<TapLeaf> {
    constructor() {
        super("walletrpc.TapLeaf", [
            { no: 1, name: "leaf_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TapLeaf>): TapLeaf {
        const message = { leafVersion: 0, script: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TapLeaf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapLeaf): TapLeaf {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 leaf_version */ 1:
                    message.leafVersion = reader.uint32();
                    break;
                case /* bytes script */ 2:
                    message.script = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapLeaf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 leaf_version = 1; */
        if (message.leafVersion !== 0)
            writer.tag(1, WireType.Varint).uint32(message.leafVersion);
        /* bytes script = 2; */
        if (message.script.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.script);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.TapLeaf
 */
export const TapLeaf = new TapLeaf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TapscriptPartialReveal$Type extends MessageType<TapscriptPartialReveal> {
    constructor() {
        super("walletrpc.TapscriptPartialReveal", [
            { no: 1, name: "revealed_leaf", kind: "message", T: () => TapLeaf },
            { no: 2, name: "full_inclusion_proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TapscriptPartialReveal>): TapscriptPartialReveal {
        const message = { fullInclusionProof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TapscriptPartialReveal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapscriptPartialReveal): TapscriptPartialReveal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* walletrpc.TapLeaf revealed_leaf */ 1:
                    message.revealedLeaf = TapLeaf.internalBinaryRead(reader, reader.uint32(), options, message.revealedLeaf);
                    break;
                case /* bytes full_inclusion_proof */ 2:
                    message.fullInclusionProof = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapscriptPartialReveal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* walletrpc.TapLeaf revealed_leaf = 1; */
        if (message.revealedLeaf)
            TapLeaf.internalBinaryWrite(message.revealedLeaf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes full_inclusion_proof = 2; */
        if (message.fullInclusionProof.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.fullInclusionProof);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.TapscriptPartialReveal
 */
export const TapscriptPartialReveal = new TapscriptPartialReveal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportTapscriptResponse$Type extends MessageType<ImportTapscriptResponse> {
    constructor() {
        super("walletrpc.ImportTapscriptResponse", [
            { no: 1, name: "p2tr_address", kind: "scalar", jsonName: "p2trAddress", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportTapscriptResponse>): ImportTapscriptResponse {
        const message = { p2TrAddress: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportTapscriptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportTapscriptResponse): ImportTapscriptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string p2tr_address = 1 [json_name = "p2trAddress"];*/ 1:
                    message.p2TrAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportTapscriptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string p2tr_address = 1 [json_name = "p2trAddress"]; */
        if (message.p2TrAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.p2TrAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ImportTapscriptResponse
 */
export const ImportTapscriptResponse = new ImportTapscriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("walletrpc.Transaction", [
            { no: 1, name: "tx_hex", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { txHex: new Uint8Array(0), label: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx_hex */ 1:
                    message.txHex = reader.bytes();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx_hex = 1; */
        if (message.txHex.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txHex);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishResponse$Type extends MessageType<PublishResponse> {
    constructor() {
        super("walletrpc.PublishResponse", [
            { no: 1, name: "publish_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublishResponse>): PublishResponse {
        const message = { publishError: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PublishResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishResponse): PublishResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string publish_error */ 1:
                    message.publishError = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string publish_error = 1; */
        if (message.publishError !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publishError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.PublishResponse
 */
export const PublishResponse = new PublishResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveTransactionResponse$Type extends MessageType<RemoveTransactionResponse> {
    constructor() {
        super("walletrpc.RemoveTransactionResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveTransactionResponse>): RemoveTransactionResponse {
        const message = { status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveTransactionResponse): RemoveTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.RemoveTransactionResponse
 */
export const RemoveTransactionResponse = new RemoveTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendOutputsRequest$Type extends MessageType<SendOutputsRequest> {
    constructor() {
        super("walletrpc.SendOutputsRequest", [
            { no: 1, name: "sat_per_kw", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TxOut },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "coin_selection_strategy", kind: "enum", T: () => ["lnrpc.CoinSelectionStrategy", CoinSelectionStrategy] }
        ]);
    }
    create(value?: PartialMessage<SendOutputsRequest>): SendOutputsRequest {
        const message = { satPerKw: 0n, outputs: [], label: "", minConfs: 0, spendUnconfirmed: false, coinSelectionStrategy: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendOutputsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendOutputsRequest): SendOutputsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 sat_per_kw */ 1:
                    message.satPerKw = reader.int64().toBigInt();
                    break;
                case /* repeated signrpc.TxOut outputs */ 2:
                    message.outputs.push(TxOut.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                case /* int32 min_confs */ 4:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 5:
                    message.spendUnconfirmed = reader.bool();
                    break;
                case /* lnrpc.CoinSelectionStrategy coin_selection_strategy */ 6:
                    message.coinSelectionStrategy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendOutputsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 sat_per_kw = 1; */
        if (message.satPerKw !== 0n)
            writer.tag(1, WireType.Varint).int64(message.satPerKw);
        /* repeated signrpc.TxOut outputs = 2; */
        for (let i = 0; i < message.outputs.length; i++)
            TxOut.internalBinaryWrite(message.outputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        /* int32 min_confs = 4; */
        if (message.minConfs !== 0)
            writer.tag(4, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 5; */
        if (message.spendUnconfirmed !== false)
            writer.tag(5, WireType.Varint).bool(message.spendUnconfirmed);
        /* lnrpc.CoinSelectionStrategy coin_selection_strategy = 6; */
        if (message.coinSelectionStrategy !== 0)
            writer.tag(6, WireType.Varint).int32(message.coinSelectionStrategy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.SendOutputsRequest
 */
export const SendOutputsRequest = new SendOutputsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendOutputsResponse$Type extends MessageType<SendOutputsResponse> {
    constructor() {
        super("walletrpc.SendOutputsResponse", [
            { no: 1, name: "raw_tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SendOutputsResponse>): SendOutputsResponse {
        const message = { rawTx: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendOutputsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendOutputsResponse): SendOutputsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes raw_tx */ 1:
                    message.rawTx = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendOutputsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes raw_tx = 1; */
        if (message.rawTx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rawTx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.SendOutputsResponse
 */
export const SendOutputsResponse = new SendOutputsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateFeeRequest$Type extends MessageType<EstimateFeeRequest> {
    constructor() {
        super("walletrpc.EstimateFeeRequest", [
            { no: 1, name: "conf_target", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateFeeRequest>): EstimateFeeRequest {
        const message = { confTarget: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateFeeRequest): EstimateFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 conf_target */ 1:
                    message.confTarget = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 conf_target = 1; */
        if (message.confTarget !== 0)
            writer.tag(1, WireType.Varint).int32(message.confTarget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.EstimateFeeRequest
 */
export const EstimateFeeRequest = new EstimateFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateFeeResponse$Type extends MessageType<EstimateFeeResponse> {
    constructor() {
        super("walletrpc.EstimateFeeResponse", [
            { no: 1, name: "sat_per_kw", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "min_relay_fee_sat_per_kw", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateFeeResponse>): EstimateFeeResponse {
        const message = { satPerKw: 0n, minRelayFeeSatPerKw: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateFeeResponse): EstimateFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 sat_per_kw */ 1:
                    message.satPerKw = reader.int64().toBigInt();
                    break;
                case /* int64 min_relay_fee_sat_per_kw */ 2:
                    message.minRelayFeeSatPerKw = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 sat_per_kw = 1; */
        if (message.satPerKw !== 0n)
            writer.tag(1, WireType.Varint).int64(message.satPerKw);
        /* int64 min_relay_fee_sat_per_kw = 2; */
        if (message.minRelayFeeSatPerKw !== 0n)
            writer.tag(2, WireType.Varint).int64(message.minRelayFeeSatPerKw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.EstimateFeeResponse
 */
export const EstimateFeeResponse = new EstimateFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingSweep$Type extends MessageType<PendingSweep> {
    constructor() {
        super("walletrpc.PendingSweep", [
            { no: 1, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 2, name: "witness_type", kind: "enum", T: () => ["walletrpc.WitnessType", WitnessType] },
            { no: 3, name: "amount_sat", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sat_per_byte", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "broadcast_attempts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "next_broadcast_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "requested_conf_target", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "requested_sat_per_byte", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "requested_sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "immediate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "budget", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "deadline_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PendingSweep>): PendingSweep {
        const message = { witnessType: 0, amountSat: 0, satPerByte: 0, broadcastAttempts: 0, nextBroadcastHeight: 0, force: false, requestedConfTarget: 0, requestedSatPerByte: 0, satPerVbyte: 0n, requestedSatPerVbyte: 0n, immediate: false, budget: 0n, deadlineHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingSweep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingSweep): PendingSweep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.OutPoint outpoint */ 1:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* walletrpc.WitnessType witness_type */ 2:
                    message.witnessType = reader.int32();
                    break;
                case /* uint32 amount_sat */ 3:
                    message.amountSat = reader.uint32();
                    break;
                case /* uint32 sat_per_byte = 4 [deprecated = true];*/ 4:
                    message.satPerByte = reader.uint32();
                    break;
                case /* uint32 broadcast_attempts */ 5:
                    message.broadcastAttempts = reader.uint32();
                    break;
                case /* uint32 next_broadcast_height = 6 [deprecated = true];*/ 6:
                    message.nextBroadcastHeight = reader.uint32();
                    break;
                case /* bool force = 7 [deprecated = true];*/ 7:
                    message.force = reader.bool();
                    break;
                case /* uint32 requested_conf_target = 8 [deprecated = true];*/ 8:
                    message.requestedConfTarget = reader.uint32();
                    break;
                case /* uint32 requested_sat_per_byte = 9 [deprecated = true];*/ 9:
                    message.requestedSatPerByte = reader.uint32();
                    break;
                case /* uint64 sat_per_vbyte */ 10:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* uint64 requested_sat_per_vbyte */ 11:
                    message.requestedSatPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* bool immediate */ 12:
                    message.immediate = reader.bool();
                    break;
                case /* uint64 budget */ 13:
                    message.budget = reader.uint64().toBigInt();
                    break;
                case /* uint32 deadline_height */ 14:
                    message.deadlineHeight = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingSweep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.OutPoint outpoint = 1; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* walletrpc.WitnessType witness_type = 2; */
        if (message.witnessType !== 0)
            writer.tag(2, WireType.Varint).int32(message.witnessType);
        /* uint32 amount_sat = 3; */
        if (message.amountSat !== 0)
            writer.tag(3, WireType.Varint).uint32(message.amountSat);
        /* uint32 sat_per_byte = 4 [deprecated = true]; */
        if (message.satPerByte !== 0)
            writer.tag(4, WireType.Varint).uint32(message.satPerByte);
        /* uint32 broadcast_attempts = 5; */
        if (message.broadcastAttempts !== 0)
            writer.tag(5, WireType.Varint).uint32(message.broadcastAttempts);
        /* uint32 next_broadcast_height = 6 [deprecated = true]; */
        if (message.nextBroadcastHeight !== 0)
            writer.tag(6, WireType.Varint).uint32(message.nextBroadcastHeight);
        /* bool force = 7 [deprecated = true]; */
        if (message.force !== false)
            writer.tag(7, WireType.Varint).bool(message.force);
        /* uint32 requested_conf_target = 8 [deprecated = true]; */
        if (message.requestedConfTarget !== 0)
            writer.tag(8, WireType.Varint).uint32(message.requestedConfTarget);
        /* uint32 requested_sat_per_byte = 9 [deprecated = true]; */
        if (message.requestedSatPerByte !== 0)
            writer.tag(9, WireType.Varint).uint32(message.requestedSatPerByte);
        /* uint64 sat_per_vbyte = 10; */
        if (message.satPerVbyte !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.satPerVbyte);
        /* uint64 requested_sat_per_vbyte = 11; */
        if (message.requestedSatPerVbyte !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.requestedSatPerVbyte);
        /* bool immediate = 12; */
        if (message.immediate !== false)
            writer.tag(12, WireType.Varint).bool(message.immediate);
        /* uint64 budget = 13; */
        if (message.budget !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.budget);
        /* uint32 deadline_height = 14; */
        if (message.deadlineHeight !== 0)
            writer.tag(14, WireType.Varint).uint32(message.deadlineHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.PendingSweep
 */
export const PendingSweep = new PendingSweep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingSweepsRequest$Type extends MessageType<PendingSweepsRequest> {
    constructor() {
        super("walletrpc.PendingSweepsRequest", []);
    }
    create(value?: PartialMessage<PendingSweepsRequest>): PendingSweepsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingSweepsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingSweepsRequest): PendingSweepsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PendingSweepsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.PendingSweepsRequest
 */
export const PendingSweepsRequest = new PendingSweepsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingSweepsResponse$Type extends MessageType<PendingSweepsResponse> {
    constructor() {
        super("walletrpc.PendingSweepsResponse", [
            { no: 1, name: "pending_sweeps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingSweep }
        ]);
    }
    create(value?: PartialMessage<PendingSweepsResponse>): PendingSweepsResponse {
        const message = { pendingSweeps: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingSweepsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingSweepsResponse): PendingSweepsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated walletrpc.PendingSweep pending_sweeps */ 1:
                    message.pendingSweeps.push(PendingSweep.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingSweepsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated walletrpc.PendingSweep pending_sweeps = 1; */
        for (let i = 0; i < message.pendingSweeps.length; i++)
            PendingSweep.internalBinaryWrite(message.pendingSweeps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.PendingSweepsResponse
 */
export const PendingSweepsResponse = new PendingSweepsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BumpFeeRequest$Type extends MessageType<BumpFeeRequest> {
    constructor() {
        super("walletrpc.BumpFeeRequest", [
            { no: 1, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 2, name: "target_conf", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sat_per_byte", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "immediate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "budget", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BumpFeeRequest>): BumpFeeRequest {
        const message = { targetConf: 0, satPerByte: 0, force: false, satPerVbyte: 0n, immediate: false, budget: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BumpFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BumpFeeRequest): BumpFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.OutPoint outpoint */ 1:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* uint32 target_conf */ 2:
                    message.targetConf = reader.uint32();
                    break;
                case /* uint32 sat_per_byte = 3 [deprecated = true];*/ 3:
                    message.satPerByte = reader.uint32();
                    break;
                case /* bool force = 4 [deprecated = true];*/ 4:
                    message.force = reader.bool();
                    break;
                case /* uint64 sat_per_vbyte */ 5:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* bool immediate */ 6:
                    message.immediate = reader.bool();
                    break;
                case /* uint64 budget */ 7:
                    message.budget = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BumpFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.OutPoint outpoint = 1; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 target_conf = 2; */
        if (message.targetConf !== 0)
            writer.tag(2, WireType.Varint).uint32(message.targetConf);
        /* uint32 sat_per_byte = 3 [deprecated = true]; */
        if (message.satPerByte !== 0)
            writer.tag(3, WireType.Varint).uint32(message.satPerByte);
        /* bool force = 4 [deprecated = true]; */
        if (message.force !== false)
            writer.tag(4, WireType.Varint).bool(message.force);
        /* uint64 sat_per_vbyte = 5; */
        if (message.satPerVbyte !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.satPerVbyte);
        /* bool immediate = 6; */
        if (message.immediate !== false)
            writer.tag(6, WireType.Varint).bool(message.immediate);
        /* uint64 budget = 7; */
        if (message.budget !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.budget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.BumpFeeRequest
 */
export const BumpFeeRequest = new BumpFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BumpFeeResponse$Type extends MessageType<BumpFeeResponse> {
    constructor() {
        super("walletrpc.BumpFeeResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BumpFeeResponse>): BumpFeeResponse {
        const message = { status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BumpFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BumpFeeResponse): BumpFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BumpFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.BumpFeeResponse
 */
export const BumpFeeResponse = new BumpFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BumpForceCloseFeeRequest$Type extends MessageType<BumpForceCloseFeeRequest> {
    constructor() {
        super("walletrpc.BumpForceCloseFeeRequest", [
            { no: 1, name: "chan_point", kind: "message", T: () => ChannelPoint },
            { no: 2, name: "deadline_delta", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "starting_feerate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "immediate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "budget", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BumpForceCloseFeeRequest>): BumpForceCloseFeeRequest {
        const message = { deadlineDelta: 0, startingFeerate: 0n, immediate: false, budget: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BumpForceCloseFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BumpForceCloseFeeRequest): BumpForceCloseFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint chan_point */ 1:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* uint32 deadline_delta */ 2:
                    message.deadlineDelta = reader.uint32();
                    break;
                case /* uint64 starting_feerate */ 3:
                    message.startingFeerate = reader.uint64().toBigInt();
                    break;
                case /* bool immediate */ 4:
                    message.immediate = reader.bool();
                    break;
                case /* uint64 budget */ 5:
                    message.budget = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BumpForceCloseFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint chan_point = 1; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 deadline_delta = 2; */
        if (message.deadlineDelta !== 0)
            writer.tag(2, WireType.Varint).uint32(message.deadlineDelta);
        /* uint64 starting_feerate = 3; */
        if (message.startingFeerate !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.startingFeerate);
        /* bool immediate = 4; */
        if (message.immediate !== false)
            writer.tag(4, WireType.Varint).bool(message.immediate);
        /* uint64 budget = 5; */
        if (message.budget !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.budget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.BumpForceCloseFeeRequest
 */
export const BumpForceCloseFeeRequest = new BumpForceCloseFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BumpForceCloseFeeResponse$Type extends MessageType<BumpForceCloseFeeResponse> {
    constructor() {
        super("walletrpc.BumpForceCloseFeeResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BumpForceCloseFeeResponse>): BumpForceCloseFeeResponse {
        const message = { status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BumpForceCloseFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BumpForceCloseFeeResponse): BumpForceCloseFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BumpForceCloseFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.BumpForceCloseFeeResponse
 */
export const BumpForceCloseFeeResponse = new BumpForceCloseFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSweepsRequest$Type extends MessageType<ListSweepsRequest> {
    constructor() {
        super("walletrpc.ListSweepsRequest", [
            { no: 1, name: "verbose", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "start_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListSweepsRequest>): ListSweepsRequest {
        const message = { verbose: false, startHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListSweepsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSweepsRequest): ListSweepsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool verbose */ 1:
                    message.verbose = reader.bool();
                    break;
                case /* int32 start_height */ 2:
                    message.startHeight = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSweepsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool verbose = 1; */
        if (message.verbose !== false)
            writer.tag(1, WireType.Varint).bool(message.verbose);
        /* int32 start_height = 2; */
        if (message.startHeight !== 0)
            writer.tag(2, WireType.Varint).int32(message.startHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListSweepsRequest
 */
export const ListSweepsRequest = new ListSweepsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSweepsResponse$Type extends MessageType<ListSweepsResponse> {
    constructor() {
        super("walletrpc.ListSweepsResponse", [
            { no: 1, name: "transaction_details", kind: "message", oneof: "sweeps", T: () => TransactionDetails },
            { no: 2, name: "transaction_ids", kind: "message", oneof: "sweeps", T: () => ListSweepsResponse_TransactionIDs }
        ]);
    }
    create(value?: PartialMessage<ListSweepsResponse>): ListSweepsResponse {
        const message = { sweeps: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListSweepsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSweepsResponse): ListSweepsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.TransactionDetails transaction_details */ 1:
                    message.sweeps = {
                        oneofKind: "transactionDetails",
                        transactionDetails: TransactionDetails.internalBinaryRead(reader, reader.uint32(), options, (message.sweeps as any).transactionDetails)
                    };
                    break;
                case /* walletrpc.ListSweepsResponse.TransactionIDs transaction_ids */ 2:
                    message.sweeps = {
                        oneofKind: "transactionIds",
                        transactionIds: ListSweepsResponse_TransactionIDs.internalBinaryRead(reader, reader.uint32(), options, (message.sweeps as any).transactionIds)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSweepsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.TransactionDetails transaction_details = 1; */
        if (message.sweeps.oneofKind === "transactionDetails")
            TransactionDetails.internalBinaryWrite(message.sweeps.transactionDetails, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* walletrpc.ListSweepsResponse.TransactionIDs transaction_ids = 2; */
        if (message.sweeps.oneofKind === "transactionIds")
            ListSweepsResponse_TransactionIDs.internalBinaryWrite(message.sweeps.transactionIds, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListSweepsResponse
 */
export const ListSweepsResponse = new ListSweepsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSweepsResponse_TransactionIDs$Type extends MessageType<ListSweepsResponse_TransactionIDs> {
    constructor() {
        super("walletrpc.ListSweepsResponse.TransactionIDs", [
            { no: 1, name: "transaction_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListSweepsResponse_TransactionIDs>): ListSweepsResponse_TransactionIDs {
        const message = { transactionIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListSweepsResponse_TransactionIDs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSweepsResponse_TransactionIDs): ListSweepsResponse_TransactionIDs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string transaction_ids */ 1:
                    message.transactionIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSweepsResponse_TransactionIDs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string transaction_ids = 1; */
        for (let i = 0; i < message.transactionIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.transactionIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListSweepsResponse.TransactionIDs
 */
export const ListSweepsResponse_TransactionIDs = new ListSweepsResponse_TransactionIDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LabelTransactionRequest$Type extends MessageType<LabelTransactionRequest> {
    constructor() {
        super("walletrpc.LabelTransactionRequest", [
            { no: 1, name: "txid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "overwrite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LabelTransactionRequest>): LabelTransactionRequest {
        const message = { txid: new Uint8Array(0), label: "", overwrite: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LabelTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LabelTransactionRequest): LabelTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes txid */ 1:
                    message.txid = reader.bytes();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* bool overwrite */ 3:
                    message.overwrite = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LabelTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes txid = 1; */
        if (message.txid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txid);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* bool overwrite = 3; */
        if (message.overwrite !== false)
            writer.tag(3, WireType.Varint).bool(message.overwrite);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.LabelTransactionRequest
 */
export const LabelTransactionRequest = new LabelTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LabelTransactionResponse$Type extends MessageType<LabelTransactionResponse> {
    constructor() {
        super("walletrpc.LabelTransactionResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LabelTransactionResponse>): LabelTransactionResponse {
        const message = { status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LabelTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LabelTransactionResponse): LabelTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LabelTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.LabelTransactionResponse
 */
export const LabelTransactionResponse = new LabelTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundPsbtRequest$Type extends MessageType<FundPsbtRequest> {
    constructor() {
        super("walletrpc.FundPsbtRequest", [
            { no: 1, name: "psbt", kind: "scalar", oneof: "template", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "raw", kind: "message", oneof: "template", T: () => TxTemplate },
            { no: 9, name: "coin_select", kind: "message", oneof: "template", T: () => PsbtCoinSelect },
            { no: 3, name: "target_conf", kind: "scalar", oneof: "fees", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sat_per_vbyte", kind: "scalar", oneof: "fees", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "sat_per_kw", kind: "scalar", oneof: "fees", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "change_type", kind: "enum", T: () => ["walletrpc.ChangeAddressType", ChangeAddressType, "CHANGE_ADDRESS_TYPE_"] },
            { no: 10, name: "coin_selection_strategy", kind: "enum", T: () => ["lnrpc.CoinSelectionStrategy", CoinSelectionStrategy] },
            { no: 12, name: "max_fee_ratio", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<FundPsbtRequest>): FundPsbtRequest {
        const message = { template: { oneofKind: undefined }, fees: { oneofKind: undefined }, account: "", minConfs: 0, spendUnconfirmed: false, changeType: 0, coinSelectionStrategy: 0, maxFeeRatio: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundPsbtRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundPsbtRequest): FundPsbtRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes psbt */ 1:
                    message.template = {
                        oneofKind: "psbt",
                        psbt: reader.bytes()
                    };
                    break;
                case /* walletrpc.TxTemplate raw */ 2:
                    message.template = {
                        oneofKind: "raw",
                        raw: TxTemplate.internalBinaryRead(reader, reader.uint32(), options, (message.template as any).raw)
                    };
                    break;
                case /* walletrpc.PsbtCoinSelect coin_select */ 9:
                    message.template = {
                        oneofKind: "coinSelect",
                        coinSelect: PsbtCoinSelect.internalBinaryRead(reader, reader.uint32(), options, (message.template as any).coinSelect)
                    };
                    break;
                case /* uint32 target_conf */ 3:
                    message.fees = {
                        oneofKind: "targetConf",
                        targetConf: reader.uint32()
                    };
                    break;
                case /* uint64 sat_per_vbyte */ 4:
                    message.fees = {
                        oneofKind: "satPerVbyte",
                        satPerVbyte: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 sat_per_kw */ 11:
                    message.fees = {
                        oneofKind: "satPerKw",
                        satPerKw: reader.uint64().toBigInt()
                    };
                    break;
                case /* string account */ 5:
                    message.account = reader.string();
                    break;
                case /* int32 min_confs */ 6:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 7:
                    message.spendUnconfirmed = reader.bool();
                    break;
                case /* walletrpc.ChangeAddressType change_type */ 8:
                    message.changeType = reader.int32();
                    break;
                case /* lnrpc.CoinSelectionStrategy coin_selection_strategy */ 10:
                    message.coinSelectionStrategy = reader.int32();
                    break;
                case /* double max_fee_ratio */ 12:
                    message.maxFeeRatio = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundPsbtRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes psbt = 1; */
        if (message.template.oneofKind === "psbt")
            writer.tag(1, WireType.LengthDelimited).bytes(message.template.psbt);
        /* walletrpc.TxTemplate raw = 2; */
        if (message.template.oneofKind === "raw")
            TxTemplate.internalBinaryWrite(message.template.raw, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* walletrpc.PsbtCoinSelect coin_select = 9; */
        if (message.template.oneofKind === "coinSelect")
            PsbtCoinSelect.internalBinaryWrite(message.template.coinSelect, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 target_conf = 3; */
        if (message.fees.oneofKind === "targetConf")
            writer.tag(3, WireType.Varint).uint32(message.fees.targetConf);
        /* uint64 sat_per_vbyte = 4; */
        if (message.fees.oneofKind === "satPerVbyte")
            writer.tag(4, WireType.Varint).uint64(message.fees.satPerVbyte);
        /* uint64 sat_per_kw = 11; */
        if (message.fees.oneofKind === "satPerKw")
            writer.tag(11, WireType.Varint).uint64(message.fees.satPerKw);
        /* string account = 5; */
        if (message.account !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.account);
        /* int32 min_confs = 6; */
        if (message.minConfs !== 0)
            writer.tag(6, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 7; */
        if (message.spendUnconfirmed !== false)
            writer.tag(7, WireType.Varint).bool(message.spendUnconfirmed);
        /* walletrpc.ChangeAddressType change_type = 8; */
        if (message.changeType !== 0)
            writer.tag(8, WireType.Varint).int32(message.changeType);
        /* lnrpc.CoinSelectionStrategy coin_selection_strategy = 10; */
        if (message.coinSelectionStrategy !== 0)
            writer.tag(10, WireType.Varint).int32(message.coinSelectionStrategy);
        /* double max_fee_ratio = 12; */
        if (message.maxFeeRatio !== 0)
            writer.tag(12, WireType.Bit64).double(message.maxFeeRatio);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.FundPsbtRequest
 */
export const FundPsbtRequest = new FundPsbtRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundPsbtResponse$Type extends MessageType<FundPsbtResponse> {
    constructor() {
        super("walletrpc.FundPsbtResponse", [
            { no: 1, name: "funded_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "change_output_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "locked_utxos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoLease }
        ]);
    }
    create(value?: PartialMessage<FundPsbtResponse>): FundPsbtResponse {
        const message = { fundedPsbt: new Uint8Array(0), changeOutputIndex: 0, lockedUtxos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundPsbtResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundPsbtResponse): FundPsbtResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes funded_psbt */ 1:
                    message.fundedPsbt = reader.bytes();
                    break;
                case /* int32 change_output_index */ 2:
                    message.changeOutputIndex = reader.int32();
                    break;
                case /* repeated walletrpc.UtxoLease locked_utxos */ 3:
                    message.lockedUtxos.push(UtxoLease.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundPsbtResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes funded_psbt = 1; */
        if (message.fundedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fundedPsbt);
        /* int32 change_output_index = 2; */
        if (message.changeOutputIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.changeOutputIndex);
        /* repeated walletrpc.UtxoLease locked_utxos = 3; */
        for (let i = 0; i < message.lockedUtxos.length; i++)
            UtxoLease.internalBinaryWrite(message.lockedUtxos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.FundPsbtResponse
 */
export const FundPsbtResponse = new FundPsbtResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxTemplate$Type extends MessageType<TxTemplate> {
    constructor() {
        super("walletrpc.TxTemplate", [
            { no: 1, name: "inputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OutPoint },
            { no: 2, name: "outputs", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<TxTemplate>): TxTemplate {
        const message = { inputs: [], outputs: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxTemplate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxTemplate): TxTemplate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.OutPoint inputs */ 1:
                    message.inputs.push(OutPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, uint64> outputs */ 2:
                    this.binaryReadMap2(message.outputs, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: TxTemplate["outputs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TxTemplate["outputs"] | undefined, val: TxTemplate["outputs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field walletrpc.TxTemplate.outputs");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: TxTemplate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.OutPoint inputs = 1; */
        for (let i = 0; i < message.inputs.length; i++)
            OutPoint.internalBinaryWrite(message.inputs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, uint64> outputs = 2; */
        for (let k of Object.keys(message.outputs))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.outputs[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.TxTemplate
 */
export const TxTemplate = new TxTemplate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PsbtCoinSelect$Type extends MessageType<PsbtCoinSelect> {
    constructor() {
        super("walletrpc.PsbtCoinSelect", [
            { no: 1, name: "psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "existing_output_index", kind: "scalar", oneof: "changeOutput", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "add", kind: "scalar", oneof: "changeOutput", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PsbtCoinSelect>): PsbtCoinSelect {
        const message = { psbt: new Uint8Array(0), changeOutput: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PsbtCoinSelect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PsbtCoinSelect): PsbtCoinSelect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes psbt */ 1:
                    message.psbt = reader.bytes();
                    break;
                case /* int32 existing_output_index */ 2:
                    message.changeOutput = {
                        oneofKind: "existingOutputIndex",
                        existingOutputIndex: reader.int32()
                    };
                    break;
                case /* bool add */ 3:
                    message.changeOutput = {
                        oneofKind: "add",
                        add: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PsbtCoinSelect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes psbt = 1; */
        if (message.psbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.psbt);
        /* int32 existing_output_index = 2; */
        if (message.changeOutput.oneofKind === "existingOutputIndex")
            writer.tag(2, WireType.Varint).int32(message.changeOutput.existingOutputIndex);
        /* bool add = 3; */
        if (message.changeOutput.oneofKind === "add")
            writer.tag(3, WireType.Varint).bool(message.changeOutput.add);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.PsbtCoinSelect
 */
export const PsbtCoinSelect = new PsbtCoinSelect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UtxoLease$Type extends MessageType<UtxoLease> {
    constructor() {
        super("walletrpc.UtxoLease", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 3, name: "expiration", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "pk_script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UtxoLease>): UtxoLease {
        const message = { id: new Uint8Array(0), expiration: 0n, pkScript: new Uint8Array(0), value: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UtxoLease>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UtxoLease): UtxoLease {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* lnrpc.OutPoint outpoint */ 2:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* uint64 expiration */ 3:
                    message.expiration = reader.uint64().toBigInt();
                    break;
                case /* bytes pk_script */ 4:
                    message.pkScript = reader.bytes();
                    break;
                case /* uint64 value */ 5:
                    message.value = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UtxoLease, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* lnrpc.OutPoint outpoint = 2; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 expiration = 3; */
        if (message.expiration !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.expiration);
        /* bytes pk_script = 4; */
        if (message.pkScript.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.pkScript);
        /* uint64 value = 5; */
        if (message.value !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.UtxoLease
 */
export const UtxoLease = new UtxoLease$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignPsbtRequest$Type extends MessageType<SignPsbtRequest> {
    constructor() {
        super("walletrpc.SignPsbtRequest", [
            { no: 1, name: "funded_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignPsbtRequest>): SignPsbtRequest {
        const message = { fundedPsbt: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignPsbtRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignPsbtRequest): SignPsbtRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes funded_psbt */ 1:
                    message.fundedPsbt = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignPsbtRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes funded_psbt = 1; */
        if (message.fundedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fundedPsbt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.SignPsbtRequest
 */
export const SignPsbtRequest = new SignPsbtRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignPsbtResponse$Type extends MessageType<SignPsbtResponse> {
    constructor() {
        super("walletrpc.SignPsbtResponse", [
            { no: 1, name: "signed_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signed_inputs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SignPsbtResponse>): SignPsbtResponse {
        const message = { signedPsbt: new Uint8Array(0), signedInputs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignPsbtResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignPsbtResponse): SignPsbtResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signed_psbt */ 1:
                    message.signedPsbt = reader.bytes();
                    break;
                case /* repeated uint32 signed_inputs */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.signedInputs.push(reader.uint32());
                    else
                        message.signedInputs.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignPsbtResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signed_psbt = 1; */
        if (message.signedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signedPsbt);
        /* repeated uint32 signed_inputs = 2; */
        if (message.signedInputs.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.signedInputs.length; i++)
                writer.uint32(message.signedInputs[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.SignPsbtResponse
 */
export const SignPsbtResponse = new SignPsbtResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalizePsbtRequest$Type extends MessageType<FinalizePsbtRequest> {
    constructor() {
        super("walletrpc.FinalizePsbtRequest", [
            { no: 1, name: "funded_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FinalizePsbtRequest>): FinalizePsbtRequest {
        const message = { fundedPsbt: new Uint8Array(0), account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FinalizePsbtRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalizePsbtRequest): FinalizePsbtRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes funded_psbt */ 1:
                    message.fundedPsbt = reader.bytes();
                    break;
                case /* string account */ 5:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinalizePsbtRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes funded_psbt = 1; */
        if (message.fundedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fundedPsbt);
        /* string account = 5; */
        if (message.account !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.FinalizePsbtRequest
 */
export const FinalizePsbtRequest = new FinalizePsbtRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalizePsbtResponse$Type extends MessageType<FinalizePsbtResponse> {
    constructor() {
        super("walletrpc.FinalizePsbtResponse", [
            { no: 1, name: "signed_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "raw_final_tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FinalizePsbtResponse>): FinalizePsbtResponse {
        const message = { signedPsbt: new Uint8Array(0), rawFinalTx: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FinalizePsbtResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalizePsbtResponse): FinalizePsbtResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signed_psbt */ 1:
                    message.signedPsbt = reader.bytes();
                    break;
                case /* bytes raw_final_tx */ 2:
                    message.rawFinalTx = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinalizePsbtResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signed_psbt = 1; */
        if (message.signedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signedPsbt);
        /* bytes raw_final_tx = 2; */
        if (message.rawFinalTx.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rawFinalTx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.FinalizePsbtResponse
 */
export const FinalizePsbtResponse = new FinalizePsbtResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLeasesRequest$Type extends MessageType<ListLeasesRequest> {
    constructor() {
        super("walletrpc.ListLeasesRequest", []);
    }
    create(value?: PartialMessage<ListLeasesRequest>): ListLeasesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListLeasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListLeasesRequest): ListLeasesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListLeasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListLeasesRequest
 */
export const ListLeasesRequest = new ListLeasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLeasesResponse$Type extends MessageType<ListLeasesResponse> {
    constructor() {
        super("walletrpc.ListLeasesResponse", [
            { no: 1, name: "locked_utxos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoLease }
        ]);
    }
    create(value?: PartialMessage<ListLeasesResponse>): ListLeasesResponse {
        const message = { lockedUtxos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListLeasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListLeasesResponse): ListLeasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated walletrpc.UtxoLease locked_utxos */ 1:
                    message.lockedUtxos.push(UtxoLease.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListLeasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated walletrpc.UtxoLease locked_utxos = 1; */
        for (let i = 0; i < message.lockedUtxos.length; i++)
            UtxoLease.internalBinaryWrite(message.lockedUtxos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message walletrpc.ListLeasesResponse
 */
export const ListLeasesResponse = new ListLeasesResponse$Type();
/**
 * @generated ServiceType for protobuf service walletrpc.WalletKit
 */
export const WalletKit = new ServiceType("walletrpc.WalletKit", [
    { name: "ListUnspent", options: {}, I: ListUnspentRequest, O: ListUnspentResponse },
    { name: "LeaseOutput", options: {}, I: LeaseOutputRequest, O: LeaseOutputResponse },
    { name: "ReleaseOutput", options: {}, I: ReleaseOutputRequest, O: ReleaseOutputResponse },
    { name: "ListLeases", options: {}, I: ListLeasesRequest, O: ListLeasesResponse },
    { name: "DeriveNextKey", options: {}, I: KeyReq, O: KeyDescriptor },
    { name: "DeriveKey", options: {}, I: KeyLocator, O: KeyDescriptor },
    { name: "NextAddr", options: {}, I: AddrRequest, O: AddrResponse },
    { name: "GetTransaction", options: {}, I: GetTransactionRequest, O: Transaction$ },
    { name: "ListAccounts", options: {}, I: ListAccountsRequest, O: ListAccountsResponse },
    { name: "RequiredReserve", options: {}, I: RequiredReserveRequest, O: RequiredReserveResponse },
    { name: "ListAddresses", options: {}, I: ListAddressesRequest, O: ListAddressesResponse },
    { name: "SignMessageWithAddr", options: {}, I: SignMessageWithAddrRequest, O: SignMessageWithAddrResponse },
    { name: "VerifyMessageWithAddr", options: {}, I: VerifyMessageWithAddrRequest, O: VerifyMessageWithAddrResponse },
    { name: "ImportAccount", options: {}, I: ImportAccountRequest, O: ImportAccountResponse },
    { name: "ImportPublicKey", options: {}, I: ImportPublicKeyRequest, O: ImportPublicKeyResponse },
    { name: "ImportTapscript", options: {}, I: ImportTapscriptRequest, O: ImportTapscriptResponse },
    { name: "PublishTransaction", options: {}, I: Transaction, O: PublishResponse },
    { name: "RemoveTransaction", options: {}, I: GetTransactionRequest, O: RemoveTransactionResponse },
    { name: "SendOutputs", options: {}, I: SendOutputsRequest, O: SendOutputsResponse },
    { name: "EstimateFee", options: {}, I: EstimateFeeRequest, O: EstimateFeeResponse },
    { name: "PendingSweeps", options: {}, I: PendingSweepsRequest, O: PendingSweepsResponse },
    { name: "BumpFee", options: {}, I: BumpFeeRequest, O: BumpFeeResponse },
    { name: "BumpForceCloseFee", options: {}, I: BumpForceCloseFeeRequest, O: BumpForceCloseFeeResponse },
    { name: "ListSweeps", options: {}, I: ListSweepsRequest, O: ListSweepsResponse },
    { name: "LabelTransaction", options: {}, I: LabelTransactionRequest, O: LabelTransactionResponse },
    { name: "FundPsbt", options: {}, I: FundPsbtRequest, O: FundPsbtResponse },
    { name: "SignPsbt", options: {}, I: SignPsbtRequest, O: SignPsbtResponse },
    { name: "FinalizePsbt", options: {}, I: FinalizePsbtRequest, O: FinalizePsbtResponse }
]);
