// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "router.proto" (package "routerrpc", syntax proto3)
// tslint:disable
import { Payment } from "./lightning";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ChannelPoint } from "./lightning";
import { HTLCAttempt } from "./lightning";
import { Failure_FailureCode } from "./lightning";
import { Failure } from "./lightning";
import { Route } from "./lightning";
import { FeatureBit } from "./lightning";
import { RouteHint } from "./lightning";
/**
 * @generated from protobuf message routerrpc.SendPaymentRequest
 */
export interface SendPaymentRequest {
    /**
     * The identity pubkey of the payment recipient
     *
     * @generated from protobuf field: bytes dest = 1;
     */
    dest: Uint8Array;
    /**
     *
     * Number of satoshis to send.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt = 2;
     */
    amt: bigint;
    /**
     *
     * Number of millisatoshis to send.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt_msat = 12;
     */
    amtMsat: bigint;
    /**
     * The hash to use within the payment's HTLC
     *
     * @generated from protobuf field: bytes payment_hash = 3;
     */
    paymentHash: Uint8Array;
    /**
     *
     * The CLTV delta from the current height that should be used to set the
     * timelock for the final hop.
     *
     * @generated from protobuf field: int32 final_cltv_delta = 4;
     */
    finalCltvDelta: number;
    /**
     * An optional payment addr to be included within the last hop of the route.
     *
     * @generated from protobuf field: bytes payment_addr = 20;
     */
    paymentAddr: Uint8Array;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network.  With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient. The amount in the payment request may be zero. In
     * that case it is required to set the amt field as well. If no payment request
     * is specified, the following fields are required: dest, amt and payment_hash.
     *
     * @generated from protobuf field: string payment_request = 5;
     */
    paymentRequest: string;
    /**
     *
     * An upper limit on the amount of time we should spend when attempting to
     * fulfill the payment. This is expressed in seconds. If we cannot make a
     * successful payment within this time frame, an error will be returned.
     * This field must be non-zero.
     *
     * @generated from protobuf field: int32 timeout_seconds = 6;
     */
    timeoutSeconds: number;
    /**
     *
     * The maximum number of satoshis that will be paid as a fee of the payment.
     * If this field is left to the default value of 0, only zero-fee routes will
     * be considered. This usually means single hop routes connecting directly to
     * the destination. To send the payment without a fee limit, use max int here.
     *
     * The fields fee_limit_sat and fee_limit_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 fee_limit_sat = 7;
     */
    feeLimitSat: bigint;
    /**
     *
     * The maximum number of millisatoshis that will be paid as a fee of the
     * payment. If this field is left to the default value of 0, only zero-fee
     * routes will be considered. This usually means single hop routes connecting
     * directly to the destination. To send the payment without a fee limit, use
     * max int here.
     *
     * The fields fee_limit_sat and fee_limit_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 fee_limit_msat = 13;
     */
    feeLimitMsat: bigint;
    /**
     *
     * Deprecated, use outgoing_chan_ids. The channel id of the channel that must
     * be taken to the first hop. If zero, any channel may be used (unless
     * outgoing_chan_ids are set).
     *
     * @deprecated
     * @generated from protobuf field: uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * The channel ids of the channels are allowed for the first hop. If empty,
     * any channel may be used.
     *
     * @generated from protobuf field: repeated uint64 outgoing_chan_ids = 19;
     */
    outgoingChanIds: bigint[];
    /**
     *
     * The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @generated from protobuf field: bytes last_hop_pubkey = 14;
     */
    lastHopPubkey: Uint8Array;
    /**
     *
     * An optional maximum total time lock for the route. This should not exceed
     * lnd's `--max-cltv-expiry` setting. If zero, then the value of
     * `--max-cltv-expiry` is enforced.
     *
     * @generated from protobuf field: int32 cltv_limit = 9;
     */
    cltvLimit: number;
    /**
     *
     * Optional route hints to reach the destination through private channels.
     *
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 10;
     */
    routeHints: RouteHint[];
    /**
     *
     * An optional field that can be used to pass an arbitrary set of TLV records
     * to a peer which understands the new records. This can be used to pass
     * application specific data during the payment attempt. Record types are
     * required to be in the custom range >= 65536. When using REST, the values
     * must be encoded as base64.
     *
     * @generated from protobuf field: map<uint64, bytes> dest_custom_records = 11;
     */
    destCustomRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * If set, circular payments to self are permitted.
     *
     * @generated from protobuf field: bool allow_self_payment = 15;
     */
    allowSelfPayment: boolean;
    /**
     *
     * Features assumed to be supported by the final node. All transitive feature
     * dependencies must also be set properly. For a given feature bit pair, either
     * optional or remote may be set, but not both. If this field is nil or empty,
     * the router will try to load destination features from the graph as a
     * fallback.
     *
     * @generated from protobuf field: repeated lnrpc.FeatureBit dest_features = 16;
     */
    destFeatures: FeatureBit[];
    /**
     *
     * The maximum number of partial payments that may be use to complete the full
     * amount.
     *
     * @generated from protobuf field: uint32 max_parts = 17;
     */
    maxParts: number;
    /**
     *
     * If set, only the final payment update is streamed back. Intermediate updates
     * that show which htlcs are still in flight are suppressed.
     *
     * @generated from protobuf field: bool no_inflight_updates = 18;
     */
    noInflightUpdates: boolean;
    /**
     *
     * The largest payment split that should be attempted when making a payment if
     * splitting is necessary. Setting this value will effectively cause lnd to
     * split more aggressively, vs only when it thinks it needs to. Note that this
     * value is in milli-satoshis.
     *
     * @generated from protobuf field: uint64 max_shard_size_msat = 21;
     */
    maxShardSizeMsat: bigint;
    /**
     *
     * If set, an AMP-payment will be attempted.
     *
     * @generated from protobuf field: bool amp = 22;
     */
    amp: boolean;
    /**
     *
     * The time preference for this payment. Set to -1 to optimize for fees
     * only, to 1 to optimize for reliability only or a value inbetween for a mix.
     *
     * @generated from protobuf field: double time_pref = 23;
     */
    timePref: number;
}
/**
 * @generated from protobuf message routerrpc.TrackPaymentRequest
 */
export interface TrackPaymentRequest {
    /**
     * The hash of the payment to look up.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     *
     * If set, only the final payment update is streamed back. Intermediate updates
     * that show which htlcs are still in flight are suppressed.
     *
     * @generated from protobuf field: bool no_inflight_updates = 2;
     */
    noInflightUpdates: boolean;
}
/**
 * @generated from protobuf message routerrpc.TrackPaymentsRequest
 */
export interface TrackPaymentsRequest {
    /**
     *
     * If set, only the final payment updates are streamed back. Intermediate
     * updates that show which htlcs are still in flight are suppressed.
     *
     * @generated from protobuf field: bool no_inflight_updates = 1;
     */
    noInflightUpdates: boolean;
}
/**
 * @generated from protobuf message routerrpc.RouteFeeRequest
 */
export interface RouteFeeRequest {
    /**
     *
     * The destination once wishes to obtain a routing fee quote to.
     *
     * @generated from protobuf field: bytes dest = 1;
     */
    dest: Uint8Array;
    /**
     *
     * The amount one wishes to send to the target destination.
     *
     * @generated from protobuf field: int64 amt_sat = 2;
     */
    amtSat: bigint;
}
/**
 * @generated from protobuf message routerrpc.RouteFeeResponse
 */
export interface RouteFeeResponse {
    /**
     *
     * A lower bound of the estimated fee to the target destination within the
     * network, expressed in milli-satoshis.
     *
     * @generated from protobuf field: int64 routing_fee_msat = 1;
     */
    routingFeeMsat: bigint;
    /**
     *
     * An estimate of the worst case time delay that can occur. Note that callers
     * will still need to factor in the final CLTV delta of the last hop into this
     * value.
     *
     * @generated from protobuf field: int64 time_lock_delay = 2;
     */
    timeLockDelay: bigint;
}
/**
 * @generated from protobuf message routerrpc.SendToRouteRequest
 */
export interface SendToRouteRequest {
    /**
     * The payment hash to use for the HTLC.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     * Route that should be used to attempt to complete the payment.
     *
     * @generated from protobuf field: lnrpc.Route route = 2;
     */
    route?: Route;
    /**
     *
     * Whether the payment should be marked as failed when a temporary error is
     * returned from the given route. Set it to true so the payment won't be
     * failed unless a terminal error is occurred, such as payment timeout, no
     * routes, incorrect payment details, or insufficient funds.
     *
     * @generated from protobuf field: bool skip_temp_err = 3;
     */
    skipTempErr: boolean;
}
/**
 * @generated from protobuf message routerrpc.SendToRouteResponse
 */
export interface SendToRouteResponse {
    /**
     * The preimage obtained by making the payment.
     *
     * @generated from protobuf field: bytes preimage = 1;
     */
    preimage: Uint8Array;
    /**
     * The failure message in case the payment failed.
     *
     * @generated from protobuf field: lnrpc.Failure failure = 2;
     */
    failure?: Failure;
}
/**
 * @generated from protobuf message routerrpc.ResetMissionControlRequest
 */
export interface ResetMissionControlRequest {
}
/**
 * @generated from protobuf message routerrpc.ResetMissionControlResponse
 */
export interface ResetMissionControlResponse {
}
/**
 * @generated from protobuf message routerrpc.QueryMissionControlRequest
 */
export interface QueryMissionControlRequest {
}
/**
 * QueryMissionControlResponse contains mission control state.
 *
 * @generated from protobuf message routerrpc.QueryMissionControlResponse
 */
export interface QueryMissionControlResponse {
    /**
     * Node pair-level mission control state.
     *
     * @generated from protobuf field: repeated routerrpc.PairHistory pairs = 2;
     */
    pairs: PairHistory[];
}
/**
 * @generated from protobuf message routerrpc.XImportMissionControlRequest
 */
export interface XImportMissionControlRequest {
    /**
     * Node pair-level mission control state to be imported.
     *
     * @generated from protobuf field: repeated routerrpc.PairHistory pairs = 1;
     */
    pairs: PairHistory[];
    /**
     * Whether to force override MC pair history. Note that even with force
     * override the failure pair is imported before the success pair and both
     * still clamp existing failure/success amounts.
     *
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean;
}
/**
 * @generated from protobuf message routerrpc.XImportMissionControlResponse
 */
export interface XImportMissionControlResponse {
}
/**
 * PairHistory contains the mission control state for a particular node pair.
 *
 * @generated from protobuf message routerrpc.PairHistory
 */
export interface PairHistory {
    /**
     * The source node pubkey of the pair.
     *
     * @generated from protobuf field: bytes node_from = 1;
     */
    nodeFrom: Uint8Array;
    /**
     * The destination node pubkey of the pair.
     *
     * @generated from protobuf field: bytes node_to = 2;
     */
    nodeTo: Uint8Array;
    /**
     * @generated from protobuf field: routerrpc.PairData history = 7;
     */
    history?: PairData;
}
/**
 * @generated from protobuf message routerrpc.PairData
 */
export interface PairData {
    /**
     * Time of last failure.
     *
     * @generated from protobuf field: int64 fail_time = 1;
     */
    failTime: bigint;
    /**
     *
     * Lowest amount that failed to forward rounded to whole sats. This may be
     * set to zero if the failure is independent of amount.
     *
     * @generated from protobuf field: int64 fail_amt_sat = 2;
     */
    failAmtSat: bigint;
    /**
     *
     * Lowest amount that failed to forward in millisats. This may be
     * set to zero if the failure is independent of amount.
     *
     * @generated from protobuf field: int64 fail_amt_msat = 4;
     */
    failAmtMsat: bigint;
    /**
     * Time of last success.
     *
     * @generated from protobuf field: int64 success_time = 5;
     */
    successTime: bigint;
    /**
     * Highest amount that we could successfully forward rounded to whole sats.
     *
     * @generated from protobuf field: int64 success_amt_sat = 6;
     */
    successAmtSat: bigint;
    /**
     * Highest amount that we could successfully forward in millisats.
     *
     * @generated from protobuf field: int64 success_amt_msat = 7;
     */
    successAmtMsat: bigint;
}
/**
 * @generated from protobuf message routerrpc.GetMissionControlConfigRequest
 */
export interface GetMissionControlConfigRequest {
}
/**
 * @generated from protobuf message routerrpc.GetMissionControlConfigResponse
 */
export interface GetMissionControlConfigResponse {
    /**
     *
     * Mission control's currently active config.
     *
     * @generated from protobuf field: routerrpc.MissionControlConfig config = 1;
     */
    config?: MissionControlConfig;
}
/**
 * @generated from protobuf message routerrpc.SetMissionControlConfigRequest
 */
export interface SetMissionControlConfigRequest {
    /**
     *
     * The config to set for mission control. Note that all values *must* be set,
     * because the full config will be applied.
     *
     * @generated from protobuf field: routerrpc.MissionControlConfig config = 1;
     */
    config?: MissionControlConfig;
}
/**
 * @generated from protobuf message routerrpc.SetMissionControlConfigResponse
 */
export interface SetMissionControlConfigResponse {
}
/**
 * @generated from protobuf message routerrpc.MissionControlConfig
 */
export interface MissionControlConfig {
    /**
     *
     * The amount of time mission control will take to restore a penalized node
     * or channel back to 50% success probability, expressed in seconds. Setting
     * this value to a higher value will penalize failures for longer, making
     * mission control less likely to route through nodes and channels that we
     * have previously recorded failures for.
     *
     * @generated from protobuf field: uint64 half_life_seconds = 1;
     */
    halfLifeSeconds: bigint;
    /**
     *
     * The probability of success mission control should assign to hop in a route
     * where it has no other information available. Higher values will make mission
     * control more willing to try hops that we have no information about, lower
     * values will discourage trying these hops.
     *
     * @generated from protobuf field: float hop_probability = 2;
     */
    hopProbability: number;
    /**
     *
     * The importance that mission control should place on historical results,
     * expressed as a value in [0;1]. Setting this value to 1 will ignore all
     * historical payments and just use the hop probability to assess the
     * probability of success for each hop. A zero value ignores hop probability
     * completely and relies entirely on historical results, unless none are
     * available.
     *
     * @generated from protobuf field: float weight = 3;
     */
    weight: number;
    /**
     *
     * The maximum number of payment results that mission control will store.
     *
     * @generated from protobuf field: uint32 maximum_payment_results = 4;
     */
    maximumPaymentResults: number;
    /**
     *
     * The minimum time that must have passed since the previously recorded failure
     * before we raise the failure amount.
     *
     * @generated from protobuf field: uint64 minimum_failure_relax_interval = 5;
     */
    minimumFailureRelaxInterval: bigint;
}
/**
 * @generated from protobuf message routerrpc.QueryProbabilityRequest
 */
export interface QueryProbabilityRequest {
    /**
     * The source node pubkey of the pair.
     *
     * @generated from protobuf field: bytes from_node = 1;
     */
    fromNode: Uint8Array;
    /**
     * The destination node pubkey of the pair.
     *
     * @generated from protobuf field: bytes to_node = 2;
     */
    toNode: Uint8Array;
    /**
     * The amount for which to calculate a probability.
     *
     * @generated from protobuf field: int64 amt_msat = 3;
     */
    amtMsat: bigint;
}
/**
 * @generated from protobuf message routerrpc.QueryProbabilityResponse
 */
export interface QueryProbabilityResponse {
    /**
     * The success probability for the requested pair.
     *
     * @generated from protobuf field: double probability = 1;
     */
    probability: number;
    /**
     * The historical data for the requested pair.
     *
     * @generated from protobuf field: routerrpc.PairData history = 2;
     */
    history?: PairData;
}
/**
 * @generated from protobuf message routerrpc.BuildRouteRequest
 */
export interface BuildRouteRequest {
    /**
     *
     * The amount to send expressed in msat. If set to zero, the minimum routable
     * amount is used.
     *
     * @generated from protobuf field: int64 amt_msat = 1;
     */
    amtMsat: bigint;
    /**
     *
     * CLTV delta from the current height that should be used for the timelock
     * of the final hop
     *
     * @generated from protobuf field: int32 final_cltv_delta = 2;
     */
    finalCltvDelta: number;
    /**
     *
     * The channel id of the channel that must be taken to the first hop. If zero,
     * any channel may be used.
     *
     * @generated from protobuf field: uint64 outgoing_chan_id = 3 [jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * A list of hops that defines the route. This does not include the source hop
     * pubkey.
     *
     * @generated from protobuf field: repeated bytes hop_pubkeys = 4;
     */
    hopPubkeys: Uint8Array[];
    /**
     * An optional payment addr to be included within the last hop of the route.
     *
     * @generated from protobuf field: bytes payment_addr = 5;
     */
    paymentAddr: Uint8Array;
}
/**
 * @generated from protobuf message routerrpc.BuildRouteResponse
 */
export interface BuildRouteResponse {
    /**
     *
     * Fully specified route that can be used to execute the payment.
     *
     * @generated from protobuf field: lnrpc.Route route = 1;
     */
    route?: Route;
}
/**
 * @generated from protobuf message routerrpc.SubscribeHtlcEventsRequest
 */
export interface SubscribeHtlcEventsRequest {
}
/**
 *
 * HtlcEvent contains the htlc event that was processed. These are served on a
 * best-effort basis; events are not persisted, delivery is not guaranteed
 * (in the event of a crash in the switch, forward events may be lost) and
 * some events may be replayed upon restart. Events consumed from this package
 * should be de-duplicated by the htlc's unique combination of incoming and
 * outgoing channel id and htlc id. [EXPERIMENTAL]
 *
 * @generated from protobuf message routerrpc.HtlcEvent
 */
export interface HtlcEvent {
    /**
     *
     * The short channel id that the incoming htlc arrived at our node on. This
     * value is zero for sends.
     *
     * @generated from protobuf field: uint64 incoming_channel_id = 1;
     */
    incomingChannelId: bigint;
    /**
     *
     * The short channel id that the outgoing htlc left our node on. This value
     * is zero for receives.
     *
     * @generated from protobuf field: uint64 outgoing_channel_id = 2;
     */
    outgoingChannelId: bigint;
    /**
     *
     * Incoming id is the index of the incoming htlc in the incoming channel.
     * This value is zero for sends.
     *
     * @generated from protobuf field: uint64 incoming_htlc_id = 3;
     */
    incomingHtlcId: bigint;
    /**
     *
     * Outgoing id is the index of the outgoing htlc in the outgoing channel.
     * This value is zero for receives.
     *
     * @generated from protobuf field: uint64 outgoing_htlc_id = 4;
     */
    outgoingHtlcId: bigint;
    /**
     *
     * The time in unix nanoseconds that the event occurred.
     *
     * @generated from protobuf field: uint64 timestamp_ns = 5;
     */
    timestampNs: bigint;
    /**
     *
     * The event type indicates whether the htlc was part of a send, receive or
     * forward.
     *
     * @generated from protobuf field: routerrpc.HtlcEvent.EventType event_type = 6;
     */
    eventType: HtlcEvent_EventType;
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "forwardEvent";
        /**
         * @generated from protobuf field: routerrpc.ForwardEvent forward_event = 7;
         */
        forwardEvent: ForwardEvent;
    } | {
        oneofKind: "forwardFailEvent";
        /**
         * @generated from protobuf field: routerrpc.ForwardFailEvent forward_fail_event = 8;
         */
        forwardFailEvent: ForwardFailEvent;
    } | {
        oneofKind: "settleEvent";
        /**
         * @generated from protobuf field: routerrpc.SettleEvent settle_event = 9;
         */
        settleEvent: SettleEvent;
    } | {
        oneofKind: "linkFailEvent";
        /**
         * @generated from protobuf field: routerrpc.LinkFailEvent link_fail_event = 10;
         */
        linkFailEvent: LinkFailEvent;
    } | {
        oneofKind: "subscribedEvent";
        /**
         * @generated from protobuf field: routerrpc.SubscribedEvent subscribed_event = 11;
         */
        subscribedEvent: SubscribedEvent;
    } | {
        oneofKind: "finalHtlcEvent";
        /**
         * @generated from protobuf field: routerrpc.FinalHtlcEvent final_htlc_event = 12;
         */
        finalHtlcEvent: FinalHtlcEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum routerrpc.HtlcEvent.EventType
 */
export enum HtlcEvent_EventType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SEND = 1;
     */
    SEND = 1,
    /**
     * @generated from protobuf enum value: RECEIVE = 2;
     */
    RECEIVE = 2,
    /**
     * @generated from protobuf enum value: FORWARD = 3;
     */
    FORWARD = 3
}
/**
 * @generated from protobuf message routerrpc.HtlcInfo
 */
export interface HtlcInfo {
    /**
     * The timelock on the incoming htlc.
     *
     * @generated from protobuf field: uint32 incoming_timelock = 1;
     */
    incomingTimelock: number;
    /**
     * The timelock on the outgoing htlc.
     *
     * @generated from protobuf field: uint32 outgoing_timelock = 2;
     */
    outgoingTimelock: number;
    /**
     * The amount of the incoming htlc.
     *
     * @generated from protobuf field: uint64 incoming_amt_msat = 3;
     */
    incomingAmtMsat: bigint;
    /**
     * The amount of the outgoing htlc.
     *
     * @generated from protobuf field: uint64 outgoing_amt_msat = 4;
     */
    outgoingAmtMsat: bigint;
}
/**
 * @generated from protobuf message routerrpc.ForwardEvent
 */
export interface ForwardEvent {
    /**
     * Info contains details about the htlc that was forwarded.
     *
     * @generated from protobuf field: routerrpc.HtlcInfo info = 1;
     */
    info?: HtlcInfo;
}
/**
 * @generated from protobuf message routerrpc.ForwardFailEvent
 */
export interface ForwardFailEvent {
}
/**
 * @generated from protobuf message routerrpc.SettleEvent
 */
export interface SettleEvent {
    /**
     * The revealed preimage.
     *
     * @generated from protobuf field: bytes preimage = 1;
     */
    preimage: Uint8Array;
}
/**
 * @generated from protobuf message routerrpc.FinalHtlcEvent
 */
export interface FinalHtlcEvent {
    /**
     * @generated from protobuf field: bool settled = 1;
     */
    settled: boolean;
    /**
     * @generated from protobuf field: bool offchain = 2;
     */
    offchain: boolean;
}
/**
 * @generated from protobuf message routerrpc.SubscribedEvent
 */
export interface SubscribedEvent {
}
/**
 * @generated from protobuf message routerrpc.LinkFailEvent
 */
export interface LinkFailEvent {
    /**
     * Info contains details about the htlc that we failed.
     *
     * @generated from protobuf field: routerrpc.HtlcInfo info = 1;
     */
    info?: HtlcInfo;
    /**
     * FailureCode is the BOLT error code for the failure.
     *
     * @generated from protobuf field: lnrpc.Failure.FailureCode wire_failure = 2;
     */
    wireFailure: Failure_FailureCode;
    /**
     *
     * FailureDetail provides additional information about the reason for the
     * failure. This detail enriches the information provided by the wire message
     * and may be 'no detail' if the wire message requires no additional metadata.
     *
     * @generated from protobuf field: routerrpc.FailureDetail failure_detail = 3;
     */
    failureDetail: FailureDetail;
    /**
     * A string representation of the link failure.
     *
     * @generated from protobuf field: string failure_string = 4;
     */
    failureString: string;
}
/**
 * @generated from protobuf message routerrpc.PaymentStatus
 */
export interface PaymentStatus {
    /**
     * Current state the payment is in.
     *
     * @generated from protobuf field: routerrpc.PaymentState state = 1;
     */
    state: PaymentState;
    /**
     *
     * The pre-image of the payment when state is SUCCEEDED.
     *
     * @generated from protobuf field: bytes preimage = 2;
     */
    preimage: Uint8Array;
    /**
     *
     * The HTLCs made in attempt to settle the payment [EXPERIMENTAL].
     *
     * @generated from protobuf field: repeated lnrpc.HTLCAttempt htlcs = 4;
     */
    htlcs: HTLCAttempt[];
}
/**
 * @generated from protobuf message routerrpc.CircuitKey
 */
export interface CircuitKey {
    /**
     * / The id of the channel that the is part of this circuit.
     *
     * @generated from protobuf field: uint64 chan_id = 1;
     */
    chanId: bigint;
    /**
     * / The index of the incoming htlc in the incoming channel.
     *
     * @generated from protobuf field: uint64 htlc_id = 2;
     */
    htlcId: bigint;
}
/**
 * @generated from protobuf message routerrpc.ForwardHtlcInterceptRequest
 */
export interface ForwardHtlcInterceptRequest {
    /**
     *
     * The key of this forwarded htlc. It defines the incoming channel id and
     * the index in this channel.
     *
     * @generated from protobuf field: routerrpc.CircuitKey incoming_circuit_key = 1;
     */
    incomingCircuitKey?: CircuitKey;
    /**
     * The incoming htlc amount.
     *
     * @generated from protobuf field: uint64 incoming_amount_msat = 5;
     */
    incomingAmountMsat: bigint;
    /**
     * The incoming htlc expiry.
     *
     * @generated from protobuf field: uint32 incoming_expiry = 6;
     */
    incomingExpiry: number;
    /**
     *
     * The htlc payment hash. This value is not guaranteed to be unique per
     * request.
     *
     * @generated from protobuf field: bytes payment_hash = 2;
     */
    paymentHash: Uint8Array;
    /**
     * The requested outgoing channel id for this forwarded htlc. Because of
     * non-strict forwarding, this isn't necessarily the channel over which the
     * packet will be forwarded eventually. A different channel to the same peer
     * may be selected as well.
     *
     * @generated from protobuf field: uint64 outgoing_requested_chan_id = 7;
     */
    outgoingRequestedChanId: bigint;
    /**
     * The outgoing htlc amount.
     *
     * @generated from protobuf field: uint64 outgoing_amount_msat = 3;
     */
    outgoingAmountMsat: bigint;
    /**
     * The outgoing htlc expiry.
     *
     * @generated from protobuf field: uint32 outgoing_expiry = 4;
     */
    outgoingExpiry: number;
    /**
     * Any custom records that were present in the payload.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 8;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * The onion blob for the next hop
     *
     * @generated from protobuf field: bytes onion_blob = 9;
     */
    onionBlob: Uint8Array;
    /**
     * The block height at which this htlc will be auto-failed to prevent the
     * channel from force-closing.
     *
     * @generated from protobuf field: int32 auto_fail_height = 10;
     */
    autoFailHeight: number;
}
/**
 * *
 * ForwardHtlcInterceptResponse enables the caller to resolve a previously hold
 * forward. The caller can choose either to:
 * - `Resume`: Execute the default behavior (usually forward).
 * - `Reject`: Fail the htlc backwards.
 * - `Settle`: Settle this htlc with a given preimage.
 *
 * @generated from protobuf message routerrpc.ForwardHtlcInterceptResponse
 */
export interface ForwardHtlcInterceptResponse {
    /**
     * *
     * The key of this forwarded htlc. It defines the incoming channel id and
     * the index in this channel.
     *
     * @generated from protobuf field: routerrpc.CircuitKey incoming_circuit_key = 1;
     */
    incomingCircuitKey?: CircuitKey;
    /**
     * The resolve action for this intercepted htlc.
     *
     * @generated from protobuf field: routerrpc.ResolveHoldForwardAction action = 2;
     */
    action: ResolveHoldForwardAction;
    /**
     * The preimage in case the resolve action is Settle.
     *
     * @generated from protobuf field: bytes preimage = 3;
     */
    preimage: Uint8Array;
    /**
     * Encrypted failure message in case the resolve action is Fail.
     *
     * If failure_message is specified, the failure_code field must be set
     * to zero.
     *
     * @generated from protobuf field: bytes failure_message = 4;
     */
    failureMessage: Uint8Array;
    /**
     * Return the specified failure code in case the resolve action is Fail. The
     * message data fields are populated automatically.
     *
     * If a non-zero failure_code is specified, failure_message must not be set.
     *
     * For backwards-compatibility reasons, TEMPORARY_CHANNEL_FAILURE is the
     * default value for this field.
     *
     * @generated from protobuf field: lnrpc.Failure.FailureCode failure_code = 5;
     */
    failureCode: Failure_FailureCode;
}
/**
 * @generated from protobuf message routerrpc.UpdateChanStatusRequest
 */
export interface UpdateChanStatusRequest {
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
    /**
     * @generated from protobuf field: routerrpc.ChanStatusAction action = 2;
     */
    action: ChanStatusAction;
}
/**
 * @generated from protobuf message routerrpc.UpdateChanStatusResponse
 */
export interface UpdateChanStatusResponse {
}
/**
 * @generated from protobuf enum routerrpc.FailureDetail
 */
export enum FailureDetail {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: NO_DETAIL = 1;
     */
    NO_DETAIL = 1,
    /**
     * @generated from protobuf enum value: ONION_DECODE = 2;
     */
    ONION_DECODE = 2,
    /**
     * @generated from protobuf enum value: LINK_NOT_ELIGIBLE = 3;
     */
    LINK_NOT_ELIGIBLE = 3,
    /**
     * @generated from protobuf enum value: ON_CHAIN_TIMEOUT = 4;
     */
    ON_CHAIN_TIMEOUT = 4,
    /**
     * @generated from protobuf enum value: HTLC_EXCEEDS_MAX = 5;
     */
    HTLC_EXCEEDS_MAX = 5,
    /**
     * @generated from protobuf enum value: INSUFFICIENT_BALANCE = 6;
     */
    INSUFFICIENT_BALANCE = 6,
    /**
     * @generated from protobuf enum value: INCOMPLETE_FORWARD = 7;
     */
    INCOMPLETE_FORWARD = 7,
    /**
     * @generated from protobuf enum value: HTLC_ADD_FAILED = 8;
     */
    HTLC_ADD_FAILED = 8,
    /**
     * @generated from protobuf enum value: FORWARDS_DISABLED = 9;
     */
    FORWARDS_DISABLED = 9,
    /**
     * @generated from protobuf enum value: INVOICE_CANCELED = 10;
     */
    INVOICE_CANCELED = 10,
    /**
     * @generated from protobuf enum value: INVOICE_UNDERPAID = 11;
     */
    INVOICE_UNDERPAID = 11,
    /**
     * @generated from protobuf enum value: INVOICE_EXPIRY_TOO_SOON = 12;
     */
    INVOICE_EXPIRY_TOO_SOON = 12,
    /**
     * @generated from protobuf enum value: INVOICE_NOT_OPEN = 13;
     */
    INVOICE_NOT_OPEN = 13,
    /**
     * @generated from protobuf enum value: MPP_INVOICE_TIMEOUT = 14;
     */
    MPP_INVOICE_TIMEOUT = 14,
    /**
     * @generated from protobuf enum value: ADDRESS_MISMATCH = 15;
     */
    ADDRESS_MISMATCH = 15,
    /**
     * @generated from protobuf enum value: SET_TOTAL_MISMATCH = 16;
     */
    SET_TOTAL_MISMATCH = 16,
    /**
     * @generated from protobuf enum value: SET_TOTAL_TOO_LOW = 17;
     */
    SET_TOTAL_TOO_LOW = 17,
    /**
     * @generated from protobuf enum value: SET_OVERPAID = 18;
     */
    SET_OVERPAID = 18,
    /**
     * @generated from protobuf enum value: UNKNOWN_INVOICE = 19;
     */
    UNKNOWN_INVOICE = 19,
    /**
     * @generated from protobuf enum value: INVALID_KEYSEND = 20;
     */
    INVALID_KEYSEND = 20,
    /**
     * @generated from protobuf enum value: MPP_IN_PROGRESS = 21;
     */
    MPP_IN_PROGRESS = 21,
    /**
     * @generated from protobuf enum value: CIRCULAR_ROUTE = 22;
     */
    CIRCULAR_ROUTE = 22
}
/**
 * @generated from protobuf enum routerrpc.PaymentState
 */
export enum PaymentState {
    /**
     *
     * Payment is still in flight.
     *
     * @generated from protobuf enum value: IN_FLIGHT = 0;
     */
    IN_FLIGHT = 0,
    /**
     *
     * Payment completed successfully.
     *
     * @generated from protobuf enum value: SUCCEEDED = 1;
     */
    SUCCEEDED = 1,
    /**
     *
     * There are more routes to try, but the payment timeout was exceeded.
     *
     * @generated from protobuf enum value: FAILED_TIMEOUT = 2;
     */
    FAILED_TIMEOUT = 2,
    /**
     *
     * All possible routes were tried and failed permanently. Or were no
     * routes to the destination at all.
     *
     * @generated from protobuf enum value: FAILED_NO_ROUTE = 3;
     */
    FAILED_NO_ROUTE = 3,
    /**
     *
     * A non-recoverable error has occurred.
     *
     * @generated from protobuf enum value: FAILED_ERROR = 4;
     */
    FAILED_ERROR = 4,
    /**
     *
     * Payment details incorrect (unknown hash, invalid amt or
     * invalid final cltv delta)
     *
     * @generated from protobuf enum value: FAILED_INCORRECT_PAYMENT_DETAILS = 5;
     */
    FAILED_INCORRECT_PAYMENT_DETAILS = 5,
    /**
     *
     * Insufficient local balance.
     *
     * @generated from protobuf enum value: FAILED_INSUFFICIENT_BALANCE = 6;
     */
    FAILED_INSUFFICIENT_BALANCE = 6
}
/**
 * @generated from protobuf enum routerrpc.ResolveHoldForwardAction
 */
export enum ResolveHoldForwardAction {
    /**
     * @generated from protobuf enum value: SETTLE = 0;
     */
    SETTLE = 0,
    /**
     * @generated from protobuf enum value: FAIL = 1;
     */
    FAIL = 1,
    /**
     * @generated from protobuf enum value: RESUME = 2;
     */
    RESUME = 2
}
/**
 * @generated from protobuf enum routerrpc.ChanStatusAction
 */
export enum ChanStatusAction {
    /**
     * @generated from protobuf enum value: ENABLE = 0;
     */
    ENABLE = 0,
    /**
     * @generated from protobuf enum value: DISABLE = 1;
     */
    DISABLE = 1,
    /**
     * @generated from protobuf enum value: AUTO = 2;
     */
    AUTO = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SendPaymentRequest$Type extends MessageType<SendPaymentRequest> {
    constructor() {
        super("routerrpc.SendPaymentRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "amt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "timeout_seconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "fee_limit_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "fee_limit_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 19, name: "outgoing_chan_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "last_hop_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "cltv_limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "route_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteHint },
            { no: 11, name: "dest_custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 15, name: "allow_self_payment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "dest_features", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["lnrpc.FeatureBit", FeatureBit] },
            { no: 17, name: "max_parts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "max_shard_size_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "amp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "time_pref", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SendPaymentRequest>): SendPaymentRequest {
        const message = { dest: new Uint8Array(0), amt: 0n, amtMsat: 0n, paymentHash: new Uint8Array(0), finalCltvDelta: 0, paymentAddr: new Uint8Array(0), paymentRequest: "", timeoutSeconds: 0, feeLimitSat: 0n, feeLimitMsat: 0n, outgoingChanId: "0", outgoingChanIds: [], lastHopPubkey: new Uint8Array(0), cltvLimit: 0, routeHints: [], destCustomRecords: {}, allowSelfPayment: false, destFeatures: [], maxParts: 0, noInflightUpdates: false, maxShardSizeMsat: 0n, amp: false, timePref: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendPaymentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendPaymentRequest): SendPaymentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* int64 amt */ 2:
                    message.amt = reader.int64().toBigInt();
                    break;
                case /* int64 amt_msat */ 12:
                    message.amtMsat = reader.int64().toBigInt();
                    break;
                case /* bytes payment_hash */ 3:
                    message.paymentHash = reader.bytes();
                    break;
                case /* int32 final_cltv_delta */ 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* bytes payment_addr */ 20:
                    message.paymentAddr = reader.bytes();
                    break;
                case /* string payment_request */ 5:
                    message.paymentRequest = reader.string();
                    break;
                case /* int32 timeout_seconds */ 6:
                    message.timeoutSeconds = reader.int32();
                    break;
                case /* int64 fee_limit_sat */ 7:
                    message.feeLimitSat = reader.int64().toBigInt();
                    break;
                case /* int64 fee_limit_msat */ 13:
                    message.feeLimitMsat = reader.int64().toBigInt();
                    break;
                case /* uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING];*/ 8:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* repeated uint64 outgoing_chan_ids */ 19:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.outgoingChanIds.push(reader.uint64().toBigInt());
                    else
                        message.outgoingChanIds.push(reader.uint64().toBigInt());
                    break;
                case /* bytes last_hop_pubkey */ 14:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case /* int32 cltv_limit */ 9:
                    message.cltvLimit = reader.int32();
                    break;
                case /* repeated lnrpc.RouteHint route_hints */ 10:
                    message.routeHints.push(RouteHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint64, bytes> dest_custom_records */ 11:
                    this.binaryReadMap11(message.destCustomRecords, reader, options);
                    break;
                case /* bool allow_self_payment */ 15:
                    message.allowSelfPayment = reader.bool();
                    break;
                case /* repeated lnrpc.FeatureBit dest_features */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.destFeatures.push(reader.int32());
                    else
                        message.destFeatures.push(reader.int32());
                    break;
                case /* uint32 max_parts */ 17:
                    message.maxParts = reader.uint32();
                    break;
                case /* bool no_inflight_updates */ 18:
                    message.noInflightUpdates = reader.bool();
                    break;
                case /* uint64 max_shard_size_msat */ 21:
                    message.maxShardSizeMsat = reader.uint64().toBigInt();
                    break;
                case /* bool amp */ 22:
                    message.amp = reader.bool();
                    break;
                case /* double time_pref */ 23:
                    message.timePref = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: SendPaymentRequest["destCustomRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendPaymentRequest["destCustomRecords"] | undefined, val: SendPaymentRequest["destCustomRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field routerrpc.SendPaymentRequest.dest_custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: SendPaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.dest);
        /* int64 amt = 2; */
        if (message.amt !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amt);
        /* int64 amt_msat = 12; */
        if (message.amtMsat !== 0n)
            writer.tag(12, WireType.Varint).int64(message.amtMsat);
        /* bytes payment_hash = 3; */
        if (message.paymentHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.paymentHash);
        /* int32 final_cltv_delta = 4; */
        if (message.finalCltvDelta !== 0)
            writer.tag(4, WireType.Varint).int32(message.finalCltvDelta);
        /* bytes payment_addr = 20; */
        if (message.paymentAddr.length)
            writer.tag(20, WireType.LengthDelimited).bytes(message.paymentAddr);
        /* string payment_request = 5; */
        if (message.paymentRequest !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paymentRequest);
        /* int32 timeout_seconds = 6; */
        if (message.timeoutSeconds !== 0)
            writer.tag(6, WireType.Varint).int32(message.timeoutSeconds);
        /* int64 fee_limit_sat = 7; */
        if (message.feeLimitSat !== 0n)
            writer.tag(7, WireType.Varint).int64(message.feeLimitSat);
        /* int64 fee_limit_msat = 13; */
        if (message.feeLimitMsat !== 0n)
            writer.tag(13, WireType.Varint).int64(message.feeLimitMsat);
        /* uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(8, WireType.Varint).uint64(message.outgoingChanId);
        /* repeated uint64 outgoing_chan_ids = 19; */
        if (message.outgoingChanIds.length) {
            writer.tag(19, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.outgoingChanIds.length; i++)
                writer.uint64(message.outgoingChanIds[i]);
            writer.join();
        }
        /* bytes last_hop_pubkey = 14; */
        if (message.lastHopPubkey.length)
            writer.tag(14, WireType.LengthDelimited).bytes(message.lastHopPubkey);
        /* int32 cltv_limit = 9; */
        if (message.cltvLimit !== 0)
            writer.tag(9, WireType.Varint).int32(message.cltvLimit);
        /* repeated lnrpc.RouteHint route_hints = 10; */
        for (let i = 0; i < message.routeHints.length; i++)
            RouteHint.internalBinaryWrite(message.routeHints[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* map<uint64, bytes> dest_custom_records = 11; */
        for (let k of Object.keys(message.destCustomRecords))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.destCustomRecords[k]).join();
        /* bool allow_self_payment = 15; */
        if (message.allowSelfPayment !== false)
            writer.tag(15, WireType.Varint).bool(message.allowSelfPayment);
        /* repeated lnrpc.FeatureBit dest_features = 16; */
        if (message.destFeatures.length) {
            writer.tag(16, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.destFeatures.length; i++)
                writer.int32(message.destFeatures[i]);
            writer.join();
        }
        /* uint32 max_parts = 17; */
        if (message.maxParts !== 0)
            writer.tag(17, WireType.Varint).uint32(message.maxParts);
        /* bool no_inflight_updates = 18; */
        if (message.noInflightUpdates !== false)
            writer.tag(18, WireType.Varint).bool(message.noInflightUpdates);
        /* uint64 max_shard_size_msat = 21; */
        if (message.maxShardSizeMsat !== 0n)
            writer.tag(21, WireType.Varint).uint64(message.maxShardSizeMsat);
        /* bool amp = 22; */
        if (message.amp !== false)
            writer.tag(22, WireType.Varint).bool(message.amp);
        /* double time_pref = 23; */
        if (message.timePref !== 0)
            writer.tag(23, WireType.Bit64).double(message.timePref);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendPaymentRequest
 */
export const SendPaymentRequest = new SendPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPaymentRequest$Type extends MessageType<TrackPaymentRequest> {
    constructor() {
        super("routerrpc.TrackPaymentRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TrackPaymentRequest>): TrackPaymentRequest {
        const message = { paymentHash: new Uint8Array(0), noInflightUpdates: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackPaymentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPaymentRequest): TrackPaymentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* bool no_inflight_updates */ 2:
                    message.noInflightUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paymentHash);
        /* bool no_inflight_updates = 2; */
        if (message.noInflightUpdates !== false)
            writer.tag(2, WireType.Varint).bool(message.noInflightUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentRequest
 */
export const TrackPaymentRequest = new TrackPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPaymentsRequest$Type extends MessageType<TrackPaymentsRequest> {
    constructor() {
        super("routerrpc.TrackPaymentsRequest", [
            { no: 1, name: "no_inflight_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TrackPaymentsRequest>): TrackPaymentsRequest {
        const message = { noInflightUpdates: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackPaymentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPaymentsRequest): TrackPaymentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool no_inflight_updates */ 1:
                    message.noInflightUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool no_inflight_updates = 1; */
        if (message.noInflightUpdates !== false)
            writer.tag(1, WireType.Varint).bool(message.noInflightUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentsRequest
 */
export const TrackPaymentsRequest = new TrackPaymentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteFeeRequest$Type extends MessageType<RouteFeeRequest> {
    constructor() {
        super("routerrpc.RouteFeeRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RouteFeeRequest>): RouteFeeRequest {
        const message = { dest: new Uint8Array(0), amtSat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RouteFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteFeeRequest): RouteFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* int64 amt_sat */ 2:
                    message.amtSat = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.dest);
        /* int64 amt_sat = 2; */
        if (message.amtSat !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amtSat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeRequest
 */
export const RouteFeeRequest = new RouteFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteFeeResponse$Type extends MessageType<RouteFeeResponse> {
    constructor() {
        super("routerrpc.RouteFeeResponse", [
            { no: 1, name: "routing_fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "time_lock_delay", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RouteFeeResponse>): RouteFeeResponse {
        const message = { routingFeeMsat: 0n, timeLockDelay: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RouteFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteFeeResponse): RouteFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 routing_fee_msat */ 1:
                    message.routingFeeMsat = reader.int64().toBigInt();
                    break;
                case /* int64 time_lock_delay */ 2:
                    message.timeLockDelay = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 routing_fee_msat = 1; */
        if (message.routingFeeMsat !== 0n)
            writer.tag(1, WireType.Varint).int64(message.routingFeeMsat);
        /* int64 time_lock_delay = 2; */
        if (message.timeLockDelay !== 0n)
            writer.tag(2, WireType.Varint).int64(message.timeLockDelay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeResponse
 */
export const RouteFeeResponse = new RouteFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteRequest$Type extends MessageType<SendToRouteRequest> {
    constructor() {
        super("routerrpc.SendToRouteRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "route", kind: "message", T: () => Route },
            { no: 3, name: "skip_temp_err", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SendToRouteRequest>): SendToRouteRequest {
        const message = { paymentHash: new Uint8Array(0), skipTempErr: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendToRouteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendToRouteRequest): SendToRouteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* lnrpc.Route route */ 2:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                case /* bool skip_temp_err */ 3:
                    message.skipTempErr = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendToRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paymentHash);
        /* lnrpc.Route route = 2; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_temp_err = 3; */
        if (message.skipTempErr !== false)
            writer.tag(3, WireType.Varint).bool(message.skipTempErr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteRequest
 */
export const SendToRouteRequest = new SendToRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteResponse$Type extends MessageType<SendToRouteResponse> {
    constructor() {
        super("routerrpc.SendToRouteResponse", [
            { no: 1, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "failure", kind: "message", T: () => Failure }
        ]);
    }
    create(value?: PartialMessage<SendToRouteResponse>): SendToRouteResponse {
        const message = { preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendToRouteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendToRouteResponse): SendToRouteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes preimage */ 1:
                    message.preimage = reader.bytes();
                    break;
                case /* lnrpc.Failure failure */ 2:
                    message.failure = Failure.internalBinaryRead(reader, reader.uint32(), options, message.failure);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendToRouteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes preimage = 1; */
        if (message.preimage.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preimage);
        /* lnrpc.Failure failure = 2; */
        if (message.failure)
            Failure.internalBinaryWrite(message.failure, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteResponse
 */
export const SendToRouteResponse = new SendToRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetMissionControlRequest$Type extends MessageType<ResetMissionControlRequest> {
    constructor() {
        super("routerrpc.ResetMissionControlRequest", []);
    }
    create(value?: PartialMessage<ResetMissionControlRequest>): ResetMissionControlRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResetMissionControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetMissionControlRequest): ResetMissionControlRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResetMissionControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlRequest
 */
export const ResetMissionControlRequest = new ResetMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetMissionControlResponse$Type extends MessageType<ResetMissionControlResponse> {
    constructor() {
        super("routerrpc.ResetMissionControlResponse", []);
    }
    create(value?: PartialMessage<ResetMissionControlResponse>): ResetMissionControlResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResetMissionControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetMissionControlResponse): ResetMissionControlResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResetMissionControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlResponse
 */
export const ResetMissionControlResponse = new ResetMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMissionControlRequest$Type extends MessageType<QueryMissionControlRequest> {
    constructor() {
        super("routerrpc.QueryMissionControlRequest", []);
    }
    create(value?: PartialMessage<QueryMissionControlRequest>): QueryMissionControlRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryMissionControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMissionControlRequest): QueryMissionControlRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryMissionControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlRequest
 */
export const QueryMissionControlRequest = new QueryMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMissionControlResponse$Type extends MessageType<QueryMissionControlResponse> {
    constructor() {
        super("routerrpc.QueryMissionControlResponse", [
            { no: 2, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PairHistory }
        ]);
    }
    create(value?: PartialMessage<QueryMissionControlResponse>): QueryMissionControlResponse {
        const message = { pairs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryMissionControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMissionControlResponse): QueryMissionControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routerrpc.PairHistory pairs */ 2:
                    message.pairs.push(PairHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMissionControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated routerrpc.PairHistory pairs = 2; */
        for (let i = 0; i < message.pairs.length; i++)
            PairHistory.internalBinaryWrite(message.pairs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlResponse
 */
export const QueryMissionControlResponse = new QueryMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XImportMissionControlRequest$Type extends MessageType<XImportMissionControlRequest> {
    constructor() {
        super("routerrpc.XImportMissionControlRequest", [
            { no: 1, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PairHistory },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<XImportMissionControlRequest>): XImportMissionControlRequest {
        const message = { pairs: [], force: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<XImportMissionControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: XImportMissionControlRequest): XImportMissionControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routerrpc.PairHistory pairs */ 1:
                    message.pairs.push(PairHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: XImportMissionControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated routerrpc.PairHistory pairs = 1; */
        for (let i = 0; i < message.pairs.length; i++)
            PairHistory.internalBinaryWrite(message.pairs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlRequest
 */
export const XImportMissionControlRequest = new XImportMissionControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XImportMissionControlResponse$Type extends MessageType<XImportMissionControlResponse> {
    constructor() {
        super("routerrpc.XImportMissionControlResponse", []);
    }
    create(value?: PartialMessage<XImportMissionControlResponse>): XImportMissionControlResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<XImportMissionControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: XImportMissionControlResponse): XImportMissionControlResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: XImportMissionControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlResponse
 */
export const XImportMissionControlResponse = new XImportMissionControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PairHistory$Type extends MessageType<PairHistory> {
    constructor() {
        super("routerrpc.PairHistory", [
            { no: 1, name: "node_from", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "node_to", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "history", kind: "message", T: () => PairData }
        ]);
    }
    create(value?: PartialMessage<PairHistory>): PairHistory {
        const message = { nodeFrom: new Uint8Array(0), nodeTo: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PairHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PairHistory): PairHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes node_from */ 1:
                    message.nodeFrom = reader.bytes();
                    break;
                case /* bytes node_to */ 2:
                    message.nodeTo = reader.bytes();
                    break;
                case /* routerrpc.PairData history */ 7:
                    message.history = PairData.internalBinaryRead(reader, reader.uint32(), options, message.history);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PairHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes node_from = 1; */
        if (message.nodeFrom.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nodeFrom);
        /* bytes node_to = 2; */
        if (message.nodeTo.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.nodeTo);
        /* routerrpc.PairData history = 7; */
        if (message.history)
            PairData.internalBinaryWrite(message.history, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PairHistory
 */
export const PairHistory = new PairHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PairData$Type extends MessageType<PairData> {
    constructor() {
        super("routerrpc.PairData", [
            { no: 1, name: "fail_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "fail_amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fail_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "success_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "success_amt_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "success_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PairData>): PairData {
        const message = { failTime: 0n, failAmtSat: 0n, failAmtMsat: 0n, successTime: 0n, successAmtSat: 0n, successAmtMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PairData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PairData): PairData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 fail_time */ 1:
                    message.failTime = reader.int64().toBigInt();
                    break;
                case /* int64 fail_amt_sat */ 2:
                    message.failAmtSat = reader.int64().toBigInt();
                    break;
                case /* int64 fail_amt_msat */ 4:
                    message.failAmtMsat = reader.int64().toBigInt();
                    break;
                case /* int64 success_time */ 5:
                    message.successTime = reader.int64().toBigInt();
                    break;
                case /* int64 success_amt_sat */ 6:
                    message.successAmtSat = reader.int64().toBigInt();
                    break;
                case /* int64 success_amt_msat */ 7:
                    message.successAmtMsat = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PairData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 fail_time = 1; */
        if (message.failTime !== 0n)
            writer.tag(1, WireType.Varint).int64(message.failTime);
        /* int64 fail_amt_sat = 2; */
        if (message.failAmtSat !== 0n)
            writer.tag(2, WireType.Varint).int64(message.failAmtSat);
        /* int64 fail_amt_msat = 4; */
        if (message.failAmtMsat !== 0n)
            writer.tag(4, WireType.Varint).int64(message.failAmtMsat);
        /* int64 success_time = 5; */
        if (message.successTime !== 0n)
            writer.tag(5, WireType.Varint).int64(message.successTime);
        /* int64 success_amt_sat = 6; */
        if (message.successAmtSat !== 0n)
            writer.tag(6, WireType.Varint).int64(message.successAmtSat);
        /* int64 success_amt_msat = 7; */
        if (message.successAmtMsat !== 0n)
            writer.tag(7, WireType.Varint).int64(message.successAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PairData
 */
export const PairData = new PairData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMissionControlConfigRequest$Type extends MessageType<GetMissionControlConfigRequest> {
    constructor() {
        super("routerrpc.GetMissionControlConfigRequest", []);
    }
    create(value?: PartialMessage<GetMissionControlConfigRequest>): GetMissionControlConfigRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMissionControlConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMissionControlConfigRequest): GetMissionControlConfigRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMissionControlConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigRequest
 */
export const GetMissionControlConfigRequest = new GetMissionControlConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMissionControlConfigResponse$Type extends MessageType<GetMissionControlConfigResponse> {
    constructor() {
        super("routerrpc.GetMissionControlConfigResponse", [
            { no: 1, name: "config", kind: "message", T: () => MissionControlConfig }
        ]);
    }
    create(value?: PartialMessage<GetMissionControlConfigResponse>): GetMissionControlConfigResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMissionControlConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMissionControlConfigResponse): GetMissionControlConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.MissionControlConfig config */ 1:
                    message.config = MissionControlConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMissionControlConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.MissionControlConfig config = 1; */
        if (message.config)
            MissionControlConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigResponse
 */
export const GetMissionControlConfigResponse = new GetMissionControlConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMissionControlConfigRequest$Type extends MessageType<SetMissionControlConfigRequest> {
    constructor() {
        super("routerrpc.SetMissionControlConfigRequest", [
            { no: 1, name: "config", kind: "message", T: () => MissionControlConfig }
        ]);
    }
    create(value?: PartialMessage<SetMissionControlConfigRequest>): SetMissionControlConfigRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetMissionControlConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMissionControlConfigRequest): SetMissionControlConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.MissionControlConfig config */ 1:
                    message.config = MissionControlConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetMissionControlConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.MissionControlConfig config = 1; */
        if (message.config)
            MissionControlConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigRequest
 */
export const SetMissionControlConfigRequest = new SetMissionControlConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMissionControlConfigResponse$Type extends MessageType<SetMissionControlConfigResponse> {
    constructor() {
        super("routerrpc.SetMissionControlConfigResponse", []);
    }
    create(value?: PartialMessage<SetMissionControlConfigResponse>): SetMissionControlConfigResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetMissionControlConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMissionControlConfigResponse): SetMissionControlConfigResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetMissionControlConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigResponse
 */
export const SetMissionControlConfigResponse = new SetMissionControlConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionControlConfig$Type extends MessageType<MissionControlConfig> {
    constructor() {
        super("routerrpc.MissionControlConfig", [
            { no: 1, name: "half_life_seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "hop_probability", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "maximum_payment_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "minimum_failure_relax_interval", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MissionControlConfig>): MissionControlConfig {
        const message = { halfLifeSeconds: 0n, hopProbability: 0, weight: 0, maximumPaymentResults: 0, minimumFailureRelaxInterval: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MissionControlConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionControlConfig): MissionControlConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 half_life_seconds */ 1:
                    message.halfLifeSeconds = reader.uint64().toBigInt();
                    break;
                case /* float hop_probability */ 2:
                    message.hopProbability = reader.float();
                    break;
                case /* float weight */ 3:
                    message.weight = reader.float();
                    break;
                case /* uint32 maximum_payment_results */ 4:
                    message.maximumPaymentResults = reader.uint32();
                    break;
                case /* uint64 minimum_failure_relax_interval */ 5:
                    message.minimumFailureRelaxInterval = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionControlConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 half_life_seconds = 1; */
        if (message.halfLifeSeconds !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.halfLifeSeconds);
        /* float hop_probability = 2; */
        if (message.hopProbability !== 0)
            writer.tag(2, WireType.Bit32).float(message.hopProbability);
        /* float weight = 3; */
        if (message.weight !== 0)
            writer.tag(3, WireType.Bit32).float(message.weight);
        /* uint32 maximum_payment_results = 4; */
        if (message.maximumPaymentResults !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maximumPaymentResults);
        /* uint64 minimum_failure_relax_interval = 5; */
        if (message.minimumFailureRelaxInterval !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.minimumFailureRelaxInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.MissionControlConfig
 */
export const MissionControlConfig = new MissionControlConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryProbabilityRequest$Type extends MessageType<QueryProbabilityRequest> {
    constructor() {
        super("routerrpc.QueryProbabilityRequest", [
            { no: 1, name: "from_node", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "to_node", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryProbabilityRequest>): QueryProbabilityRequest {
        const message = { fromNode: new Uint8Array(0), toNode: new Uint8Array(0), amtMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryProbabilityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryProbabilityRequest): QueryProbabilityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes from_node */ 1:
                    message.fromNode = reader.bytes();
                    break;
                case /* bytes to_node */ 2:
                    message.toNode = reader.bytes();
                    break;
                case /* int64 amt_msat */ 3:
                    message.amtMsat = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryProbabilityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes from_node = 1; */
        if (message.fromNode.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fromNode);
        /* bytes to_node = 2; */
        if (message.toNode.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.toNode);
        /* int64 amt_msat = 3; */
        if (message.amtMsat !== 0n)
            writer.tag(3, WireType.Varint).int64(message.amtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityRequest
 */
export const QueryProbabilityRequest = new QueryProbabilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryProbabilityResponse$Type extends MessageType<QueryProbabilityResponse> {
    constructor() {
        super("routerrpc.QueryProbabilityResponse", [
            { no: 1, name: "probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "history", kind: "message", T: () => PairData }
        ]);
    }
    create(value?: PartialMessage<QueryProbabilityResponse>): QueryProbabilityResponse {
        const message = { probability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryProbabilityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryProbabilityResponse): QueryProbabilityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double probability */ 1:
                    message.probability = reader.double();
                    break;
                case /* routerrpc.PairData history */ 2:
                    message.history = PairData.internalBinaryRead(reader, reader.uint32(), options, message.history);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryProbabilityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double probability = 1; */
        if (message.probability !== 0)
            writer.tag(1, WireType.Bit64).double(message.probability);
        /* routerrpc.PairData history = 2; */
        if (message.history)
            PairData.internalBinaryWrite(message.history, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityResponse
 */
export const QueryProbabilityResponse = new QueryProbabilityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildRouteRequest$Type extends MessageType<BuildRouteRequest> {
    constructor() {
        super("routerrpc.BuildRouteRequest", [
            { no: 1, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "hop_pubkeys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BuildRouteRequest>): BuildRouteRequest {
        const message = { amtMsat: 0n, finalCltvDelta: 0, outgoingChanId: "0", hopPubkeys: [], paymentAddr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuildRouteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildRouteRequest): BuildRouteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 amt_msat */ 1:
                    message.amtMsat = reader.int64().toBigInt();
                    break;
                case /* int32 final_cltv_delta */ 2:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* uint64 outgoing_chan_id = 3 [jstype = JS_STRING];*/ 3:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* repeated bytes hop_pubkeys */ 4:
                    message.hopPubkeys.push(reader.bytes());
                    break;
                case /* bytes payment_addr */ 5:
                    message.paymentAddr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 amt_msat = 1; */
        if (message.amtMsat !== 0n)
            writer.tag(1, WireType.Varint).int64(message.amtMsat);
        /* int32 final_cltv_delta = 2; */
        if (message.finalCltvDelta !== 0)
            writer.tag(2, WireType.Varint).int32(message.finalCltvDelta);
        /* uint64 outgoing_chan_id = 3 [jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(3, WireType.Varint).uint64(message.outgoingChanId);
        /* repeated bytes hop_pubkeys = 4; */
        for (let i = 0; i < message.hopPubkeys.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hopPubkeys[i]);
        /* bytes payment_addr = 5; */
        if (message.paymentAddr.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.paymentAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteRequest
 */
export const BuildRouteRequest = new BuildRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildRouteResponse$Type extends MessageType<BuildRouteResponse> {
    constructor() {
        super("routerrpc.BuildRouteResponse", [
            { no: 1, name: "route", kind: "message", T: () => Route }
        ]);
    }
    create(value?: PartialMessage<BuildRouteResponse>): BuildRouteResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuildRouteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildRouteResponse): BuildRouteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.Route route */ 1:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildRouteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.Route route = 1; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteResponse
 */
export const BuildRouteResponse = new BuildRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHtlcEventsRequest$Type extends MessageType<SubscribeHtlcEventsRequest> {
    constructor() {
        super("routerrpc.SubscribeHtlcEventsRequest", []);
    }
    create(value?: PartialMessage<SubscribeHtlcEventsRequest>): SubscribeHtlcEventsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHtlcEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHtlcEventsRequest): SubscribeHtlcEventsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHtlcEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribeHtlcEventsRequest
 */
export const SubscribeHtlcEventsRequest = new SubscribeHtlcEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HtlcEvent$Type extends MessageType<HtlcEvent> {
    constructor() {
        super("routerrpc.HtlcEvent", [
            { no: 1, name: "incoming_channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "outgoing_channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "incoming_htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "outgoing_htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "event_type", kind: "enum", T: () => ["routerrpc.HtlcEvent.EventType", HtlcEvent_EventType] },
            { no: 7, name: "forward_event", kind: "message", oneof: "event", T: () => ForwardEvent },
            { no: 8, name: "forward_fail_event", kind: "message", oneof: "event", T: () => ForwardFailEvent },
            { no: 9, name: "settle_event", kind: "message", oneof: "event", T: () => SettleEvent },
            { no: 10, name: "link_fail_event", kind: "message", oneof: "event", T: () => LinkFailEvent },
            { no: 11, name: "subscribed_event", kind: "message", oneof: "event", T: () => SubscribedEvent },
            { no: 12, name: "final_htlc_event", kind: "message", oneof: "event", T: () => FinalHtlcEvent }
        ]);
    }
    create(value?: PartialMessage<HtlcEvent>): HtlcEvent {
        const message = { incomingChannelId: 0n, outgoingChannelId: 0n, incomingHtlcId: 0n, outgoingHtlcId: 0n, timestampNs: 0n, eventType: 0, event: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HtlcEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HtlcEvent): HtlcEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 incoming_channel_id */ 1:
                    message.incomingChannelId = reader.uint64().toBigInt();
                    break;
                case /* uint64 outgoing_channel_id */ 2:
                    message.outgoingChannelId = reader.uint64().toBigInt();
                    break;
                case /* uint64 incoming_htlc_id */ 3:
                    message.incomingHtlcId = reader.uint64().toBigInt();
                    break;
                case /* uint64 outgoing_htlc_id */ 4:
                    message.outgoingHtlcId = reader.uint64().toBigInt();
                    break;
                case /* uint64 timestamp_ns */ 5:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                case /* routerrpc.HtlcEvent.EventType event_type */ 6:
                    message.eventType = reader.int32();
                    break;
                case /* routerrpc.ForwardEvent forward_event */ 7:
                    message.event = {
                        oneofKind: "forwardEvent",
                        forwardEvent: ForwardEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).forwardEvent)
                    };
                    break;
                case /* routerrpc.ForwardFailEvent forward_fail_event */ 8:
                    message.event = {
                        oneofKind: "forwardFailEvent",
                        forwardFailEvent: ForwardFailEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).forwardFailEvent)
                    };
                    break;
                case /* routerrpc.SettleEvent settle_event */ 9:
                    message.event = {
                        oneofKind: "settleEvent",
                        settleEvent: SettleEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).settleEvent)
                    };
                    break;
                case /* routerrpc.LinkFailEvent link_fail_event */ 10:
                    message.event = {
                        oneofKind: "linkFailEvent",
                        linkFailEvent: LinkFailEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).linkFailEvent)
                    };
                    break;
                case /* routerrpc.SubscribedEvent subscribed_event */ 11:
                    message.event = {
                        oneofKind: "subscribedEvent",
                        subscribedEvent: SubscribedEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).subscribedEvent)
                    };
                    break;
                case /* routerrpc.FinalHtlcEvent final_htlc_event */ 12:
                    message.event = {
                        oneofKind: "finalHtlcEvent",
                        finalHtlcEvent: FinalHtlcEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).finalHtlcEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HtlcEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 incoming_channel_id = 1; */
        if (message.incomingChannelId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.incomingChannelId);
        /* uint64 outgoing_channel_id = 2; */
        if (message.outgoingChannelId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.outgoingChannelId);
        /* uint64 incoming_htlc_id = 3; */
        if (message.incomingHtlcId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.incomingHtlcId);
        /* uint64 outgoing_htlc_id = 4; */
        if (message.outgoingHtlcId !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.outgoingHtlcId);
        /* uint64 timestamp_ns = 5; */
        if (message.timestampNs !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.timestampNs);
        /* routerrpc.HtlcEvent.EventType event_type = 6; */
        if (message.eventType !== 0)
            writer.tag(6, WireType.Varint).int32(message.eventType);
        /* routerrpc.ForwardEvent forward_event = 7; */
        if (message.event.oneofKind === "forwardEvent")
            ForwardEvent.internalBinaryWrite(message.event.forwardEvent, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ForwardFailEvent forward_fail_event = 8; */
        if (message.event.oneofKind === "forwardFailEvent")
            ForwardFailEvent.internalBinaryWrite(message.event.forwardFailEvent, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.SettleEvent settle_event = 9; */
        if (message.event.oneofKind === "settleEvent")
            SettleEvent.internalBinaryWrite(message.event.settleEvent, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.LinkFailEvent link_fail_event = 10; */
        if (message.event.oneofKind === "linkFailEvent")
            LinkFailEvent.internalBinaryWrite(message.event.linkFailEvent, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.SubscribedEvent subscribed_event = 11; */
        if (message.event.oneofKind === "subscribedEvent")
            SubscribedEvent.internalBinaryWrite(message.event.subscribedEvent, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.FinalHtlcEvent final_htlc_event = 12; */
        if (message.event.oneofKind === "finalHtlcEvent")
            FinalHtlcEvent.internalBinaryWrite(message.event.finalHtlcEvent, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcEvent
 */
export const HtlcEvent = new HtlcEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HtlcInfo$Type extends MessageType<HtlcInfo> {
    constructor() {
        super("routerrpc.HtlcInfo", [
            { no: 1, name: "incoming_timelock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "outgoing_timelock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "incoming_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "outgoing_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HtlcInfo>): HtlcInfo {
        const message = { incomingTimelock: 0, outgoingTimelock: 0, incomingAmtMsat: 0n, outgoingAmtMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HtlcInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HtlcInfo): HtlcInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 incoming_timelock */ 1:
                    message.incomingTimelock = reader.uint32();
                    break;
                case /* uint32 outgoing_timelock */ 2:
                    message.outgoingTimelock = reader.uint32();
                    break;
                case /* uint64 incoming_amt_msat */ 3:
                    message.incomingAmtMsat = reader.uint64().toBigInt();
                    break;
                case /* uint64 outgoing_amt_msat */ 4:
                    message.outgoingAmtMsat = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HtlcInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 incoming_timelock = 1; */
        if (message.incomingTimelock !== 0)
            writer.tag(1, WireType.Varint).uint32(message.incomingTimelock);
        /* uint32 outgoing_timelock = 2; */
        if (message.outgoingTimelock !== 0)
            writer.tag(2, WireType.Varint).uint32(message.outgoingTimelock);
        /* uint64 incoming_amt_msat = 3; */
        if (message.incomingAmtMsat !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.incomingAmtMsat);
        /* uint64 outgoing_amt_msat = 4; */
        if (message.outgoingAmtMsat !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.outgoingAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcInfo
 */
export const HtlcInfo = new HtlcInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardEvent$Type extends MessageType<ForwardEvent> {
    constructor() {
        super("routerrpc.ForwardEvent", [
            { no: 1, name: "info", kind: "message", T: () => HtlcInfo }
        ]);
    }
    create(value?: PartialMessage<ForwardEvent>): ForwardEvent {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardEvent): ForwardEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.HtlcInfo info */ 1:
                    message.info = HtlcInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForwardEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.HtlcInfo info = 1; */
        if (message.info)
            HtlcInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardEvent
 */
export const ForwardEvent = new ForwardEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardFailEvent$Type extends MessageType<ForwardFailEvent> {
    constructor() {
        super("routerrpc.ForwardFailEvent", []);
    }
    create(value?: PartialMessage<ForwardFailEvent>): ForwardFailEvent {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardFailEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardFailEvent): ForwardFailEvent {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ForwardFailEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardFailEvent
 */
export const ForwardFailEvent = new ForwardFailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettleEvent$Type extends MessageType<SettleEvent> {
    constructor() {
        super("routerrpc.SettleEvent", [
            { no: 1, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SettleEvent>): SettleEvent {
        const message = { preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SettleEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettleEvent): SettleEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes preimage */ 1:
                    message.preimage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettleEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes preimage = 1; */
        if (message.preimage.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preimage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SettleEvent
 */
export const SettleEvent = new SettleEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalHtlcEvent$Type extends MessageType<FinalHtlcEvent> {
    constructor() {
        super("routerrpc.FinalHtlcEvent", [
            { no: 1, name: "settled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "offchain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FinalHtlcEvent>): FinalHtlcEvent {
        const message = { settled: false, offchain: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FinalHtlcEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalHtlcEvent): FinalHtlcEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool settled */ 1:
                    message.settled = reader.bool();
                    break;
                case /* bool offchain */ 2:
                    message.offchain = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinalHtlcEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool settled = 1; */
        if (message.settled !== false)
            writer.tag(1, WireType.Varint).bool(message.settled);
        /* bool offchain = 2; */
        if (message.offchain !== false)
            writer.tag(2, WireType.Varint).bool(message.offchain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.FinalHtlcEvent
 */
export const FinalHtlcEvent = new FinalHtlcEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribedEvent$Type extends MessageType<SubscribedEvent> {
    constructor() {
        super("routerrpc.SubscribedEvent", []);
    }
    create(value?: PartialMessage<SubscribedEvent>): SubscribedEvent {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribedEvent): SubscribedEvent {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribedEvent
 */
export const SubscribedEvent = new SubscribedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkFailEvent$Type extends MessageType<LinkFailEvent> {
    constructor() {
        super("routerrpc.LinkFailEvent", [
            { no: 1, name: "info", kind: "message", T: () => HtlcInfo },
            { no: 2, name: "wire_failure", kind: "enum", T: () => ["lnrpc.Failure.FailureCode", Failure_FailureCode] },
            { no: 3, name: "failure_detail", kind: "enum", T: () => ["routerrpc.FailureDetail", FailureDetail] },
            { no: 4, name: "failure_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LinkFailEvent>): LinkFailEvent {
        const message = { wireFailure: 0, failureDetail: 0, failureString: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LinkFailEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkFailEvent): LinkFailEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.HtlcInfo info */ 1:
                    message.info = HtlcInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* lnrpc.Failure.FailureCode wire_failure */ 2:
                    message.wireFailure = reader.int32();
                    break;
                case /* routerrpc.FailureDetail failure_detail */ 3:
                    message.failureDetail = reader.int32();
                    break;
                case /* string failure_string */ 4:
                    message.failureString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinkFailEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.HtlcInfo info = 1; */
        if (message.info)
            HtlcInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Failure.FailureCode wire_failure = 2; */
        if (message.wireFailure !== 0)
            writer.tag(2, WireType.Varint).int32(message.wireFailure);
        /* routerrpc.FailureDetail failure_detail = 3; */
        if (message.failureDetail !== 0)
            writer.tag(3, WireType.Varint).int32(message.failureDetail);
        /* string failure_string = 4; */
        if (message.failureString !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.failureString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.LinkFailEvent
 */
export const LinkFailEvent = new LinkFailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaymentStatus$Type extends MessageType<PaymentStatus> {
    constructor() {
        super("routerrpc.PaymentStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["routerrpc.PaymentState", PaymentState] },
            { no: 2, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HTLCAttempt }
        ]);
    }
    create(value?: PartialMessage<PaymentStatus>): PaymentStatus {
        const message = { state: 0, preimage: new Uint8Array(0), htlcs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PaymentStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaymentStatus): PaymentStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.PaymentState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* bytes preimage */ 2:
                    message.preimage = reader.bytes();
                    break;
                case /* repeated lnrpc.HTLCAttempt htlcs */ 4:
                    message.htlcs.push(HTLCAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaymentStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.PaymentState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* bytes preimage = 2; */
        if (message.preimage.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.preimage);
        /* repeated lnrpc.HTLCAttempt htlcs = 4; */
        for (let i = 0; i < message.htlcs.length; i++)
            HTLCAttempt.internalBinaryWrite(message.htlcs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.PaymentStatus
 */
export const PaymentStatus = new PaymentStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CircuitKey$Type extends MessageType<CircuitKey> {
    constructor() {
        super("routerrpc.CircuitKey", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "htlc_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CircuitKey>): CircuitKey {
        const message = { chanId: 0n, htlcId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CircuitKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CircuitKey): CircuitKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id */ 1:
                    message.chanId = reader.uint64().toBigInt();
                    break;
                case /* uint64 htlc_id */ 2:
                    message.htlcId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CircuitKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1; */
        if (message.chanId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* uint64 htlc_id = 2; */
        if (message.htlcId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.htlcId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.CircuitKey
 */
export const CircuitKey = new CircuitKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardHtlcInterceptRequest$Type extends MessageType<ForwardHtlcInterceptRequest> {
    constructor() {
        super("routerrpc.ForwardHtlcInterceptRequest", [
            { no: 1, name: "incoming_circuit_key", kind: "message", T: () => CircuitKey },
            { no: 5, name: "incoming_amount_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "incoming_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "outgoing_requested_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "outgoing_amount_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "outgoing_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 9, name: "onion_blob", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "auto_fail_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForwardHtlcInterceptRequest>): ForwardHtlcInterceptRequest {
        const message = { incomingAmountMsat: 0n, incomingExpiry: 0, paymentHash: new Uint8Array(0), outgoingRequestedChanId: 0n, outgoingAmountMsat: 0n, outgoingExpiry: 0, customRecords: {}, onionBlob: new Uint8Array(0), autoFailHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardHtlcInterceptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardHtlcInterceptRequest): ForwardHtlcInterceptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.CircuitKey incoming_circuit_key */ 1:
                    message.incomingCircuitKey = CircuitKey.internalBinaryRead(reader, reader.uint32(), options, message.incomingCircuitKey);
                    break;
                case /* uint64 incoming_amount_msat */ 5:
                    message.incomingAmountMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 incoming_expiry */ 6:
                    message.incomingExpiry = reader.uint32();
                    break;
                case /* bytes payment_hash */ 2:
                    message.paymentHash = reader.bytes();
                    break;
                case /* uint64 outgoing_requested_chan_id */ 7:
                    message.outgoingRequestedChanId = reader.uint64().toBigInt();
                    break;
                case /* uint64 outgoing_amount_msat */ 3:
                    message.outgoingAmountMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 outgoing_expiry */ 4:
                    message.outgoingExpiry = reader.uint32();
                    break;
                case /* map<uint64, bytes> custom_records */ 8:
                    this.binaryReadMap8(message.customRecords, reader, options);
                    break;
                case /* bytes onion_blob */ 9:
                    message.onionBlob = reader.bytes();
                    break;
                case /* int32 auto_fail_height */ 10:
                    message.autoFailHeight = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: ForwardHtlcInterceptRequest["customRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ForwardHtlcInterceptRequest["customRecords"] | undefined, val: ForwardHtlcInterceptRequest["customRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field routerrpc.ForwardHtlcInterceptRequest.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: ForwardHtlcInterceptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.CircuitKey incoming_circuit_key = 1; */
        if (message.incomingCircuitKey)
            CircuitKey.internalBinaryWrite(message.incomingCircuitKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 incoming_amount_msat = 5; */
        if (message.incomingAmountMsat !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.incomingAmountMsat);
        /* uint32 incoming_expiry = 6; */
        if (message.incomingExpiry !== 0)
            writer.tag(6, WireType.Varint).uint32(message.incomingExpiry);
        /* bytes payment_hash = 2; */
        if (message.paymentHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.paymentHash);
        /* uint64 outgoing_requested_chan_id = 7; */
        if (message.outgoingRequestedChanId !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.outgoingRequestedChanId);
        /* uint64 outgoing_amount_msat = 3; */
        if (message.outgoingAmountMsat !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.outgoingAmountMsat);
        /* uint32 outgoing_expiry = 4; */
        if (message.outgoingExpiry !== 0)
            writer.tag(4, WireType.Varint).uint32(message.outgoingExpiry);
        /* map<uint64, bytes> custom_records = 8; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        /* bytes onion_blob = 9; */
        if (message.onionBlob.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.onionBlob);
        /* int32 auto_fail_height = 10; */
        if (message.autoFailHeight !== 0)
            writer.tag(10, WireType.Varint).int32(message.autoFailHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptRequest
 */
export const ForwardHtlcInterceptRequest = new ForwardHtlcInterceptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardHtlcInterceptResponse$Type extends MessageType<ForwardHtlcInterceptResponse> {
    constructor() {
        super("routerrpc.ForwardHtlcInterceptResponse", [
            { no: 1, name: "incoming_circuit_key", kind: "message", T: () => CircuitKey },
            { no: 2, name: "action", kind: "enum", T: () => ["routerrpc.ResolveHoldForwardAction", ResolveHoldForwardAction] },
            { no: 3, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "failure_message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "failure_code", kind: "enum", T: () => ["lnrpc.Failure.FailureCode", Failure_FailureCode] }
        ]);
    }
    create(value?: PartialMessage<ForwardHtlcInterceptResponse>): ForwardHtlcInterceptResponse {
        const message = { action: 0, preimage: new Uint8Array(0), failureMessage: new Uint8Array(0), failureCode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardHtlcInterceptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardHtlcInterceptResponse): ForwardHtlcInterceptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routerrpc.CircuitKey incoming_circuit_key */ 1:
                    message.incomingCircuitKey = CircuitKey.internalBinaryRead(reader, reader.uint32(), options, message.incomingCircuitKey);
                    break;
                case /* routerrpc.ResolveHoldForwardAction action */ 2:
                    message.action = reader.int32();
                    break;
                case /* bytes preimage */ 3:
                    message.preimage = reader.bytes();
                    break;
                case /* bytes failure_message */ 4:
                    message.failureMessage = reader.bytes();
                    break;
                case /* lnrpc.Failure.FailureCode failure_code */ 5:
                    message.failureCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForwardHtlcInterceptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routerrpc.CircuitKey incoming_circuit_key = 1; */
        if (message.incomingCircuitKey)
            CircuitKey.internalBinaryWrite(message.incomingCircuitKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ResolveHoldForwardAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        /* bytes preimage = 3; */
        if (message.preimage.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.preimage);
        /* bytes failure_message = 4; */
        if (message.failureMessage.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.failureMessage);
        /* lnrpc.Failure.FailureCode failure_code = 5; */
        if (message.failureCode !== 0)
            writer.tag(5, WireType.Varint).int32(message.failureCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptResponse
 */
export const ForwardHtlcInterceptResponse = new ForwardHtlcInterceptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateChanStatusRequest$Type extends MessageType<UpdateChanStatusRequest> {
    constructor() {
        super("routerrpc.UpdateChanStatusRequest", [
            { no: 1, name: "chan_point", kind: "message", T: () => ChannelPoint },
            { no: 2, name: "action", kind: "enum", T: () => ["routerrpc.ChanStatusAction", ChanStatusAction] }
        ]);
    }
    create(value?: PartialMessage<UpdateChanStatusRequest>): UpdateChanStatusRequest {
        const message = { action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateChanStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateChanStatusRequest): UpdateChanStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint chan_point */ 1:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* routerrpc.ChanStatusAction action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateChanStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint chan_point = 1; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* routerrpc.ChanStatusAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusRequest
 */
export const UpdateChanStatusRequest = new UpdateChanStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateChanStatusResponse$Type extends MessageType<UpdateChanStatusResponse> {
    constructor() {
        super("routerrpc.UpdateChanStatusResponse", []);
    }
    create(value?: PartialMessage<UpdateChanStatusResponse>): UpdateChanStatusResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateChanStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateChanStatusResponse): UpdateChanStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateChanStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusResponse
 */
export const UpdateChanStatusResponse = new UpdateChanStatusResponse$Type();
/**
 * @generated ServiceType for protobuf service routerrpc.Router
 */
export const Router = new ServiceType("routerrpc.Router", [
    { name: "SendPaymentV2", serverStreaming: true, options: {}, I: SendPaymentRequest, O: Payment },
    { name: "TrackPaymentV2", serverStreaming: true, options: {}, I: TrackPaymentRequest, O: Payment },
    { name: "TrackPayments", serverStreaming: true, options: {}, I: TrackPaymentsRequest, O: Payment },
    { name: "EstimateRouteFee", options: {}, I: RouteFeeRequest, O: RouteFeeResponse },
    { name: "SendToRoute", options: {}, I: SendToRouteRequest, O: SendToRouteResponse },
    { name: "SendToRouteV2", options: {}, I: SendToRouteRequest, O: HTLCAttempt },
    { name: "ResetMissionControl", options: {}, I: ResetMissionControlRequest, O: ResetMissionControlResponse },
    { name: "QueryMissionControl", options: {}, I: QueryMissionControlRequest, O: QueryMissionControlResponse },
    { name: "XImportMissionControl", options: {}, I: XImportMissionControlRequest, O: XImportMissionControlResponse },
    { name: "GetMissionControlConfig", options: {}, I: GetMissionControlConfigRequest, O: GetMissionControlConfigResponse },
    { name: "SetMissionControlConfig", options: {}, I: SetMissionControlConfigRequest, O: SetMissionControlConfigResponse },
    { name: "QueryProbability", options: {}, I: QueryProbabilityRequest, O: QueryProbabilityResponse },
    { name: "BuildRoute", options: {}, I: BuildRouteRequest, O: BuildRouteResponse },
    { name: "SubscribeHtlcEvents", serverStreaming: true, options: {}, I: SubscribeHtlcEventsRequest, O: HtlcEvent },
    { name: "SendPayment", serverStreaming: true, options: {}, I: SendPaymentRequest, O: PaymentStatus },
    { name: "TrackPayment", serverStreaming: true, options: {}, I: TrackPaymentRequest, O: PaymentStatus },
    { name: "HtlcInterceptor", serverStreaming: true, clientStreaming: true, options: {}, I: ForwardHtlcInterceptResponse, O: ForwardHtlcInterceptRequest },
    { name: "UpdateChanStatus", options: {}, I: UpdateChanStatusRequest, O: UpdateChanStatusResponse }
]);
