// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "chainnotifier.proto" (package "chainrpc", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message chainrpc.ConfRequest
 */
export interface ConfRequest {
    /**
     *
     * The transaction hash for which we should request a confirmation notification
     * for. If set to a hash of all zeros, then the confirmation notification will
     * be requested for the script instead.
     *
     * @generated from protobuf field: bytes txid = 1;
     */
    txid: Uint8Array;
    /**
     *
     * An output script within a transaction with the hash above which will be used
     * by light clients to match block filters. If the transaction hash is set to a
     * hash of all zeros, then a confirmation notification will be requested for
     * this script instead.
     *
     * @generated from protobuf field: bytes script = 2;
     */
    script: Uint8Array;
    /**
     *
     * The number of desired confirmations the transaction/output script should
     * reach before dispatching a confirmation notification.
     *
     * @generated from protobuf field: uint32 num_confs = 3;
     */
    numConfs: number;
    /**
     *
     * The earliest height in the chain for which the transaction/output script
     * could have been included in a block. This should in most cases be set to the
     * broadcast height of the transaction/output script.
     *
     * @generated from protobuf field: uint32 height_hint = 4;
     */
    heightHint: number;
    /**
     *
     * If true, then the block that mines the specified txid/script will be
     * included in eventual the notification event.
     *
     * @generated from protobuf field: bool include_block = 5;
     */
    includeBlock: boolean;
}
/**
 * @generated from protobuf message chainrpc.ConfDetails
 */
export interface ConfDetails {
    /**
     * The raw bytes of the confirmed transaction.
     *
     * @generated from protobuf field: bytes raw_tx = 1;
     */
    rawTx: Uint8Array;
    /**
     * The hash of the block in which the confirmed transaction was included in.
     *
     * @generated from protobuf field: bytes block_hash = 2;
     */
    blockHash: Uint8Array;
    /**
     * The height of the block in which the confirmed transaction was included
     * in.
     *
     * @generated from protobuf field: uint32 block_height = 3;
     */
    blockHeight: number;
    /**
     * The index of the confirmed transaction within the block.
     *
     * @generated from protobuf field: uint32 tx_index = 4;
     */
    txIndex: number;
    /**
     *
     * The raw bytes of the block that mined the transaction. Only included if
     * include_block was set in the request.
     *
     * @generated from protobuf field: bytes raw_block = 5;
     */
    rawBlock: Uint8Array;
}
/**
 * TODO(wilmer): need to know how the client will use this first.
 *
 * @generated from protobuf message chainrpc.Reorg
 */
export interface Reorg {
}
/**
 * @generated from protobuf message chainrpc.ConfEvent
 */
export interface ConfEvent {
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "conf";
        /**
         *
         * An event that includes the confirmation details of the request
         * (txid/ouput script).
         *
         * @generated from protobuf field: chainrpc.ConfDetails conf = 1;
         */
        conf: ConfDetails;
    } | {
        oneofKind: "reorg";
        /**
         *
         * An event send when the transaction of the request is reorged out of the
         * chain.
         *
         * @generated from protobuf field: chainrpc.Reorg reorg = 2;
         */
        reorg: Reorg;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message chainrpc.Outpoint
 */
export interface Outpoint {
    /**
     * The hash of the transaction.
     *
     * @generated from protobuf field: bytes hash = 1;
     */
    hash: Uint8Array;
    /**
     * The index of the output within the transaction.
     *
     * @generated from protobuf field: uint32 index = 2;
     */
    index: number;
}
/**
 * @generated from protobuf message chainrpc.SpendRequest
 */
export interface SpendRequest {
    /**
     *
     * The outpoint for which we should request a spend notification for. If set to
     * a zero outpoint, then the spend notification will be requested for the
     * script instead. A zero or nil outpoint is not supported for Taproot spends
     * because the output script cannot reliably be computed from the witness alone
     * and the spent output script is not always available in the rescan context.
     * So an outpoint must _always_ be specified when registering a spend
     * notification for a Taproot output.
     *
     * @generated from protobuf field: chainrpc.Outpoint outpoint = 1;
     */
    outpoint?: Outpoint;
    /**
     *
     * The output script for the outpoint above. This will be used by light clients
     * to match block filters. If the outpoint is set to a zero outpoint, then a
     * spend notification will be requested for this script instead.
     *
     * @generated from protobuf field: bytes script = 2;
     */
    script: Uint8Array;
    /**
     *
     * The earliest height in the chain for which the outpoint/output script could
     * have been spent. This should in most cases be set to the broadcast height of
     * the outpoint/output script.
     *
     * @generated from protobuf field: uint32 height_hint = 3;
     */
    heightHint: number;
}
/**
 * @generated from protobuf message chainrpc.SpendDetails
 */
export interface SpendDetails {
    /**
     * The outpoint was that spent.
     *
     * @generated from protobuf field: chainrpc.Outpoint spending_outpoint = 1;
     */
    spendingOutpoint?: Outpoint;
    /**
     * The raw bytes of the spending transaction.
     *
     * @generated from protobuf field: bytes raw_spending_tx = 2;
     */
    rawSpendingTx: Uint8Array;
    /**
     * The hash of the spending transaction.
     *
     * @generated from protobuf field: bytes spending_tx_hash = 3;
     */
    spendingTxHash: Uint8Array;
    /**
     * The input of the spending transaction that fulfilled the spend request.
     *
     * @generated from protobuf field: uint32 spending_input_index = 4;
     */
    spendingInputIndex: number;
    /**
     * The height at which the spending transaction was included in a block.
     *
     * @generated from protobuf field: uint32 spending_height = 5;
     */
    spendingHeight: number;
}
/**
 * @generated from protobuf message chainrpc.SpendEvent
 */
export interface SpendEvent {
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "spend";
        /**
         *
         * An event that includes the details of the spending transaction of the
         * request (outpoint/output script).
         *
         * @generated from protobuf field: chainrpc.SpendDetails spend = 1;
         */
        spend: SpendDetails;
    } | {
        oneofKind: "reorg";
        /**
         *
         * An event sent when the spending transaction of the request was
         * reorged out of the chain.
         *
         * @generated from protobuf field: chainrpc.Reorg reorg = 2;
         */
        reorg: Reorg;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message chainrpc.BlockEpoch
 */
export interface BlockEpoch {
    /**
     * The hash of the block.
     *
     * @generated from protobuf field: bytes hash = 1;
     */
    hash: Uint8Array;
    /**
     * The height of the block.
     *
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class ConfRequest$Type extends MessageType<ConfRequest> {
    constructor() {
        super("chainrpc.ConfRequest", [
            { no: 1, name: "txid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "num_confs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "height_hint", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "include_block", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ConfRequest>): ConfRequest {
        const message = { txid: new Uint8Array(0), script: new Uint8Array(0), numConfs: 0, heightHint: 0, includeBlock: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfRequest): ConfRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes txid */ 1:
                    message.txid = reader.bytes();
                    break;
                case /* bytes script */ 2:
                    message.script = reader.bytes();
                    break;
                case /* uint32 num_confs */ 3:
                    message.numConfs = reader.uint32();
                    break;
                case /* uint32 height_hint */ 4:
                    message.heightHint = reader.uint32();
                    break;
                case /* bool include_block */ 5:
                    message.includeBlock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes txid = 1; */
        if (message.txid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txid);
        /* bytes script = 2; */
        if (message.script.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.script);
        /* uint32 num_confs = 3; */
        if (message.numConfs !== 0)
            writer.tag(3, WireType.Varint).uint32(message.numConfs);
        /* uint32 height_hint = 4; */
        if (message.heightHint !== 0)
            writer.tag(4, WireType.Varint).uint32(message.heightHint);
        /* bool include_block = 5; */
        if (message.includeBlock !== false)
            writer.tag(5, WireType.Varint).bool(message.includeBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.ConfRequest
 */
export const ConfRequest = new ConfRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfDetails$Type extends MessageType<ConfDetails> {
    constructor() {
        super("chainrpc.ConfDetails", [
            { no: 1, name: "raw_tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "block_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "block_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tx_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "raw_block", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ConfDetails>): ConfDetails {
        const message = { rawTx: new Uint8Array(0), blockHash: new Uint8Array(0), blockHeight: 0, txIndex: 0, rawBlock: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfDetails): ConfDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes raw_tx */ 1:
                    message.rawTx = reader.bytes();
                    break;
                case /* bytes block_hash */ 2:
                    message.blockHash = reader.bytes();
                    break;
                case /* uint32 block_height */ 3:
                    message.blockHeight = reader.uint32();
                    break;
                case /* uint32 tx_index */ 4:
                    message.txIndex = reader.uint32();
                    break;
                case /* bytes raw_block */ 5:
                    message.rawBlock = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes raw_tx = 1; */
        if (message.rawTx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rawTx);
        /* bytes block_hash = 2; */
        if (message.blockHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.blockHash);
        /* uint32 block_height = 3; */
        if (message.blockHeight !== 0)
            writer.tag(3, WireType.Varint).uint32(message.blockHeight);
        /* uint32 tx_index = 4; */
        if (message.txIndex !== 0)
            writer.tag(4, WireType.Varint).uint32(message.txIndex);
        /* bytes raw_block = 5; */
        if (message.rawBlock.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.rawBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.ConfDetails
 */
export const ConfDetails = new ConfDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reorg$Type extends MessageType<Reorg> {
    constructor() {
        super("chainrpc.Reorg", []);
    }
    create(value?: PartialMessage<Reorg>): Reorg {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Reorg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reorg): Reorg {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Reorg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.Reorg
 */
export const Reorg = new Reorg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfEvent$Type extends MessageType<ConfEvent> {
    constructor() {
        super("chainrpc.ConfEvent", [
            { no: 1, name: "conf", kind: "message", oneof: "event", T: () => ConfDetails },
            { no: 2, name: "reorg", kind: "message", oneof: "event", T: () => Reorg }
        ]);
    }
    create(value?: PartialMessage<ConfEvent>): ConfEvent {
        const message = { event: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfEvent): ConfEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chainrpc.ConfDetails conf */ 1:
                    message.event = {
                        oneofKind: "conf",
                        conf: ConfDetails.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).conf)
                    };
                    break;
                case /* chainrpc.Reorg reorg */ 2:
                    message.event = {
                        oneofKind: "reorg",
                        reorg: Reorg.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).reorg)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chainrpc.ConfDetails conf = 1; */
        if (message.event.oneofKind === "conf")
            ConfDetails.internalBinaryWrite(message.event.conf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* chainrpc.Reorg reorg = 2; */
        if (message.event.oneofKind === "reorg")
            Reorg.internalBinaryWrite(message.event.reorg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.ConfEvent
 */
export const ConfEvent = new ConfEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Outpoint$Type extends MessageType<Outpoint> {
    constructor() {
        super("chainrpc.Outpoint", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Outpoint>): Outpoint {
        const message = { hash: new Uint8Array(0), index: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Outpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Outpoint): Outpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* uint32 index */ 2:
                    message.index = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Outpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* uint32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.Outpoint
 */
export const Outpoint = new Outpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpendRequest$Type extends MessageType<SpendRequest> {
    constructor() {
        super("chainrpc.SpendRequest", [
            { no: 1, name: "outpoint", kind: "message", T: () => Outpoint },
            { no: 2, name: "script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "height_hint", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpendRequest>): SpendRequest {
        const message = { script: new Uint8Array(0), heightHint: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpendRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpendRequest): SpendRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chainrpc.Outpoint outpoint */ 1:
                    message.outpoint = Outpoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* bytes script */ 2:
                    message.script = reader.bytes();
                    break;
                case /* uint32 height_hint */ 3:
                    message.heightHint = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpendRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chainrpc.Outpoint outpoint = 1; */
        if (message.outpoint)
            Outpoint.internalBinaryWrite(message.outpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes script = 2; */
        if (message.script.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.script);
        /* uint32 height_hint = 3; */
        if (message.heightHint !== 0)
            writer.tag(3, WireType.Varint).uint32(message.heightHint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.SpendRequest
 */
export const SpendRequest = new SpendRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpendDetails$Type extends MessageType<SpendDetails> {
    constructor() {
        super("chainrpc.SpendDetails", [
            { no: 1, name: "spending_outpoint", kind: "message", T: () => Outpoint },
            { no: 2, name: "raw_spending_tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "spending_tx_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "spending_input_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "spending_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpendDetails>): SpendDetails {
        const message = { rawSpendingTx: new Uint8Array(0), spendingTxHash: new Uint8Array(0), spendingInputIndex: 0, spendingHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpendDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpendDetails): SpendDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chainrpc.Outpoint spending_outpoint */ 1:
                    message.spendingOutpoint = Outpoint.internalBinaryRead(reader, reader.uint32(), options, message.spendingOutpoint);
                    break;
                case /* bytes raw_spending_tx */ 2:
                    message.rawSpendingTx = reader.bytes();
                    break;
                case /* bytes spending_tx_hash */ 3:
                    message.spendingTxHash = reader.bytes();
                    break;
                case /* uint32 spending_input_index */ 4:
                    message.spendingInputIndex = reader.uint32();
                    break;
                case /* uint32 spending_height */ 5:
                    message.spendingHeight = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpendDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chainrpc.Outpoint spending_outpoint = 1; */
        if (message.spendingOutpoint)
            Outpoint.internalBinaryWrite(message.spendingOutpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes raw_spending_tx = 2; */
        if (message.rawSpendingTx.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rawSpendingTx);
        /* bytes spending_tx_hash = 3; */
        if (message.spendingTxHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.spendingTxHash);
        /* uint32 spending_input_index = 4; */
        if (message.spendingInputIndex !== 0)
            writer.tag(4, WireType.Varint).uint32(message.spendingInputIndex);
        /* uint32 spending_height = 5; */
        if (message.spendingHeight !== 0)
            writer.tag(5, WireType.Varint).uint32(message.spendingHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.SpendDetails
 */
export const SpendDetails = new SpendDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpendEvent$Type extends MessageType<SpendEvent> {
    constructor() {
        super("chainrpc.SpendEvent", [
            { no: 1, name: "spend", kind: "message", oneof: "event", T: () => SpendDetails },
            { no: 2, name: "reorg", kind: "message", oneof: "event", T: () => Reorg }
        ]);
    }
    create(value?: PartialMessage<SpendEvent>): SpendEvent {
        const message = { event: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpendEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpendEvent): SpendEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chainrpc.SpendDetails spend */ 1:
                    message.event = {
                        oneofKind: "spend",
                        spend: SpendDetails.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).spend)
                    };
                    break;
                case /* chainrpc.Reorg reorg */ 2:
                    message.event = {
                        oneofKind: "reorg",
                        reorg: Reorg.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).reorg)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpendEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chainrpc.SpendDetails spend = 1; */
        if (message.event.oneofKind === "spend")
            SpendDetails.internalBinaryWrite(message.event.spend, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* chainrpc.Reorg reorg = 2; */
        if (message.event.oneofKind === "reorg")
            Reorg.internalBinaryWrite(message.event.reorg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.SpendEvent
 */
export const SpendEvent = new SpendEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockEpoch$Type extends MessageType<BlockEpoch> {
    constructor() {
        super("chainrpc.BlockEpoch", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlockEpoch>): BlockEpoch {
        const message = { hash: new Uint8Array(0), height: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockEpoch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockEpoch): BlockEpoch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockEpoch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chainrpc.BlockEpoch
 */
export const BlockEpoch = new BlockEpoch$Type();
/**
 * @generated ServiceType for protobuf service chainrpc.ChainNotifier
 */
export const ChainNotifier = new ServiceType("chainrpc.ChainNotifier", [
    { name: "RegisterConfirmationsNtfn", serverStreaming: true, options: {}, I: ConfRequest, O: ConfEvent },
    { name: "RegisterSpendNtfn", serverStreaming: true, options: {}, I: SpendRequest, O: SpendEvent },
    { name: "RegisterBlockEpochNtfn", serverStreaming: true, options: {}, I: BlockEpoch, O: BlockEpoch }
]);
