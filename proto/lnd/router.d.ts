// @generated by protobuf-ts 2.8.1 with parameter long_type_number,output_javascript
// @generated from protobuf file "router.proto" (package "routerrpc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ChannelPoint } from "./lightning";
import { HTLCAttempt } from "./lightning";
import { Failure_FailureCode } from "./lightning";
import { Failure } from "./lightning";
import { Route } from "./lightning";
import { FeatureBit } from "./lightning";
import { RouteHint } from "./lightning";
/**
 * @generated from protobuf message routerrpc.SendPaymentRequest
 */
export interface SendPaymentRequest {
    /**
     * The identity pubkey of the payment recipient
     *
     * @generated from protobuf field: bytes dest = 1;
     */
    dest: Uint8Array;
    /**
     *
     * Number of satoshis to send.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt = 2;
     */
    amt: number;
    /**
     *
     * Number of millisatoshis to send.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt_msat = 12;
     */
    amtMsat: number;
    /**
     * The hash to use within the payment's HTLC
     *
     * @generated from protobuf field: bytes payment_hash = 3;
     */
    paymentHash: Uint8Array;
    /**
     *
     * The CLTV delta from the current height that should be used to set the
     * timelock for the final hop.
     *
     * @generated from protobuf field: int32 final_cltv_delta = 4;
     */
    finalCltvDelta: number;
    /**
     * An optional payment addr to be included within the last hop of the route.
     *
     * @generated from protobuf field: bytes payment_addr = 20;
     */
    paymentAddr: Uint8Array;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network.  With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient. The amount in the payment request may be zero. In
     * that case it is required to set the amt field as well. If no payment request
     * is specified, the following fields are required: dest, amt and payment_hash.
     *
     * @generated from protobuf field: string payment_request = 5;
     */
    paymentRequest: string;
    /**
     *
     * An upper limit on the amount of time we should spend when attempting to
     * fulfill the payment. This is expressed in seconds. If we cannot make a
     * successful payment within this time frame, an error will be returned.
     * This field must be non-zero.
     *
     * @generated from protobuf field: int32 timeout_seconds = 6;
     */
    timeoutSeconds: number;
    /**
     *
     * The maximum number of satoshis that will be paid as a fee of the payment.
     * If this field is left to the default value of 0, only zero-fee routes will
     * be considered. This usually means single hop routes connecting directly to
     * the destination. To send the payment without a fee limit, use max int here.
     *
     * The fields fee_limit_sat and fee_limit_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 fee_limit_sat = 7;
     */
    feeLimitSat: number;
    /**
     *
     * The maximum number of millisatoshis that will be paid as a fee of the
     * payment. If this field is left to the default value of 0, only zero-fee
     * routes will be considered. This usually means single hop routes connecting
     * directly to the destination. To send the payment without a fee limit, use
     * max int here.
     *
     * The fields fee_limit_sat and fee_limit_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 fee_limit_msat = 13;
     */
    feeLimitMsat: number;
    /**
     *
     * Deprecated, use outgoing_chan_ids. The channel id of the channel that must
     * be taken to the first hop. If zero, any channel may be used (unless
     * outgoing_chan_ids are set).
     *
     * @deprecated
     * @generated from protobuf field: uint64 outgoing_chan_id = 8 [deprecated = true, jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * The channel ids of the channels are allowed for the first hop. If empty,
     * any channel may be used.
     *
     * @generated from protobuf field: repeated uint64 outgoing_chan_ids = 19;
     */
    outgoingChanIds: number[];
    /**
     *
     * The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @generated from protobuf field: bytes last_hop_pubkey = 14;
     */
    lastHopPubkey: Uint8Array;
    /**
     *
     * An optional maximum total time lock for the route. This should not exceed
     * lnd's `--max-cltv-expiry` setting. If zero, then the value of
     * `--max-cltv-expiry` is enforced.
     *
     * @generated from protobuf field: int32 cltv_limit = 9;
     */
    cltvLimit: number;
    /**
     *
     * Optional route hints to reach the destination through private channels.
     *
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 10;
     */
    routeHints: RouteHint[];
    /**
     *
     * An optional field that can be used to pass an arbitrary set of TLV records
     * to a peer which understands the new records. This can be used to pass
     * application specific data during the payment attempt. Record types are
     * required to be in the custom range >= 65536. When using REST, the values
     * must be encoded as base64.
     *
     * @generated from protobuf field: map<uint64, bytes> dest_custom_records = 11;
     */
    destCustomRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * If set, circular payments to self are permitted.
     *
     * @generated from protobuf field: bool allow_self_payment = 15;
     */
    allowSelfPayment: boolean;
    /**
     *
     * Features assumed to be supported by the final node. All transitive feature
     * dependencies must also be set properly. For a given feature bit pair, either
     * optional or remote may be set, but not both. If this field is nil or empty,
     * the router will try to load destination features from the graph as a
     * fallback.
     *
     * @generated from protobuf field: repeated lnrpc.FeatureBit dest_features = 16;
     */
    destFeatures: FeatureBit[];
    /**
     *
     * The maximum number of partial payments that may be use to complete the full
     * amount.
     *
     * @generated from protobuf field: uint32 max_parts = 17;
     */
    maxParts: number;
    /**
     *
     * If set, only the final payment update is streamed back. Intermediate updates
     * that show which htlcs are still in flight are suppressed.
     *
     * @generated from protobuf field: bool no_inflight_updates = 18;
     */
    noInflightUpdates: boolean;
    /**
     *
     * The largest payment split that should be attempted when making a payment if
     * splitting is necessary. Setting this value will effectively cause lnd to
     * split more aggressively, vs only when it thinks it needs to. Note that this
     * value is in milli-satoshis.
     *
     * @generated from protobuf field: uint64 max_shard_size_msat = 21;
     */
    maxShardSizeMsat: number;
    /**
     *
     * If set, an AMP-payment will be attempted.
     *
     * @generated from protobuf field: bool amp = 22;
     */
    amp: boolean;
    /**
     *
     * The time preference for this payment. Set to -1 to optimize for fees
     * only, to 1 to optimize for reliability only or a value inbetween for a mix.
     *
     * @generated from protobuf field: double time_pref = 23;
     */
    timePref: number;
}
/**
 * @generated from protobuf message routerrpc.TrackPaymentRequest
 */
export interface TrackPaymentRequest {
    /**
     * The hash of the payment to look up.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     *
     * If set, only the final payment update is streamed back. Intermediate updates
     * that show which htlcs are still in flight are suppressed.
     *
     * @generated from protobuf field: bool no_inflight_updates = 2;
     */
    noInflightUpdates: boolean;
}
/**
 * @generated from protobuf message routerrpc.TrackPaymentsRequest
 */
export interface TrackPaymentsRequest {
    /**
     *
     * If set, only the final payment updates are streamed back. Intermediate
     * updates that show which htlcs are still in flight are suppressed.
     *
     * @generated from protobuf field: bool no_inflight_updates = 1;
     */
    noInflightUpdates: boolean;
}
/**
 * @generated from protobuf message routerrpc.RouteFeeRequest
 */
export interface RouteFeeRequest {
    /**
     *
     * The destination once wishes to obtain a routing fee quote to.
     *
     * @generated from protobuf field: bytes dest = 1;
     */
    dest: Uint8Array;
    /**
     *
     * The amount one wishes to send to the target destination.
     *
     * @generated from protobuf field: int64 amt_sat = 2;
     */
    amtSat: number;
}
/**
 * @generated from protobuf message routerrpc.RouteFeeResponse
 */
export interface RouteFeeResponse {
    /**
     *
     * A lower bound of the estimated fee to the target destination within the
     * network, expressed in milli-satoshis.
     *
     * @generated from protobuf field: int64 routing_fee_msat = 1;
     */
    routingFeeMsat: number;
    /**
     *
     * An estimate of the worst case time delay that can occur. Note that callers
     * will still need to factor in the final CLTV delta of the last hop into this
     * value.
     *
     * @generated from protobuf field: int64 time_lock_delay = 2;
     */
    timeLockDelay: number;
}
/**
 * @generated from protobuf message routerrpc.SendToRouteRequest
 */
export interface SendToRouteRequest {
    /**
     * The payment hash to use for the HTLC.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     * Route that should be used to attempt to complete the payment.
     *
     * @generated from protobuf field: lnrpc.Route route = 2;
     */
    route?: Route;
    /**
     *
     * Whether the payment should be marked as failed when a temporary error is
     * returned from the given route. Set it to true so the payment won't be
     * failed unless a terminal error is occurred, such as payment timeout, no
     * routes, incorrect payment details, or insufficient funds.
     *
     * @generated from protobuf field: bool skip_temp_err = 3;
     */
    skipTempErr: boolean;
}
/**
 * @generated from protobuf message routerrpc.SendToRouteResponse
 */
export interface SendToRouteResponse {
    /**
     * The preimage obtained by making the payment.
     *
     * @generated from protobuf field: bytes preimage = 1;
     */
    preimage: Uint8Array;
    /**
     * The failure message in case the payment failed.
     *
     * @generated from protobuf field: lnrpc.Failure failure = 2;
     */
    failure?: Failure;
}
/**
 * @generated from protobuf message routerrpc.ResetMissionControlRequest
 */
export interface ResetMissionControlRequest {
}
/**
 * @generated from protobuf message routerrpc.ResetMissionControlResponse
 */
export interface ResetMissionControlResponse {
}
/**
 * @generated from protobuf message routerrpc.QueryMissionControlRequest
 */
export interface QueryMissionControlRequest {
}
/**
 * QueryMissionControlResponse contains mission control state.
 *
 * @generated from protobuf message routerrpc.QueryMissionControlResponse
 */
export interface QueryMissionControlResponse {
    /**
     * Node pair-level mission control state.
     *
     * @generated from protobuf field: repeated routerrpc.PairHistory pairs = 2;
     */
    pairs: PairHistory[];
}
/**
 * @generated from protobuf message routerrpc.XImportMissionControlRequest
 */
export interface XImportMissionControlRequest {
    /**
     * Node pair-level mission control state to be imported.
     *
     * @generated from protobuf field: repeated routerrpc.PairHistory pairs = 1;
     */
    pairs: PairHistory[];
    /**
     * Whether to force override MC pair history. Note that even with force
     * override the failure pair is imported before the success pair and both
     * still clamp existing failure/success amounts.
     *
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean;
}
/**
 * @generated from protobuf message routerrpc.XImportMissionControlResponse
 */
export interface XImportMissionControlResponse {
}
/**
 * PairHistory contains the mission control state for a particular node pair.
 *
 * @generated from protobuf message routerrpc.PairHistory
 */
export interface PairHistory {
    /**
     * The source node pubkey of the pair.
     *
     * @generated from protobuf field: bytes node_from = 1;
     */
    nodeFrom: Uint8Array;
    /**
     * The destination node pubkey of the pair.
     *
     * @generated from protobuf field: bytes node_to = 2;
     */
    nodeTo: Uint8Array;
    /**
     * @generated from protobuf field: routerrpc.PairData history = 7;
     */
    history?: PairData;
}
/**
 * @generated from protobuf message routerrpc.PairData
 */
export interface PairData {
    /**
     * Time of last failure.
     *
     * @generated from protobuf field: int64 fail_time = 1;
     */
    failTime: number;
    /**
     *
     * Lowest amount that failed to forward rounded to whole sats. This may be
     * set to zero if the failure is independent of amount.
     *
     * @generated from protobuf field: int64 fail_amt_sat = 2;
     */
    failAmtSat: number;
    /**
     *
     * Lowest amount that failed to forward in millisats. This may be
     * set to zero if the failure is independent of amount.
     *
     * @generated from protobuf field: int64 fail_amt_msat = 4;
     */
    failAmtMsat: number;
    /**
     * Time of last success.
     *
     * @generated from protobuf field: int64 success_time = 5;
     */
    successTime: number;
    /**
     * Highest amount that we could successfully forward rounded to whole sats.
     *
     * @generated from protobuf field: int64 success_amt_sat = 6;
     */
    successAmtSat: number;
    /**
     * Highest amount that we could successfully forward in millisats.
     *
     * @generated from protobuf field: int64 success_amt_msat = 7;
     */
    successAmtMsat: number;
}
/**
 * @generated from protobuf message routerrpc.GetMissionControlConfigRequest
 */
export interface GetMissionControlConfigRequest {
}
/**
 * @generated from protobuf message routerrpc.GetMissionControlConfigResponse
 */
export interface GetMissionControlConfigResponse {
    /**
     *
     * Mission control's currently active config.
     *
     * @generated from protobuf field: routerrpc.MissionControlConfig config = 1;
     */
    config?: MissionControlConfig;
}
/**
 * @generated from protobuf message routerrpc.SetMissionControlConfigRequest
 */
export interface SetMissionControlConfigRequest {
    /**
     *
     * The config to set for mission control. Note that all values *must* be set,
     * because the full config will be applied.
     *
     * @generated from protobuf field: routerrpc.MissionControlConfig config = 1;
     */
    config?: MissionControlConfig;
}
/**
 * @generated from protobuf message routerrpc.SetMissionControlConfigResponse
 */
export interface SetMissionControlConfigResponse {
}
/**
 * @generated from protobuf message routerrpc.MissionControlConfig
 */
export interface MissionControlConfig {
    /**
     *
     * The amount of time mission control will take to restore a penalized node
     * or channel back to 50% success probability, expressed in seconds. Setting
     * this value to a higher value will penalize failures for longer, making
     * mission control less likely to route through nodes and channels that we
     * have previously recorded failures for.
     *
     * @generated from protobuf field: uint64 half_life_seconds = 1;
     */
    halfLifeSeconds: number;
    /**
     *
     * The probability of success mission control should assign to hop in a route
     * where it has no other information available. Higher values will make mission
     * control more willing to try hops that we have no information about, lower
     * values will discourage trying these hops.
     *
     * @generated from protobuf field: float hop_probability = 2;
     */
    hopProbability: number;
    /**
     *
     * The importance that mission control should place on historical results,
     * expressed as a value in [0;1]. Setting this value to 1 will ignore all
     * historical payments and just use the hop probability to assess the
     * probability of success for each hop. A zero value ignores hop probability
     * completely and relies entirely on historical results, unless none are
     * available.
     *
     * @generated from protobuf field: float weight = 3;
     */
    weight: number;
    /**
     *
     * The maximum number of payment results that mission control will store.
     *
     * @generated from protobuf field: uint32 maximum_payment_results = 4;
     */
    maximumPaymentResults: number;
    /**
     *
     * The minimum time that must have passed since the previously recorded failure
     * before we raise the failure amount.
     *
     * @generated from protobuf field: uint64 minimum_failure_relax_interval = 5;
     */
    minimumFailureRelaxInterval: number;
}
/**
 * @generated from protobuf message routerrpc.QueryProbabilityRequest
 */
export interface QueryProbabilityRequest {
    /**
     * The source node pubkey of the pair.
     *
     * @generated from protobuf field: bytes from_node = 1;
     */
    fromNode: Uint8Array;
    /**
     * The destination node pubkey of the pair.
     *
     * @generated from protobuf field: bytes to_node = 2;
     */
    toNode: Uint8Array;
    /**
     * The amount for which to calculate a probability.
     *
     * @generated from protobuf field: int64 amt_msat = 3;
     */
    amtMsat: number;
}
/**
 * @generated from protobuf message routerrpc.QueryProbabilityResponse
 */
export interface QueryProbabilityResponse {
    /**
     * The success probability for the requested pair.
     *
     * @generated from protobuf field: double probability = 1;
     */
    probability: number;
    /**
     * The historical data for the requested pair.
     *
     * @generated from protobuf field: routerrpc.PairData history = 2;
     */
    history?: PairData;
}
/**
 * @generated from protobuf message routerrpc.BuildRouteRequest
 */
export interface BuildRouteRequest {
    /**
     *
     * The amount to send expressed in msat. If set to zero, the minimum routable
     * amount is used.
     *
     * @generated from protobuf field: int64 amt_msat = 1;
     */
    amtMsat: number;
    /**
     *
     * CLTV delta from the current height that should be used for the timelock
     * of the final hop
     *
     * @generated from protobuf field: int32 final_cltv_delta = 2;
     */
    finalCltvDelta: number;
    /**
     *
     * The channel id of the channel that must be taken to the first hop. If zero,
     * any channel may be used.
     *
     * @generated from protobuf field: uint64 outgoing_chan_id = 3 [jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * A list of hops that defines the route. This does not include the source hop
     * pubkey.
     *
     * @generated from protobuf field: repeated bytes hop_pubkeys = 4;
     */
    hopPubkeys: Uint8Array[];
    /**
     * An optional payment addr to be included within the last hop of the route.
     *
     * @generated from protobuf field: bytes payment_addr = 5;
     */
    paymentAddr: Uint8Array;
}
/**
 * @generated from protobuf message routerrpc.BuildRouteResponse
 */
export interface BuildRouteResponse {
    /**
     *
     * Fully specified route that can be used to execute the payment.
     *
     * @generated from protobuf field: lnrpc.Route route = 1;
     */
    route?: Route;
}
/**
 * @generated from protobuf message routerrpc.SubscribeHtlcEventsRequest
 */
export interface SubscribeHtlcEventsRequest {
}
/**
 *
 * HtlcEvent contains the htlc event that was processed. These are served on a
 * best-effort basis; events are not persisted, delivery is not guaranteed
 * (in the event of a crash in the switch, forward events may be lost) and
 * some events may be replayed upon restart. Events consumed from this package
 * should be de-duplicated by the htlc's unique combination of incoming and
 * outgoing channel id and htlc id. [EXPERIMENTAL]
 *
 * @generated from protobuf message routerrpc.HtlcEvent
 */
export interface HtlcEvent {
    /**
     *
     * The short channel id that the incoming htlc arrived at our node on. This
     * value is zero for sends.
     *
     * @generated from protobuf field: uint64 incoming_channel_id = 1;
     */
    incomingChannelId: number;
    /**
     *
     * The short channel id that the outgoing htlc left our node on. This value
     * is zero for receives.
     *
     * @generated from protobuf field: uint64 outgoing_channel_id = 2;
     */
    outgoingChannelId: number;
    /**
     *
     * Incoming id is the index of the incoming htlc in the incoming channel.
     * This value is zero for sends.
     *
     * @generated from protobuf field: uint64 incoming_htlc_id = 3;
     */
    incomingHtlcId: number;
    /**
     *
     * Outgoing id is the index of the outgoing htlc in the outgoing channel.
     * This value is zero for receives.
     *
     * @generated from protobuf field: uint64 outgoing_htlc_id = 4;
     */
    outgoingHtlcId: number;
    /**
     *
     * The time in unix nanoseconds that the event occurred.
     *
     * @generated from protobuf field: uint64 timestamp_ns = 5;
     */
    timestampNs: number;
    /**
     *
     * The event type indicates whether the htlc was part of a send, receive or
     * forward.
     *
     * @generated from protobuf field: routerrpc.HtlcEvent.EventType event_type = 6;
     */
    eventType: HtlcEvent_EventType;
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "forwardEvent";
        /**
         * @generated from protobuf field: routerrpc.ForwardEvent forward_event = 7;
         */
        forwardEvent: ForwardEvent;
    } | {
        oneofKind: "forwardFailEvent";
        /**
         * @generated from protobuf field: routerrpc.ForwardFailEvent forward_fail_event = 8;
         */
        forwardFailEvent: ForwardFailEvent;
    } | {
        oneofKind: "settleEvent";
        /**
         * @generated from protobuf field: routerrpc.SettleEvent settle_event = 9;
         */
        settleEvent: SettleEvent;
    } | {
        oneofKind: "linkFailEvent";
        /**
         * @generated from protobuf field: routerrpc.LinkFailEvent link_fail_event = 10;
         */
        linkFailEvent: LinkFailEvent;
    } | {
        oneofKind: "subscribedEvent";
        /**
         * @generated from protobuf field: routerrpc.SubscribedEvent subscribed_event = 11;
         */
        subscribedEvent: SubscribedEvent;
    } | {
        oneofKind: "finalHtlcEvent";
        /**
         * @generated from protobuf field: routerrpc.FinalHtlcEvent final_htlc_event = 12;
         */
        finalHtlcEvent: FinalHtlcEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum routerrpc.HtlcEvent.EventType
 */
export declare enum HtlcEvent_EventType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SEND = 1;
     */
    SEND = 1,
    /**
     * @generated from protobuf enum value: RECEIVE = 2;
     */
    RECEIVE = 2,
    /**
     * @generated from protobuf enum value: FORWARD = 3;
     */
    FORWARD = 3
}
/**
 * @generated from protobuf message routerrpc.HtlcInfo
 */
export interface HtlcInfo {
    /**
     * The timelock on the incoming htlc.
     *
     * @generated from protobuf field: uint32 incoming_timelock = 1;
     */
    incomingTimelock: number;
    /**
     * The timelock on the outgoing htlc.
     *
     * @generated from protobuf field: uint32 outgoing_timelock = 2;
     */
    outgoingTimelock: number;
    /**
     * The amount of the incoming htlc.
     *
     * @generated from protobuf field: uint64 incoming_amt_msat = 3;
     */
    incomingAmtMsat: number;
    /**
     * The amount of the outgoing htlc.
     *
     * @generated from protobuf field: uint64 outgoing_amt_msat = 4;
     */
    outgoingAmtMsat: number;
}
/**
 * @generated from protobuf message routerrpc.ForwardEvent
 */
export interface ForwardEvent {
    /**
     * Info contains details about the htlc that was forwarded.
     *
     * @generated from protobuf field: routerrpc.HtlcInfo info = 1;
     */
    info?: HtlcInfo;
}
/**
 * @generated from protobuf message routerrpc.ForwardFailEvent
 */
export interface ForwardFailEvent {
}
/**
 * @generated from protobuf message routerrpc.SettleEvent
 */
export interface SettleEvent {
    /**
     * The revealed preimage.
     *
     * @generated from protobuf field: bytes preimage = 1;
     */
    preimage: Uint8Array;
}
/**
 * @generated from protobuf message routerrpc.FinalHtlcEvent
 */
export interface FinalHtlcEvent {
    /**
     * @generated from protobuf field: bool settled = 1;
     */
    settled: boolean;
    /**
     * @generated from protobuf field: bool offchain = 2;
     */
    offchain: boolean;
}
/**
 * @generated from protobuf message routerrpc.SubscribedEvent
 */
export interface SubscribedEvent {
}
/**
 * @generated from protobuf message routerrpc.LinkFailEvent
 */
export interface LinkFailEvent {
    /**
     * Info contains details about the htlc that we failed.
     *
     * @generated from protobuf field: routerrpc.HtlcInfo info = 1;
     */
    info?: HtlcInfo;
    /**
     * FailureCode is the BOLT error code for the failure.
     *
     * @generated from protobuf field: lnrpc.Failure.FailureCode wire_failure = 2;
     */
    wireFailure: Failure_FailureCode;
    /**
     *
     * FailureDetail provides additional information about the reason for the
     * failure. This detail enriches the information provided by the wire message
     * and may be 'no detail' if the wire message requires no additional metadata.
     *
     * @generated from protobuf field: routerrpc.FailureDetail failure_detail = 3;
     */
    failureDetail: FailureDetail;
    /**
     * A string representation of the link failure.
     *
     * @generated from protobuf field: string failure_string = 4;
     */
    failureString: string;
}
/**
 * @generated from protobuf message routerrpc.PaymentStatus
 */
export interface PaymentStatus {
    /**
     * Current state the payment is in.
     *
     * @generated from protobuf field: routerrpc.PaymentState state = 1;
     */
    state: PaymentState;
    /**
     *
     * The pre-image of the payment when state is SUCCEEDED.
     *
     * @generated from protobuf field: bytes preimage = 2;
     */
    preimage: Uint8Array;
    /**
     *
     * The HTLCs made in attempt to settle the payment [EXPERIMENTAL].
     *
     * @generated from protobuf field: repeated lnrpc.HTLCAttempt htlcs = 4;
     */
    htlcs: HTLCAttempt[];
}
/**
 * @generated from protobuf message routerrpc.CircuitKey
 */
export interface CircuitKey {
    /**
     * / The id of the channel that the is part of this circuit.
     *
     * @generated from protobuf field: uint64 chan_id = 1;
     */
    chanId: number;
    /**
     * / The index of the incoming htlc in the incoming channel.
     *
     * @generated from protobuf field: uint64 htlc_id = 2;
     */
    htlcId: number;
}
/**
 * @generated from protobuf message routerrpc.ForwardHtlcInterceptRequest
 */
export interface ForwardHtlcInterceptRequest {
    /**
     *
     * The key of this forwarded htlc. It defines the incoming channel id and
     * the index in this channel.
     *
     * @generated from protobuf field: routerrpc.CircuitKey incoming_circuit_key = 1;
     */
    incomingCircuitKey?: CircuitKey;
    /**
     * The incoming htlc amount.
     *
     * @generated from protobuf field: uint64 incoming_amount_msat = 5;
     */
    incomingAmountMsat: number;
    /**
     * The incoming htlc expiry.
     *
     * @generated from protobuf field: uint32 incoming_expiry = 6;
     */
    incomingExpiry: number;
    /**
     *
     * The htlc payment hash. This value is not guaranteed to be unique per
     * request.
     *
     * @generated from protobuf field: bytes payment_hash = 2;
     */
    paymentHash: Uint8Array;
    /**
     * The requested outgoing channel id for this forwarded htlc. Because of
     * non-strict forwarding, this isn't necessarily the channel over which the
     * packet will be forwarded eventually. A different channel to the same peer
     * may be selected as well.
     *
     * @generated from protobuf field: uint64 outgoing_requested_chan_id = 7;
     */
    outgoingRequestedChanId: number;
    /**
     * The outgoing htlc amount.
     *
     * @generated from protobuf field: uint64 outgoing_amount_msat = 3;
     */
    outgoingAmountMsat: number;
    /**
     * The outgoing htlc expiry.
     *
     * @generated from protobuf field: uint32 outgoing_expiry = 4;
     */
    outgoingExpiry: number;
    /**
     * Any custom records that were present in the payload.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 8;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * The onion blob for the next hop
     *
     * @generated from protobuf field: bytes onion_blob = 9;
     */
    onionBlob: Uint8Array;
    /**
     * The block height at which this htlc will be auto-failed to prevent the
     * channel from force-closing.
     *
     * @generated from protobuf field: int32 auto_fail_height = 10;
     */
    autoFailHeight: number;
}
/**
 * *
 * ForwardHtlcInterceptResponse enables the caller to resolve a previously hold
 * forward. The caller can choose either to:
 * - `Resume`: Execute the default behavior (usually forward).
 * - `Reject`: Fail the htlc backwards.
 * - `Settle`: Settle this htlc with a given preimage.
 *
 * @generated from protobuf message routerrpc.ForwardHtlcInterceptResponse
 */
export interface ForwardHtlcInterceptResponse {
    /**
     * *
     * The key of this forwarded htlc. It defines the incoming channel id and
     * the index in this channel.
     *
     * @generated from protobuf field: routerrpc.CircuitKey incoming_circuit_key = 1;
     */
    incomingCircuitKey?: CircuitKey;
    /**
     * The resolve action for this intercepted htlc.
     *
     * @generated from protobuf field: routerrpc.ResolveHoldForwardAction action = 2;
     */
    action: ResolveHoldForwardAction;
    /**
     * The preimage in case the resolve action is Settle.
     *
     * @generated from protobuf field: bytes preimage = 3;
     */
    preimage: Uint8Array;
    /**
     * Encrypted failure message in case the resolve action is Fail.
     *
     * If failure_message is specified, the failure_code field must be set
     * to zero.
     *
     * @generated from protobuf field: bytes failure_message = 4;
     */
    failureMessage: Uint8Array;
    /**
     * Return the specified failure code in case the resolve action is Fail. The
     * message data fields are populated automatically.
     *
     * If a non-zero failure_code is specified, failure_message must not be set.
     *
     * For backwards-compatibility reasons, TEMPORARY_CHANNEL_FAILURE is the
     * default value for this field.
     *
     * @generated from protobuf field: lnrpc.Failure.FailureCode failure_code = 5;
     */
    failureCode: Failure_FailureCode;
}
/**
 * @generated from protobuf message routerrpc.UpdateChanStatusRequest
 */
export interface UpdateChanStatusRequest {
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
    /**
     * @generated from protobuf field: routerrpc.ChanStatusAction action = 2;
     */
    action: ChanStatusAction;
}
/**
 * @generated from protobuf message routerrpc.UpdateChanStatusResponse
 */
export interface UpdateChanStatusResponse {
}
/**
 * @generated from protobuf enum routerrpc.FailureDetail
 */
export declare enum FailureDetail {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: NO_DETAIL = 1;
     */
    NO_DETAIL = 1,
    /**
     * @generated from protobuf enum value: ONION_DECODE = 2;
     */
    ONION_DECODE = 2,
    /**
     * @generated from protobuf enum value: LINK_NOT_ELIGIBLE = 3;
     */
    LINK_NOT_ELIGIBLE = 3,
    /**
     * @generated from protobuf enum value: ON_CHAIN_TIMEOUT = 4;
     */
    ON_CHAIN_TIMEOUT = 4,
    /**
     * @generated from protobuf enum value: HTLC_EXCEEDS_MAX = 5;
     */
    HTLC_EXCEEDS_MAX = 5,
    /**
     * @generated from protobuf enum value: INSUFFICIENT_BALANCE = 6;
     */
    INSUFFICIENT_BALANCE = 6,
    /**
     * @generated from protobuf enum value: INCOMPLETE_FORWARD = 7;
     */
    INCOMPLETE_FORWARD = 7,
    /**
     * @generated from protobuf enum value: HTLC_ADD_FAILED = 8;
     */
    HTLC_ADD_FAILED = 8,
    /**
     * @generated from protobuf enum value: FORWARDS_DISABLED = 9;
     */
    FORWARDS_DISABLED = 9,
    /**
     * @generated from protobuf enum value: INVOICE_CANCELED = 10;
     */
    INVOICE_CANCELED = 10,
    /**
     * @generated from protobuf enum value: INVOICE_UNDERPAID = 11;
     */
    INVOICE_UNDERPAID = 11,
    /**
     * @generated from protobuf enum value: INVOICE_EXPIRY_TOO_SOON = 12;
     */
    INVOICE_EXPIRY_TOO_SOON = 12,
    /**
     * @generated from protobuf enum value: INVOICE_NOT_OPEN = 13;
     */
    INVOICE_NOT_OPEN = 13,
    /**
     * @generated from protobuf enum value: MPP_INVOICE_TIMEOUT = 14;
     */
    MPP_INVOICE_TIMEOUT = 14,
    /**
     * @generated from protobuf enum value: ADDRESS_MISMATCH = 15;
     */
    ADDRESS_MISMATCH = 15,
    /**
     * @generated from protobuf enum value: SET_TOTAL_MISMATCH = 16;
     */
    SET_TOTAL_MISMATCH = 16,
    /**
     * @generated from protobuf enum value: SET_TOTAL_TOO_LOW = 17;
     */
    SET_TOTAL_TOO_LOW = 17,
    /**
     * @generated from protobuf enum value: SET_OVERPAID = 18;
     */
    SET_OVERPAID = 18,
    /**
     * @generated from protobuf enum value: UNKNOWN_INVOICE = 19;
     */
    UNKNOWN_INVOICE = 19,
    /**
     * @generated from protobuf enum value: INVALID_KEYSEND = 20;
     */
    INVALID_KEYSEND = 20,
    /**
     * @generated from protobuf enum value: MPP_IN_PROGRESS = 21;
     */
    MPP_IN_PROGRESS = 21,
    /**
     * @generated from protobuf enum value: CIRCULAR_ROUTE = 22;
     */
    CIRCULAR_ROUTE = 22
}
/**
 * @generated from protobuf enum routerrpc.PaymentState
 */
export declare enum PaymentState {
    /**
     *
     * Payment is still in flight.
     *
     * @generated from protobuf enum value: IN_FLIGHT = 0;
     */
    IN_FLIGHT = 0,
    /**
     *
     * Payment completed successfully.
     *
     * @generated from protobuf enum value: SUCCEEDED = 1;
     */
    SUCCEEDED = 1,
    /**
     *
     * There are more routes to try, but the payment timeout was exceeded.
     *
     * @generated from protobuf enum value: FAILED_TIMEOUT = 2;
     */
    FAILED_TIMEOUT = 2,
    /**
     *
     * All possible routes were tried and failed permanently. Or were no
     * routes to the destination at all.
     *
     * @generated from protobuf enum value: FAILED_NO_ROUTE = 3;
     */
    FAILED_NO_ROUTE = 3,
    /**
     *
     * A non-recoverable error has occurred.
     *
     * @generated from protobuf enum value: FAILED_ERROR = 4;
     */
    FAILED_ERROR = 4,
    /**
     *
     * Payment details incorrect (unknown hash, invalid amt or
     * invalid final cltv delta)
     *
     * @generated from protobuf enum value: FAILED_INCORRECT_PAYMENT_DETAILS = 5;
     */
    FAILED_INCORRECT_PAYMENT_DETAILS = 5,
    /**
     *
     * Insufficient local balance.
     *
     * @generated from protobuf enum value: FAILED_INSUFFICIENT_BALANCE = 6;
     */
    FAILED_INSUFFICIENT_BALANCE = 6
}
/**
 * @generated from protobuf enum routerrpc.ResolveHoldForwardAction
 */
export declare enum ResolveHoldForwardAction {
    /**
     * @generated from protobuf enum value: SETTLE = 0;
     */
    SETTLE = 0,
    /**
     * @generated from protobuf enum value: FAIL = 1;
     */
    FAIL = 1,
    /**
     * @generated from protobuf enum value: RESUME = 2;
     */
    RESUME = 2
}
/**
 * @generated from protobuf enum routerrpc.ChanStatusAction
 */
export declare enum ChanStatusAction {
    /**
     * @generated from protobuf enum value: ENABLE = 0;
     */
    ENABLE = 0,
    /**
     * @generated from protobuf enum value: DISABLE = 1;
     */
    DISABLE = 1,
    /**
     * @generated from protobuf enum value: AUTO = 2;
     */
    AUTO = 2
}
declare class SendPaymentRequest$Type extends MessageType<SendPaymentRequest> {
    constructor();
    create(value?: PartialMessage<SendPaymentRequest>): SendPaymentRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendPaymentRequest): SendPaymentRequest;
    private binaryReadMap11;
    internalBinaryWrite(message: SendPaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SendPaymentRequest
 */
export declare const SendPaymentRequest: SendPaymentRequest$Type;
declare class TrackPaymentRequest$Type extends MessageType<TrackPaymentRequest> {
    constructor();
    create(value?: PartialMessage<TrackPaymentRequest>): TrackPaymentRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPaymentRequest): TrackPaymentRequest;
    internalBinaryWrite(message: TrackPaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentRequest
 */
export declare const TrackPaymentRequest: TrackPaymentRequest$Type;
declare class TrackPaymentsRequest$Type extends MessageType<TrackPaymentsRequest> {
    constructor();
    create(value?: PartialMessage<TrackPaymentsRequest>): TrackPaymentsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPaymentsRequest): TrackPaymentsRequest;
    internalBinaryWrite(message: TrackPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.TrackPaymentsRequest
 */
export declare const TrackPaymentsRequest: TrackPaymentsRequest$Type;
declare class RouteFeeRequest$Type extends MessageType<RouteFeeRequest> {
    constructor();
    create(value?: PartialMessage<RouteFeeRequest>): RouteFeeRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteFeeRequest): RouteFeeRequest;
    internalBinaryWrite(message: RouteFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeRequest
 */
export declare const RouteFeeRequest: RouteFeeRequest$Type;
declare class RouteFeeResponse$Type extends MessageType<RouteFeeResponse> {
    constructor();
    create(value?: PartialMessage<RouteFeeResponse>): RouteFeeResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteFeeResponse): RouteFeeResponse;
    internalBinaryWrite(message: RouteFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.RouteFeeResponse
 */
export declare const RouteFeeResponse: RouteFeeResponse$Type;
declare class SendToRouteRequest$Type extends MessageType<SendToRouteRequest> {
    constructor();
    create(value?: PartialMessage<SendToRouteRequest>): SendToRouteRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendToRouteRequest): SendToRouteRequest;
    internalBinaryWrite(message: SendToRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteRequest
 */
export declare const SendToRouteRequest: SendToRouteRequest$Type;
declare class SendToRouteResponse$Type extends MessageType<SendToRouteResponse> {
    constructor();
    create(value?: PartialMessage<SendToRouteResponse>): SendToRouteResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendToRouteResponse): SendToRouteResponse;
    internalBinaryWrite(message: SendToRouteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SendToRouteResponse
 */
export declare const SendToRouteResponse: SendToRouteResponse$Type;
declare class ResetMissionControlRequest$Type extends MessageType<ResetMissionControlRequest> {
    constructor();
    create(value?: PartialMessage<ResetMissionControlRequest>): ResetMissionControlRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetMissionControlRequest): ResetMissionControlRequest;
    internalBinaryWrite(message: ResetMissionControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlRequest
 */
export declare const ResetMissionControlRequest: ResetMissionControlRequest$Type;
declare class ResetMissionControlResponse$Type extends MessageType<ResetMissionControlResponse> {
    constructor();
    create(value?: PartialMessage<ResetMissionControlResponse>): ResetMissionControlResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetMissionControlResponse): ResetMissionControlResponse;
    internalBinaryWrite(message: ResetMissionControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.ResetMissionControlResponse
 */
export declare const ResetMissionControlResponse: ResetMissionControlResponse$Type;
declare class QueryMissionControlRequest$Type extends MessageType<QueryMissionControlRequest> {
    constructor();
    create(value?: PartialMessage<QueryMissionControlRequest>): QueryMissionControlRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMissionControlRequest): QueryMissionControlRequest;
    internalBinaryWrite(message: QueryMissionControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlRequest
 */
export declare const QueryMissionControlRequest: QueryMissionControlRequest$Type;
declare class QueryMissionControlResponse$Type extends MessageType<QueryMissionControlResponse> {
    constructor();
    create(value?: PartialMessage<QueryMissionControlResponse>): QueryMissionControlResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMissionControlResponse): QueryMissionControlResponse;
    internalBinaryWrite(message: QueryMissionControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryMissionControlResponse
 */
export declare const QueryMissionControlResponse: QueryMissionControlResponse$Type;
declare class XImportMissionControlRequest$Type extends MessageType<XImportMissionControlRequest> {
    constructor();
    create(value?: PartialMessage<XImportMissionControlRequest>): XImportMissionControlRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: XImportMissionControlRequest): XImportMissionControlRequest;
    internalBinaryWrite(message: XImportMissionControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlRequest
 */
export declare const XImportMissionControlRequest: XImportMissionControlRequest$Type;
declare class XImportMissionControlResponse$Type extends MessageType<XImportMissionControlResponse> {
    constructor();
    create(value?: PartialMessage<XImportMissionControlResponse>): XImportMissionControlResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: XImportMissionControlResponse): XImportMissionControlResponse;
    internalBinaryWrite(message: XImportMissionControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.XImportMissionControlResponse
 */
export declare const XImportMissionControlResponse: XImportMissionControlResponse$Type;
declare class PairHistory$Type extends MessageType<PairHistory> {
    constructor();
    create(value?: PartialMessage<PairHistory>): PairHistory;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PairHistory): PairHistory;
    internalBinaryWrite(message: PairHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.PairHistory
 */
export declare const PairHistory: PairHistory$Type;
declare class PairData$Type extends MessageType<PairData> {
    constructor();
    create(value?: PartialMessage<PairData>): PairData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PairData): PairData;
    internalBinaryWrite(message: PairData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.PairData
 */
export declare const PairData: PairData$Type;
declare class GetMissionControlConfigRequest$Type extends MessageType<GetMissionControlConfigRequest> {
    constructor();
    create(value?: PartialMessage<GetMissionControlConfigRequest>): GetMissionControlConfigRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMissionControlConfigRequest): GetMissionControlConfigRequest;
    internalBinaryWrite(message: GetMissionControlConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigRequest
 */
export declare const GetMissionControlConfigRequest: GetMissionControlConfigRequest$Type;
declare class GetMissionControlConfigResponse$Type extends MessageType<GetMissionControlConfigResponse> {
    constructor();
    create(value?: PartialMessage<GetMissionControlConfigResponse>): GetMissionControlConfigResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMissionControlConfigResponse): GetMissionControlConfigResponse;
    internalBinaryWrite(message: GetMissionControlConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.GetMissionControlConfigResponse
 */
export declare const GetMissionControlConfigResponse: GetMissionControlConfigResponse$Type;
declare class SetMissionControlConfigRequest$Type extends MessageType<SetMissionControlConfigRequest> {
    constructor();
    create(value?: PartialMessage<SetMissionControlConfigRequest>): SetMissionControlConfigRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMissionControlConfigRequest): SetMissionControlConfigRequest;
    internalBinaryWrite(message: SetMissionControlConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigRequest
 */
export declare const SetMissionControlConfigRequest: SetMissionControlConfigRequest$Type;
declare class SetMissionControlConfigResponse$Type extends MessageType<SetMissionControlConfigResponse> {
    constructor();
    create(value?: PartialMessage<SetMissionControlConfigResponse>): SetMissionControlConfigResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMissionControlConfigResponse): SetMissionControlConfigResponse;
    internalBinaryWrite(message: SetMissionControlConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SetMissionControlConfigResponse
 */
export declare const SetMissionControlConfigResponse: SetMissionControlConfigResponse$Type;
declare class MissionControlConfig$Type extends MessageType<MissionControlConfig> {
    constructor();
    create(value?: PartialMessage<MissionControlConfig>): MissionControlConfig;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionControlConfig): MissionControlConfig;
    internalBinaryWrite(message: MissionControlConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.MissionControlConfig
 */
export declare const MissionControlConfig: MissionControlConfig$Type;
declare class QueryProbabilityRequest$Type extends MessageType<QueryProbabilityRequest> {
    constructor();
    create(value?: PartialMessage<QueryProbabilityRequest>): QueryProbabilityRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryProbabilityRequest): QueryProbabilityRequest;
    internalBinaryWrite(message: QueryProbabilityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityRequest
 */
export declare const QueryProbabilityRequest: QueryProbabilityRequest$Type;
declare class QueryProbabilityResponse$Type extends MessageType<QueryProbabilityResponse> {
    constructor();
    create(value?: PartialMessage<QueryProbabilityResponse>): QueryProbabilityResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryProbabilityResponse): QueryProbabilityResponse;
    internalBinaryWrite(message: QueryProbabilityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.QueryProbabilityResponse
 */
export declare const QueryProbabilityResponse: QueryProbabilityResponse$Type;
declare class BuildRouteRequest$Type extends MessageType<BuildRouteRequest> {
    constructor();
    create(value?: PartialMessage<BuildRouteRequest>): BuildRouteRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildRouteRequest): BuildRouteRequest;
    internalBinaryWrite(message: BuildRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteRequest
 */
export declare const BuildRouteRequest: BuildRouteRequest$Type;
declare class BuildRouteResponse$Type extends MessageType<BuildRouteResponse> {
    constructor();
    create(value?: PartialMessage<BuildRouteResponse>): BuildRouteResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildRouteResponse): BuildRouteResponse;
    internalBinaryWrite(message: BuildRouteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.BuildRouteResponse
 */
export declare const BuildRouteResponse: BuildRouteResponse$Type;
declare class SubscribeHtlcEventsRequest$Type extends MessageType<SubscribeHtlcEventsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeHtlcEventsRequest>): SubscribeHtlcEventsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHtlcEventsRequest): SubscribeHtlcEventsRequest;
    internalBinaryWrite(message: SubscribeHtlcEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribeHtlcEventsRequest
 */
export declare const SubscribeHtlcEventsRequest: SubscribeHtlcEventsRequest$Type;
declare class HtlcEvent$Type extends MessageType<HtlcEvent> {
    constructor();
    create(value?: PartialMessage<HtlcEvent>): HtlcEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HtlcEvent): HtlcEvent;
    internalBinaryWrite(message: HtlcEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcEvent
 */
export declare const HtlcEvent: HtlcEvent$Type;
declare class HtlcInfo$Type extends MessageType<HtlcInfo> {
    constructor();
    create(value?: PartialMessage<HtlcInfo>): HtlcInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HtlcInfo): HtlcInfo;
    internalBinaryWrite(message: HtlcInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.HtlcInfo
 */
export declare const HtlcInfo: HtlcInfo$Type;
declare class ForwardEvent$Type extends MessageType<ForwardEvent> {
    constructor();
    create(value?: PartialMessage<ForwardEvent>): ForwardEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardEvent): ForwardEvent;
    internalBinaryWrite(message: ForwardEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardEvent
 */
export declare const ForwardEvent: ForwardEvent$Type;
declare class ForwardFailEvent$Type extends MessageType<ForwardFailEvent> {
    constructor();
    create(value?: PartialMessage<ForwardFailEvent>): ForwardFailEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardFailEvent): ForwardFailEvent;
    internalBinaryWrite(message: ForwardFailEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardFailEvent
 */
export declare const ForwardFailEvent: ForwardFailEvent$Type;
declare class SettleEvent$Type extends MessageType<SettleEvent> {
    constructor();
    create(value?: PartialMessage<SettleEvent>): SettleEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettleEvent): SettleEvent;
    internalBinaryWrite(message: SettleEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SettleEvent
 */
export declare const SettleEvent: SettleEvent$Type;
declare class FinalHtlcEvent$Type extends MessageType<FinalHtlcEvent> {
    constructor();
    create(value?: PartialMessage<FinalHtlcEvent>): FinalHtlcEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalHtlcEvent): FinalHtlcEvent;
    internalBinaryWrite(message: FinalHtlcEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.FinalHtlcEvent
 */
export declare const FinalHtlcEvent: FinalHtlcEvent$Type;
declare class SubscribedEvent$Type extends MessageType<SubscribedEvent> {
    constructor();
    create(value?: PartialMessage<SubscribedEvent>): SubscribedEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribedEvent): SubscribedEvent;
    internalBinaryWrite(message: SubscribedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.SubscribedEvent
 */
export declare const SubscribedEvent: SubscribedEvent$Type;
declare class LinkFailEvent$Type extends MessageType<LinkFailEvent> {
    constructor();
    create(value?: PartialMessage<LinkFailEvent>): LinkFailEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkFailEvent): LinkFailEvent;
    internalBinaryWrite(message: LinkFailEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.LinkFailEvent
 */
export declare const LinkFailEvent: LinkFailEvent$Type;
declare class PaymentStatus$Type extends MessageType<PaymentStatus> {
    constructor();
    create(value?: PartialMessage<PaymentStatus>): PaymentStatus;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaymentStatus): PaymentStatus;
    internalBinaryWrite(message: PaymentStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.PaymentStatus
 */
export declare const PaymentStatus: PaymentStatus$Type;
declare class CircuitKey$Type extends MessageType<CircuitKey> {
    constructor();
    create(value?: PartialMessage<CircuitKey>): CircuitKey;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CircuitKey): CircuitKey;
    internalBinaryWrite(message: CircuitKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.CircuitKey
 */
export declare const CircuitKey: CircuitKey$Type;
declare class ForwardHtlcInterceptRequest$Type extends MessageType<ForwardHtlcInterceptRequest> {
    constructor();
    create(value?: PartialMessage<ForwardHtlcInterceptRequest>): ForwardHtlcInterceptRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardHtlcInterceptRequest): ForwardHtlcInterceptRequest;
    private binaryReadMap8;
    internalBinaryWrite(message: ForwardHtlcInterceptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptRequest
 */
export declare const ForwardHtlcInterceptRequest: ForwardHtlcInterceptRequest$Type;
declare class ForwardHtlcInterceptResponse$Type extends MessageType<ForwardHtlcInterceptResponse> {
    constructor();
    create(value?: PartialMessage<ForwardHtlcInterceptResponse>): ForwardHtlcInterceptResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardHtlcInterceptResponse): ForwardHtlcInterceptResponse;
    internalBinaryWrite(message: ForwardHtlcInterceptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.ForwardHtlcInterceptResponse
 */
export declare const ForwardHtlcInterceptResponse: ForwardHtlcInterceptResponse$Type;
declare class UpdateChanStatusRequest$Type extends MessageType<UpdateChanStatusRequest> {
    constructor();
    create(value?: PartialMessage<UpdateChanStatusRequest>): UpdateChanStatusRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateChanStatusRequest): UpdateChanStatusRequest;
    internalBinaryWrite(message: UpdateChanStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusRequest
 */
export declare const UpdateChanStatusRequest: UpdateChanStatusRequest$Type;
declare class UpdateChanStatusResponse$Type extends MessageType<UpdateChanStatusResponse> {
    constructor();
    create(value?: PartialMessage<UpdateChanStatusResponse>): UpdateChanStatusResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateChanStatusResponse): UpdateChanStatusResponse;
    internalBinaryWrite(message: UpdateChanStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message routerrpc.UpdateChanStatusResponse
 */
export declare const UpdateChanStatusResponse: UpdateChanStatusResponse$Type;
/**
 * @generated ServiceType for protobuf service routerrpc.Router
 */
export declare const Router: any;
export {};
