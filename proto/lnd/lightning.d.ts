// @generated by protobuf-ts 2.8.1 with parameter long_type_number,output_javascript
// @generated from protobuf file "lightning.proto" (package "lnrpc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message lnrpc.LookupHtlcRequest
 */
export interface LookupHtlcRequest {
    /**
     * @generated from protobuf field: uint64 chan_id = 1;
     */
    chanId: number;
    /**
     * @generated from protobuf field: uint64 htlc_index = 2;
     */
    htlcIndex: number;
}
/**
 * @generated from protobuf message lnrpc.LookupHtlcResponse
 */
export interface LookupHtlcResponse {
    /**
     * @generated from protobuf field: bool settled = 1;
     */
    settled: boolean;
    /**
     * @generated from protobuf field: bool offchain = 2;
     */
    offchain: boolean;
}
/**
 * @generated from protobuf message lnrpc.SubscribeCustomMessagesRequest
 */
export interface SubscribeCustomMessagesRequest {
}
/**
 * @generated from protobuf message lnrpc.CustomMessage
 */
export interface CustomMessage {
    /**
     * Peer from which the message originates
     *
     * @generated from protobuf field: bytes peer = 1;
     */
    peer: Uint8Array;
    /**
     * Message type. This value will be in the custom range (>= 32768).
     *
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
    /**
     * Raw message data
     *
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendCustomMessageRequest
 */
export interface SendCustomMessageRequest {
    /**
     * Peer to send the message to
     *
     * @generated from protobuf field: bytes peer = 1;
     */
    peer: Uint8Array;
    /**
     * Message type. This value needs to be in the custom range (>= 32768).
     *
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
    /**
     * Raw message data.
     *
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendCustomMessageResponse
 */
export interface SendCustomMessageResponse {
}
/**
 * @generated from protobuf message lnrpc.Utxo
 */
export interface Utxo {
    /**
     * The type of address
     *
     * @generated from protobuf field: lnrpc.AddressType address_type = 1;
     */
    addressType: AddressType;
    /**
     * The address
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * The value of the unspent coin in satoshis
     *
     * @generated from protobuf field: int64 amount_sat = 3;
     */
    amountSat: number;
    /**
     * The pkscript in hex
     *
     * @generated from protobuf field: string pk_script = 4;
     */
    pkScript: string;
    /**
     * The outpoint in format txid:n
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 5;
     */
    outpoint?: OutPoint;
    /**
     * The number of confirmations for the Utxo
     *
     * @generated from protobuf field: int64 confirmations = 6;
     */
    confirmations: number;
}
/**
 * @generated from protobuf message lnrpc.OutputDetail
 */
export interface OutputDetail {
    /**
     * The type of the output
     *
     * @generated from protobuf field: lnrpc.OutputScriptType output_type = 1;
     */
    outputType: OutputScriptType;
    /**
     * The address
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * The pkscript in hex
     *
     * @generated from protobuf field: string pk_script = 3;
     */
    pkScript: string;
    /**
     * The output index used in the raw transaction
     *
     * @generated from protobuf field: int64 output_index = 4;
     */
    outputIndex: number;
    /**
     * The value of the output coin in satoshis
     *
     * @generated from protobuf field: int64 amount = 5;
     */
    amount: number;
    /**
     * Denotes if the output is controlled by the internal wallet
     *
     * @generated from protobuf field: bool is_our_address = 6;
     */
    isOurAddress: boolean;
}
/**
 * @generated from protobuf message lnrpc.Transaction
 */
export interface Transaction {
    /**
     * The transaction hash
     *
     * @generated from protobuf field: string tx_hash = 1;
     */
    txHash: string;
    /**
     * The transaction amount, denominated in satoshis
     *
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: number;
    /**
     * The number of confirmations
     *
     * @generated from protobuf field: int32 num_confirmations = 3;
     */
    numConfirmations: number;
    /**
     * The hash of the block this transaction was included in
     *
     * @generated from protobuf field: string block_hash = 4;
     */
    blockHash: string;
    /**
     * The height of the block this transaction was included in
     *
     * @generated from protobuf field: int32 block_height = 5;
     */
    blockHeight: number;
    /**
     * Timestamp of this transaction
     *
     * @generated from protobuf field: int64 time_stamp = 6;
     */
    timeStamp: number;
    /**
     * Fees paid for this transaction
     *
     * @generated from protobuf field: int64 total_fees = 7;
     */
    totalFees: number;
    /**
     * Addresses that received funds for this transaction. Deprecated as it is
     * now incorporated in the output_details field.
     *
     * @deprecated
     * @generated from protobuf field: repeated string dest_addresses = 8 [deprecated = true];
     */
    destAddresses: string[];
    /**
     * Outputs that received funds for this transaction
     *
     * @generated from protobuf field: repeated lnrpc.OutputDetail output_details = 11;
     */
    outputDetails: OutputDetail[];
    /**
     * The raw transaction hex.
     *
     * @generated from protobuf field: string raw_tx_hex = 9;
     */
    rawTxHex: string;
    /**
     * A label that was optionally set on transaction broadcast.
     *
     * @generated from protobuf field: string label = 10;
     */
    label: string;
    /**
     * PreviousOutpoints/Inputs of this transaction.
     *
     * @generated from protobuf field: repeated lnrpc.PreviousOutPoint previous_outpoints = 12;
     */
    previousOutpoints: PreviousOutPoint[];
}
/**
 * @generated from protobuf message lnrpc.GetTransactionsRequest
 */
export interface GetTransactionsRequest {
    /**
     *
     * The height from which to list transactions, inclusive. If this value is
     * greater than end_height, transactions will be read in reverse.
     *
     * @generated from protobuf field: int32 start_height = 1;
     */
    startHeight: number;
    /**
     *
     * The height until which to list transactions, inclusive. To include
     * unconfirmed transactions, this value should be set to -1, which will
     * return transactions from start_height until the current chain tip and
     * unconfirmed transactions. If no end_height is provided, the call will
     * default to this option.
     *
     * @generated from protobuf field: int32 end_height = 2;
     */
    endHeight: number;
    /**
     * An optional filter to only include transactions relevant to an account.
     *
     * @generated from protobuf field: string account = 3;
     */
    account: string;
}
/**
 * @generated from protobuf message lnrpc.TransactionDetails
 */
export interface TransactionDetails {
    /**
     * The list of transactions relevant to the wallet.
     *
     * @generated from protobuf field: repeated lnrpc.Transaction transactions = 1;
     */
    transactions: Transaction[];
}
/**
 * @generated from protobuf message lnrpc.FeeLimit
 */
export interface FeeLimit {
    /**
     * @generated from protobuf oneof: limit
     */
    limit: {
        oneofKind: "fixed";
        /**
         *
         * The fee limit expressed as a fixed amount of satoshis.
         *
         * The fields fixed and fixed_msat are mutually exclusive.
         *
         * @generated from protobuf field: int64 fixed = 1;
         */
        fixed: number;
    } | {
        oneofKind: "fixedMsat";
        /**
         *
         * The fee limit expressed as a fixed amount of millisatoshis.
         *
         * The fields fixed and fixed_msat are mutually exclusive.
         *
         * @generated from protobuf field: int64 fixed_msat = 3;
         */
        fixedMsat: number;
    } | {
        oneofKind: "percent";
        /**
         * The fee limit expressed as a percentage of the payment amount.
         *
         * @generated from protobuf field: int64 percent = 2;
         */
        percent: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.SendRequest
 */
export interface SendRequest {
    /**
     *
     * The identity pubkey of the payment recipient. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes dest = 1;
     */
    dest: Uint8Array;
    /**
     *
     * The hex-encoded identity pubkey of the payment recipient. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string dest_string = 2 [deprecated = true];
     */
    destString: string;
    /**
     *
     * The amount to send expressed in satoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt = 3;
     */
    amt: number;
    /**
     *
     * The amount to send expressed in millisatoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt_msat = 12;
     */
    amtMsat: number;
    /**
     *
     * The hash to use within the payment's HTLC. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes payment_hash = 4;
     */
    paymentHash: Uint8Array;
    /**
     *
     * The hex-encoded hash to use within the payment's HTLC. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string payment_hash_string = 5 [deprecated = true];
     */
    paymentHashString: string;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network. With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient.
     *
     * @generated from protobuf field: string payment_request = 6;
     */
    paymentRequest: string;
    /**
     *
     * The CLTV delta from the current height that should be used to set the
     * timelock for the final hop.
     *
     * @generated from protobuf field: int32 final_cltv_delta = 7;
     */
    finalCltvDelta: number;
    /**
     *
     * The maximum number of satoshis that will be paid as a fee of the payment.
     * This value can be represented either as a percentage of the amount being
     * sent, or as a fixed amount of the maximum fee the user is willing the pay to
     * send the payment. If not specified, lnd will use a default value of 100%
     * fees for small amounts (<=1k sat) or 5% fees for larger amounts.
     *
     * @generated from protobuf field: lnrpc.FeeLimit fee_limit = 8;
     */
    feeLimit?: FeeLimit;
    /**
     *
     * The channel id of the channel that must be taken to the first hop. If zero,
     * any channel may be used.
     *
     * @generated from protobuf field: uint64 outgoing_chan_id = 9 [jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @generated from protobuf field: bytes last_hop_pubkey = 13;
     */
    lastHopPubkey: Uint8Array;
    /**
     *
     * An optional maximum total time lock for the route. This should not exceed
     * lnd's `--max-cltv-expiry` setting. If zero, then the value of
     * `--max-cltv-expiry` is enforced.
     *
     * @generated from protobuf field: uint32 cltv_limit = 10;
     */
    cltvLimit: number;
    /**
     *
     * An optional field that can be used to pass an arbitrary set of TLV records
     * to a peer which understands the new records. This can be used to pass
     * application specific data during the payment attempt. Record types are
     * required to be in the custom range >= 65536. When using REST, the values
     * must be encoded as base64.
     *
     * @generated from protobuf field: map<uint64, bytes> dest_custom_records = 11;
     */
    destCustomRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * If set, circular payments to self are permitted.
     *
     * @generated from protobuf field: bool allow_self_payment = 14;
     */
    allowSelfPayment: boolean;
    /**
     *
     * Features assumed to be supported by the final node. All transitive feature
     * dependencies must also be set properly. For a given feature bit pair, either
     * optional or remote may be set, but not both. If this field is nil or empty,
     * the router will try to load destination features from the graph as a
     * fallback.
     *
     * @generated from protobuf field: repeated lnrpc.FeatureBit dest_features = 15;
     */
    destFeatures: FeatureBit[];
    /**
     *
     * The payment address of the generated invoice.
     *
     * @generated from protobuf field: bytes payment_addr = 16;
     */
    paymentAddr: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendResponse
 */
export interface SendResponse {
    /**
     * @generated from protobuf field: string payment_error = 1;
     */
    paymentError: string;
    /**
     * @generated from protobuf field: bytes payment_preimage = 2;
     */
    paymentPreimage: Uint8Array;
    /**
     * @generated from protobuf field: lnrpc.Route payment_route = 3;
     */
    paymentRoute?: Route;
    /**
     * @generated from protobuf field: bytes payment_hash = 4;
     */
    paymentHash: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendToRouteRequest
 */
export interface SendToRouteRequest {
    /**
     *
     * The payment hash to use for the HTLC. When using REST, this field must be
     * encoded as base64.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     *
     * An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string payment_hash_string = 2 [deprecated = true];
     */
    paymentHashString: string;
    /**
     * Route that should be used to attempt to complete the payment.
     *
     * @generated from protobuf field: lnrpc.Route route = 4;
     */
    route?: Route;
}
/**
 * @generated from protobuf message lnrpc.ChannelAcceptRequest
 */
export interface ChannelAcceptRequest {
    /**
     * The pubkey of the node that wishes to open an inbound channel.
     *
     * @generated from protobuf field: bytes node_pubkey = 1;
     */
    nodePubkey: Uint8Array;
    /**
     * The hash of the genesis block that the proposed channel resides in.
     *
     * @generated from protobuf field: bytes chain_hash = 2;
     */
    chainHash: Uint8Array;
    /**
     * The pending channel id.
     *
     * @generated from protobuf field: bytes pending_chan_id = 3;
     */
    pendingChanId: Uint8Array;
    /**
     * The funding amount in satoshis that initiator wishes to use in the
     * channel.
     *
     * @generated from protobuf field: uint64 funding_amt = 4;
     */
    fundingAmt: number;
    /**
     * The push amount of the proposed channel in millisatoshis.
     *
     * @generated from protobuf field: uint64 push_amt = 5;
     */
    pushAmt: number;
    /**
     * The dust limit of the initiator's commitment tx.
     *
     * @generated from protobuf field: uint64 dust_limit = 6;
     */
    dustLimit: number;
    /**
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     *
     * @generated from protobuf field: uint64 max_value_in_flight = 7;
     */
    maxValueInFlight: number;
    /**
     * The minimum amount of satoshis the initiator requires us to have at all
     * times.
     *
     * @generated from protobuf field: uint64 channel_reserve = 8;
     */
    channelReserve: number;
    /**
     * The smallest HTLC in millisatoshis that the initiator will accept.
     *
     * @generated from protobuf field: uint64 min_htlc = 9;
     */
    minHtlc: number;
    /**
     * The initial fee rate that the initiator suggests for both commitment
     * transactions.
     *
     * @generated from protobuf field: uint64 fee_per_kw = 10;
     */
    feePerKw: number;
    /**
     *
     * The number of blocks to use for the relative time lock in the pay-to-self
     * output of both commitment transactions.
     *
     * @generated from protobuf field: uint32 csv_delay = 11;
     */
    csvDelay: number;
    /**
     * The total number of incoming HTLC's that the initiator will accept.
     *
     * @generated from protobuf field: uint32 max_accepted_htlcs = 12;
     */
    maxAcceptedHtlcs: number;
    /**
     * A bit-field which the initiator uses to specify proposed channel
     * behavior.
     *
     * @generated from protobuf field: uint32 channel_flags = 13;
     */
    channelFlags: number;
    /**
     * The commitment type the initiator wishes to use for the proposed channel.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 14;
     */
    commitmentType: CommitmentType;
    /**
     * Whether the initiator wants to open a zero-conf channel via the channel
     * type.
     *
     * @generated from protobuf field: bool wants_zero_conf = 15;
     */
    wantsZeroConf: boolean;
    /**
     * Whether the initiator wants to use the scid-alias channel type. This is
     * separate from the feature bit.
     *
     * @generated from protobuf field: bool wants_scid_alias = 16;
     */
    wantsScidAlias: boolean;
}
/**
 * @generated from protobuf message lnrpc.ChannelAcceptResponse
 */
export interface ChannelAcceptResponse {
    /**
     * Whether or not the client accepts the channel.
     *
     * @generated from protobuf field: bool accept = 1;
     */
    accept: boolean;
    /**
     * The pending channel id to which this response applies.
     *
     * @generated from protobuf field: bytes pending_chan_id = 2;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * An optional error to send the initiating party to indicate why the channel
     * was rejected. This field *should not* contain sensitive information, it will
     * be sent to the initiating party. This field should only be set if accept is
     * false, the channel will be rejected if an error is set with accept=true
     * because the meaning of this response is ambiguous. Limited to 500
     * characters.
     *
     * @generated from protobuf field: string error = 3;
     */
    error: string;
    /**
     *
     * The upfront shutdown address to use if the initiating peer supports option
     * upfront shutdown script (see ListPeers for the features supported). Note
     * that the channel open will fail if this value is set for a peer that does
     * not support this feature bit.
     *
     * @generated from protobuf field: string upfront_shutdown = 4;
     */
    upfrontShutdown: string;
    /**
     *
     * The csv delay (in blocks) that we require for the remote party.
     *
     * @generated from protobuf field: uint32 csv_delay = 5;
     */
    csvDelay: number;
    /**
     *
     * The reserve amount in satoshis that we require the remote peer to adhere to.
     * We require that the remote peer always have some reserve amount allocated to
     * them so that there is always a disincentive to broadcast old state (if they
     * hold 0 sats on their side of the channel, there is nothing to lose).
     *
     * @generated from protobuf field: uint64 reserve_sat = 6;
     */
    reserveSat: number;
    /**
     *
     * The maximum amount of funds in millisatoshis that we allow the remote peer
     * to have in outstanding htlcs.
     *
     * @generated from protobuf field: uint64 in_flight_max_msat = 7;
     */
    inFlightMaxMsat: number;
    /**
     *
     * The maximum number of htlcs that the remote peer can offer us.
     *
     * @generated from protobuf field: uint32 max_htlc_count = 8;
     */
    maxHtlcCount: number;
    /**
     *
     * The minimum value in millisatoshis for incoming htlcs on the channel.
     *
     * @generated from protobuf field: uint64 min_htlc_in = 9;
     */
    minHtlcIn: number;
    /**
     *
     * The number of confirmations we require before we consider the channel open.
     *
     * @generated from protobuf field: uint32 min_accept_depth = 10;
     */
    minAcceptDepth: number;
    /**
     *
     * Whether the responder wants this to be a zero-conf channel. This will fail
     * if either side does not have the scid-alias feature bit set. The minimum
     * depth field must be zero if this is true.
     *
     * @generated from protobuf field: bool zero_conf = 11;
     */
    zeroConf: boolean;
}
/**
 * @generated from protobuf message lnrpc.ChannelPoint
 */
export interface ChannelPoint {
    /**
     * @generated from protobuf oneof: funding_txid
     */
    fundingTxid: {
        oneofKind: "fundingTxidBytes";
        /**
         *
         * Txid of the funding transaction. When using REST, this field must be
         * encoded as base64.
         *
         * @generated from protobuf field: bytes funding_txid_bytes = 1;
         */
        fundingTxidBytes: Uint8Array;
    } | {
        oneofKind: "fundingTxidStr";
        /**
         *
         * Hex-encoded string representing the byte-reversed hash of the funding
         * transaction.
         *
         * @generated from protobuf field: string funding_txid_str = 2;
         */
        fundingTxidStr: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * The index of the output of the funding transaction
     *
     * @generated from protobuf field: uint32 output_index = 3;
     */
    outputIndex: number;
}
/**
 * @generated from protobuf message lnrpc.OutPoint
 */
export interface OutPoint {
    /**
     * Raw bytes representing the transaction id.
     *
     * @generated from protobuf field: bytes txid_bytes = 1;
     */
    txidBytes: Uint8Array;
    /**
     * Reversed, hex-encoded string representing the transaction id.
     *
     * @generated from protobuf field: string txid_str = 2;
     */
    txidStr: string;
    /**
     * The index of the output on the transaction.
     *
     * @generated from protobuf field: uint32 output_index = 3;
     */
    outputIndex: number;
}
/**
 * @generated from protobuf message lnrpc.PreviousOutPoint
 */
export interface PreviousOutPoint {
    /**
     * The outpoint in format txid:n.
     *
     * @generated from protobuf field: string outpoint = 1;
     */
    outpoint: string;
    /**
     * Denotes if the outpoint is controlled by the internal wallet.
     * The flag will only detect p2wkh, np2wkh and p2tr inputs as its own.
     *
     * @generated from protobuf field: bool is_our_output = 2;
     */
    isOurOutput: boolean;
}
/**
 * @generated from protobuf message lnrpc.LightningAddress
 */
export interface LightningAddress {
    /**
     * The identity pubkey of the Lightning node.
     *
     * @generated from protobuf field: string pubkey = 1;
     */
    pubkey: string;
    /**
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`.
     *
     * @generated from protobuf field: string host = 2;
     */
    host: string;
}
/**
 * @generated from protobuf message lnrpc.EstimateFeeRequest
 */
export interface EstimateFeeRequest {
    /**
     * The map from addresses to amounts for the transaction.
     *
     * @generated from protobuf field: map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"];
     */
    addrToAmount: {
        [key: string]: number;
    };
    /**
     * The target number of blocks that this transaction should be confirmed
     * by.
     *
     * @generated from protobuf field: int32 target_conf = 2;
     */
    targetConf: number;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 3;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 4;
     */
    spendUnconfirmed: boolean;
}
/**
 * @generated from protobuf message lnrpc.EstimateFeeResponse
 */
export interface EstimateFeeResponse {
    /**
     * The total fee in satoshis.
     *
     * @generated from protobuf field: int64 fee_sat = 1;
     */
    feeSat: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * The fee rate in satoshi/vbyte.
     *
     * @deprecated
     * @generated from protobuf field: int64 feerate_sat_per_byte = 2 [deprecated = true];
     */
    feerateSatPerByte: number;
    /**
     * The fee rate in satoshi/vbyte.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 3;
     */
    satPerVbyte: number;
}
/**
 * @generated from protobuf message lnrpc.SendManyRequest
 */
export interface SendManyRequest {
    /**
     * The map from addresses to amounts
     *
     * @generated from protobuf field: map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"];
     */
    addrToAmount: {
        [key: string]: number;
    };
    /**
     * The target number of blocks that this transaction should be confirmed
     * by.
     *
     * @generated from protobuf field: int32 target_conf = 3;
     */
    targetConf: number;
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 4;
     */
    satPerVbyte: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 5 [deprecated = true];
     */
    satPerByte: number;
    /**
     * An optional label for the transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 6;
     */
    label: string;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 7;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 8;
     */
    spendUnconfirmed: boolean;
}
/**
 * @generated from protobuf message lnrpc.SendManyResponse
 */
export interface SendManyResponse {
    /**
     * The id of the transaction
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message lnrpc.SendCoinsRequest
 */
export interface SendCoinsRequest {
    /**
     * The address to send coins to
     *
     * @generated from protobuf field: string addr = 1;
     */
    addr: string;
    /**
     * The amount in satoshis to send
     *
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: number;
    /**
     * The target number of blocks that this transaction should be confirmed
     * by.
     *
     * @generated from protobuf field: int32 target_conf = 3;
     */
    targetConf: number;
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 4;
     */
    satPerVbyte: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 5 [deprecated = true];
     */
    satPerByte: number;
    /**
     *
     * If set, then the amount field will be ignored, and lnd will attempt to
     * send all the coins under control of the internal wallet to the specified
     * address.
     *
     * @generated from protobuf field: bool send_all = 6;
     */
    sendAll: boolean;
    /**
     * An optional label for the transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 7;
     */
    label: string;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 8;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 9;
     */
    spendUnconfirmed: boolean;
}
/**
 * @generated from protobuf message lnrpc.SendCoinsResponse
 */
export interface SendCoinsResponse {
    /**
     * The transaction ID of the transaction
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message lnrpc.ListUnspentRequest
 */
export interface ListUnspentRequest {
    /**
     * The minimum number of confirmations to be included.
     *
     * @generated from protobuf field: int32 min_confs = 1;
     */
    minConfs: number;
    /**
     * The maximum number of confirmations to be included.
     *
     * @generated from protobuf field: int32 max_confs = 2;
     */
    maxConfs: number;
    /**
     * An optional filter to only include outputs belonging to an account.
     *
     * @generated from protobuf field: string account = 3;
     */
    account: string;
}
/**
 * @generated from protobuf message lnrpc.ListUnspentResponse
 */
export interface ListUnspentResponse {
    /**
     * A list of utxos
     *
     * @generated from protobuf field: repeated lnrpc.Utxo utxos = 1;
     */
    utxos: Utxo[];
}
/**
 * @generated from protobuf message lnrpc.NewAddressRequest
 */
export interface NewAddressRequest {
    /**
     * The type of address to generate.
     *
     * @generated from protobuf field: lnrpc.AddressType type = 1;
     */
    type: AddressType;
    /**
     *
     * The name of the account to generate a new address for. If empty, the
     * default wallet account is used.
     *
     * @generated from protobuf field: string account = 2;
     */
    account: string;
}
/**
 * @generated from protobuf message lnrpc.NewAddressResponse
 */
export interface NewAddressResponse {
    /**
     * The newly generated wallet address
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message lnrpc.SignMessageRequest
 */
export interface SignMessageRequest {
    /**
     *
     * The message to be signed. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     *
     * Instead of the default double-SHA256 hashing of the message before signing,
     * only use one round of hashing instead.
     *
     * @generated from protobuf field: bool single_hash = 2;
     */
    singleHash: boolean;
}
/**
 * @generated from protobuf message lnrpc.SignMessageResponse
 */
export interface SignMessageResponse {
    /**
     * The signature for the given message
     *
     * @generated from protobuf field: string signature = 1;
     */
    signature: string;
}
/**
 * @generated from protobuf message lnrpc.VerifyMessageRequest
 */
export interface VerifyMessageRequest {
    /**
     *
     * The message over which the signature is to be verified. When using REST,
     * this field must be encoded as base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     * The signature to be verified over the given message
     *
     * @generated from protobuf field: string signature = 2;
     */
    signature: string;
}
/**
 * @generated from protobuf message lnrpc.VerifyMessageResponse
 */
export interface VerifyMessageResponse {
    /**
     * Whether the signature was valid over the given message
     *
     * @generated from protobuf field: bool valid = 1;
     */
    valid: boolean;
    /**
     * The pubkey recovered from the signature
     *
     * @generated from protobuf field: string pubkey = 2;
     */
    pubkey: string;
}
/**
 * @generated from protobuf message lnrpc.ConnectPeerRequest
 */
export interface ConnectPeerRequest {
    /**
     *
     * Lightning address of the peer to connect to.
     *
     * @generated from protobuf field: lnrpc.LightningAddress addr = 1;
     */
    addr?: LightningAddress;
    /**
     *
     * If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous.
     *
     * @generated from protobuf field: bool perm = 2;
     */
    perm: boolean;
    /**
     *
     * The connection timeout value (in seconds) for this request. It won't affect
     * other requests.
     *
     * @generated from protobuf field: uint64 timeout = 3;
     */
    timeout: number;
}
/**
 * @generated from protobuf message lnrpc.ConnectPeerResponse
 */
export interface ConnectPeerResponse {
}
/**
 * @generated from protobuf message lnrpc.DisconnectPeerRequest
 */
export interface DisconnectPeerRequest {
    /**
     * The pubkey of the node to disconnect from
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
}
/**
 * @generated from protobuf message lnrpc.DisconnectPeerResponse
 */
export interface DisconnectPeerResponse {
}
/**
 * @generated from protobuf message lnrpc.HTLC
 */
export interface HTLC {
    /**
     * @generated from protobuf field: bool incoming = 1;
     */
    incoming: boolean;
    /**
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: number;
    /**
     * @generated from protobuf field: bytes hash_lock = 3;
     */
    hashLock: Uint8Array;
    /**
     * @generated from protobuf field: uint32 expiration_height = 4;
     */
    expirationHeight: number;
    /**
     * Index identifying the htlc on the channel.
     *
     * @generated from protobuf field: uint64 htlc_index = 5;
     */
    htlcIndex: number;
    /**
     * If this HTLC is involved in a forwarding operation, this field indicates
     * the forwarding channel. For an outgoing htlc, it is the incoming channel.
     * For an incoming htlc, it is the outgoing channel. When the htlc
     * originates from this node or this node is the final destination,
     * forwarding_channel will be zero. The forwarding channel will also be zero
     * for htlcs that need to be forwarded but don't have a forwarding decision
     * persisted yet.
     *
     * @generated from protobuf field: uint64 forwarding_channel = 6;
     */
    forwardingChannel: number;
    /**
     * Index identifying the htlc on the forwarding channel.
     *
     * @generated from protobuf field: uint64 forwarding_htlc_index = 7;
     */
    forwardingHtlcIndex: number;
}
/**
 * @generated from protobuf message lnrpc.ChannelConstraints
 */
export interface ChannelConstraints {
    /**
     *
     * The CSV delay expressed in relative blocks. If the channel is force closed,
     * we will need to wait for this many blocks before we can regain our funds.
     *
     * @generated from protobuf field: uint32 csv_delay = 1;
     */
    csvDelay: number;
    /**
     * The minimum satoshis this node is required to reserve in its balance.
     *
     * @generated from protobuf field: uint64 chan_reserve_sat = 2;
     */
    chanReserveSat: number;
    /**
     * The dust limit (in satoshis) of the initiator's commitment tx.
     *
     * @generated from protobuf field: uint64 dust_limit_sat = 3;
     */
    dustLimitSat: number;
    /**
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     *
     * @generated from protobuf field: uint64 max_pending_amt_msat = 4;
     */
    maxPendingAmtMsat: number;
    /**
     * The smallest HTLC in millisatoshis that the initiator will accept.
     *
     * @generated from protobuf field: uint64 min_htlc_msat = 5;
     */
    minHtlcMsat: number;
    /**
     * The total number of incoming HTLC's that the initiator will accept.
     *
     * @generated from protobuf field: uint32 max_accepted_htlcs = 6;
     */
    maxAcceptedHtlcs: number;
}
/**
 * @generated from protobuf message lnrpc.Channel
 */
export interface Channel {
    /**
     * Whether this channel is active or not
     *
     * @generated from protobuf field: bool active = 1;
     */
    active: boolean;
    /**
     * The identity pubkey of the remote node
     *
     * @generated from protobuf field: string remote_pubkey = 2;
     */
    remotePubkey: string;
    /**
     *
     * The outpoint (txid:index) of the funding transaction. With this value, Bob
     * will be able to generate a signature for Alice's version of the commitment
     * transaction.
     *
     * @generated from protobuf field: string channel_point = 3;
     */
    channelPoint: string;
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 4 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The total amount of funds held in this channel
     *
     * @generated from protobuf field: int64 capacity = 5;
     */
    capacity: number;
    /**
     * This node's current balance in this channel
     *
     * @generated from protobuf field: int64 local_balance = 6;
     */
    localBalance: number;
    /**
     * The counterparty's current balance in this channel
     *
     * @generated from protobuf field: int64 remote_balance = 7;
     */
    remoteBalance: number;
    /**
     *
     * The amount calculated to be paid in fees for the current set of commitment
     * transactions. The fee amount is persisted with the channel in order to
     * allow the fee amount to be removed and recalculated with each channel state
     * update, including updates that happen after a system restart.
     *
     * @generated from protobuf field: int64 commit_fee = 8;
     */
    commitFee: number;
    /**
     * The weight of the commitment transaction
     *
     * @generated from protobuf field: int64 commit_weight = 9;
     */
    commitWeight: number;
    /**
     *
     * The required number of satoshis per kilo-weight that the requester will pay
     * at all times, for both the funding transaction and commitment transaction.
     * This value can later be updated once the channel is open.
     *
     * @generated from protobuf field: int64 fee_per_kw = 10;
     */
    feePerKw: number;
    /**
     * The unsettled balance in this channel
     *
     * @generated from protobuf field: int64 unsettled_balance = 11;
     */
    unsettledBalance: number;
    /**
     *
     * The total number of satoshis we've sent within this channel.
     *
     * @generated from protobuf field: int64 total_satoshis_sent = 12;
     */
    totalSatoshisSent: number;
    /**
     *
     * The total number of satoshis we've received within this channel.
     *
     * @generated from protobuf field: int64 total_satoshis_received = 13;
     */
    totalSatoshisReceived: number;
    /**
     *
     * The total number of updates conducted within this channel.
     *
     * @generated from protobuf field: uint64 num_updates = 14;
     */
    numUpdates: number;
    /**
     *
     * The list of active, uncleared HTLCs currently pending within the channel.
     *
     * @generated from protobuf field: repeated lnrpc.HTLC pending_htlcs = 15;
     */
    pendingHtlcs: HTLC[];
    /**
     *
     * Deprecated. The CSV delay expressed in relative blocks. If the channel is
     * force closed, we will need to wait for this many blocks before we can regain
     * our funds.
     *
     * @deprecated
     * @generated from protobuf field: uint32 csv_delay = 16 [deprecated = true];
     */
    csvDelay: number;
    /**
     * Whether this channel is advertised to the network or not.
     *
     * @generated from protobuf field: bool private = 17;
     */
    private: boolean;
    /**
     * True if we were the ones that created the channel.
     *
     * @generated from protobuf field: bool initiator = 18;
     */
    initiator: boolean;
    /**
     * A set of flags showing the current state of the channel.
     *
     * @generated from protobuf field: string chan_status_flags = 19;
     */
    chanStatusFlags: string;
    /**
     * Deprecated. The minimum satoshis this node is required to reserve in its
     * balance.
     *
     * @deprecated
     * @generated from protobuf field: int64 local_chan_reserve_sat = 20 [deprecated = true];
     */
    localChanReserveSat: number;
    /**
     *
     * Deprecated. The minimum satoshis the other node is required to reserve in
     * its balance.
     *
     * @deprecated
     * @generated from protobuf field: int64 remote_chan_reserve_sat = 21 [deprecated = true];
     */
    remoteChanReserveSat: number;
    /**
     * Deprecated. Use commitment_type.
     *
     * @deprecated
     * @generated from protobuf field: bool static_remote_key = 22 [deprecated = true];
     */
    staticRemoteKey: boolean;
    /**
     * The commitment type used by this channel.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 26;
     */
    commitmentType: CommitmentType;
    /**
     *
     * The number of seconds that the channel has been monitored by the channel
     * scoring system. Scores are currently not persisted, so this value may be
     * less than the lifetime of the channel [EXPERIMENTAL].
     *
     * @generated from protobuf field: int64 lifetime = 23;
     */
    lifetime: number;
    /**
     *
     * The number of seconds that the remote peer has been observed as being online
     * by the channel scoring system over the lifetime of the channel
     * [EXPERIMENTAL].
     *
     * @generated from protobuf field: int64 uptime = 24;
     */
    uptime: number;
    /**
     *
     * Close address is the address that we will enforce payout to on cooperative
     * close if the channel was opened utilizing option upfront shutdown. This
     * value can be set on channel open by setting close_address in an open channel
     * request. If this value is not set, you can still choose a payout address by
     * cooperatively closing with the delivery_address field set.
     *
     * @generated from protobuf field: string close_address = 25;
     */
    closeAddress: string;
    /**
     *
     * The amount that the initiator of the channel optionally pushed to the remote
     * party on channel open. This amount will be zero if the channel initiator did
     * not push any funds to the remote peer. If the initiator field is true, we
     * pushed this amount to our peer, if it is false, the remote peer pushed this
     * amount to us.
     *
     * @generated from protobuf field: uint64 push_amount_sat = 27;
     */
    pushAmountSat: number;
    /**
     *
     * This uint32 indicates if this channel is to be considered 'frozen'. A
     * frozen channel doest not allow a cooperative channel close by the
     * initiator. The thaw_height is the height that this restriction stops
     * applying to the channel. This field is optional, not setting it or using a
     * value of zero will mean the channel has no additional restrictions. The
     * height can be interpreted in two ways: as a relative height if the value is
     * less than 500,000, or as an absolute height otherwise.
     *
     * @generated from protobuf field: uint32 thaw_height = 28;
     */
    thawHeight: number;
    /**
     * List constraints for the local node.
     *
     * @generated from protobuf field: lnrpc.ChannelConstraints local_constraints = 29;
     */
    localConstraints?: ChannelConstraints;
    /**
     * List constraints for the remote node.
     *
     * @generated from protobuf field: lnrpc.ChannelConstraints remote_constraints = 30;
     */
    remoteConstraints?: ChannelConstraints;
    /**
     *
     * This lists out the set of alias short channel ids that exist for a channel.
     * This may be empty.
     *
     * @generated from protobuf field: repeated uint64 alias_scids = 31;
     */
    aliasScids: number[];
    /**
     * Whether or not this is a zero-conf channel.
     *
     * @generated from protobuf field: bool zero_conf = 32;
     */
    zeroConf: boolean;
    /**
     * This is the confirmed / on-chain zero-conf SCID.
     *
     * @generated from protobuf field: uint64 zero_conf_confirmed_scid = 33;
     */
    zeroConfConfirmedScid: number;
}
/**
 * @generated from protobuf message lnrpc.ListChannelsRequest
 */
export interface ListChannelsRequest {
    /**
     * @generated from protobuf field: bool active_only = 1;
     */
    activeOnly: boolean;
    /**
     * @generated from protobuf field: bool inactive_only = 2;
     */
    inactiveOnly: boolean;
    /**
     * @generated from protobuf field: bool public_only = 3;
     */
    publicOnly: boolean;
    /**
     * @generated from protobuf field: bool private_only = 4;
     */
    privateOnly: boolean;
    /**
     *
     * Filters the response for channels with a target peer's pubkey. If peer is
     * empty, all channels will be returned.
     *
     * @generated from protobuf field: bytes peer = 5;
     */
    peer: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.ListChannelsResponse
 */
export interface ListChannelsResponse {
    /**
     * The list of active channels
     *
     * @generated from protobuf field: repeated lnrpc.Channel channels = 11;
     */
    channels: Channel[];
}
/**
 * @generated from protobuf message lnrpc.AliasMap
 */
export interface AliasMap {
    /**
     *
     * For non-zero-conf channels, this is the confirmed SCID. Otherwise, this is
     * the first assigned "base" alias.
     *
     * @generated from protobuf field: uint64 base_scid = 1;
     */
    baseScid: number;
    /**
     * The set of all aliases stored for the base SCID.
     *
     * @generated from protobuf field: repeated uint64 aliases = 2;
     */
    aliases: number[];
}
/**
 * @generated from protobuf message lnrpc.ListAliasesRequest
 */
export interface ListAliasesRequest {
}
/**
 * @generated from protobuf message lnrpc.ListAliasesResponse
 */
export interface ListAliasesResponse {
    /**
     * @generated from protobuf field: repeated lnrpc.AliasMap alias_maps = 1;
     */
    aliasMaps: AliasMap[];
}
/**
 * @generated from protobuf message lnrpc.ChannelCloseSummary
 */
export interface ChannelCloseSummary {
    /**
     * The outpoint (txid:index) of the funding transaction.
     *
     * @generated from protobuf field: string channel_point = 1;
     */
    channelPoint: string;
    /**
     *  The unique channel ID for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 2 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The hash of the genesis block that this channel resides within.
     *
     * @generated from protobuf field: string chain_hash = 3;
     */
    chainHash: string;
    /**
     * The txid of the transaction which ultimately closed this channel.
     *
     * @generated from protobuf field: string closing_tx_hash = 4;
     */
    closingTxHash: string;
    /**
     * Public key of the remote peer that we formerly had a channel with.
     *
     * @generated from protobuf field: string remote_pubkey = 5;
     */
    remotePubkey: string;
    /**
     * Total capacity of the channel.
     *
     * @generated from protobuf field: int64 capacity = 6;
     */
    capacity: number;
    /**
     * Height at which the funding transaction was spent.
     *
     * @generated from protobuf field: uint32 close_height = 7;
     */
    closeHeight: number;
    /**
     * Settled balance at the time of channel closure
     *
     * @generated from protobuf field: int64 settled_balance = 8;
     */
    settledBalance: number;
    /**
     * The sum of all the time-locked outputs at the time of channel closure
     *
     * @generated from protobuf field: int64 time_locked_balance = 9;
     */
    timeLockedBalance: number;
    /**
     * Details on how the channel was closed.
     *
     * @generated from protobuf field: lnrpc.ChannelCloseSummary.ClosureType close_type = 10;
     */
    closeType: ChannelCloseSummary_ClosureType;
    /**
     *
     * Open initiator is the party that initiated opening the channel. Note that
     * this value may be unknown if the channel was closed before we migrated to
     * store open channel information after close.
     *
     * @generated from protobuf field: lnrpc.Initiator open_initiator = 11;
     */
    openInitiator: Initiator;
    /**
     *
     * Close initiator indicates which party initiated the close. This value will
     * be unknown for channels that were cooperatively closed before we started
     * tracking cooperative close initiators. Note that this indicates which party
     * initiated a close, and it is possible for both to initiate cooperative or
     * force closes, although only one party's close will be confirmed on chain.
     *
     * @generated from protobuf field: lnrpc.Initiator close_initiator = 12;
     */
    closeInitiator: Initiator;
    /**
     * @generated from protobuf field: repeated lnrpc.Resolution resolutions = 13;
     */
    resolutions: Resolution[];
    /**
     *
     * This lists out the set of alias short channel ids that existed for the
     * closed channel. This may be empty.
     *
     * @generated from protobuf field: repeated uint64 alias_scids = 14;
     */
    aliasScids: number[];
    /**
     *  The confirmed SCID for a zero-conf channel.
     *
     * @generated from protobuf field: uint64 zero_conf_confirmed_scid = 15 [jstype = JS_STRING];
     */
    zeroConfConfirmedScid: string;
}
/**
 * @generated from protobuf enum lnrpc.ChannelCloseSummary.ClosureType
 */
export declare enum ChannelCloseSummary_ClosureType {
    /**
     * @generated from protobuf enum value: COOPERATIVE_CLOSE = 0;
     */
    COOPERATIVE_CLOSE = 0,
    /**
     * @generated from protobuf enum value: LOCAL_FORCE_CLOSE = 1;
     */
    LOCAL_FORCE_CLOSE = 1,
    /**
     * @generated from protobuf enum value: REMOTE_FORCE_CLOSE = 2;
     */
    REMOTE_FORCE_CLOSE = 2,
    /**
     * @generated from protobuf enum value: BREACH_CLOSE = 3;
     */
    BREACH_CLOSE = 3,
    /**
     * @generated from protobuf enum value: FUNDING_CANCELED = 4;
     */
    FUNDING_CANCELED = 4,
    /**
     * @generated from protobuf enum value: ABANDONED = 5;
     */
    ABANDONED = 5
}
/**
 * @generated from protobuf message lnrpc.Resolution
 */
export interface Resolution {
    /**
     * The type of output we are resolving.
     *
     * @generated from protobuf field: lnrpc.ResolutionType resolution_type = 1;
     */
    resolutionType: ResolutionType;
    /**
     * The outcome of our on chain action that resolved the outpoint.
     *
     * @generated from protobuf field: lnrpc.ResolutionOutcome outcome = 2;
     */
    outcome: ResolutionOutcome;
    /**
     * The outpoint that was spent by the resolution.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 3;
     */
    outpoint?: OutPoint;
    /**
     * The amount that was claimed by the resolution.
     *
     * @generated from protobuf field: uint64 amount_sat = 4;
     */
    amountSat: number;
    /**
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     *
     * @generated from protobuf field: string sweep_txid = 5;
     */
    sweepTxid: string;
}
/**
 * @generated from protobuf message lnrpc.ClosedChannelsRequest
 */
export interface ClosedChannelsRequest {
    /**
     * @generated from protobuf field: bool cooperative = 1;
     */
    cooperative: boolean;
    /**
     * @generated from protobuf field: bool local_force = 2;
     */
    localForce: boolean;
    /**
     * @generated from protobuf field: bool remote_force = 3;
     */
    remoteForce: boolean;
    /**
     * @generated from protobuf field: bool breach = 4;
     */
    breach: boolean;
    /**
     * @generated from protobuf field: bool funding_canceled = 5;
     */
    fundingCanceled: boolean;
    /**
     * @generated from protobuf field: bool abandoned = 6;
     */
    abandoned: boolean;
}
/**
 * @generated from protobuf message lnrpc.ClosedChannelsResponse
 */
export interface ClosedChannelsResponse {
    /**
     * @generated from protobuf field: repeated lnrpc.ChannelCloseSummary channels = 1;
     */
    channels: ChannelCloseSummary[];
}
/**
 * @generated from protobuf message lnrpc.Peer
 */
export interface Peer {
    /**
     * The identity pubkey of the peer
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     * Network address of the peer; eg `127.0.0.1:10011`
     *
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * Bytes of data transmitted to this peer
     *
     * @generated from protobuf field: uint64 bytes_sent = 4;
     */
    bytesSent: number;
    /**
     * Bytes of data transmitted from this peer
     *
     * @generated from protobuf field: uint64 bytes_recv = 5;
     */
    bytesRecv: number;
    /**
     * Satoshis sent to this peer
     *
     * @generated from protobuf field: int64 sat_sent = 6;
     */
    satSent: number;
    /**
     * Satoshis received from this peer
     *
     * @generated from protobuf field: int64 sat_recv = 7;
     */
    satRecv: number;
    /**
     * A channel is inbound if the counterparty initiated the channel
     *
     * @generated from protobuf field: bool inbound = 8;
     */
    inbound: boolean;
    /**
     * Ping time to this peer
     *
     * @generated from protobuf field: int64 ping_time = 9;
     */
    pingTime: number;
    /**
     * The type of sync we are currently performing with this peer.
     *
     * @generated from protobuf field: lnrpc.Peer.SyncType sync_type = 10;
     */
    syncType: Peer_SyncType;
    /**
     * Features advertised by the remote peer in their init message.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 11;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     *
     * The latest errors received from our peer with timestamps, limited to the 10
     * most recent errors. These errors are tracked across peer connections, but
     * are not persisted across lnd restarts. Note that these errors are only
     * stored for peers that we have channels open with, to prevent peers from
     * spamming us with errors at no cost.
     *
     * @generated from protobuf field: repeated lnrpc.TimestampedError errors = 12;
     */
    errors: TimestampedError[];
    /**
     *
     * The number of times we have recorded this peer going offline or coming
     * online, recorded across restarts. Note that this value is decreased over
     * time if the peer has not recently flapped, so that we can forgive peers
     * with historically high flap counts.
     *
     * @generated from protobuf field: int32 flap_count = 13;
     */
    flapCount: number;
    /**
     *
     * The timestamp of the last flap we observed for this peer. If this value is
     * zero, we have not observed any flaps for this peer.
     *
     * @generated from protobuf field: int64 last_flap_ns = 14;
     */
    lastFlapNs: number;
    /**
     *
     * The last ping payload the peer has sent to us.
     *
     * @generated from protobuf field: bytes last_ping_payload = 15;
     */
    lastPingPayload: Uint8Array;
}
/**
 * @generated from protobuf enum lnrpc.Peer.SyncType
 */
export declare enum Peer_SyncType {
    /**
     *
     * Denotes that we cannot determine the peer's current sync type.
     *
     * @generated from protobuf enum value: UNKNOWN_SYNC = 0;
     */
    UNKNOWN_SYNC = 0,
    /**
     *
     * Denotes that we are actively receiving new graph updates from the peer.
     *
     * @generated from protobuf enum value: ACTIVE_SYNC = 1;
     */
    ACTIVE_SYNC = 1,
    /**
     *
     * Denotes that we are not receiving new graph updates from the peer.
     *
     * @generated from protobuf enum value: PASSIVE_SYNC = 2;
     */
    PASSIVE_SYNC = 2,
    /**
     *
     * Denotes that this peer is pinned into an active sync.
     *
     * @generated from protobuf enum value: PINNED_SYNC = 3;
     */
    PINNED_SYNC = 3
}
/**
 * @generated from protobuf message lnrpc.TimestampedError
 */
export interface TimestampedError {
    /**
     * The unix timestamp in seconds when the error occurred.
     *
     * @generated from protobuf field: uint64 timestamp = 1;
     */
    timestamp: number;
    /**
     * The string representation of the error sent by our peer.
     *
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message lnrpc.ListPeersRequest
 */
export interface ListPeersRequest {
    /**
     *
     * If true, only the last error that our peer sent us will be returned with
     * the peer's information, rather than the full set of historic errors we have
     * stored.
     *
     * @generated from protobuf field: bool latest_error = 1;
     */
    latestError: boolean;
}
/**
 * @generated from protobuf message lnrpc.ListPeersResponse
 */
export interface ListPeersResponse {
    /**
     * The list of currently connected peers
     *
     * @generated from protobuf field: repeated lnrpc.Peer peers = 1;
     */
    peers: Peer[];
}
/**
 * @generated from protobuf message lnrpc.PeerEventSubscription
 */
export interface PeerEventSubscription {
}
/**
 * @generated from protobuf message lnrpc.PeerEvent
 */
export interface PeerEvent {
    /**
     * The identity pubkey of the peer.
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     * @generated from protobuf field: lnrpc.PeerEvent.EventType type = 2;
     */
    type: PeerEvent_EventType;
}
/**
 * @generated from protobuf enum lnrpc.PeerEvent.EventType
 */
export declare enum PeerEvent_EventType {
    /**
     * @generated from protobuf enum value: PEER_ONLINE = 0;
     */
    PEER_ONLINE = 0,
    /**
     * @generated from protobuf enum value: PEER_OFFLINE = 1;
     */
    PEER_OFFLINE = 1
}
/**
 * @generated from protobuf message lnrpc.GetInfoRequest
 */
export interface GetInfoRequest {
}
/**
 * @generated from protobuf message lnrpc.GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * The version of the LND software that the node is running.
     *
     * @generated from protobuf field: string version = 14;
     */
    version: string;
    /**
     * The SHA1 commit hash that the daemon is compiled with.
     *
     * @generated from protobuf field: string commit_hash = 20;
     */
    commitHash: string;
    /**
     * The identity pubkey of the current node.
     *
     * @generated from protobuf field: string identity_pubkey = 1;
     */
    identityPubkey: string;
    /**
     * If applicable, the alias of the current node, e.g. "bob"
     *
     * @generated from protobuf field: string alias = 2;
     */
    alias: string;
    /**
     * The color of the current node in hex code format
     *
     * @generated from protobuf field: string color = 17;
     */
    color: string;
    /**
     * Number of pending channels
     *
     * @generated from protobuf field: uint32 num_pending_channels = 3;
     */
    numPendingChannels: number;
    /**
     * Number of active channels
     *
     * @generated from protobuf field: uint32 num_active_channels = 4;
     */
    numActiveChannels: number;
    /**
     * Number of inactive channels
     *
     * @generated from protobuf field: uint32 num_inactive_channels = 15;
     */
    numInactiveChannels: number;
    /**
     * Number of peers
     *
     * @generated from protobuf field: uint32 num_peers = 5;
     */
    numPeers: number;
    /**
     * The node's current view of the height of the best block
     *
     * @generated from protobuf field: uint32 block_height = 6;
     */
    blockHeight: number;
    /**
     * The node's current view of the hash of the best block
     *
     * @generated from protobuf field: string block_hash = 8;
     */
    blockHash: string;
    /**
     * Timestamp of the block best known to the wallet
     *
     * @generated from protobuf field: int64 best_header_timestamp = 13;
     */
    bestHeaderTimestamp: number;
    /**
     * Whether the wallet's view is synced to the main chain
     *
     * @generated from protobuf field: bool synced_to_chain = 9;
     */
    syncedToChain: boolean;
    /**
     * Whether we consider ourselves synced with the public channel graph.
     *
     * @generated from protobuf field: bool synced_to_graph = 18;
     */
    syncedToGraph: boolean;
    /**
     *
     * Whether the current node is connected to testnet. This field is
     * deprecated and the network field should be used instead
     *
     * @deprecated
     * @generated from protobuf field: bool testnet = 10 [deprecated = true];
     */
    testnet: boolean;
    /**
     * A list of active chains the node is connected to
     *
     * @generated from protobuf field: repeated lnrpc.Chain chains = 16;
     */
    chains: Chain[];
    /**
     * The URIs of the current node.
     *
     * @generated from protobuf field: repeated string uris = 12;
     */
    uris: string[];
    /**
     *
     * Features that our node has advertised in our init message, node
     * announcements and invoices.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 19;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     *
     * Indicates whether the HTLC interceptor API is in always-on mode.
     *
     * @generated from protobuf field: bool require_htlc_interceptor = 21;
     */
    requireHtlcInterceptor: boolean;
}
/**
 * @generated from protobuf message lnrpc.GetRecoveryInfoRequest
 */
export interface GetRecoveryInfoRequest {
}
/**
 * @generated from protobuf message lnrpc.GetRecoveryInfoResponse
 */
export interface GetRecoveryInfoResponse {
    /**
     * Whether the wallet is in recovery mode
     *
     * @generated from protobuf field: bool recovery_mode = 1;
     */
    recoveryMode: boolean;
    /**
     * Whether the wallet recovery progress is finished
     *
     * @generated from protobuf field: bool recovery_finished = 2;
     */
    recoveryFinished: boolean;
    /**
     * The recovery progress, ranging from 0 to 1.
     *
     * @generated from protobuf field: double progress = 3;
     */
    progress: number;
}
/**
 * @generated from protobuf message lnrpc.Chain
 */
export interface Chain {
    /**
     * The blockchain the node is on (eg bitcoin, litecoin)
     *
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * The network the node is on (eg regtest, testnet, mainnet)
     *
     * @generated from protobuf field: string network = 2;
     */
    network: string;
}
/**
 * @generated from protobuf message lnrpc.ConfirmationUpdate
 */
export interface ConfirmationUpdate {
    /**
     * @generated from protobuf field: bytes block_sha = 1;
     */
    blockSha: Uint8Array;
    /**
     * @generated from protobuf field: int32 block_height = 2;
     */
    blockHeight: number;
    /**
     * @generated from protobuf field: uint32 num_confs_left = 3;
     */
    numConfsLeft: number;
}
/**
 * @generated from protobuf message lnrpc.ChannelOpenUpdate
 */
export interface ChannelOpenUpdate {
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint channel_point = 1;
     */
    channelPoint?: ChannelPoint;
}
/**
 * @generated from protobuf message lnrpc.ChannelCloseUpdate
 */
export interface ChannelCloseUpdate {
    /**
     * @generated from protobuf field: bytes closing_txid = 1;
     */
    closingTxid: Uint8Array;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
}
/**
 * @generated from protobuf message lnrpc.CloseChannelRequest
 */
export interface CloseChannelRequest {
    /**
     *
     * The outpoint (txid:index) of the funding transaction. With this value, Bob
     * will be able to generate a signature for Alice's version of the commitment
     * transaction.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint channel_point = 1;
     */
    channelPoint?: ChannelPoint;
    /**
     * If true, then the channel will be closed forcibly. This means the
     * current commitment transaction will be signed and broadcast.
     *
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean;
    /**
     * The target number of blocks that the closure transaction should be
     * confirmed by.
     *
     * @generated from protobuf field: int32 target_conf = 3;
     */
    targetConf: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * closure transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 4 [deprecated = true];
     */
    satPerByte: number;
    /**
     *
     * An optional address to send funds to in the case of a cooperative close.
     * If the channel was opened with an upfront shutdown script and this field
     * is set, the request to close will fail because the channel must pay out
     * to the upfront shutdown addresss.
     *
     * @generated from protobuf field: string delivery_address = 5;
     */
    deliveryAddress: string;
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * closure transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 6;
     */
    satPerVbyte: number;
    /**
     * The maximum fee rate the closer is willing to pay.
     *
     * NOTE: This field is only respected if we're the initiator of the channel.
     *
     * @generated from protobuf field: uint64 max_fee_per_vbyte = 7;
     */
    maxFeePerVbyte: number;
}
/**
 * @generated from protobuf message lnrpc.CloseStatusUpdate
 */
export interface CloseStatusUpdate {
    /**
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "closePending";
        /**
         * @generated from protobuf field: lnrpc.PendingUpdate close_pending = 1;
         */
        closePending: PendingUpdate;
    } | {
        oneofKind: "chanClose";
        /**
         * @generated from protobuf field: lnrpc.ChannelCloseUpdate chan_close = 3;
         */
        chanClose: ChannelCloseUpdate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.PendingUpdate
 */
export interface PendingUpdate {
    /**
     * @generated from protobuf field: bytes txid = 1;
     */
    txid: Uint8Array;
    /**
     * @generated from protobuf field: uint32 output_index = 2;
     */
    outputIndex: number;
}
/**
 * @generated from protobuf message lnrpc.ReadyForPsbtFunding
 */
export interface ReadyForPsbtFunding {
    /**
     *
     * The P2WSH address of the channel funding multisig address that the below
     * specified amount in satoshis needs to be sent to.
     *
     * @generated from protobuf field: string funding_address = 1;
     */
    fundingAddress: string;
    /**
     *
     * The exact amount in satoshis that needs to be sent to the above address to
     * fund the pending channel.
     *
     * @generated from protobuf field: int64 funding_amount = 2;
     */
    fundingAmount: number;
    /**
     *
     * A raw PSBT that contains the pending channel output. If a base PSBT was
     * provided in the PsbtShim, this is the base PSBT with one additional output.
     * If no base PSBT was specified, this is an otherwise empty PSBT with exactly
     * one output.
     *
     * @generated from protobuf field: bytes psbt = 3;
     */
    psbt: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.BatchOpenChannelRequest
 */
export interface BatchOpenChannelRequest {
    /**
     * The list of channels to open.
     *
     * @generated from protobuf field: repeated lnrpc.BatchOpenChannel channels = 1;
     */
    channels: BatchOpenChannel[];
    /**
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     *
     * @generated from protobuf field: int32 target_conf = 2;
     */
    targetConf: number;
    /**
     * A manual fee rate set in sat/vByte that should be used when crafting the
     * funding transaction.
     *
     * @generated from protobuf field: int64 sat_per_vbyte = 3;
     */
    satPerVbyte: number;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 4;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 5;
     */
    spendUnconfirmed: boolean;
    /**
     * An optional label for the batch transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 6;
     */
    label: string;
}
/**
 * @generated from protobuf message lnrpc.BatchOpenChannel
 */
export interface BatchOpenChannel {
    /**
     * The pubkey of the node to open a channel with. When using REST, this
     * field must be encoded as base64.
     *
     * @generated from protobuf field: bytes node_pubkey = 1;
     */
    nodePubkey: Uint8Array;
    /**
     * The number of satoshis the wallet should commit to the channel.
     *
     * @generated from protobuf field: int64 local_funding_amount = 2;
     */
    localFundingAmount: number;
    /**
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state.
     *
     * @generated from protobuf field: int64 push_sat = 3;
     */
    pushSat: number;
    /**
     * Whether this channel should be private, not announced to the greater
     * network.
     *
     * @generated from protobuf field: bool private = 4;
     */
    private: boolean;
    /**
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     *
     * @generated from protobuf field: int64 min_htlc_msat = 5;
     */
    minHtlcMsat: number;
    /**
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     *
     * @generated from protobuf field: uint32 remote_csv_delay = 6;
     */
    remoteCsvDelay: number;
    /**
     *
     * Close address is an optional address which specifies the address to which
     * funds should be paid out to upon cooperative close. This field may only be
     * set if the peer supports the option upfront feature bit (call listpeers
     * to check). The remote peer will only accept cooperative closes to this
     * address if it is set.
     *
     * Note: If this value is set on channel creation, you will *not* be able to
     * cooperatively close out to a different address.
     *
     * @generated from protobuf field: string close_address = 7;
     */
    closeAddress: string;
    /**
     *
     * An optional, unique identifier of 32 random bytes that will be used as the
     * pending channel ID to identify the channel while it is in the pre-pending
     * state.
     *
     * @generated from protobuf field: bytes pending_chan_id = 8;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * The explicit commitment type to use. Note this field will only be used if
     * the remote peer supports explicit channel negotiation.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 9;
     */
    commitmentType: CommitmentType;
}
/**
 * @generated from protobuf message lnrpc.BatchOpenChannelResponse
 */
export interface BatchOpenChannelResponse {
    /**
     * @generated from protobuf field: repeated lnrpc.PendingUpdate pending_channels = 1;
     */
    pendingChannels: PendingUpdate[];
}
/**
 * @generated from protobuf message lnrpc.OpenChannelRequest
 */
export interface OpenChannelRequest {
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * funding transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 1;
     */
    satPerVbyte: number;
    /**
     *
     * The pubkey of the node to open a channel with. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes node_pubkey = 2;
     */
    nodePubkey: Uint8Array;
    /**
     *
     * The hex encoded pubkey of the node to open a channel with. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string node_pubkey_string = 3 [deprecated = true];
     */
    nodePubkeyString: string;
    /**
     * The number of satoshis the wallet should commit to the channel
     *
     * @generated from protobuf field: int64 local_funding_amount = 4;
     */
    localFundingAmount: number;
    /**
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state
     *
     * @generated from protobuf field: int64 push_sat = 5;
     */
    pushSat: number;
    /**
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     *
     * @generated from protobuf field: int32 target_conf = 6;
     */
    targetConf: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * funding transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 7 [deprecated = true];
     */
    satPerByte: number;
    /**
     * Whether this channel should be private, not announced to the greater
     * network.
     *
     * @generated from protobuf field: bool private = 8;
     */
    private: boolean;
    /**
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     *
     * @generated from protobuf field: int64 min_htlc_msat = 9;
     */
    minHtlcMsat: number;
    /**
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     *
     * @generated from protobuf field: uint32 remote_csv_delay = 10;
     */
    remoteCsvDelay: number;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 11;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 12;
     */
    spendUnconfirmed: boolean;
    /**
     *
     * Close address is an optional address which specifies the address to which
     * funds should be paid out to upon cooperative close. This field may only be
     * set if the peer supports the option upfront feature bit (call listpeers
     * to check). The remote peer will only accept cooperative closes to this
     * address if it is set.
     *
     * Note: If this value is set on channel creation, you will *not* be able to
     * cooperatively close out to a different address.
     *
     * @generated from protobuf field: string close_address = 13;
     */
    closeAddress: string;
    /**
     *
     * Funding shims are an optional argument that allow the caller to intercept
     * certain funding functionality. For example, a shim can be provided to use a
     * particular key for the commitment key (ideally cold) rather than use one
     * that is generated by the wallet as normal, or signal that signing will be
     * carried out in an interactive manner (PSBT based).
     *
     * @generated from protobuf field: lnrpc.FundingShim funding_shim = 14;
     */
    fundingShim?: FundingShim;
    /**
     *
     * The maximum amount of coins in millisatoshi that can be pending within
     * the channel. It only applies to the remote party.
     *
     * @generated from protobuf field: uint64 remote_max_value_in_flight_msat = 15;
     */
    remoteMaxValueInFlightMsat: number;
    /**
     *
     * The maximum number of concurrent HTLCs we will allow the remote party to add
     * to the commitment transaction.
     *
     * @generated from protobuf field: uint32 remote_max_htlcs = 16;
     */
    remoteMaxHtlcs: number;
    /**
     *
     * Max local csv is the maximum csv delay we will allow for our own commitment
     * transaction.
     *
     * @generated from protobuf field: uint32 max_local_csv = 17;
     */
    maxLocalCsv: number;
    /**
     *
     * The explicit commitment type to use. Note this field will only be used if
     * the remote peer supports explicit channel negotiation.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 18;
     */
    commitmentType: CommitmentType;
    /**
     *
     * If this is true, then a zero-conf channel open will be attempted.
     *
     * @generated from protobuf field: bool zero_conf = 19;
     */
    zeroConf: boolean;
    /**
     *
     * If this is true, then an option-scid-alias channel-type open will be
     * attempted.
     *
     * @generated from protobuf field: bool scid_alias = 20;
     */
    scidAlias: boolean;
    /**
     *
     * The base fee charged regardless of the number of milli-satoshis sent.
     *
     * @generated from protobuf field: uint64 base_fee = 21;
     */
    baseFee: number;
    /**
     *
     * The fee rate in ppm (parts per million) that will be charged in
     * proportion of the value of each forwarded HTLC.
     *
     * @generated from protobuf field: uint64 fee_rate = 22;
     */
    feeRate: number;
    /**
     *
     * If use_base_fee is true the open channel announcement will update the
     * channel base fee with the value specified in base_fee. In the case of
     * a base_fee of 0 use_base_fee is needed downstream to distinguish whether
     * to use the default base fee value specified in the config or 0.
     *
     * @generated from protobuf field: bool use_base_fee = 23;
     */
    useBaseFee: boolean;
    /**
     *
     * If use_fee_rate is true the open channel announcement will update the
     * channel fee rate with the value specified in fee_rate. In the case of
     * a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
     * to use the default fee rate value specified in the config or 0.
     *
     * @generated from protobuf field: bool use_fee_rate = 24;
     */
    useFeeRate: boolean;
    /**
     *
     * The number of satoshis we require the remote peer to reserve. This value,
     * if specified, must be above the dust limit and below 20% of the channel
     * capacity.
     *
     * @generated from protobuf field: uint64 remote_chan_reserve_sat = 25;
     */
    remoteChanReserveSat: number;
}
/**
 * @generated from protobuf message lnrpc.OpenStatusUpdate
 */
export interface OpenStatusUpdate {
    /**
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "chanPending";
        /**
         *
         * Signals that the channel is now fully negotiated and the funding
         * transaction published.
         *
         * @generated from protobuf field: lnrpc.PendingUpdate chan_pending = 1;
         */
        chanPending: PendingUpdate;
    } | {
        oneofKind: "chanOpen";
        /**
         *
         * Signals that the channel's funding transaction has now reached the
         * required number of confirmations on chain and can be used.
         *
         * @generated from protobuf field: lnrpc.ChannelOpenUpdate chan_open = 3;
         */
        chanOpen: ChannelOpenUpdate;
    } | {
        oneofKind: "psbtFund";
        /**
         *
         * Signals that the funding process has been suspended and the construction
         * of a PSBT that funds the channel PK script is now required.
         *
         * @generated from protobuf field: lnrpc.ReadyForPsbtFunding psbt_fund = 5;
         */
        psbtFund: ReadyForPsbtFunding;
    } | {
        oneofKind: undefined;
    };
    /**
     *
     * The pending channel ID of the created channel. This value may be used to
     * further the funding flow manually via the FundingStateStep method.
     *
     * @generated from protobuf field: bytes pending_chan_id = 4;
     */
    pendingChanId: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.KeyLocator
 */
export interface KeyLocator {
    /**
     * The family of key being identified.
     *
     * @generated from protobuf field: int32 key_family = 1;
     */
    keyFamily: number;
    /**
     * The precise index of the key being identified.
     *
     * @generated from protobuf field: int32 key_index = 2;
     */
    keyIndex: number;
}
/**
 * @generated from protobuf message lnrpc.KeyDescriptor
 */
export interface KeyDescriptor {
    /**
     *
     * The raw bytes of the key being identified.
     *
     * @generated from protobuf field: bytes raw_key_bytes = 1;
     */
    rawKeyBytes: Uint8Array;
    /**
     *
     * The key locator that identifies which key to use for signing.
     *
     * @generated from protobuf field: lnrpc.KeyLocator key_loc = 2;
     */
    keyLoc?: KeyLocator;
}
/**
 * @generated from protobuf message lnrpc.ChanPointShim
 */
export interface ChanPointShim {
    /**
     *
     * The size of the pre-crafted output to be used as the channel point for this
     * channel funding.
     *
     * @generated from protobuf field: int64 amt = 1;
     */
    amt: number;
    /**
     * The target channel point to refrence in created commitment transactions.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 2;
     */
    chanPoint?: ChannelPoint;
    /**
     * Our local key to use when creating the multi-sig output.
     *
     * @generated from protobuf field: lnrpc.KeyDescriptor local_key = 3;
     */
    localKey?: KeyDescriptor;
    /**
     * The key of the remote party to use when creating the multi-sig output.
     *
     * @generated from protobuf field: bytes remote_key = 4;
     */
    remoteKey: Uint8Array;
    /**
     *
     * If non-zero, then this will be used as the pending channel ID on the wire
     * protocol to initate the funding request. This is an optional field, and
     * should only be set if the responder is already expecting a specific pending
     * channel ID.
     *
     * @generated from protobuf field: bytes pending_chan_id = 5;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * This uint32 indicates if this channel is to be considered 'frozen'. A frozen
     * channel does not allow a cooperative channel close by the initiator. The
     * thaw_height is the height that this restriction stops applying to the
     * channel. The height can be interpreted in two ways: as a relative height if
     * the value is less than 500,000, or as an absolute height otherwise.
     *
     * @generated from protobuf field: uint32 thaw_height = 6;
     */
    thawHeight: number;
}
/**
 * @generated from protobuf message lnrpc.PsbtShim
 */
export interface PsbtShim {
    /**
     *
     * A unique identifier of 32 random bytes that will be used as the pending
     * channel ID to identify the PSBT state machine when interacting with it and
     * on the wire protocol to initiate the funding request.
     *
     * @generated from protobuf field: bytes pending_chan_id = 1;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * An optional base PSBT the new channel output will be added to. If this is
     * non-empty, it must be a binary serialized PSBT.
     *
     * @generated from protobuf field: bytes base_psbt = 2;
     */
    basePsbt: Uint8Array;
    /**
     *
     * If a channel should be part of a batch (multiple channel openings in one
     * transaction), it can be dangerous if the whole batch transaction is
     * published too early before all channel opening negotiations are completed.
     * This flag prevents this particular channel from broadcasting the transaction
     * after the negotiation with the remote peer. In a batch of channel openings
     * this flag should be set to true for every channel but the very last.
     *
     * @generated from protobuf field: bool no_publish = 3;
     */
    noPublish: boolean;
}
/**
 * @generated from protobuf message lnrpc.FundingShim
 */
export interface FundingShim {
    /**
     * @generated from protobuf oneof: shim
     */
    shim: {
        oneofKind: "chanPointShim";
        /**
         *
         * A channel shim where the channel point was fully constructed outside
         * of lnd's wallet and the transaction might already be published.
         *
         * @generated from protobuf field: lnrpc.ChanPointShim chan_point_shim = 1;
         */
        chanPointShim: ChanPointShim;
    } | {
        oneofKind: "psbtShim";
        /**
         *
         * A channel shim that uses a PSBT to fund and sign the channel funding
         * transaction.
         *
         * @generated from protobuf field: lnrpc.PsbtShim psbt_shim = 2;
         */
        psbtShim: PsbtShim;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.FundingShimCancel
 */
export interface FundingShimCancel {
    /**
     * The pending channel ID of the channel to cancel the funding shim for.
     *
     * @generated from protobuf field: bytes pending_chan_id = 1;
     */
    pendingChanId: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.FundingPsbtVerify
 */
export interface FundingPsbtVerify {
    /**
     *
     * The funded but not yet signed PSBT that sends the exact channel capacity
     * amount to the PK script returned in the open channel message in a previous
     * step.
     *
     * @generated from protobuf field: bytes funded_psbt = 1;
     */
    fundedPsbt: Uint8Array;
    /**
     * The pending channel ID of the channel to get the PSBT for.
     *
     * @generated from protobuf field: bytes pending_chan_id = 2;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * Can only be used if the no_publish flag was set to true in the OpenChannel
     * call meaning that the caller is solely responsible for publishing the final
     * funding transaction. If skip_finalize is set to true then lnd will not wait
     * for a FundingPsbtFinalize state step and instead assumes that a transaction
     * with the same TXID as the passed in PSBT will eventually confirm.
     * IT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is
     * eventually published does have the _same TXID_ as the verified PSBT. That
     * means no inputs or outputs can change, only signatures can be added. If the
     * TXID changes between this call and the publish step then the channel will
     * never be created and the funds will be in limbo.
     *
     * @generated from protobuf field: bool skip_finalize = 3;
     */
    skipFinalize: boolean;
}
/**
 * @generated from protobuf message lnrpc.FundingPsbtFinalize
 */
export interface FundingPsbtFinalize {
    /**
     *
     * The funded PSBT that contains all witness data to send the exact channel
     * capacity amount to the PK script returned in the open channel message in a
     * previous step. Cannot be set at the same time as final_raw_tx.
     *
     * @generated from protobuf field: bytes signed_psbt = 1;
     */
    signedPsbt: Uint8Array;
    /**
     * The pending channel ID of the channel to get the PSBT for.
     *
     * @generated from protobuf field: bytes pending_chan_id = 2;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * As an alternative to the signed PSBT with all witness data, the final raw
     * wire format transaction can also be specified directly. Cannot be set at the
     * same time as signed_psbt.
     *
     * @generated from protobuf field: bytes final_raw_tx = 3;
     */
    finalRawTx: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.FundingTransitionMsg
 */
export interface FundingTransitionMsg {
    /**
     * @generated from protobuf oneof: trigger
     */
    trigger: {
        oneofKind: "shimRegister";
        /**
         *
         * The funding shim to register. This should be used before any
         * channel funding has began by the remote party, as it is intended as a
         * preparatory step for the full channel funding.
         *
         * @generated from protobuf field: lnrpc.FundingShim shim_register = 1;
         */
        shimRegister: FundingShim;
    } | {
        oneofKind: "shimCancel";
        /**
         * Used to cancel an existing registered funding shim.
         *
         * @generated from protobuf field: lnrpc.FundingShimCancel shim_cancel = 2;
         */
        shimCancel: FundingShimCancel;
    } | {
        oneofKind: "psbtVerify";
        /**
         *
         * Used to continue a funding flow that was initiated to be executed
         * through a PSBT. This step verifies that the PSBT contains the correct
         * outputs to fund the channel.
         *
         * @generated from protobuf field: lnrpc.FundingPsbtVerify psbt_verify = 3;
         */
        psbtVerify: FundingPsbtVerify;
    } | {
        oneofKind: "psbtFinalize";
        /**
         *
         * Used to continue a funding flow that was initiated to be executed
         * through a PSBT. This step finalizes the funded and signed PSBT, finishes
         * negotiation with the peer and finally publishes the resulting funding
         * transaction.
         *
         * @generated from protobuf field: lnrpc.FundingPsbtFinalize psbt_finalize = 4;
         */
        psbtFinalize: FundingPsbtFinalize;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.FundingStateStepResp
 */
export interface FundingStateStepResp {
}
/**
 * @generated from protobuf message lnrpc.PendingHTLC
 */
export interface PendingHTLC {
    /**
     * The direction within the channel that the htlc was sent
     *
     * @generated from protobuf field: bool incoming = 1;
     */
    incoming: boolean;
    /**
     * The total value of the htlc
     *
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: number;
    /**
     * The final output to be swept back to the user's wallet
     *
     * @generated from protobuf field: string outpoint = 3;
     */
    outpoint: string;
    /**
     * The next block height at which we can spend the current stage
     *
     * @generated from protobuf field: uint32 maturity_height = 4;
     */
    maturityHeight: number;
    /**
     *
     * The number of blocks remaining until the current stage can be swept.
     * Negative values indicate how many blocks have passed since becoming
     * mature.
     *
     * @generated from protobuf field: int32 blocks_til_maturity = 5;
     */
    blocksTilMaturity: number;
    /**
     * Indicates whether the htlc is in its first or second stage of recovery
     *
     * @generated from protobuf field: uint32 stage = 6;
     */
    stage: number;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsRequest
 */
export interface PendingChannelsRequest {
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse
 */
export interface PendingChannelsResponse {
    /**
     * The balance in satoshis encumbered in pending channels
     *
     * @generated from protobuf field: int64 total_limbo_balance = 1;
     */
    totalLimboBalance: number;
    /**
     * Channels pending opening
     *
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;
     */
    pendingOpenChannels: PendingChannelsResponse_PendingOpenChannel[];
    /**
     *
     * Deprecated: Channels pending closing previously contained cooperatively
     * closed channels with a single confirmation. These channels are now
     * considered closed from the time we see them on chain.
     *
     * @deprecated
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];
     */
    pendingClosingChannels: PendingChannelsResponse_ClosedChannel[];
    /**
     * Channels pending force closing
     *
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;
     */
    pendingForceClosingChannels: PendingChannelsResponse_ForceClosedChannel[];
    /**
     * Channels waiting for closing tx to confirm
     *
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;
     */
    waitingCloseChannels: PendingChannelsResponse_WaitingCloseChannel[];
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.PendingChannel
 */
export interface PendingChannelsResponse_PendingChannel {
    /**
     * @generated from protobuf field: string remote_node_pub = 1;
     */
    remoteNodePub: string;
    /**
     * @generated from protobuf field: string channel_point = 2;
     */
    channelPoint: string;
    /**
     * @generated from protobuf field: int64 capacity = 3;
     */
    capacity: number;
    /**
     * @generated from protobuf field: int64 local_balance = 4;
     */
    localBalance: number;
    /**
     * @generated from protobuf field: int64 remote_balance = 5;
     */
    remoteBalance: number;
    /**
     * The minimum satoshis this node is required to reserve in its
     * balance.
     *
     * @generated from protobuf field: int64 local_chan_reserve_sat = 6;
     */
    localChanReserveSat: number;
    /**
     *
     * The minimum satoshis the other node is required to reserve in its
     * balance.
     *
     * @generated from protobuf field: int64 remote_chan_reserve_sat = 7;
     */
    remoteChanReserveSat: number;
    /**
     * The party that initiated opening the channel.
     *
     * @generated from protobuf field: lnrpc.Initiator initiator = 8;
     */
    initiator: Initiator;
    /**
     * The commitment type used by this channel.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 9;
     */
    commitmentType: CommitmentType;
    /**
     * Total number of forwarding packages created in this channel.
     *
     * @generated from protobuf field: int64 num_forwarding_packages = 10;
     */
    numForwardingPackages: number;
    /**
     * A set of flags showing the current state of the channel.
     *
     * @generated from protobuf field: string chan_status_flags = 11;
     */
    chanStatusFlags: string;
    /**
     * Whether this channel is advertised to the network or not.
     *
     * @generated from protobuf field: bool private = 12;
     */
    private: boolean;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.PendingOpenChannel
 */
export interface PendingChannelsResponse_PendingOpenChannel {
    /**
     * The pending channel
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     *
     * The amount calculated to be paid in fees for the current set of
     * commitment transactions. The fee amount is persisted with the channel
     * in order to allow the fee amount to be removed and recalculated with
     * each channel state update, including updates that happen after a system
     * restart.
     *
     * @generated from protobuf field: int64 commit_fee = 4;
     */
    commitFee: number;
    /**
     * The weight of the commitment transaction
     *
     * @generated from protobuf field: int64 commit_weight = 5;
     */
    commitWeight: number;
    /**
     *
     * The required number of satoshis per kilo-weight that the requester will
     * pay at all times, for both the funding transaction and commitment
     * transaction. This value can later be updated once the channel is open.
     *
     * @generated from protobuf field: int64 fee_per_kw = 6;
     */
    feePerKw: number;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.WaitingCloseChannel
 */
export interface PendingChannelsResponse_WaitingCloseChannel {
    /**
     * The pending channel waiting for closing tx to confirm
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     * The balance in satoshis encumbered in this channel
     *
     * @generated from protobuf field: int64 limbo_balance = 2;
     */
    limboBalance: number;
    /**
     *
     * A list of valid commitment transactions. Any of these can confirm at
     * this point.
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.Commitments commitments = 3;
     */
    commitments?: PendingChannelsResponse_Commitments;
    /**
     * The transaction id of the closing transaction
     *
     * @generated from protobuf field: string closing_txid = 4;
     */
    closingTxid: string;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.Commitments
 */
export interface PendingChannelsResponse_Commitments {
    /**
     * Hash of the local version of the commitment tx.
     *
     * @generated from protobuf field: string local_txid = 1;
     */
    localTxid: string;
    /**
     * Hash of the remote version of the commitment tx.
     *
     * @generated from protobuf field: string remote_txid = 2;
     */
    remoteTxid: string;
    /**
     * Hash of the remote pending version of the commitment tx.
     *
     * @generated from protobuf field: string remote_pending_txid = 3;
     */
    remotePendingTxid: string;
    /**
     *
     * The amount in satoshis calculated to be paid in fees for the local
     * commitment.
     *
     * @generated from protobuf field: uint64 local_commit_fee_sat = 4;
     */
    localCommitFeeSat: number;
    /**
     *
     * The amount in satoshis calculated to be paid in fees for the remote
     * commitment.
     *
     * @generated from protobuf field: uint64 remote_commit_fee_sat = 5;
     */
    remoteCommitFeeSat: number;
    /**
     *
     * The amount in satoshis calculated to be paid in fees for the remote
     * pending commitment.
     *
     * @generated from protobuf field: uint64 remote_pending_commit_fee_sat = 6;
     */
    remotePendingCommitFeeSat: number;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.ClosedChannel
 */
export interface PendingChannelsResponse_ClosedChannel {
    /**
     * The pending channel to be closed
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     * The transaction id of the closing transaction
     *
     * @generated from protobuf field: string closing_txid = 2;
     */
    closingTxid: string;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.ForceClosedChannel
 */
export interface PendingChannelsResponse_ForceClosedChannel {
    /**
     * The pending channel to be force closed
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     * The transaction id of the closing transaction
     *
     * @generated from protobuf field: string closing_txid = 2;
     */
    closingTxid: string;
    /**
     * The balance in satoshis encumbered in this pending channel
     *
     * @generated from protobuf field: int64 limbo_balance = 3;
     */
    limboBalance: number;
    /**
     * The height at which funds can be swept into the wallet
     *
     * @generated from protobuf field: uint32 maturity_height = 4;
     */
    maturityHeight: number;
    /**
     *
     * Remaining # of blocks until the commitment output can be swept.
     * Negative values indicate how many blocks have passed since becoming
     * mature.
     *
     * @generated from protobuf field: int32 blocks_til_maturity = 5;
     */
    blocksTilMaturity: number;
    /**
     * The total value of funds successfully recovered from this channel
     *
     * @generated from protobuf field: int64 recovered_balance = 6;
     */
    recoveredBalance: number;
    /**
     * @generated from protobuf field: repeated lnrpc.PendingHTLC pending_htlcs = 8;
     */
    pendingHtlcs: PendingHTLC[];
    /**
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;
     */
    anchor: PendingChannelsResponse_ForceClosedChannel_AnchorState;
}
/**
 *
 * There are three resolution states for the anchor:
 * limbo, lost and recovered. Derive the current state
 * from the limbo and recovered balances.
 *
 * @generated from protobuf enum lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState
 */
export declare enum PendingChannelsResponse_ForceClosedChannel_AnchorState {
    /**
     * The recovered_balance is zero and limbo_balance is non-zero.
     *
     * @generated from protobuf enum value: LIMBO = 0;
     */
    LIMBO = 0,
    /**
     * The recovered_balance is non-zero.
     *
     * @generated from protobuf enum value: RECOVERED = 1;
     */
    RECOVERED = 1,
    /**
     * A state that is neither LIMBO nor RECOVERED.
     *
     * @generated from protobuf enum value: LOST = 2;
     */
    LOST = 2
}
/**
 * @generated from protobuf message lnrpc.ChannelEventSubscription
 */
export interface ChannelEventSubscription {
}
/**
 * @generated from protobuf message lnrpc.ChannelEventUpdate
 */
export interface ChannelEventUpdate {
    /**
     * @generated from protobuf oneof: channel
     */
    channel: {
        oneofKind: "openChannel";
        /**
         * @generated from protobuf field: lnrpc.Channel open_channel = 1;
         */
        openChannel: Channel;
    } | {
        oneofKind: "closedChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelCloseSummary closed_channel = 2;
         */
        closedChannel: ChannelCloseSummary;
    } | {
        oneofKind: "activeChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelPoint active_channel = 3;
         */
        activeChannel: ChannelPoint;
    } | {
        oneofKind: "inactiveChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelPoint inactive_channel = 4;
         */
        inactiveChannel: ChannelPoint;
    } | {
        oneofKind: "pendingOpenChannel";
        /**
         * @generated from protobuf field: lnrpc.PendingUpdate pending_open_channel = 6;
         */
        pendingOpenChannel: PendingUpdate;
    } | {
        oneofKind: "fullyResolvedChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelPoint fully_resolved_channel = 7;
         */
        fullyResolvedChannel: ChannelPoint;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: lnrpc.ChannelEventUpdate.UpdateType type = 5;
     */
    type: ChannelEventUpdate_UpdateType;
}
/**
 * @generated from protobuf enum lnrpc.ChannelEventUpdate.UpdateType
 */
export declare enum ChannelEventUpdate_UpdateType {
    /**
     * @generated from protobuf enum value: OPEN_CHANNEL = 0;
     */
    OPEN_CHANNEL = 0,
    /**
     * @generated from protobuf enum value: CLOSED_CHANNEL = 1;
     */
    CLOSED_CHANNEL = 1,
    /**
     * @generated from protobuf enum value: ACTIVE_CHANNEL = 2;
     */
    ACTIVE_CHANNEL = 2,
    /**
     * @generated from protobuf enum value: INACTIVE_CHANNEL = 3;
     */
    INACTIVE_CHANNEL = 3,
    /**
     * @generated from protobuf enum value: PENDING_OPEN_CHANNEL = 4;
     */
    PENDING_OPEN_CHANNEL = 4,
    /**
     * @generated from protobuf enum value: FULLY_RESOLVED_CHANNEL = 5;
     */
    FULLY_RESOLVED_CHANNEL = 5
}
/**
 * @generated from protobuf message lnrpc.WalletAccountBalance
 */
export interface WalletAccountBalance {
    /**
     * The confirmed balance of the account (with >= 1 confirmations).
     *
     * @generated from protobuf field: int64 confirmed_balance = 1;
     */
    confirmedBalance: number;
    /**
     * The unconfirmed balance of the account (with 0 confirmations).
     *
     * @generated from protobuf field: int64 unconfirmed_balance = 2;
     */
    unconfirmedBalance: number;
}
/**
 * @generated from protobuf message lnrpc.WalletBalanceRequest
 */
export interface WalletBalanceRequest {
}
/**
 * @generated from protobuf message lnrpc.WalletBalanceResponse
 */
export interface WalletBalanceResponse {
    /**
     * The balance of the wallet
     *
     * @generated from protobuf field: int64 total_balance = 1;
     */
    totalBalance: number;
    /**
     * The confirmed balance of a wallet(with >= 1 confirmations)
     *
     * @generated from protobuf field: int64 confirmed_balance = 2;
     */
    confirmedBalance: number;
    /**
     * The unconfirmed balance of a wallet(with 0 confirmations)
     *
     * @generated from protobuf field: int64 unconfirmed_balance = 3;
     */
    unconfirmedBalance: number;
    /**
     * The total amount of wallet UTXOs held in outputs that are locked for
     * other usage.
     *
     * @generated from protobuf field: int64 locked_balance = 5;
     */
    lockedBalance: number;
    /**
     * The amount of reserve required.
     *
     * @generated from protobuf field: int64 reserved_balance_anchor_chan = 6;
     */
    reservedBalanceAnchorChan: number;
    /**
     * A mapping of each wallet account's name to its balance.
     *
     * @generated from protobuf field: map<string, lnrpc.WalletAccountBalance> account_balance = 4;
     */
    accountBalance: {
        [key: string]: WalletAccountBalance;
    };
}
/**
 * @generated from protobuf message lnrpc.Amount
 */
export interface Amount {
    /**
     * Value denominated in satoshis.
     *
     * @generated from protobuf field: uint64 sat = 1;
     */
    sat: number;
    /**
     * Value denominated in milli-satoshis.
     *
     * @generated from protobuf field: uint64 msat = 2;
     */
    msat: number;
}
/**
 * @generated from protobuf message lnrpc.ChannelBalanceRequest
 */
export interface ChannelBalanceRequest {
}
/**
 * @generated from protobuf message lnrpc.ChannelBalanceResponse
 */
export interface ChannelBalanceResponse {
    /**
     * Deprecated. Sum of channels balances denominated in satoshis
     *
     * @deprecated
     * @generated from protobuf field: int64 balance = 1 [deprecated = true];
     */
    balance: number;
    /**
     * Deprecated. Sum of channels pending balances denominated in satoshis
     *
     * @deprecated
     * @generated from protobuf field: int64 pending_open_balance = 2 [deprecated = true];
     */
    pendingOpenBalance: number;
    /**
     * Sum of channels local balances.
     *
     * @generated from protobuf field: lnrpc.Amount local_balance = 3;
     */
    localBalance?: Amount;
    /**
     * Sum of channels remote balances.
     *
     * @generated from protobuf field: lnrpc.Amount remote_balance = 4;
     */
    remoteBalance?: Amount;
    /**
     * Sum of channels local unsettled balances.
     *
     * @generated from protobuf field: lnrpc.Amount unsettled_local_balance = 5;
     */
    unsettledLocalBalance?: Amount;
    /**
     * Sum of channels remote unsettled balances.
     *
     * @generated from protobuf field: lnrpc.Amount unsettled_remote_balance = 6;
     */
    unsettledRemoteBalance?: Amount;
    /**
     * Sum of channels pending local balances.
     *
     * @generated from protobuf field: lnrpc.Amount pending_open_local_balance = 7;
     */
    pendingOpenLocalBalance?: Amount;
    /**
     * Sum of channels pending remote balances.
     *
     * @generated from protobuf field: lnrpc.Amount pending_open_remote_balance = 8;
     */
    pendingOpenRemoteBalance?: Amount;
}
/**
 * @generated from protobuf message lnrpc.QueryRoutesRequest
 */
export interface QueryRoutesRequest {
    /**
     * The 33-byte hex-encoded public key for the payment destination
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     *
     * The amount to send expressed in satoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt = 2;
     */
    amt: number;
    /**
     *
     * The amount to send expressed in millisatoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt_msat = 12;
     */
    amtMsat: number;
    /**
     *
     * An optional CLTV delta from the current height that should be used for the
     * timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
     * not add any additional block padding on top of final_ctlv_delta. This
     * padding of a few blocks needs to be added manually or otherwise failures may
     * happen when a block comes in while the payment is in flight.
     *
     * @generated from protobuf field: int32 final_cltv_delta = 4;
     */
    finalCltvDelta: number;
    /**
     *
     * The maximum number of satoshis that will be paid as a fee of the payment.
     * This value can be represented either as a percentage of the amount being
     * sent, or as a fixed amount of the maximum fee the user is willing the pay to
     * send the payment. If not specified, lnd will use a default value of 100%
     * fees for small amounts (<=1k sat) or 5% fees for larger amounts.
     *
     * @generated from protobuf field: lnrpc.FeeLimit fee_limit = 5;
     */
    feeLimit?: FeeLimit;
    /**
     *
     * A list of nodes to ignore during path finding. When using REST, these fields
     * must be encoded as base64.
     *
     * @generated from protobuf field: repeated bytes ignored_nodes = 6;
     */
    ignoredNodes: Uint8Array[];
    /**
     *
     * Deprecated. A list of edges to ignore during path finding.
     *
     * @deprecated
     * @generated from protobuf field: repeated lnrpc.EdgeLocator ignored_edges = 7 [deprecated = true];
     */
    ignoredEdges: EdgeLocator[];
    /**
     *
     * The source node where the request route should originated from. If empty,
     * self is assumed.
     *
     * @generated from protobuf field: string source_pub_key = 8;
     */
    sourcePubKey: string;
    /**
     *
     * If set to true, edge probabilities from mission control will be used to get
     * the optimal route.
     *
     * @generated from protobuf field: bool use_mission_control = 9;
     */
    useMissionControl: boolean;
    /**
     *
     * A list of directed node pairs that will be ignored during path finding.
     *
     * @generated from protobuf field: repeated lnrpc.NodePair ignored_pairs = 10;
     */
    ignoredPairs: NodePair[];
    /**
     *
     * An optional maximum total time lock for the route. If the source is empty or
     * ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
     * zero, then the value of `--max-cltv-expiry` is used as the limit.
     *
     * @generated from protobuf field: uint32 cltv_limit = 11;
     */
    cltvLimit: number;
    /**
     *
     * An optional field that can be used to pass an arbitrary set of TLV records
     * to a peer which understands the new records. This can be used to pass
     * application specific data during the payment attempt. If the destination
     * does not support the specified records, an error will be returned.
     * Record types are required to be in the custom range >= 65536. When using
     * REST, the values must be encoded as base64.
     *
     * @generated from protobuf field: map<uint64, bytes> dest_custom_records = 13;
     */
    destCustomRecords: {
        [key: string]: Uint8Array;
    };
    /**
     *
     * The channel id of the channel that must be taken to the first hop. If zero,
     * any channel may be used.
     *
     * @generated from protobuf field: uint64 outgoing_chan_id = 14 [jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @generated from protobuf field: bytes last_hop_pubkey = 15;
     */
    lastHopPubkey: Uint8Array;
    /**
     *
     * Optional route hints to reach the destination through private channels.
     *
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 16;
     */
    routeHints: RouteHint[];
    /**
     *
     * Features assumed to be supported by the final node. All transitive feature
     * dependencies must also be set properly. For a given feature bit pair, either
     * optional or remote may be set, but not both. If this field is nil or empty,
     * the router will try to load destination features from the graph as a
     * fallback.
     *
     * @generated from protobuf field: repeated lnrpc.FeatureBit dest_features = 17;
     */
    destFeatures: FeatureBit[];
    /**
     *
     * The time preference for this payment. Set to -1 to optimize for fees
     * only, to 1 to optimize for reliability only or a value inbetween for a mix.
     *
     * @generated from protobuf field: double time_pref = 18;
     */
    timePref: number;
}
/**
 * @generated from protobuf message lnrpc.NodePair
 */
export interface NodePair {
    /**
     *
     * The sending node of the pair. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes from = 1;
     */
    from: Uint8Array;
    /**
     *
     * The receiving node of the pair. When using REST, this field must be encoded
     * as base64.
     *
     * @generated from protobuf field: bytes to = 2;
     */
    to: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.EdgeLocator
 */
export interface EdgeLocator {
    /**
     * The short channel id of this edge.
     *
     * @generated from protobuf field: uint64 channel_id = 1 [jstype = JS_STRING];
     */
    channelId: string;
    /**
     *
     * The direction of this edge. If direction_reverse is false, the direction
     * of this edge is from the channel endpoint with the lexicographically smaller
     * pub key to the endpoint with the larger pub key. If direction_reverse is
     * is true, the edge goes the other way.
     *
     * @generated from protobuf field: bool direction_reverse = 2;
     */
    directionReverse: boolean;
}
/**
 * @generated from protobuf message lnrpc.QueryRoutesResponse
 */
export interface QueryRoutesResponse {
    /**
     *
     * The route that results from the path finding operation. This is still a
     * repeated field to retain backwards compatibility.
     *
     * @generated from protobuf field: repeated lnrpc.Route routes = 1;
     */
    routes: Route[];
    /**
     *
     * The success probability of the returned route based on the current mission
     * control state. [EXPERIMENTAL]
     *
     * @generated from protobuf field: double success_prob = 2;
     */
    successProb: number;
}
/**
 * @generated from protobuf message lnrpc.Hop
 */
export interface Hop {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * @deprecated
     * @generated from protobuf field: int64 chan_capacity = 2 [deprecated = true];
     */
    chanCapacity: number;
    /**
     * @deprecated
     * @generated from protobuf field: int64 amt_to_forward = 3 [deprecated = true];
     */
    amtToForward: number;
    /**
     * @deprecated
     * @generated from protobuf field: int64 fee = 4 [deprecated = true];
     */
    fee: number;
    /**
     * @generated from protobuf field: uint32 expiry = 5;
     */
    expiry: number;
    /**
     * @generated from protobuf field: int64 amt_to_forward_msat = 6;
     */
    amtToForwardMsat: number;
    /**
     * @generated from protobuf field: int64 fee_msat = 7;
     */
    feeMsat: number;
    /**
     *
     * An optional public key of the hop. If the public key is given, the payment
     * can be executed without relying on a copy of the channel graph.
     *
     * @generated from protobuf field: string pub_key = 8;
     */
    pubKey: string;
    /**
     *
     * If set to true, then this hop will be encoded using the new variable length
     * TLV format. Note that if any custom tlv_records below are specified, then
     * this field MUST be set to true for them to be encoded properly.
     *
     * @deprecated
     * @generated from protobuf field: bool tlv_payload = 9 [deprecated = true];
     */
    tlvPayload: boolean;
    /**
     *
     * An optional TLV record that signals the use of an MPP payment. If present,
     * the receiver will enforce that the same mpp_record is included in the final
     * hop payload of all non-zero payments in the HTLC set. If empty, a regular
     * single-shot payment is or was attempted.
     *
     * @generated from protobuf field: lnrpc.MPPRecord mpp_record = 10;
     */
    mppRecord?: MPPRecord;
    /**
     *
     * An optional TLV record that signals the use of an AMP payment. If present,
     * the receiver will treat all received payments including the same
     * (payment_addr, set_id) pair  as being part of one logical payment. The
     * payment will be settled by XORing the root_share's together and deriving the
     * child hashes and preimages according to BOLT XX. Must be used in conjunction
     * with mpp_record.
     *
     * @generated from protobuf field: lnrpc.AMPRecord amp_record = 12;
     */
    ampRecord?: AMPRecord;
    /**
     *
     * An optional set of key-value TLV records. This is useful within the context
     * of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     * to drop off at each hop within the onion.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 11;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * The payment metadata to send along with the payment to the payee.
     *
     * @generated from protobuf field: bytes metadata = 13;
     */
    metadata: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.MPPRecord
 */
export interface MPPRecord {
    /**
     *
     * A unique, random identifier used to authenticate the sender as the intended
     * payer of a multi-path payment. The payment_addr must be the same for all
     * subpayments, and match the payment_addr provided in the receiver's invoice.
     * The same payment_addr must be used on all subpayments.
     *
     * @generated from protobuf field: bytes payment_addr = 11;
     */
    paymentAddr: Uint8Array;
    /**
     *
     * The total amount in milli-satoshis being sent as part of a larger multi-path
     * payment. The caller is responsible for ensuring subpayments to the same node
     * and payment_hash sum exactly to total_amt_msat. The same
     * total_amt_msat must be used on all subpayments.
     *
     * @generated from protobuf field: int64 total_amt_msat = 10;
     */
    totalAmtMsat: number;
}
/**
 * @generated from protobuf message lnrpc.AMPRecord
 */
export interface AMPRecord {
    /**
     * @generated from protobuf field: bytes root_share = 1;
     */
    rootShare: Uint8Array;
    /**
     * @generated from protobuf field: bytes set_id = 2;
     */
    setId: Uint8Array;
    /**
     * @generated from protobuf field: uint32 child_index = 3;
     */
    childIndex: number;
}
/**
 *
 * A path through the channel graph which runs over one or more channels in
 * succession. This struct carries all the information required to craft the
 * Sphinx onion packet, and send the payment along the first hop in the path. A
 * route is only selected as valid if all the channels have sufficient capacity to
 * carry the initial payment amount after fees are accounted for.
 *
 * @generated from protobuf message lnrpc.Route
 */
export interface Route {
    /**
     *
     * The cumulative (final) time lock across the entire route. This is the CLTV
     * value that should be extended to the first hop in the route. All other hops
     * will decrement the time-lock as advertised, leaving enough time for all
     * hops to wait for or present the payment preimage to complete the payment.
     *
     * @generated from protobuf field: uint32 total_time_lock = 1;
     */
    totalTimeLock: number;
    /**
     *
     * The sum of the fees paid at each hop within the final route. In the case
     * of a one-hop payment, this value will be zero as we don't need to pay a fee
     * to ourselves.
     *
     * @deprecated
     * @generated from protobuf field: int64 total_fees = 2 [deprecated = true];
     */
    totalFees: number;
    /**
     *
     * The total amount of funds required to complete a payment over this route.
     * This value includes the cumulative fees at each hop. As a result, the HTLC
     * extended to the first-hop in the route will need to have at least this many
     * satoshis, otherwise the route will fail at an intermediate node due to an
     * insufficient amount of fees.
     *
     * @deprecated
     * @generated from protobuf field: int64 total_amt = 3 [deprecated = true];
     */
    totalAmt: number;
    /**
     *
     * Contains details concerning the specific forwarding details at each hop.
     *
     * @generated from protobuf field: repeated lnrpc.Hop hops = 4;
     */
    hops: Hop[];
    /**
     *
     * The total fees in millisatoshis.
     *
     * @generated from protobuf field: int64 total_fees_msat = 5;
     */
    totalFeesMsat: number;
    /**
     *
     * The total amount in millisatoshis.
     *
     * @generated from protobuf field: int64 total_amt_msat = 6;
     */
    totalAmtMsat: number;
}
/**
 * @generated from protobuf message lnrpc.NodeInfoRequest
 */
export interface NodeInfoRequest {
    /**
     * The 33-byte hex-encoded compressed public of the target node
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     * If true, will include all known channels associated with the node.
     *
     * @generated from protobuf field: bool include_channels = 2;
     */
    includeChannels: boolean;
}
/**
 * @generated from protobuf message lnrpc.NodeInfo
 */
export interface NodeInfo {
    /**
     *
     * An individual vertex/node within the channel graph. A node is
     * connected to other nodes by one or more channel edges emanating from it. As
     * the graph is directed, a node will also have an incoming edge attached to
     * it for each outgoing edge.
     *
     * @generated from protobuf field: lnrpc.LightningNode node = 1;
     */
    node?: LightningNode;
    /**
     * The total number of channels for the node.
     *
     * @generated from protobuf field: uint32 num_channels = 2;
     */
    numChannels: number;
    /**
     * The sum of all channels capacity for the node, denominated in satoshis.
     *
     * @generated from protobuf field: int64 total_capacity = 3;
     */
    totalCapacity: number;
    /**
     * A list of all public channels for the node.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelEdge channels = 4;
     */
    channels: ChannelEdge[];
}
/**
 *
 * An individual vertex/node within the channel graph. A node is
 * connected to other nodes by one or more channel edges emanating from it. As the
 * graph is directed, a node will also have an incoming edge attached to it for
 * each outgoing edge.
 *
 * @generated from protobuf message lnrpc.LightningNode
 */
export interface LightningNode {
    /**
     * @generated from protobuf field: uint32 last_update = 1;
     */
    lastUpdate: number;
    /**
     * @generated from protobuf field: string pub_key = 2;
     */
    pubKey: string;
    /**
     * @generated from protobuf field: string alias = 3;
     */
    alias: string;
    /**
     * @generated from protobuf field: repeated lnrpc.NodeAddress addresses = 4;
     */
    addresses: NodeAddress[];
    /**
     * @generated from protobuf field: string color = 5;
     */
    color: string;
    /**
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 6;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     * Custom node announcement tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 7;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
}
/**
 * @generated from protobuf message lnrpc.NodeAddress
 */
export interface NodeAddress {
    /**
     * @generated from protobuf field: string network = 1;
     */
    network: string;
    /**
     * @generated from protobuf field: string addr = 2;
     */
    addr: string;
}
/**
 * @generated from protobuf message lnrpc.RoutingPolicy
 */
export interface RoutingPolicy {
    /**
     * @generated from protobuf field: uint32 time_lock_delta = 1;
     */
    timeLockDelta: number;
    /**
     * @generated from protobuf field: int64 min_htlc = 2;
     */
    minHtlc: number;
    /**
     * @generated from protobuf field: int64 fee_base_msat = 3;
     */
    feeBaseMsat: number;
    /**
     * @generated from protobuf field: int64 fee_rate_milli_msat = 4;
     */
    feeRateMilliMsat: number;
    /**
     * @generated from protobuf field: bool disabled = 5;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: uint64 max_htlc_msat = 6;
     */
    maxHtlcMsat: number;
    /**
     * @generated from protobuf field: uint32 last_update = 7;
     */
    lastUpdate: number;
    /**
     * Custom channel update tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 8;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
}
/**
 *
 * A fully authenticated channel along with all its unique attributes.
 * Once an authenticated channel announcement has been processed on the network,
 * then an instance of ChannelEdgeInfo encapsulating the channels attributes is
 * stored. The other portions relevant to routing policy of a channel are stored
 * within a ChannelEdgePolicy for each direction of the channel.
 *
 * @generated from protobuf message lnrpc.ChannelEdge
 */
export interface ChannelEdge {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 channel_id = 1 [jstype = JS_STRING];
     */
    channelId: string;
    /**
     * @generated from protobuf field: string chan_point = 2;
     */
    chanPoint: string;
    /**
     * @deprecated
     * @generated from protobuf field: uint32 last_update = 3 [deprecated = true];
     */
    lastUpdate: number;
    /**
     * @generated from protobuf field: string node1_pub = 4;
     */
    node1Pub: string;
    /**
     * @generated from protobuf field: string node2_pub = 5;
     */
    node2Pub: string;
    /**
     * @generated from protobuf field: int64 capacity = 6;
     */
    capacity: number;
    /**
     * @generated from protobuf field: lnrpc.RoutingPolicy node1_policy = 7;
     */
    node1Policy?: RoutingPolicy;
    /**
     * @generated from protobuf field: lnrpc.RoutingPolicy node2_policy = 8;
     */
    node2Policy?: RoutingPolicy;
    /**
     * Custom channel announcement tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 9;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
}
/**
 * @generated from protobuf message lnrpc.ChannelGraphRequest
 */
export interface ChannelGraphRequest {
    /**
     *
     * Whether unannounced channels are included in the response or not. If set,
     * unannounced channels are included. Unannounced channels are both private
     * channels, and public channels that are not yet announced to the network.
     *
     * @generated from protobuf field: bool include_unannounced = 1;
     */
    includeUnannounced: boolean;
}
/**
 * Returns a new instance of the directed channel graph.
 *
 * @generated from protobuf message lnrpc.ChannelGraph
 */
export interface ChannelGraph {
    /**
     * The list of `LightningNode`s in this channel graph
     *
     * @generated from protobuf field: repeated lnrpc.LightningNode nodes = 1;
     */
    nodes: LightningNode[];
    /**
     * The list of `ChannelEdge`s in this channel graph
     *
     * @generated from protobuf field: repeated lnrpc.ChannelEdge edges = 2;
     */
    edges: ChannelEdge[];
}
/**
 * @generated from protobuf message lnrpc.NodeMetricsRequest
 */
export interface NodeMetricsRequest {
    /**
     * The requested node metrics.
     *
     * @generated from protobuf field: repeated lnrpc.NodeMetricType types = 1;
     */
    types: NodeMetricType[];
}
/**
 * @generated from protobuf message lnrpc.NodeMetricsResponse
 */
export interface NodeMetricsResponse {
    /**
     *
     * Betweenness centrality is the sum of the ratio of shortest paths that pass
     * through the node for each pair of nodes in the graph (not counting paths
     * starting or ending at this node).
     * Map of node pubkey to betweenness centrality of the node. Normalized
     * values are in the [0,1] closed interval.
     *
     * @generated from protobuf field: map<string, lnrpc.FloatMetric> betweenness_centrality = 1;
     */
    betweennessCentrality: {
        [key: string]: FloatMetric;
    };
}
/**
 * @generated from protobuf message lnrpc.FloatMetric
 */
export interface FloatMetric {
    /**
     * Arbitrary float value.
     *
     * @generated from protobuf field: double value = 1;
     */
    value: number;
    /**
     * The value normalized to [0,1] or [-1,1].
     *
     * @generated from protobuf field: double normalized_value = 2;
     */
    normalizedValue: number;
}
/**
 * @generated from protobuf message lnrpc.ChanInfoRequest
 */
export interface ChanInfoRequest {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
}
/**
 * @generated from protobuf message lnrpc.NetworkInfoRequest
 */
export interface NetworkInfoRequest {
}
/**
 * @generated from protobuf message lnrpc.NetworkInfo
 */
export interface NetworkInfo {
    /**
     * @generated from protobuf field: uint32 graph_diameter = 1;
     */
    graphDiameter: number;
    /**
     * @generated from protobuf field: double avg_out_degree = 2;
     */
    avgOutDegree: number;
    /**
     * @generated from protobuf field: uint32 max_out_degree = 3;
     */
    maxOutDegree: number;
    /**
     * @generated from protobuf field: uint32 num_nodes = 4;
     */
    numNodes: number;
    /**
     * @generated from protobuf field: uint32 num_channels = 5;
     */
    numChannels: number;
    /**
     * @generated from protobuf field: int64 total_network_capacity = 6;
     */
    totalNetworkCapacity: number;
    /**
     * @generated from protobuf field: double avg_channel_size = 7;
     */
    avgChannelSize: number;
    /**
     * @generated from protobuf field: int64 min_channel_size = 8;
     */
    minChannelSize: number;
    /**
     * @generated from protobuf field: int64 max_channel_size = 9;
     */
    maxChannelSize: number;
    /**
     * @generated from protobuf field: int64 median_channel_size_sat = 10;
     */
    medianChannelSizeSat: number;
    /**
     * The number of edges marked as zombies.
     *
     * @generated from protobuf field: uint64 num_zombie_chans = 11;
     */
    numZombieChans: number;
}
/**
 * @generated from protobuf message lnrpc.StopRequest
 */
export interface StopRequest {
}
/**
 * @generated from protobuf message lnrpc.StopResponse
 */
export interface StopResponse {
}
/**
 * @generated from protobuf message lnrpc.GraphTopologySubscription
 */
export interface GraphTopologySubscription {
}
/**
 * @generated from protobuf message lnrpc.GraphTopologyUpdate
 */
export interface GraphTopologyUpdate {
    /**
     * @generated from protobuf field: repeated lnrpc.NodeUpdate node_updates = 1;
     */
    nodeUpdates: NodeUpdate[];
    /**
     * @generated from protobuf field: repeated lnrpc.ChannelEdgeUpdate channel_updates = 2;
     */
    channelUpdates: ChannelEdgeUpdate[];
    /**
     * @generated from protobuf field: repeated lnrpc.ClosedChannelUpdate closed_chans = 3;
     */
    closedChans: ClosedChannelUpdate[];
}
/**
 * @generated from protobuf message lnrpc.NodeUpdate
 */
export interface NodeUpdate {
    /**
     *
     * Deprecated, use node_addresses.
     *
     * @deprecated
     * @generated from protobuf field: repeated string addresses = 1 [deprecated = true];
     */
    addresses: string[];
    /**
     * @generated from protobuf field: string identity_key = 2;
     */
    identityKey: string;
    /**
     *
     * Deprecated, use features.
     *
     * @deprecated
     * @generated from protobuf field: bytes global_features = 3 [deprecated = true];
     */
    globalFeatures: Uint8Array;
    /**
     * @generated from protobuf field: string alias = 4;
     */
    alias: string;
    /**
     * @generated from protobuf field: string color = 5;
     */
    color: string;
    /**
     * @generated from protobuf field: repeated lnrpc.NodeAddress node_addresses = 7;
     */
    nodeAddresses: NodeAddress[];
    /**
     *
     * Features that the node has advertised in the init message, node
     * announcements and invoices.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 6;
     */
    features: {
        [key: number]: Feature;
    };
}
/**
 * @generated from protobuf message lnrpc.ChannelEdgeUpdate
 */
export interface ChannelEdgeUpdate {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 2;
     */
    chanPoint?: ChannelPoint;
    /**
     * @generated from protobuf field: int64 capacity = 3;
     */
    capacity: number;
    /**
     * @generated from protobuf field: lnrpc.RoutingPolicy routing_policy = 4;
     */
    routingPolicy?: RoutingPolicy;
    /**
     * @generated from protobuf field: string advertising_node = 5;
     */
    advertisingNode: string;
    /**
     * @generated from protobuf field: string connecting_node = 6;
     */
    connectingNode: string;
}
/**
 * @generated from protobuf message lnrpc.ClosedChannelUpdate
 */
export interface ClosedChannelUpdate {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * @generated from protobuf field: int64 capacity = 2;
     */
    capacity: number;
    /**
     * @generated from protobuf field: uint32 closed_height = 3;
     */
    closedHeight: number;
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 4;
     */
    chanPoint?: ChannelPoint;
}
/**
 * @generated from protobuf message lnrpc.HopHint
 */
export interface HopHint {
    /**
     * The public key of the node at the start of the channel.
     *
     * @generated from protobuf field: string node_id = 1;
     */
    nodeId: string;
    /**
     * The unique identifier of the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 2 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The base fee of the channel denominated in millisatoshis.
     *
     * @generated from protobuf field: uint32 fee_base_msat = 3;
     */
    feeBaseMsat: number;
    /**
     *
     * The fee rate of the channel for sending one satoshi across it denominated in
     * millionths of a satoshi.
     *
     * @generated from protobuf field: uint32 fee_proportional_millionths = 4;
     */
    feeProportionalMillionths: number;
    /**
     * The time-lock delta of the channel.
     *
     * @generated from protobuf field: uint32 cltv_expiry_delta = 5;
     */
    cltvExpiryDelta: number;
}
/**
 * @generated from protobuf message lnrpc.SetID
 */
export interface SetID {
    /**
     * @generated from protobuf field: bytes set_id = 1;
     */
    setId: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.RouteHint
 */
export interface RouteHint {
    /**
     *
     * A list of hop hints that when chained together can assist in reaching a
     * specific destination.
     *
     * @generated from protobuf field: repeated lnrpc.HopHint hop_hints = 1;
     */
    hopHints: HopHint[];
}
/**
 * @generated from protobuf message lnrpc.AMPInvoiceState
 */
export interface AMPInvoiceState {
    /**
     * The state the HTLCs associated with this setID are in.
     *
     * @generated from protobuf field: lnrpc.InvoiceHTLCState state = 1;
     */
    state: InvoiceHTLCState;
    /**
     * The settle index of this HTLC set, if the invoice state is settled.
     *
     * @generated from protobuf field: uint64 settle_index = 2;
     */
    settleIndex: number;
    /**
     * The time this HTLC set was settled expressed in unix epoch.
     *
     * @generated from protobuf field: int64 settle_time = 3;
     */
    settleTime: number;
    /**
     * The total amount paid for the sub-invoice expressed in milli satoshis.
     *
     * @generated from protobuf field: int64 amt_paid_msat = 5;
     */
    amtPaidMsat: number;
}
/**
 * @generated from protobuf message lnrpc.Invoice
 */
export interface Invoice {
    /**
     *
     * An optional memo to attach along with the invoice. Used for record keeping
     * purposes for the invoice's creator, and will also be set in the description
     * field of the encoded payment request if the description_hash field is not
     * being used.
     *
     * @generated from protobuf field: string memo = 1;
     */
    memo: string;
    /**
     *
     * The hex-encoded preimage (32 byte) which will allow settling an incoming
     * HTLC payable to this preimage. When using REST, this field must be encoded
     * as base64.
     *
     * @generated from protobuf field: bytes r_preimage = 3;
     */
    rPreimage: Uint8Array;
    /**
     *
     * The hash of the preimage. When using REST, this field must be encoded as
     * base64.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: bytes r_hash = 4;
     */
    rHash: Uint8Array;
    /**
     *
     * The value of this invoice in satoshis
     *
     * The fields value and value_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 value = 5;
     */
    value: number;
    /**
     *
     * The value of this invoice in millisatoshis
     *
     * The fields value and value_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 value_msat = 23;
     */
    valueMsat: number;
    /**
     *
     * Whether this invoice has been fulfilled
     *
     * The field is deprecated. Use the state field instead (compare to SETTLED).
     *
     * @deprecated
     * @generated from protobuf field: bool settled = 6 [deprecated = true];
     */
    settled: boolean;
    /**
     *
     * When this invoice was created.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 creation_date = 7;
     */
    creationDate: number;
    /**
     *
     * When this invoice was settled.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 settle_date = 8;
     */
    settleDate: number;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network. With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: string payment_request = 9;
     */
    paymentRequest: string;
    /**
     *
     * Hash (SHA-256) of a description of the payment. Used if the description of
     * payment (memo) is too long to naturally fit within the description field
     * of an encoded payment request. When using REST, this field must be encoded
     * as base64.
     *
     * @generated from protobuf field: bytes description_hash = 10;
     */
    descriptionHash: Uint8Array;
    /**
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     *
     * @generated from protobuf field: int64 expiry = 11;
     */
    expiry: number;
    /**
     * Fallback on-chain address.
     *
     * @generated from protobuf field: string fallback_addr = 12;
     */
    fallbackAddr: string;
    /**
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     *
     * @generated from protobuf field: uint64 cltv_expiry = 13;
     */
    cltvExpiry: number;
    /**
     *
     * Route hints that can each be individually used to assist in reaching the
     * invoice's destination.
     *
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 14;
     */
    routeHints: RouteHint[];
    /**
     * Whether this invoice should include routing hints for private channels.
     *
     * @generated from protobuf field: bool private = 15;
     */
    private: boolean;
    /**
     *
     * The "add" index of this invoice. Each newly created invoice will increment
     * this index making it monotonically increasing. Callers to the
     * SubscribeInvoices call can use this to instantly get notified of all added
     * invoices with an add_index greater than this one.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: uint64 add_index = 16;
     */
    addIndex: number;
    /**
     *
     * The "settle" index of this invoice. Each newly settled invoice will
     * increment this index making it monotonically increasing. Callers to the
     * SubscribeInvoices call can use this to instantly get notified of all
     * settled invoices with an settle_index greater than this one.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: uint64 settle_index = 17;
     */
    settleIndex: number;
    /**
     * Deprecated, use amt_paid_sat or amt_paid_msat.
     *
     * @deprecated
     * @generated from protobuf field: int64 amt_paid = 18 [deprecated = true];
     */
    amtPaid: number;
    /**
     *
     * The amount that was accepted for this invoice, in satoshis. This will ONLY
     * be set if this invoice has been settled. We provide this field as if the
     * invoice was created with a zero value, then we need to record what amount
     * was ultimately accepted. Additionally, it's possible that the sender paid
     * MORE that was specified in the original invoice. So we'll record that here
     * as well.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 amt_paid_sat = 19;
     */
    amtPaidSat: number;
    /**
     *
     * The amount that was accepted for this invoice, in millisatoshis. This will
     * ONLY be set if this invoice has been settled. We provide this field as if
     * the invoice was created with a zero value, then we need to record what
     * amount was ultimately accepted. Additionally, it's possible that the sender
     * paid MORE that was specified in the original invoice. So we'll record that
     * here as well.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 amt_paid_msat = 20;
     */
    amtPaidMsat: number;
    /**
     *
     * The state the invoice is in.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: lnrpc.Invoice.InvoiceState state = 21;
     */
    state: Invoice_InvoiceState;
    /**
     *
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: repeated lnrpc.InvoiceHTLC htlcs = 22;
     */
    htlcs: InvoiceHTLC[];
    /**
     *
     * List of features advertised on the invoice.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 24;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     *
     * Indicates if this invoice was a spontaneous payment that arrived via keysend
     * [EXPERIMENTAL].
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: bool is_keysend = 25;
     */
    isKeysend: boolean;
    /**
     *
     * The payment address of this invoice. This value will be used in MPP
     * payments, and also for newer invoices that always require the MPP payload
     * for added end-to-end security.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: bytes payment_addr = 26;
     */
    paymentAddr: Uint8Array;
    /**
     *
     * Signals whether or not this is an AMP invoice.
     *
     * @generated from protobuf field: bool is_amp = 27;
     */
    isAmp: boolean;
    /**
     *
     * [EXPERIMENTAL]:
     *
     * Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the
     * given set ID. This field is always populated for AMP invoices, and can be
     * used along side LookupInvoice to obtain the HTLC information related to a
     * given sub-invoice.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: map<string, lnrpc.AMPInvoiceState> amp_invoice_state = 28;
     */
    ampInvoiceState: {
        [key: string]: AMPInvoiceState;
    };
}
/**
 * @generated from protobuf enum lnrpc.Invoice.InvoiceState
 */
export declare enum Invoice_InvoiceState {
    /**
     * @generated from protobuf enum value: OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: SETTLED = 1;
     */
    SETTLED = 1,
    /**
     * @generated from protobuf enum value: CANCELED = 2;
     */
    CANCELED = 2,
    /**
     * @generated from protobuf enum value: ACCEPTED = 3;
     */
    ACCEPTED = 3
}
/**
 * Details of an HTLC that paid to an invoice
 *
 * @generated from protobuf message lnrpc.InvoiceHTLC
 */
export interface InvoiceHTLC {
    /**
     * Short channel id over which the htlc was received.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * Index identifying the htlc on the channel.
     *
     * @generated from protobuf field: uint64 htlc_index = 2;
     */
    htlcIndex: number;
    /**
     * The amount of the htlc in msat.
     *
     * @generated from protobuf field: uint64 amt_msat = 3;
     */
    amtMsat: number;
    /**
     * Block height at which this htlc was accepted.
     *
     * @generated from protobuf field: int32 accept_height = 4;
     */
    acceptHeight: number;
    /**
     * Time at which this htlc was accepted.
     *
     * @generated from protobuf field: int64 accept_time = 5;
     */
    acceptTime: number;
    /**
     * Time at which this htlc was settled or canceled.
     *
     * @generated from protobuf field: int64 resolve_time = 6;
     */
    resolveTime: number;
    /**
     * Block height at which this htlc expires.
     *
     * @generated from protobuf field: int32 expiry_height = 7;
     */
    expiryHeight: number;
    /**
     * Current state the htlc is in.
     *
     * @generated from protobuf field: lnrpc.InvoiceHTLCState state = 8;
     */
    state: InvoiceHTLCState;
    /**
     * Custom tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 9;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * The total amount of the mpp payment in msat.
     *
     * @generated from protobuf field: uint64 mpp_total_amt_msat = 10;
     */
    mppTotalAmtMsat: number;
    /**
     * Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.
     *
     * @generated from protobuf field: lnrpc.AMP amp = 11;
     */
    amp?: AMP;
}
/**
 * Details specific to AMP HTLCs.
 *
 * @generated from protobuf message lnrpc.AMP
 */
export interface AMP {
    /**
     * An n-of-n secret share of the root seed from which child payment hashes
     * and preimages are derived.
     *
     * @generated from protobuf field: bytes root_share = 1;
     */
    rootShare: Uint8Array;
    /**
     * An identifier for the HTLC set that this HTLC belongs to.
     *
     * @generated from protobuf field: bytes set_id = 2;
     */
    setId: Uint8Array;
    /**
     * A nonce used to randomize the child preimage and child hash from a given
     * root_share.
     *
     * @generated from protobuf field: uint32 child_index = 3;
     */
    childIndex: number;
    /**
     * The payment hash of the AMP HTLC.
     *
     * @generated from protobuf field: bytes hash = 4;
     */
    hash: Uint8Array;
    /**
     * The preimage used to settle this AMP htlc. This field will only be
     * populated if the invoice is in InvoiceState_ACCEPTED or
     * InvoiceState_SETTLED.
     *
     * @generated from protobuf field: bytes preimage = 5;
     */
    preimage: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.AddInvoiceResponse
 */
export interface AddInvoiceResponse {
    /**
     * @generated from protobuf field: bytes r_hash = 1;
     */
    rHash: Uint8Array;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network. With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient.
     *
     * @generated from protobuf field: string payment_request = 2;
     */
    paymentRequest: string;
    /**
     *
     * The "add" index of this invoice. Each newly created invoice will increment
     * this index making it monotonically increasing. Callers to the
     * SubscribeInvoices call can use this to instantly get notified of all added
     * invoices with an add_index greater than this one.
     *
     * @generated from protobuf field: uint64 add_index = 16;
     */
    addIndex: number;
    /**
     *
     * The payment address of the generated invoice. This value should be used
     * in all payments for this invoice as we require it for end to end
     * security.
     *
     * @generated from protobuf field: bytes payment_addr = 17;
     */
    paymentAddr: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.PaymentHash
 */
export interface PaymentHash {
    /**
     *
     * The hex-encoded payment hash of the invoice to be looked up. The passed
     * payment hash must be exactly 32 bytes, otherwise an error is returned.
     * Deprecated now that the REST gateway supports base64 encoding of bytes
     * fields.
     *
     * @deprecated
     * @generated from protobuf field: string r_hash_str = 1 [deprecated = true];
     */
    rHashStr: string;
    /**
     *
     * The payment hash of the invoice to be looked up. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes r_hash = 2;
     */
    rHash: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.ListInvoiceRequest
 */
export interface ListInvoiceRequest {
    /**
     *
     * If set, only invoices that are not settled and not canceled will be returned
     * in the response.
     *
     * @generated from protobuf field: bool pending_only = 1;
     */
    pendingOnly: boolean;
    /**
     *
     * The index of an invoice that will be used as either the start or end of a
     * query to determine which invoices should be returned in the response.
     *
     * @generated from protobuf field: uint64 index_offset = 4;
     */
    indexOffset: number;
    /**
     * The max number of invoices to return in the response to this query.
     *
     * @generated from protobuf field: uint64 num_max_invoices = 5;
     */
    numMaxInvoices: number;
    /**
     *
     * If set, the invoices returned will result from seeking backwards from the
     * specified index offset. This can be used to paginate backwards.
     *
     * @generated from protobuf field: bool reversed = 6;
     */
    reversed: boolean;
}
/**
 * @generated from protobuf message lnrpc.ListInvoiceResponse
 */
export interface ListInvoiceResponse {
    /**
     *
     * A list of invoices from the time slice of the time series specified in the
     * request.
     *
     * @generated from protobuf field: repeated lnrpc.Invoice invoices = 1;
     */
    invoices: Invoice[];
    /**
     *
     * The index of the last item in the set of returned invoices. This can be used
     * to seek further, pagination style.
     *
     * @generated from protobuf field: uint64 last_index_offset = 2;
     */
    lastIndexOffset: number;
    /**
     *
     * The index of the last item in the set of returned invoices. This can be used
     * to seek backwards, pagination style.
     *
     * @generated from protobuf field: uint64 first_index_offset = 3;
     */
    firstIndexOffset: number;
}
/**
 * @generated from protobuf message lnrpc.InvoiceSubscription
 */
export interface InvoiceSubscription {
    /**
     *
     * If specified (non-zero), then we'll first start by sending out
     * notifications for all added indexes with an add_index greater than this
     * value. This allows callers to catch up on any events they missed while they
     * weren't connected to the streaming RPC.
     *
     * @generated from protobuf field: uint64 add_index = 1;
     */
    addIndex: number;
    /**
     *
     * If specified (non-zero), then we'll first start by sending out
     * notifications for all settled indexes with an settle_index greater than
     * this value. This allows callers to catch up on any events they missed while
     * they weren't connected to the streaming RPC.
     *
     * @generated from protobuf field: uint64 settle_index = 2;
     */
    settleIndex: number;
}
/**
 * @generated from protobuf message lnrpc.Payment
 */
export interface Payment {
    /**
     * The payment hash
     *
     * @generated from protobuf field: string payment_hash = 1;
     */
    paymentHash: string;
    /**
     * Deprecated, use value_sat or value_msat.
     *
     * @deprecated
     * @generated from protobuf field: int64 value = 2 [deprecated = true];
     */
    value: number;
    /**
     * Deprecated, use creation_time_ns
     *
     * @deprecated
     * @generated from protobuf field: int64 creation_date = 3 [deprecated = true];
     */
    creationDate: number;
    /**
     * Deprecated, use fee_sat or fee_msat.
     *
     * @deprecated
     * @generated from protobuf field: int64 fee = 5 [deprecated = true];
     */
    fee: number;
    /**
     * The payment preimage
     *
     * @generated from protobuf field: string payment_preimage = 6;
     */
    paymentPreimage: string;
    /**
     * The value of the payment in satoshis
     *
     * @generated from protobuf field: int64 value_sat = 7;
     */
    valueSat: number;
    /**
     * The value of the payment in milli-satoshis
     *
     * @generated from protobuf field: int64 value_msat = 8;
     */
    valueMsat: number;
    /**
     * The optional payment request being fulfilled.
     *
     * @generated from protobuf field: string payment_request = 9;
     */
    paymentRequest: string;
    /**
     * The status of the payment.
     *
     * @generated from protobuf field: lnrpc.Payment.PaymentStatus status = 10;
     */
    status: Payment_PaymentStatus;
    /**
     *  The fee paid for this payment in satoshis
     *
     * @generated from protobuf field: int64 fee_sat = 11;
     */
    feeSat: number;
    /**
     *  The fee paid for this payment in milli-satoshis
     *
     * @generated from protobuf field: int64 fee_msat = 12;
     */
    feeMsat: number;
    /**
     * The time in UNIX nanoseconds at which the payment was created.
     *
     * @generated from protobuf field: int64 creation_time_ns = 13;
     */
    creationTimeNs: number;
    /**
     * The HTLCs made in attempt to settle the payment.
     *
     * @generated from protobuf field: repeated lnrpc.HTLCAttempt htlcs = 14;
     */
    htlcs: HTLCAttempt[];
    /**
     *
     * The creation index of this payment. Each payment can be uniquely identified
     * by this index, which may not strictly increment by 1 for payments made in
     * older versions of lnd.
     *
     * @generated from protobuf field: uint64 payment_index = 15;
     */
    paymentIndex: number;
    /**
     * @generated from protobuf field: lnrpc.PaymentFailureReason failure_reason = 16;
     */
    failureReason: PaymentFailureReason;
}
/**
 * @generated from protobuf enum lnrpc.Payment.PaymentStatus
 */
export declare enum Payment_PaymentStatus {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: IN_FLIGHT = 1;
     */
    IN_FLIGHT = 1,
    /**
     * @generated from protobuf enum value: SUCCEEDED = 2;
     */
    SUCCEEDED = 2,
    /**
     * @generated from protobuf enum value: FAILED = 3;
     */
    FAILED = 3
}
/**
 * @generated from protobuf message lnrpc.HTLCAttempt
 */
export interface HTLCAttempt {
    /**
     * The unique ID that is used for this attempt.
     *
     * @generated from protobuf field: uint64 attempt_id = 7;
     */
    attemptId: number;
    /**
     * The status of the HTLC.
     *
     * @generated from protobuf field: lnrpc.HTLCAttempt.HTLCStatus status = 1;
     */
    status: HTLCAttempt_HTLCStatus;
    /**
     * The route taken by this HTLC.
     *
     * @generated from protobuf field: lnrpc.Route route = 2;
     */
    route?: Route;
    /**
     * The time in UNIX nanoseconds at which this HTLC was sent.
     *
     * @generated from protobuf field: int64 attempt_time_ns = 3;
     */
    attemptTimeNs: number;
    /**
     *
     * The time in UNIX nanoseconds at which this HTLC was settled or failed.
     * This value will not be set if the HTLC is still IN_FLIGHT.
     *
     * @generated from protobuf field: int64 resolve_time_ns = 4;
     */
    resolveTimeNs: number;
    /**
     * Detailed htlc failure info.
     *
     * @generated from protobuf field: lnrpc.Failure failure = 5;
     */
    failure?: Failure;
    /**
     * The preimage that was used to settle the HTLC.
     *
     * @generated from protobuf field: bytes preimage = 6;
     */
    preimage: Uint8Array;
}
/**
 * @generated from protobuf enum lnrpc.HTLCAttempt.HTLCStatus
 */
export declare enum HTLCAttempt_HTLCStatus {
    /**
     * @generated from protobuf enum value: IN_FLIGHT = 0;
     */
    IN_FLIGHT = 0,
    /**
     * @generated from protobuf enum value: SUCCEEDED = 1;
     */
    SUCCEEDED = 1,
    /**
     * @generated from protobuf enum value: FAILED = 2;
     */
    FAILED = 2
}
/**
 * @generated from protobuf message lnrpc.ListPaymentsRequest
 */
export interface ListPaymentsRequest {
    /**
     *
     * If true, then return payments that have not yet fully completed. This means
     * that pending payments, as well as failed payments will show up if this
     * field is set to true. This flag doesn't change the meaning of the indices,
     * which are tied to individual payments.
     *
     * @generated from protobuf field: bool include_incomplete = 1;
     */
    includeIncomplete: boolean;
    /**
     *
     * The index of a payment that will be used as either the start or end of a
     * query to determine which payments should be returned in the response. The
     * index_offset is exclusive. In the case of a zero index_offset, the query
     * will start with the oldest payment when paginating forwards, or will end
     * with the most recent payment when paginating backwards.
     *
     * @generated from protobuf field: uint64 index_offset = 2;
     */
    indexOffset: number;
    /**
     * The maximal number of payments returned in the response to this query.
     *
     * @generated from protobuf field: uint64 max_payments = 3;
     */
    maxPayments: number;
    /**
     *
     * If set, the payments returned will result from seeking backwards from the
     * specified index offset. This can be used to paginate backwards. The order
     * of the returned payments is always oldest first (ascending index order).
     *
     * @generated from protobuf field: bool reversed = 4;
     */
    reversed: boolean;
    /**
     *
     * If set, all payments (complete and incomplete, independent of the
     * max_payments parameter) will be counted. Note that setting this to true will
     * increase the run time of the call significantly on systems that have a lot
     * of payments, as all of them have to be iterated through to be counted.
     *
     * @generated from protobuf field: bool count_total_payments = 5;
     */
    countTotalPayments: boolean;
}
/**
 * @generated from protobuf message lnrpc.ListPaymentsResponse
 */
export interface ListPaymentsResponse {
    /**
     * The list of payments
     *
     * @generated from protobuf field: repeated lnrpc.Payment payments = 1;
     */
    payments: Payment[];
    /**
     *
     * The index of the first item in the set of returned payments. This can be
     * used as the index_offset to continue seeking backwards in the next request.
     *
     * @generated from protobuf field: uint64 first_index_offset = 2;
     */
    firstIndexOffset: number;
    /**
     *
     * The index of the last item in the set of returned payments. This can be used
     * as the index_offset to continue seeking forwards in the next request.
     *
     * @generated from protobuf field: uint64 last_index_offset = 3;
     */
    lastIndexOffset: number;
    /**
     *
     * Will only be set if count_total_payments in the request was set. Represents
     * the total number of payments (complete and incomplete, independent of the
     * number of payments requested in the query) currently present in the payments
     * database.
     *
     * @generated from protobuf field: uint64 total_num_payments = 4;
     */
    totalNumPayments: number;
}
/**
 * @generated from protobuf message lnrpc.DeletePaymentRequest
 */
export interface DeletePaymentRequest {
    /**
     * Payment hash to delete.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     *
     * Only delete failed HTLCs from the payment, not the payment itself.
     *
     * @generated from protobuf field: bool failed_htlcs_only = 2;
     */
    failedHtlcsOnly: boolean;
}
/**
 * @generated from protobuf message lnrpc.DeleteAllPaymentsRequest
 */
export interface DeleteAllPaymentsRequest {
    /**
     * Only delete failed payments.
     *
     * @generated from protobuf field: bool failed_payments_only = 1;
     */
    failedPaymentsOnly: boolean;
    /**
     *
     * Only delete failed HTLCs from payments, not the payment itself.
     *
     * @generated from protobuf field: bool failed_htlcs_only = 2;
     */
    failedHtlcsOnly: boolean;
}
/**
 * @generated from protobuf message lnrpc.DeletePaymentResponse
 */
export interface DeletePaymentResponse {
}
/**
 * @generated from protobuf message lnrpc.DeleteAllPaymentsResponse
 */
export interface DeleteAllPaymentsResponse {
}
/**
 * @generated from protobuf message lnrpc.AbandonChannelRequest
 */
export interface AbandonChannelRequest {
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint channel_point = 1;
     */
    channelPoint?: ChannelPoint;
    /**
     * @generated from protobuf field: bool pending_funding_shim_only = 2;
     */
    pendingFundingShimOnly: boolean;
    /**
     *
     * Override the requirement for being in dev mode by setting this to true and
     * confirming the user knows what they are doing and this is a potential foot
     * gun to lose funds if used on active channels.
     *
     * @generated from protobuf field: bool i_know_what_i_am_doing = 3;
     */
    iKnowWhatIAmDoing: boolean;
}
/**
 * @generated from protobuf message lnrpc.AbandonChannelResponse
 */
export interface AbandonChannelResponse {
}
/**
 * @generated from protobuf message lnrpc.DebugLevelRequest
 */
export interface DebugLevelRequest {
    /**
     * @generated from protobuf field: bool show = 1;
     */
    show: boolean;
    /**
     * @generated from protobuf field: string level_spec = 2;
     */
    levelSpec: string;
}
/**
 * @generated from protobuf message lnrpc.DebugLevelResponse
 */
export interface DebugLevelResponse {
    /**
     * @generated from protobuf field: string sub_systems = 1;
     */
    subSystems: string;
}
/**
 * @generated from protobuf message lnrpc.PayReqString
 */
export interface PayReqString {
    /**
     * The payment request string to be decoded
     *
     * @generated from protobuf field: string pay_req = 1;
     */
    payReq: string;
}
/**
 * @generated from protobuf message lnrpc.PayReq
 */
export interface PayReq {
    /**
     * @generated from protobuf field: string destination = 1;
     */
    destination: string;
    /**
     * @generated from protobuf field: string payment_hash = 2;
     */
    paymentHash: string;
    /**
     * @generated from protobuf field: int64 num_satoshis = 3;
     */
    numSatoshis: number;
    /**
     * @generated from protobuf field: int64 timestamp = 4;
     */
    timestamp: number;
    /**
     * @generated from protobuf field: int64 expiry = 5;
     */
    expiry: number;
    /**
     * @generated from protobuf field: string description = 6;
     */
    description: string;
    /**
     * @generated from protobuf field: string description_hash = 7;
     */
    descriptionHash: string;
    /**
     * @generated from protobuf field: string fallback_addr = 8;
     */
    fallbackAddr: string;
    /**
     * @generated from protobuf field: int64 cltv_expiry = 9;
     */
    cltvExpiry: number;
    /**
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 10;
     */
    routeHints: RouteHint[];
    /**
     * @generated from protobuf field: bytes payment_addr = 11;
     */
    paymentAddr: Uint8Array;
    /**
     * @generated from protobuf field: int64 num_msat = 12;
     */
    numMsat: number;
    /**
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 13;
     */
    features: {
        [key: number]: Feature;
    };
}
/**
 * @generated from protobuf message lnrpc.Feature
 */
export interface Feature {
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bool is_required = 3;
     */
    isRequired: boolean;
    /**
     * @generated from protobuf field: bool is_known = 4;
     */
    isKnown: boolean;
}
/**
 * @generated from protobuf message lnrpc.FeeReportRequest
 */
export interface FeeReportRequest {
}
/**
 * @generated from protobuf message lnrpc.ChannelFeeReport
 */
export interface ChannelFeeReport {
    /**
     * The short channel id that this fee report belongs to.
     *
     * @generated from protobuf field: uint64 chan_id = 5 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The channel that this fee report belongs to.
     *
     * @generated from protobuf field: string channel_point = 1;
     */
    channelPoint: string;
    /**
     * The base fee charged regardless of the number of milli-satoshis sent.
     *
     * @generated from protobuf field: int64 base_fee_msat = 2;
     */
    baseFeeMsat: number;
    /**
     * The amount charged per milli-satoshis transferred expressed in
     * millionths of a satoshi.
     *
     * @generated from protobuf field: int64 fee_per_mil = 3;
     */
    feePerMil: number;
    /**
     * The effective fee rate in milli-satoshis. Computed by dividing the
     * fee_per_mil value by 1 million.
     *
     * @generated from protobuf field: double fee_rate = 4;
     */
    feeRate: number;
}
/**
 * @generated from protobuf message lnrpc.FeeReportResponse
 */
export interface FeeReportResponse {
    /**
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelFeeReport channel_fees = 1;
     */
    channelFees: ChannelFeeReport[];
    /**
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 24 hrs.
     *
     * @generated from protobuf field: uint64 day_fee_sum = 2;
     */
    dayFeeSum: number;
    /**
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 week.
     *
     * @generated from protobuf field: uint64 week_fee_sum = 3;
     */
    weekFeeSum: number;
    /**
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 month.
     *
     * @generated from protobuf field: uint64 month_fee_sum = 4;
     */
    monthFeeSum: number;
}
/**
 * @generated from protobuf message lnrpc.PolicyUpdateRequest
 */
export interface PolicyUpdateRequest {
    /**
     * @generated from protobuf oneof: scope
     */
    scope: {
        oneofKind: "global";
        /**
         * If set, then this update applies to all currently active channels.
         *
         * @generated from protobuf field: bool global = 1;
         */
        global: boolean;
    } | {
        oneofKind: "chanPoint";
        /**
         * If set, this update will target a specific channel.
         *
         * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 2;
         */
        chanPoint: ChannelPoint;
    } | {
        oneofKind: undefined;
    };
    /**
     * The base fee charged regardless of the number of milli-satoshis sent.
     *
     * @generated from protobuf field: int64 base_fee_msat = 3;
     */
    baseFeeMsat: number;
    /**
     * The effective fee rate in milli-satoshis. The precision of this value
     * goes up to 6 decimal places, so 1e-6.
     *
     * @generated from protobuf field: double fee_rate = 4;
     */
    feeRate: number;
    /**
     * The effective fee rate in micro-satoshis (parts per million).
     *
     * @generated from protobuf field: uint32 fee_rate_ppm = 9;
     */
    feeRatePpm: number;
    /**
     * The required timelock delta for HTLCs forwarded over the channel.
     *
     * @generated from protobuf field: uint32 time_lock_delta = 5;
     */
    timeLockDelta: number;
    /**
     * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
     * HTLC will be unchanged.
     *
     * @generated from protobuf field: uint64 max_htlc_msat = 6;
     */
    maxHtlcMsat: number;
    /**
     * The minimum HTLC size in milli-satoshis. Only applied if
     * min_htlc_msat_specified is true.
     *
     * @generated from protobuf field: uint64 min_htlc_msat = 7;
     */
    minHtlcMsat: number;
    /**
     * If true, min_htlc_msat is applied.
     *
     * @generated from protobuf field: bool min_htlc_msat_specified = 8;
     */
    minHtlcMsatSpecified: boolean;
}
/**
 * @generated from protobuf message lnrpc.FailedUpdate
 */
export interface FailedUpdate {
    /**
     * The outpoint in format txid:n
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 1;
     */
    outpoint?: OutPoint;
    /**
     * Reason for the policy update failure.
     *
     * @generated from protobuf field: lnrpc.UpdateFailure reason = 2;
     */
    reason: UpdateFailure;
    /**
     * A string representation of the policy update error.
     *
     * @generated from protobuf field: string update_error = 3;
     */
    updateError: string;
}
/**
 * @generated from protobuf message lnrpc.PolicyUpdateResponse
 */
export interface PolicyUpdateResponse {
    /**
     * List of failed policy updates.
     *
     * @generated from protobuf field: repeated lnrpc.FailedUpdate failed_updates = 1;
     */
    failedUpdates: FailedUpdate[];
}
/**
 * @generated from protobuf message lnrpc.ForwardingHistoryRequest
 */
export interface ForwardingHistoryRequest {
    /**
     * Start time is the starting point of the forwarding history request. All
     * records beyond this point will be included, respecting the end time, and
     * the index offset.
     *
     * @generated from protobuf field: uint64 start_time = 1;
     */
    startTime: number;
    /**
     * End time is the end point of the forwarding history request. The
     * response will carry at most 50k records between the start time and the
     * end time. The index offset can be used to implement pagination.
     *
     * @generated from protobuf field: uint64 end_time = 2;
     */
    endTime: number;
    /**
     * Index offset is the offset in the time series to start at. As each
     * response can only contain 50k records, callers can use this to skip
     * around within a packed time series.
     *
     * @generated from protobuf field: uint32 index_offset = 3;
     */
    indexOffset: number;
    /**
     * The max number of events to return in the response to this query.
     *
     * @generated from protobuf field: uint32 num_max_events = 4;
     */
    numMaxEvents: number;
    /**
     * Informs the server if the peer alias should be looked up for each
     * forwarding event.
     *
     * @generated from protobuf field: bool peer_alias_lookup = 5;
     */
    peerAliasLookup: boolean;
}
/**
 * @generated from protobuf message lnrpc.ForwardingEvent
 */
export interface ForwardingEvent {
    /**
     * Timestamp is the time (unix epoch offset) that this circuit was
     * completed. Deprecated by timestamp_ns.
     *
     * @deprecated
     * @generated from protobuf field: uint64 timestamp = 1 [deprecated = true];
     */
    timestamp: number;
    /**
     * The incoming channel ID that carried the HTLC that created the circuit.
     *
     * @generated from protobuf field: uint64 chan_id_in = 2 [jstype = JS_STRING];
     */
    chanIdIn: string;
    /**
     * The outgoing channel ID that carried the preimage that completed the
     * circuit.
     *
     * @generated from protobuf field: uint64 chan_id_out = 4 [jstype = JS_STRING];
     */
    chanIdOut: string;
    /**
     * The total amount (in satoshis) of the incoming HTLC that created half
     * the circuit.
     *
     * @generated from protobuf field: uint64 amt_in = 5;
     */
    amtIn: number;
    /**
     * The total amount (in satoshis) of the outgoing HTLC that created the
     * second half of the circuit.
     *
     * @generated from protobuf field: uint64 amt_out = 6;
     */
    amtOut: number;
    /**
     * The total fee (in satoshis) that this payment circuit carried.
     *
     * @generated from protobuf field: uint64 fee = 7;
     */
    fee: number;
    /**
     * The total fee (in milli-satoshis) that this payment circuit carried.
     *
     * @generated from protobuf field: uint64 fee_msat = 8;
     */
    feeMsat: number;
    /**
     * The total amount (in milli-satoshis) of the incoming HTLC that created
     * half the circuit.
     *
     * @generated from protobuf field: uint64 amt_in_msat = 9;
     */
    amtInMsat: number;
    /**
     * The total amount (in milli-satoshis) of the outgoing HTLC that created
     * the second half of the circuit.
     *
     * @generated from protobuf field: uint64 amt_out_msat = 10;
     */
    amtOutMsat: number;
    /**
     * The number of nanoseconds elapsed since January 1, 1970 UTC when this
     * circuit was completed.
     *
     * @generated from protobuf field: uint64 timestamp_ns = 11;
     */
    timestampNs: number;
    /**
     * The peer alias of the incoming channel.
     *
     * @generated from protobuf field: string peer_alias_in = 12;
     */
    peerAliasIn: string;
    /**
     * The peer alias of the outgoing channel.
     *
     * @generated from protobuf field: string peer_alias_out = 13;
     */
    peerAliasOut: string;
}
/**
 * @generated from protobuf message lnrpc.ForwardingHistoryResponse
 */
export interface ForwardingHistoryResponse {
    /**
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     *
     * @generated from protobuf field: repeated lnrpc.ForwardingEvent forwarding_events = 1;
     */
    forwardingEvents: ForwardingEvent[];
    /**
     * The index of the last time in the set of returned forwarding events. Can
     * be used to seek further, pagination style.
     *
     * @generated from protobuf field: uint32 last_offset_index = 2;
     */
    lastOffsetIndex: number;
}
/**
 * @generated from protobuf message lnrpc.ExportChannelBackupRequest
 */
export interface ExportChannelBackupRequest {
    /**
     * The target channel point to obtain a back up for.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
}
/**
 * @generated from protobuf message lnrpc.ChannelBackup
 */
export interface ChannelBackup {
    /**
     *
     * Identifies the channel that this backup belongs to.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
    /**
     *
     * Is an encrypted single-chan backup. this can be passed to
     * RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
     * order to trigger the recovery protocol. When using REST, this field must be
     * encoded as base64.
     *
     * @generated from protobuf field: bytes chan_backup = 2;
     */
    chanBackup: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.MultiChanBackup
 */
export interface MultiChanBackup {
    /**
     *
     * Is the set of all channels that are included in this multi-channel backup.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelPoint chan_points = 1;
     */
    chanPoints: ChannelPoint[];
    /**
     *
     * A single encrypted blob containing all the static channel backups of the
     * channel listed above. This can be stored as a single file or blob, and
     * safely be replaced with any prior/future versions. When using REST, this
     * field must be encoded as base64.
     *
     * @generated from protobuf field: bytes multi_chan_backup = 2;
     */
    multiChanBackup: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.ChanBackupExportRequest
 */
export interface ChanBackupExportRequest {
}
/**
 * @generated from protobuf message lnrpc.ChanBackupSnapshot
 */
export interface ChanBackupSnapshot {
    /**
     *
     * The set of new channels that have been added since the last channel backup
     * snapshot was requested.
     *
     * @generated from protobuf field: lnrpc.ChannelBackups single_chan_backups = 1;
     */
    singleChanBackups?: ChannelBackups;
    /**
     *
     * A multi-channel backup that covers all open channels currently known to
     * lnd.
     *
     * @generated from protobuf field: lnrpc.MultiChanBackup multi_chan_backup = 2;
     */
    multiChanBackup?: MultiChanBackup;
}
/**
 * @generated from protobuf message lnrpc.ChannelBackups
 */
export interface ChannelBackups {
    /**
     *
     * A set of single-chan static channel backups.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelBackup chan_backups = 1;
     */
    chanBackups: ChannelBackup[];
}
/**
 * @generated from protobuf message lnrpc.RestoreChanBackupRequest
 */
export interface RestoreChanBackupRequest {
    /**
     * @generated from protobuf oneof: backup
     */
    backup: {
        oneofKind: "chanBackups";
        /**
         *
         * The channels to restore as a list of channel/backup pairs.
         *
         * @generated from protobuf field: lnrpc.ChannelBackups chan_backups = 1;
         */
        chanBackups: ChannelBackups;
    } | {
        oneofKind: "multiChanBackup";
        /**
         *
         * The channels to restore in the packed multi backup format. When using
         * REST, this field must be encoded as base64.
         *
         * @generated from protobuf field: bytes multi_chan_backup = 2;
         */
        multiChanBackup: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.RestoreBackupResponse
 */
export interface RestoreBackupResponse {
}
/**
 * @generated from protobuf message lnrpc.ChannelBackupSubscription
 */
export interface ChannelBackupSubscription {
}
/**
 * @generated from protobuf message lnrpc.VerifyChanBackupResponse
 */
export interface VerifyChanBackupResponse {
}
/**
 * @generated from protobuf message lnrpc.MacaroonPermission
 */
export interface MacaroonPermission {
    /**
     * The entity a permission grants access to.
     *
     * @generated from protobuf field: string entity = 1;
     */
    entity: string;
    /**
     * The action that is granted.
     *
     * @generated from protobuf field: string action = 2;
     */
    action: string;
}
/**
 * @generated from protobuf message lnrpc.BakeMacaroonRequest
 */
export interface BakeMacaroonRequest {
    /**
     * The list of permissions the new macaroon should grant.
     *
     * @generated from protobuf field: repeated lnrpc.MacaroonPermission permissions = 1;
     */
    permissions: MacaroonPermission[];
    /**
     * The root key ID used to create the macaroon, must be a positive integer.
     *
     * @generated from protobuf field: uint64 root_key_id = 2;
     */
    rootKeyId: number;
    /**
     *
     * Informs the RPC on whether to allow external permissions that LND is not
     * aware of.
     *
     * @generated from protobuf field: bool allow_external_permissions = 3;
     */
    allowExternalPermissions: boolean;
}
/**
 * @generated from protobuf message lnrpc.BakeMacaroonResponse
 */
export interface BakeMacaroonResponse {
    /**
     * The hex encoded macaroon, serialized in binary format.
     *
     * @generated from protobuf field: string macaroon = 1;
     */
    macaroon: string;
}
/**
 * @generated from protobuf message lnrpc.ListMacaroonIDsRequest
 */
export interface ListMacaroonIDsRequest {
}
/**
 * @generated from protobuf message lnrpc.ListMacaroonIDsResponse
 */
export interface ListMacaroonIDsResponse {
    /**
     * The list of root key IDs that are in use.
     *
     * @generated from protobuf field: repeated uint64 root_key_ids = 1;
     */
    rootKeyIds: number[];
}
/**
 * @generated from protobuf message lnrpc.DeleteMacaroonIDRequest
 */
export interface DeleteMacaroonIDRequest {
    /**
     * The root key ID to be removed.
     *
     * @generated from protobuf field: uint64 root_key_id = 1;
     */
    rootKeyId: number;
}
/**
 * @generated from protobuf message lnrpc.DeleteMacaroonIDResponse
 */
export interface DeleteMacaroonIDResponse {
    /**
     * A boolean indicates that the deletion is successful.
     *
     * @generated from protobuf field: bool deleted = 1;
     */
    deleted: boolean;
}
/**
 * @generated from protobuf message lnrpc.MacaroonPermissionList
 */
export interface MacaroonPermissionList {
    /**
     * A list of macaroon permissions.
     *
     * @generated from protobuf field: repeated lnrpc.MacaroonPermission permissions = 1;
     */
    permissions: MacaroonPermission[];
}
/**
 * @generated from protobuf message lnrpc.ListPermissionsRequest
 */
export interface ListPermissionsRequest {
}
/**
 * @generated from protobuf message lnrpc.ListPermissionsResponse
 */
export interface ListPermissionsResponse {
    /**
     *
     * A map between all RPC method URIs and their required macaroon permissions to
     * access them.
     *
     * @generated from protobuf field: map<string, lnrpc.MacaroonPermissionList> method_permissions = 1;
     */
    methodPermissions: {
        [key: string]: MacaroonPermissionList;
    };
}
/**
 * @generated from protobuf message lnrpc.Failure
 */
export interface Failure {
    /**
     * Failure code as defined in the Lightning spec
     *
     * @generated from protobuf field: lnrpc.Failure.FailureCode code = 1;
     */
    code: Failure_FailureCode;
    /**
     * An optional channel update message.
     *
     * @generated from protobuf field: lnrpc.ChannelUpdate channel_update = 3;
     */
    channelUpdate?: ChannelUpdate;
    /**
     * A failure type-dependent htlc value.
     *
     * @generated from protobuf field: uint64 htlc_msat = 4;
     */
    htlcMsat: number;
    /**
     * The sha256 sum of the onion payload.
     *
     * @generated from protobuf field: bytes onion_sha_256 = 5;
     */
    onionSha256: Uint8Array;
    /**
     * A failure type-dependent cltv expiry value.
     *
     * @generated from protobuf field: uint32 cltv_expiry = 6;
     */
    cltvExpiry: number;
    /**
     * A failure type-dependent flags value.
     *
     * @generated from protobuf field: uint32 flags = 7;
     */
    flags: number;
    /**
     *
     * The position in the path of the intermediate or final node that generated
     * the failure message. Position zero is the sender node.
     *
     * @generated from protobuf field: uint32 failure_source_index = 8;
     */
    failureSourceIndex: number;
    /**
     * A failure type-dependent block height.
     *
     * @generated from protobuf field: uint32 height = 9;
     */
    height: number;
}
/**
 * @generated from protobuf enum lnrpc.Failure.FailureCode
 */
export declare enum Failure_FailureCode {
    /**
     *
     * The numbers assigned in this enumeration match the failure codes as
     * defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
     * a RESERVED value is added.
     *
     * @generated from protobuf enum value: RESERVED = 0;
     */
    RESERVED = 0,
    /**
     * @generated from protobuf enum value: INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1;
     */
    INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1,
    /**
     * @generated from protobuf enum value: INCORRECT_PAYMENT_AMOUNT = 2;
     */
    INCORRECT_PAYMENT_AMOUNT = 2,
    /**
     * @generated from protobuf enum value: FINAL_INCORRECT_CLTV_EXPIRY = 3;
     */
    FINAL_INCORRECT_CLTV_EXPIRY = 3,
    /**
     * @generated from protobuf enum value: FINAL_INCORRECT_HTLC_AMOUNT = 4;
     */
    FINAL_INCORRECT_HTLC_AMOUNT = 4,
    /**
     * @generated from protobuf enum value: FINAL_EXPIRY_TOO_SOON = 5;
     */
    FINAL_EXPIRY_TOO_SOON = 5,
    /**
     * @generated from protobuf enum value: INVALID_REALM = 6;
     */
    INVALID_REALM = 6,
    /**
     * @generated from protobuf enum value: EXPIRY_TOO_SOON = 7;
     */
    EXPIRY_TOO_SOON = 7,
    /**
     * @generated from protobuf enum value: INVALID_ONION_VERSION = 8;
     */
    INVALID_ONION_VERSION = 8,
    /**
     * @generated from protobuf enum value: INVALID_ONION_HMAC = 9;
     */
    INVALID_ONION_HMAC = 9,
    /**
     * @generated from protobuf enum value: INVALID_ONION_KEY = 10;
     */
    INVALID_ONION_KEY = 10,
    /**
     * @generated from protobuf enum value: AMOUNT_BELOW_MINIMUM = 11;
     */
    AMOUNT_BELOW_MINIMUM = 11,
    /**
     * @generated from protobuf enum value: FEE_INSUFFICIENT = 12;
     */
    FEE_INSUFFICIENT = 12,
    /**
     * @generated from protobuf enum value: INCORRECT_CLTV_EXPIRY = 13;
     */
    INCORRECT_CLTV_EXPIRY = 13,
    /**
     * @generated from protobuf enum value: CHANNEL_DISABLED = 14;
     */
    CHANNEL_DISABLED = 14,
    /**
     * @generated from protobuf enum value: TEMPORARY_CHANNEL_FAILURE = 15;
     */
    TEMPORARY_CHANNEL_FAILURE = 15,
    /**
     * @generated from protobuf enum value: REQUIRED_NODE_FEATURE_MISSING = 16;
     */
    REQUIRED_NODE_FEATURE_MISSING = 16,
    /**
     * @generated from protobuf enum value: REQUIRED_CHANNEL_FEATURE_MISSING = 17;
     */
    REQUIRED_CHANNEL_FEATURE_MISSING = 17,
    /**
     * @generated from protobuf enum value: UNKNOWN_NEXT_PEER = 18;
     */
    UNKNOWN_NEXT_PEER = 18,
    /**
     * @generated from protobuf enum value: TEMPORARY_NODE_FAILURE = 19;
     */
    TEMPORARY_NODE_FAILURE = 19,
    /**
     * @generated from protobuf enum value: PERMANENT_NODE_FAILURE = 20;
     */
    PERMANENT_NODE_FAILURE = 20,
    /**
     * @generated from protobuf enum value: PERMANENT_CHANNEL_FAILURE = 21;
     */
    PERMANENT_CHANNEL_FAILURE = 21,
    /**
     * @generated from protobuf enum value: EXPIRY_TOO_FAR = 22;
     */
    EXPIRY_TOO_FAR = 22,
    /**
     * @generated from protobuf enum value: MPP_TIMEOUT = 23;
     */
    MPP_TIMEOUT = 23,
    /**
     * @generated from protobuf enum value: INVALID_ONION_PAYLOAD = 24;
     */
    INVALID_ONION_PAYLOAD = 24,
    /**
     *
     * An internal error occurred.
     *
     * @generated from protobuf enum value: INTERNAL_FAILURE = 997;
     */
    INTERNAL_FAILURE = 997,
    /**
     *
     * The error source is known, but the failure itself couldn't be decoded.
     *
     * @generated from protobuf enum value: UNKNOWN_FAILURE = 998;
     */
    UNKNOWN_FAILURE = 998,
    /**
     *
     * An unreadable failure result is returned if the received failure message
     * cannot be decrypted. In that case the error source is unknown.
     *
     * @generated from protobuf enum value: UNREADABLE_FAILURE = 999;
     */
    UNREADABLE_FAILURE = 999
}
/**
 * @generated from protobuf message lnrpc.ChannelUpdate
 */
export interface ChannelUpdate {
    /**
     *
     * The signature that validates the announced data and proves the ownership
     * of node id.
     *
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
    /**
     *
     * The target chain that this channel was opened within. This value
     * should be the genesis hash of the target chain. Along with the short
     * channel ID, this uniquely identifies the channel globally in a
     * blockchain.
     *
     * @generated from protobuf field: bytes chain_hash = 2;
     */
    chainHash: Uint8Array;
    /**
     *
     * The unique description of the funding transaction.
     *
     * @generated from protobuf field: uint64 chan_id = 3 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     *
     * A timestamp that allows ordering in the case of multiple announcements.
     * We should ignore the message if timestamp is not greater than the
     * last-received.
     *
     * @generated from protobuf field: uint32 timestamp = 4;
     */
    timestamp: number;
    /**
     *
     * The bitfield that describes whether optional fields are present in this
     * update. Currently, the least-significant bit must be set to 1 if the
     * optional field MaxHtlc is present.
     *
     * @generated from protobuf field: uint32 message_flags = 10;
     */
    messageFlags: number;
    /**
     *
     * The bitfield that describes additional meta-data concerning how the
     * update is to be interpreted. Currently, the least-significant bit must be
     * set to 0 if the creating node corresponds to the first node in the
     * previously sent channel announcement and 1 otherwise. If the second bit
     * is set, then the channel is set to be disabled.
     *
     * @generated from protobuf field: uint32 channel_flags = 5;
     */
    channelFlags: number;
    /**
     *
     * The minimum number of blocks this node requires to be added to the expiry
     * of HTLCs. This is a security parameter determined by the node operator.
     * This value represents the required gap between the time locks of the
     * incoming and outgoing HTLC's set to this node.
     *
     * @generated from protobuf field: uint32 time_lock_delta = 6;
     */
    timeLockDelta: number;
    /**
     *
     * The minimum HTLC value which will be accepted.
     *
     * @generated from protobuf field: uint64 htlc_minimum_msat = 7;
     */
    htlcMinimumMsat: number;
    /**
     *
     * The base fee that must be used for incoming HTLC's to this particular
     * channel. This value will be tacked onto the required for a payment
     * independent of the size of the payment.
     *
     * @generated from protobuf field: uint32 base_fee = 8;
     */
    baseFee: number;
    /**
     *
     * The fee rate that will be charged per millionth of a satoshi.
     *
     * @generated from protobuf field: uint32 fee_rate = 9;
     */
    feeRate: number;
    /**
     *
     * The maximum HTLC value which will be accepted.
     *
     * @generated from protobuf field: uint64 htlc_maximum_msat = 11;
     */
    htlcMaximumMsat: number;
    /**
     *
     * The set of data that was appended to this message, some of which we may
     * not actually know how to iterate or parse. By holding onto this data, we
     * ensure that we're able to properly validate the set of signatures that
     * cover these new fields, and ensure we're able to make upgrades to the
     * network in a forwards compatible manner.
     *
     * @generated from protobuf field: bytes extra_opaque_data = 12;
     */
    extraOpaqueData: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.MacaroonId
 */
export interface MacaroonId {
    /**
     * @generated from protobuf field: bytes nonce = 1;
     */
    nonce: Uint8Array;
    /**
     * @generated from protobuf field: bytes storageId = 2;
     */
    storageId: Uint8Array;
    /**
     * @generated from protobuf field: repeated lnrpc.Op ops = 3;
     */
    ops: Op[];
}
/**
 * @generated from protobuf message lnrpc.Op
 */
export interface Op {
    /**
     * @generated from protobuf field: string entity = 1;
     */
    entity: string;
    /**
     * @generated from protobuf field: repeated string actions = 2;
     */
    actions: string[];
}
/**
 * @generated from protobuf message lnrpc.CheckMacPermRequest
 */
export interface CheckMacPermRequest {
    /**
     * @generated from protobuf field: bytes macaroon = 1;
     */
    macaroon: Uint8Array;
    /**
     * @generated from protobuf field: repeated lnrpc.MacaroonPermission permissions = 2;
     */
    permissions: MacaroonPermission[];
    /**
     * @generated from protobuf field: string fullMethod = 3;
     */
    fullMethod: string;
}
/**
 * @generated from protobuf message lnrpc.CheckMacPermResponse
 */
export interface CheckMacPermResponse {
    /**
     * @generated from protobuf field: bool valid = 1;
     */
    valid: boolean;
}
/**
 * @generated from protobuf message lnrpc.RPCMiddlewareRequest
 */
export interface RPCMiddlewareRequest {
    /**
     *
     * The unique ID of the intercepted original gRPC request. Useful for mapping
     * request to response when implementing full duplex message interception. For
     * streaming requests, this will be the same ID for all incoming and outgoing
     * middleware intercept messages of the _same_ stream.
     *
     * @generated from protobuf field: uint64 request_id = 1;
     */
    requestId: number;
    /**
     *
     * The raw bytes of the complete macaroon as sent by the gRPC client in the
     * original request. This might be empty for a request that doesn't require
     * macaroons such as the wallet unlocker RPCs.
     *
     * @generated from protobuf field: bytes raw_macaroon = 2;
     */
    rawMacaroon: Uint8Array;
    /**
     *
     * The parsed condition of the macaroon's custom caveat for convenient access.
     * This field only contains the value of the custom caveat that the handling
     * middleware has registered itself for. The condition _must_ be validated for
     * messages of intercept_type stream_auth and request!
     *
     * @generated from protobuf field: string custom_caveat_condition = 3;
     */
    customCaveatCondition: string;
    /**
     * @generated from protobuf oneof: intercept_type
     */
    interceptType: {
        oneofKind: "streamAuth";
        /**
         *
         * Intercept stream authentication: each new streaming RPC call that is
         * initiated against lnd and contains the middleware's custom macaroon
         * caveat can be approved or denied based upon the macaroon in the stream
         * header. This message will only be sent for streaming RPCs, unary RPCs
         * must handle the macaroon authentication in the request interception to
         * avoid an additional message round trip between lnd and the middleware.
         *
         * @generated from protobuf field: lnrpc.StreamAuth stream_auth = 4;
         */
        streamAuth: StreamAuth;
    } | {
        oneofKind: "request";
        /**
         *
         * Intercept incoming gRPC client request message: all incoming messages,
         * both on streaming and unary RPCs, are forwarded to the middleware for
         * inspection. For unary RPC messages the middleware is also expected to
         * validate the custom macaroon caveat of the request.
         *
         * @generated from protobuf field: lnrpc.RPCMessage request = 5;
         */
        request: RPCMessage;
    } | {
        oneofKind: "response";
        /**
         *
         * Intercept outgoing gRPC response message: all outgoing messages, both on
         * streaming and unary RPCs, are forwarded to the middleware for inspection
         * and amendment. The response in this message is the original response as
         * it was generated by the main RPC server. It can either be accepted
         * (=forwarded to the client), replaced/overwritten with a new message of
         * the same type, or replaced by an error message.
         *
         * @generated from protobuf field: lnrpc.RPCMessage response = 6;
         */
        response: RPCMessage;
    } | {
        oneofKind: "regComplete";
        /**
         *
         * This is used to indicate to the client that the server has successfully
         * registered the interceptor. This is only used in the very first message
         * that the server sends to the client after the client sends the server
         * the middleware registration message.
         *
         * @generated from protobuf field: bool reg_complete = 8;
         */
        regComplete: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     *
     * The unique message ID of this middleware intercept message. There can be
     * multiple middleware intercept messages per single gRPC request (one for the
     * incoming request and one for the outgoing response) or gRPC stream (one for
     * each incoming message and one for each outgoing response). This message ID
     * must be referenced when responding (accepting/rejecting/modifying) to an
     * intercept message.
     *
     * @generated from protobuf field: uint64 msg_id = 7;
     */
    msgId: number;
}
/**
 * @generated from protobuf message lnrpc.StreamAuth
 */
export interface StreamAuth {
    /**
     *
     * The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
     * example /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just
     * established.
     *
     * @generated from protobuf field: string method_full_uri = 1;
     */
    methodFullUri: string;
}
/**
 * @generated from protobuf message lnrpc.RPCMessage
 */
export interface RPCMessage {
    /**
     *
     * The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
     * example /lnrpc.Lightning/GetInfo) of the RPC method the message was sent
     * to/from.
     *
     * @generated from protobuf field: string method_full_uri = 1;
     */
    methodFullUri: string;
    /**
     *
     * Indicates whether the message was sent over a streaming RPC method or not.
     *
     * @generated from protobuf field: bool stream_rpc = 2;
     */
    streamRpc: boolean;
    /**
     *
     * The full canonical gRPC name of the message type (in the format
     * <rpcpackage>.TypeName, for example lnrpc.GetInfoRequest). In case of an
     * error being returned from lnd, this simply contains the string "error".
     *
     * @generated from protobuf field: string type_name = 3;
     */
    typeName: string;
    /**
     *
     * The full content of the gRPC message, serialized in the binary protobuf
     * format.
     *
     * @generated from protobuf field: bytes serialized = 4;
     */
    serialized: Uint8Array;
    /**
     *
     * Indicates that the response from lnd was an error, not a gRPC response. If
     * this is set to true then the type_name contains the string "error" and
     * serialized contains the error string.
     *
     * @generated from protobuf field: bool is_error = 5;
     */
    isError: boolean;
}
/**
 * @generated from protobuf message lnrpc.RPCMiddlewareResponse
 */
export interface RPCMiddlewareResponse {
    /**
     *
     * The request message ID this response refers to. Must always be set when
     * giving feedback to an intercept but is ignored for the initial registration
     * message.
     *
     * @generated from protobuf field: uint64 ref_msg_id = 1;
     */
    refMsgId: number;
    /**
     * @generated from protobuf oneof: middleware_message
     */
    middlewareMessage: {
        oneofKind: "register";
        /**
         *
         * The registration message identifies the middleware that's being
         * registered in lnd. The registration message must be sent immediately
         * after initiating the RegisterRpcMiddleware stream, otherwise lnd will
         * time out the attempt and terminate the request. NOTE: The middleware
         * will only receive interception messages for requests that contain a
         * macaroon with the custom caveat that the middleware declares it is
         * responsible for handling in the registration message! As a security
         * measure, _no_ middleware can intercept requests made with _unencumbered_
         * macaroons!
         *
         * @generated from protobuf field: lnrpc.MiddlewareRegistration register = 2;
         */
        register: MiddlewareRegistration;
    } | {
        oneofKind: "feedback";
        /**
         *
         * The middleware received an interception request and gives feedback to
         * it. The request_id indicates what message the feedback refers to.
         *
         * @generated from protobuf field: lnrpc.InterceptFeedback feedback = 3;
         */
        feedback: InterceptFeedback;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.MiddlewareRegistration
 */
export interface MiddlewareRegistration {
    /**
     *
     * The name of the middleware to register. The name should be as informative
     * as possible and is logged on registration.
     *
     * @generated from protobuf field: string middleware_name = 1;
     */
    middlewareName: string;
    /**
     *
     * The name of the custom macaroon caveat that this middleware is responsible
     * for. Only requests/responses that contain a macaroon with the registered
     * custom caveat are forwarded for interception to the middleware. The
     * exception being the read-only mode: All requests/responses are forwarded to
     * a middleware that requests read-only access but such a middleware won't be
     * allowed to _alter_ responses. As a security measure, _no_ middleware can
     * change responses to requests made with _unencumbered_ macaroons!
     * NOTE: Cannot be used at the same time as read_only_mode.
     *
     * @generated from protobuf field: string custom_macaroon_caveat_name = 2;
     */
    customMacaroonCaveatName: string;
    /**
     *
     * Instead of defining a custom macaroon caveat name a middleware can register
     * itself for read-only access only. In that mode all requests/responses are
     * forwarded to the middleware but the middleware isn't allowed to alter any of
     * the responses.
     * NOTE: Cannot be used at the same time as custom_macaroon_caveat_name.
     *
     * @generated from protobuf field: bool read_only_mode = 3;
     */
    readOnlyMode: boolean;
}
/**
 * @generated from protobuf message lnrpc.InterceptFeedback
 */
export interface InterceptFeedback {
    /**
     *
     * The error to return to the user. If this is non-empty, the incoming gRPC
     * stream/request is aborted and the error is returned to the gRPC client. If
     * this value is empty, it means the middleware accepts the stream/request/
     * response and the processing of it can continue.
     *
     * @generated from protobuf field: string error = 1;
     */
    error: string;
    /**
     *
     * A boolean indicating that the gRPC message should be replaced/overwritten.
     * This boolean is needed because in protobuf an empty message is serialized as
     * a 0-length or nil byte slice and we wouldn't be able to distinguish between
     * an empty replacement message and the "don't replace anything" case.
     *
     * @generated from protobuf field: bool replace_response = 2;
     */
    replaceResponse: boolean;
    /**
     *
     * If the replace_response field is set to true, this field must contain the
     * binary serialized gRPC message in the protobuf format.
     *
     * @generated from protobuf field: bytes replacement_serialized = 3;
     */
    replacementSerialized: Uint8Array;
}
/**
 * @generated from protobuf enum lnrpc.OutputScriptType
 */
export declare enum OutputScriptType {
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_PUBKEY_HASH = 0;
     */
    SCRIPT_TYPE_PUBKEY_HASH = 0,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_SCRIPT_HASH = 1;
     */
    SCRIPT_TYPE_SCRIPT_HASH = 1,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 2;
     */
    SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 2,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 3;
     */
    SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 3,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_PUBKEY = 4;
     */
    SCRIPT_TYPE_PUBKEY = 4,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_MULTISIG = 5;
     */
    SCRIPT_TYPE_MULTISIG = 5,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_NULLDATA = 6;
     */
    SCRIPT_TYPE_NULLDATA = 6,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_NON_STANDARD = 7;
     */
    SCRIPT_TYPE_NON_STANDARD = 7,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_UNKNOWN = 8;
     */
    SCRIPT_TYPE_WITNESS_UNKNOWN = 8,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_V1_TAPROOT = 9;
     */
    SCRIPT_TYPE_WITNESS_V1_TAPROOT = 9
}
/**
 *
 * `AddressType` has to be one of:
 *
 * - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
 * - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
 * - `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 4)
 *
 * @generated from protobuf enum lnrpc.AddressType
 */
export declare enum AddressType {
    /**
     * @generated from protobuf enum value: WITNESS_PUBKEY_HASH = 0;
     */
    WITNESS_PUBKEY_HASH = 0,
    /**
     * @generated from protobuf enum value: NESTED_PUBKEY_HASH = 1;
     */
    NESTED_PUBKEY_HASH = 1,
    /**
     * @generated from protobuf enum value: UNUSED_WITNESS_PUBKEY_HASH = 2;
     */
    UNUSED_WITNESS_PUBKEY_HASH = 2,
    /**
     * @generated from protobuf enum value: UNUSED_NESTED_PUBKEY_HASH = 3;
     */
    UNUSED_NESTED_PUBKEY_HASH = 3,
    /**
     * @generated from protobuf enum value: TAPROOT_PUBKEY = 4;
     */
    TAPROOT_PUBKEY = 4,
    /**
     * @generated from protobuf enum value: UNUSED_TAPROOT_PUBKEY = 5;
     */
    UNUSED_TAPROOT_PUBKEY = 5
}
/**
 * @generated from protobuf enum lnrpc.CommitmentType
 */
export declare enum CommitmentType {
    /**
     *
     * Returned when the commitment type isn't known or unavailable.
     *
     * @generated from protobuf enum value: UNKNOWN_COMMITMENT_TYPE = 0;
     */
    UNKNOWN_COMMITMENT_TYPE = 0,
    /**
     *
     * A channel using the legacy commitment format having tweaked to_remote
     * keys.
     *
     * @generated from protobuf enum value: LEGACY = 1;
     */
    LEGACY = 1,
    /**
     *
     * A channel that uses the modern commitment format where the key in the
     * output of the remote party does not change each state. This makes back
     * up and recovery easier as when the channel is closed, the funds go
     * directly to that key.
     *
     * @generated from protobuf enum value: STATIC_REMOTE_KEY = 2;
     */
    STATIC_REMOTE_KEY = 2,
    /**
     *
     * A channel that uses a commitment format that has anchor outputs on the
     * commitments, allowing fee bumping after a force close transaction has
     * been broadcast.
     *
     * @generated from protobuf enum value: ANCHORS = 3;
     */
    ANCHORS = 3,
    /**
     *
     * A channel that uses a commitment type that builds upon the anchors
     * commitment format, but in addition requires a CLTV clause to spend outputs
     * paying to the channel initiator. This is intended for use on leased channels
     * to guarantee that the channel initiator has no incentives to close a leased
     * channel before its maturity date.
     *
     * @generated from protobuf enum value: SCRIPT_ENFORCED_LEASE = 4;
     */
    SCRIPT_ENFORCED_LEASE = 4
}
/**
 * @generated from protobuf enum lnrpc.Initiator
 */
export declare enum Initiator {
    /**
     * @generated from protobuf enum value: INITIATOR_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: INITIATOR_LOCAL = 1;
     */
    LOCAL = 1,
    /**
     * @generated from protobuf enum value: INITIATOR_REMOTE = 2;
     */
    REMOTE = 2,
    /**
     * @generated from protobuf enum value: INITIATOR_BOTH = 3;
     */
    BOTH = 3
}
/**
 * @generated from protobuf enum lnrpc.ResolutionType
 */
export declare enum ResolutionType {
    /**
     * @generated from protobuf enum value: TYPE_UNKNOWN = 0;
     */
    TYPE_UNKNOWN = 0,
    /**
     * We resolved an anchor output.
     *
     * @generated from protobuf enum value: ANCHOR = 1;
     */
    ANCHOR = 1,
    /**
     *
     * We are resolving an incoming htlc on chain. This if this htlc is
     * claimed, we swept the incoming htlc with the preimage. If it is timed
     * out, our peer swept the timeout path.
     *
     * @generated from protobuf enum value: INCOMING_HTLC = 2;
     */
    INCOMING_HTLC = 2,
    /**
     *
     * We are resolving an outgoing htlc on chain. If this htlc is claimed,
     * the remote party swept the htlc with the preimage. If it is timed out,
     * we swept it with the timeout path.
     *
     * @generated from protobuf enum value: OUTGOING_HTLC = 3;
     */
    OUTGOING_HTLC = 3,
    /**
     * We force closed and need to sweep our time locked commitment output.
     *
     * @generated from protobuf enum value: COMMIT = 4;
     */
    COMMIT = 4
}
/**
 * @generated from protobuf enum lnrpc.ResolutionOutcome
 */
export declare enum ResolutionOutcome {
    /**
     * Outcome unknown.
     *
     * @generated from protobuf enum value: OUTCOME_UNKNOWN = 0;
     */
    OUTCOME_UNKNOWN = 0,
    /**
     * An output was claimed on chain.
     *
     * @generated from protobuf enum value: CLAIMED = 1;
     */
    CLAIMED = 1,
    /**
     * An output was left unclaimed on chain.
     *
     * @generated from protobuf enum value: UNCLAIMED = 2;
     */
    UNCLAIMED = 2,
    /**
     *
     * ResolverOutcomeAbandoned indicates that an output that we did not
     * claim on chain, for example an anchor that we did not sweep and a
     * third party claimed on chain, or a htlc that we could not decode
     * so left unclaimed.
     *
     * @generated from protobuf enum value: ABANDONED = 3;
     */
    ABANDONED = 3,
    /**
     *
     * If we force closed our channel, our htlcs need to be claimed in two
     * stages. This outcome represents the broadcast of a timeout or success
     * transaction for this two stage htlc claim.
     *
     * @generated from protobuf enum value: FIRST_STAGE = 4;
     */
    FIRST_STAGE = 4,
    /**
     * A htlc was timed out on chain.
     *
     * @generated from protobuf enum value: TIMEOUT = 5;
     */
    TIMEOUT = 5
}
/**
 * @generated from protobuf enum lnrpc.NodeMetricType
 */
export declare enum NodeMetricType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: BETWEENNESS_CENTRALITY = 1;
     */
    BETWEENNESS_CENTRALITY = 1
}
/**
 * @generated from protobuf enum lnrpc.InvoiceHTLCState
 */
export declare enum InvoiceHTLCState {
    /**
     * @generated from protobuf enum value: ACCEPTED = 0;
     */
    ACCEPTED = 0,
    /**
     * @generated from protobuf enum value: SETTLED = 1;
     */
    SETTLED = 1,
    /**
     * @generated from protobuf enum value: CANCELED = 2;
     */
    CANCELED = 2
}
/**
 * @generated from protobuf enum lnrpc.PaymentFailureReason
 */
export declare enum PaymentFailureReason {
    /**
     *
     * Payment isn't failed (yet).
     *
     * @generated from protobuf enum value: FAILURE_REASON_NONE = 0;
     */
    FAILURE_REASON_NONE = 0,
    /**
     *
     * There are more routes to try, but the payment timeout was exceeded.
     *
     * @generated from protobuf enum value: FAILURE_REASON_TIMEOUT = 1;
     */
    FAILURE_REASON_TIMEOUT = 1,
    /**
     *
     * All possible routes were tried and failed permanently. Or were no
     * routes to the destination at all.
     *
     * @generated from protobuf enum value: FAILURE_REASON_NO_ROUTE = 2;
     */
    FAILURE_REASON_NO_ROUTE = 2,
    /**
     *
     * A non-recoverable error has occured.
     *
     * @generated from protobuf enum value: FAILURE_REASON_ERROR = 3;
     */
    FAILURE_REASON_ERROR = 3,
    /**
     *
     * Payment details incorrect (unknown hash, invalid amt or
     * invalid final cltv delta)
     *
     * @generated from protobuf enum value: FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4;
     */
    FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4,
    /**
     *
     * Insufficient local balance.
     *
     * @generated from protobuf enum value: FAILURE_REASON_INSUFFICIENT_BALANCE = 5;
     */
    FAILURE_REASON_INSUFFICIENT_BALANCE = 5
}
/**
 * @generated from protobuf enum lnrpc.FeatureBit
 */
export declare enum FeatureBit {
    /**
     * @generated from protobuf enum value: DATALOSS_PROTECT_REQ = 0;
     */
    DATALOSS_PROTECT_REQ = 0,
    /**
     * @generated from protobuf enum value: DATALOSS_PROTECT_OPT = 1;
     */
    DATALOSS_PROTECT_OPT = 1,
    /**
     * @generated from protobuf enum value: INITIAL_ROUING_SYNC = 3;
     */
    INITIAL_ROUING_SYNC = 3,
    /**
     * @generated from protobuf enum value: UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;
     */
    UPFRONT_SHUTDOWN_SCRIPT_REQ = 4,
    /**
     * @generated from protobuf enum value: UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;
     */
    UPFRONT_SHUTDOWN_SCRIPT_OPT = 5,
    /**
     * @generated from protobuf enum value: GOSSIP_QUERIES_REQ = 6;
     */
    GOSSIP_QUERIES_REQ = 6,
    /**
     * @generated from protobuf enum value: GOSSIP_QUERIES_OPT = 7;
     */
    GOSSIP_QUERIES_OPT = 7,
    /**
     * @generated from protobuf enum value: TLV_ONION_REQ = 8;
     */
    TLV_ONION_REQ = 8,
    /**
     * @generated from protobuf enum value: TLV_ONION_OPT = 9;
     */
    TLV_ONION_OPT = 9,
    /**
     * @generated from protobuf enum value: EXT_GOSSIP_QUERIES_REQ = 10;
     */
    EXT_GOSSIP_QUERIES_REQ = 10,
    /**
     * @generated from protobuf enum value: EXT_GOSSIP_QUERIES_OPT = 11;
     */
    EXT_GOSSIP_QUERIES_OPT = 11,
    /**
     * @generated from protobuf enum value: STATIC_REMOTE_KEY_REQ = 12;
     */
    STATIC_REMOTE_KEY_REQ = 12,
    /**
     * @generated from protobuf enum value: STATIC_REMOTE_KEY_OPT = 13;
     */
    STATIC_REMOTE_KEY_OPT = 13,
    /**
     * @generated from protobuf enum value: PAYMENT_ADDR_REQ = 14;
     */
    PAYMENT_ADDR_REQ = 14,
    /**
     * @generated from protobuf enum value: PAYMENT_ADDR_OPT = 15;
     */
    PAYMENT_ADDR_OPT = 15,
    /**
     * @generated from protobuf enum value: MPP_REQ = 16;
     */
    MPP_REQ = 16,
    /**
     * @generated from protobuf enum value: MPP_OPT = 17;
     */
    MPP_OPT = 17,
    /**
     * @generated from protobuf enum value: WUMBO_CHANNELS_REQ = 18;
     */
    WUMBO_CHANNELS_REQ = 18,
    /**
     * @generated from protobuf enum value: WUMBO_CHANNELS_OPT = 19;
     */
    WUMBO_CHANNELS_OPT = 19,
    /**
     * @generated from protobuf enum value: ANCHORS_REQ = 20;
     */
    ANCHORS_REQ = 20,
    /**
     * @generated from protobuf enum value: ANCHORS_OPT = 21;
     */
    ANCHORS_OPT = 21,
    /**
     * @generated from protobuf enum value: ANCHORS_ZERO_FEE_HTLC_REQ = 22;
     */
    ANCHORS_ZERO_FEE_HTLC_REQ = 22,
    /**
     * @generated from protobuf enum value: ANCHORS_ZERO_FEE_HTLC_OPT = 23;
     */
    ANCHORS_ZERO_FEE_HTLC_OPT = 23,
    /**
     * @generated from protobuf enum value: AMP_REQ = 30;
     */
    AMP_REQ = 30,
    /**
     * @generated from protobuf enum value: AMP_OPT = 31;
     */
    AMP_OPT = 31
}
/**
 * @generated from protobuf enum lnrpc.UpdateFailure
 */
export declare enum UpdateFailure {
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_NOT_FOUND = 2;
     */
    NOT_FOUND = 2,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_INTERNAL_ERR = 3;
     */
    INTERNAL_ERR = 3,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_INVALID_PARAMETER = 4;
     */
    INVALID_PARAMETER = 4
}
declare class LookupHtlcRequest$Type extends MessageType<LookupHtlcRequest> {
    constructor();
    create(value?: PartialMessage<LookupHtlcRequest>): LookupHtlcRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupHtlcRequest): LookupHtlcRequest;
    internalBinaryWrite(message: LookupHtlcRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.LookupHtlcRequest
 */
export declare const LookupHtlcRequest: LookupHtlcRequest$Type;
declare class LookupHtlcResponse$Type extends MessageType<LookupHtlcResponse> {
    constructor();
    create(value?: PartialMessage<LookupHtlcResponse>): LookupHtlcResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupHtlcResponse): LookupHtlcResponse;
    internalBinaryWrite(message: LookupHtlcResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.LookupHtlcResponse
 */
export declare const LookupHtlcResponse: LookupHtlcResponse$Type;
declare class SubscribeCustomMessagesRequest$Type extends MessageType<SubscribeCustomMessagesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeCustomMessagesRequest>): SubscribeCustomMessagesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCustomMessagesRequest): SubscribeCustomMessagesRequest;
    internalBinaryWrite(message: SubscribeCustomMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SubscribeCustomMessagesRequest
 */
export declare const SubscribeCustomMessagesRequest: SubscribeCustomMessagesRequest$Type;
declare class CustomMessage$Type extends MessageType<CustomMessage> {
    constructor();
    create(value?: PartialMessage<CustomMessage>): CustomMessage;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomMessage): CustomMessage;
    internalBinaryWrite(message: CustomMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.CustomMessage
 */
export declare const CustomMessage: CustomMessage$Type;
declare class SendCustomMessageRequest$Type extends MessageType<SendCustomMessageRequest> {
    constructor();
    create(value?: PartialMessage<SendCustomMessageRequest>): SendCustomMessageRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCustomMessageRequest): SendCustomMessageRequest;
    internalBinaryWrite(message: SendCustomMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCustomMessageRequest
 */
export declare const SendCustomMessageRequest: SendCustomMessageRequest$Type;
declare class SendCustomMessageResponse$Type extends MessageType<SendCustomMessageResponse> {
    constructor();
    create(value?: PartialMessage<SendCustomMessageResponse>): SendCustomMessageResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCustomMessageResponse): SendCustomMessageResponse;
    internalBinaryWrite(message: SendCustomMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCustomMessageResponse
 */
export declare const SendCustomMessageResponse: SendCustomMessageResponse$Type;
declare class Utxo$Type extends MessageType<Utxo> {
    constructor();
    create(value?: PartialMessage<Utxo>): Utxo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Utxo): Utxo;
    internalBinaryWrite(message: Utxo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Utxo
 */
export declare const Utxo: Utxo$Type;
declare class OutputDetail$Type extends MessageType<OutputDetail> {
    constructor();
    create(value?: PartialMessage<OutputDetail>): OutputDetail;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutputDetail): OutputDetail;
    internalBinaryWrite(message: OutputDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.OutputDetail
 */
export declare const OutputDetail: OutputDetail$Type;
declare class Transaction$Type extends MessageType<Transaction> {
    constructor();
    create(value?: PartialMessage<Transaction>): Transaction;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction;
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Transaction
 */
export declare const Transaction: Transaction$Type;
declare class GetTransactionsRequest$Type extends MessageType<GetTransactionsRequest> {
    constructor();
    create(value?: PartialMessage<GetTransactionsRequest>): GetTransactionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionsRequest): GetTransactionsRequest;
    internalBinaryWrite(message: GetTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GetTransactionsRequest
 */
export declare const GetTransactionsRequest: GetTransactionsRequest$Type;
declare class TransactionDetails$Type extends MessageType<TransactionDetails> {
    constructor();
    create(value?: PartialMessage<TransactionDetails>): TransactionDetails;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionDetails): TransactionDetails;
    internalBinaryWrite(message: TransactionDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.TransactionDetails
 */
export declare const TransactionDetails: TransactionDetails$Type;
declare class FeeLimit$Type extends MessageType<FeeLimit> {
    constructor();
    create(value?: PartialMessage<FeeLimit>): FeeLimit;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeLimit): FeeLimit;
    internalBinaryWrite(message: FeeLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FeeLimit
 */
export declare const FeeLimit: FeeLimit$Type;
declare class SendRequest$Type extends MessageType<SendRequest> {
    constructor();
    create(value?: PartialMessage<SendRequest>): SendRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendRequest): SendRequest;
    private binaryReadMap11;
    internalBinaryWrite(message: SendRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendRequest
 */
export declare const SendRequest: SendRequest$Type;
declare class SendResponse$Type extends MessageType<SendResponse> {
    constructor();
    create(value?: PartialMessage<SendResponse>): SendResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendResponse): SendResponse;
    internalBinaryWrite(message: SendResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendResponse
 */
export declare const SendResponse: SendResponse$Type;
declare class SendToRouteRequest$Type extends MessageType<SendToRouteRequest> {
    constructor();
    create(value?: PartialMessage<SendToRouteRequest>): SendToRouteRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendToRouteRequest): SendToRouteRequest;
    internalBinaryWrite(message: SendToRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendToRouteRequest
 */
export declare const SendToRouteRequest: SendToRouteRequest$Type;
declare class ChannelAcceptRequest$Type extends MessageType<ChannelAcceptRequest> {
    constructor();
    create(value?: PartialMessage<ChannelAcceptRequest>): ChannelAcceptRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelAcceptRequest): ChannelAcceptRequest;
    internalBinaryWrite(message: ChannelAcceptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelAcceptRequest
 */
export declare const ChannelAcceptRequest: ChannelAcceptRequest$Type;
declare class ChannelAcceptResponse$Type extends MessageType<ChannelAcceptResponse> {
    constructor();
    create(value?: PartialMessage<ChannelAcceptResponse>): ChannelAcceptResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelAcceptResponse): ChannelAcceptResponse;
    internalBinaryWrite(message: ChannelAcceptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelAcceptResponse
 */
export declare const ChannelAcceptResponse: ChannelAcceptResponse$Type;
declare class ChannelPoint$Type extends MessageType<ChannelPoint> {
    constructor();
    create(value?: PartialMessage<ChannelPoint>): ChannelPoint;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelPoint): ChannelPoint;
    internalBinaryWrite(message: ChannelPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelPoint
 */
export declare const ChannelPoint: ChannelPoint$Type;
declare class OutPoint$Type extends MessageType<OutPoint> {
    constructor();
    create(value?: PartialMessage<OutPoint>): OutPoint;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutPoint): OutPoint;
    internalBinaryWrite(message: OutPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.OutPoint
 */
export declare const OutPoint: OutPoint$Type;
declare class PreviousOutPoint$Type extends MessageType<PreviousOutPoint> {
    constructor();
    create(value?: PartialMessage<PreviousOutPoint>): PreviousOutPoint;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreviousOutPoint): PreviousOutPoint;
    internalBinaryWrite(message: PreviousOutPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PreviousOutPoint
 */
export declare const PreviousOutPoint: PreviousOutPoint$Type;
declare class LightningAddress$Type extends MessageType<LightningAddress> {
    constructor();
    create(value?: PartialMessage<LightningAddress>): LightningAddress;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightningAddress): LightningAddress;
    internalBinaryWrite(message: LightningAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.LightningAddress
 */
export declare const LightningAddress: LightningAddress$Type;
declare class EstimateFeeRequest$Type extends MessageType<EstimateFeeRequest> {
    constructor();
    create(value?: PartialMessage<EstimateFeeRequest>): EstimateFeeRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateFeeRequest): EstimateFeeRequest;
    private binaryReadMap1;
    internalBinaryWrite(message: EstimateFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.EstimateFeeRequest
 */
export declare const EstimateFeeRequest: EstimateFeeRequest$Type;
declare class EstimateFeeResponse$Type extends MessageType<EstimateFeeResponse> {
    constructor();
    create(value?: PartialMessage<EstimateFeeResponse>): EstimateFeeResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateFeeResponse): EstimateFeeResponse;
    internalBinaryWrite(message: EstimateFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.EstimateFeeResponse
 */
export declare const EstimateFeeResponse: EstimateFeeResponse$Type;
declare class SendManyRequest$Type extends MessageType<SendManyRequest> {
    constructor();
    create(value?: PartialMessage<SendManyRequest>): SendManyRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendManyRequest): SendManyRequest;
    private binaryReadMap1;
    internalBinaryWrite(message: SendManyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendManyRequest
 */
export declare const SendManyRequest: SendManyRequest$Type;
declare class SendManyResponse$Type extends MessageType<SendManyResponse> {
    constructor();
    create(value?: PartialMessage<SendManyResponse>): SendManyResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendManyResponse): SendManyResponse;
    internalBinaryWrite(message: SendManyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendManyResponse
 */
export declare const SendManyResponse: SendManyResponse$Type;
declare class SendCoinsRequest$Type extends MessageType<SendCoinsRequest> {
    constructor();
    create(value?: PartialMessage<SendCoinsRequest>): SendCoinsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCoinsRequest): SendCoinsRequest;
    internalBinaryWrite(message: SendCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCoinsRequest
 */
export declare const SendCoinsRequest: SendCoinsRequest$Type;
declare class SendCoinsResponse$Type extends MessageType<SendCoinsResponse> {
    constructor();
    create(value?: PartialMessage<SendCoinsResponse>): SendCoinsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCoinsResponse): SendCoinsResponse;
    internalBinaryWrite(message: SendCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCoinsResponse
 */
export declare const SendCoinsResponse: SendCoinsResponse$Type;
declare class ListUnspentRequest$Type extends MessageType<ListUnspentRequest> {
    constructor();
    create(value?: PartialMessage<ListUnspentRequest>): ListUnspentRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnspentRequest): ListUnspentRequest;
    internalBinaryWrite(message: ListUnspentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListUnspentRequest
 */
export declare const ListUnspentRequest: ListUnspentRequest$Type;
declare class ListUnspentResponse$Type extends MessageType<ListUnspentResponse> {
    constructor();
    create(value?: PartialMessage<ListUnspentResponse>): ListUnspentResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnspentResponse): ListUnspentResponse;
    internalBinaryWrite(message: ListUnspentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListUnspentResponse
 */
export declare const ListUnspentResponse: ListUnspentResponse$Type;
declare class NewAddressRequest$Type extends MessageType<NewAddressRequest> {
    constructor();
    create(value?: PartialMessage<NewAddressRequest>): NewAddressRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewAddressRequest): NewAddressRequest;
    internalBinaryWrite(message: NewAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NewAddressRequest
 */
export declare const NewAddressRequest: NewAddressRequest$Type;
declare class NewAddressResponse$Type extends MessageType<NewAddressResponse> {
    constructor();
    create(value?: PartialMessage<NewAddressResponse>): NewAddressResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewAddressResponse): NewAddressResponse;
    internalBinaryWrite(message: NewAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NewAddressResponse
 */
export declare const NewAddressResponse: NewAddressResponse$Type;
declare class SignMessageRequest$Type extends MessageType<SignMessageRequest> {
    constructor();
    create(value?: PartialMessage<SignMessageRequest>): SignMessageRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageRequest): SignMessageRequest;
    internalBinaryWrite(message: SignMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SignMessageRequest
 */
export declare const SignMessageRequest: SignMessageRequest$Type;
declare class SignMessageResponse$Type extends MessageType<SignMessageResponse> {
    constructor();
    create(value?: PartialMessage<SignMessageResponse>): SignMessageResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageResponse): SignMessageResponse;
    internalBinaryWrite(message: SignMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SignMessageResponse
 */
export declare const SignMessageResponse: SignMessageResponse$Type;
declare class VerifyMessageRequest$Type extends MessageType<VerifyMessageRequest> {
    constructor();
    create(value?: PartialMessage<VerifyMessageRequest>): VerifyMessageRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageRequest): VerifyMessageRequest;
    internalBinaryWrite(message: VerifyMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.VerifyMessageRequest
 */
export declare const VerifyMessageRequest: VerifyMessageRequest$Type;
declare class VerifyMessageResponse$Type extends MessageType<VerifyMessageResponse> {
    constructor();
    create(value?: PartialMessage<VerifyMessageResponse>): VerifyMessageResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageResponse): VerifyMessageResponse;
    internalBinaryWrite(message: VerifyMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.VerifyMessageResponse
 */
export declare const VerifyMessageResponse: VerifyMessageResponse$Type;
declare class ConnectPeerRequest$Type extends MessageType<ConnectPeerRequest> {
    constructor();
    create(value?: PartialMessage<ConnectPeerRequest>): ConnectPeerRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectPeerRequest): ConnectPeerRequest;
    internalBinaryWrite(message: ConnectPeerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ConnectPeerRequest
 */
export declare const ConnectPeerRequest: ConnectPeerRequest$Type;
declare class ConnectPeerResponse$Type extends MessageType<ConnectPeerResponse> {
    constructor();
    create(value?: PartialMessage<ConnectPeerResponse>): ConnectPeerResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectPeerResponse): ConnectPeerResponse;
    internalBinaryWrite(message: ConnectPeerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ConnectPeerResponse
 */
export declare const ConnectPeerResponse: ConnectPeerResponse$Type;
declare class DisconnectPeerRequest$Type extends MessageType<DisconnectPeerRequest> {
    constructor();
    create(value?: PartialMessage<DisconnectPeerRequest>): DisconnectPeerRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectPeerRequest): DisconnectPeerRequest;
    internalBinaryWrite(message: DisconnectPeerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DisconnectPeerRequest
 */
export declare const DisconnectPeerRequest: DisconnectPeerRequest$Type;
declare class DisconnectPeerResponse$Type extends MessageType<DisconnectPeerResponse> {
    constructor();
    create(value?: PartialMessage<DisconnectPeerResponse>): DisconnectPeerResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectPeerResponse): DisconnectPeerResponse;
    internalBinaryWrite(message: DisconnectPeerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DisconnectPeerResponse
 */
export declare const DisconnectPeerResponse: DisconnectPeerResponse$Type;
declare class HTLC$Type extends MessageType<HTLC> {
    constructor();
    create(value?: PartialMessage<HTLC>): HTLC;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTLC): HTLC;
    internalBinaryWrite(message: HTLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.HTLC
 */
export declare const HTLC: HTLC$Type;
declare class ChannelConstraints$Type extends MessageType<ChannelConstraints> {
    constructor();
    create(value?: PartialMessage<ChannelConstraints>): ChannelConstraints;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelConstraints): ChannelConstraints;
    internalBinaryWrite(message: ChannelConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelConstraints
 */
export declare const ChannelConstraints: ChannelConstraints$Type;
declare class Channel$Type extends MessageType<Channel> {
    constructor();
    create(value?: PartialMessage<Channel>): Channel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Channel): Channel;
    internalBinaryWrite(message: Channel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Channel
 */
export declare const Channel: Channel$Type;
declare class ListChannelsRequest$Type extends MessageType<ListChannelsRequest> {
    constructor();
    create(value?: PartialMessage<ListChannelsRequest>): ListChannelsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListChannelsRequest): ListChannelsRequest;
    internalBinaryWrite(message: ListChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListChannelsRequest
 */
export declare const ListChannelsRequest: ListChannelsRequest$Type;
declare class ListChannelsResponse$Type extends MessageType<ListChannelsResponse> {
    constructor();
    create(value?: PartialMessage<ListChannelsResponse>): ListChannelsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListChannelsResponse): ListChannelsResponse;
    internalBinaryWrite(message: ListChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListChannelsResponse
 */
export declare const ListChannelsResponse: ListChannelsResponse$Type;
declare class AliasMap$Type extends MessageType<AliasMap> {
    constructor();
    create(value?: PartialMessage<AliasMap>): AliasMap;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AliasMap): AliasMap;
    internalBinaryWrite(message: AliasMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AliasMap
 */
export declare const AliasMap: AliasMap$Type;
declare class ListAliasesRequest$Type extends MessageType<ListAliasesRequest> {
    constructor();
    create(value?: PartialMessage<ListAliasesRequest>): ListAliasesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAliasesRequest): ListAliasesRequest;
    internalBinaryWrite(message: ListAliasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListAliasesRequest
 */
export declare const ListAliasesRequest: ListAliasesRequest$Type;
declare class ListAliasesResponse$Type extends MessageType<ListAliasesResponse> {
    constructor();
    create(value?: PartialMessage<ListAliasesResponse>): ListAliasesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAliasesResponse): ListAliasesResponse;
    internalBinaryWrite(message: ListAliasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListAliasesResponse
 */
export declare const ListAliasesResponse: ListAliasesResponse$Type;
declare class ChannelCloseSummary$Type extends MessageType<ChannelCloseSummary> {
    constructor();
    create(value?: PartialMessage<ChannelCloseSummary>): ChannelCloseSummary;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelCloseSummary): ChannelCloseSummary;
    internalBinaryWrite(message: ChannelCloseSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelCloseSummary
 */
export declare const ChannelCloseSummary: ChannelCloseSummary$Type;
declare class Resolution$Type extends MessageType<Resolution> {
    constructor();
    create(value?: PartialMessage<Resolution>): Resolution;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resolution): Resolution;
    internalBinaryWrite(message: Resolution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Resolution
 */
export declare const Resolution: Resolution$Type;
declare class ClosedChannelsRequest$Type extends MessageType<ClosedChannelsRequest> {
    constructor();
    create(value?: PartialMessage<ClosedChannelsRequest>): ClosedChannelsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClosedChannelsRequest): ClosedChannelsRequest;
    internalBinaryWrite(message: ClosedChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ClosedChannelsRequest
 */
export declare const ClosedChannelsRequest: ClosedChannelsRequest$Type;
declare class ClosedChannelsResponse$Type extends MessageType<ClosedChannelsResponse> {
    constructor();
    create(value?: PartialMessage<ClosedChannelsResponse>): ClosedChannelsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClosedChannelsResponse): ClosedChannelsResponse;
    internalBinaryWrite(message: ClosedChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ClosedChannelsResponse
 */
export declare const ClosedChannelsResponse: ClosedChannelsResponse$Type;
declare class Peer$Type extends MessageType<Peer> {
    constructor();
    create(value?: PartialMessage<Peer>): Peer;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Peer): Peer;
    private binaryReadMap11;
    internalBinaryWrite(message: Peer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Peer
 */
export declare const Peer: Peer$Type;
declare class TimestampedError$Type extends MessageType<TimestampedError> {
    constructor();
    create(value?: PartialMessage<TimestampedError>): TimestampedError;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimestampedError): TimestampedError;
    internalBinaryWrite(message: TimestampedError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.TimestampedError
 */
export declare const TimestampedError: TimestampedError$Type;
declare class ListPeersRequest$Type extends MessageType<ListPeersRequest> {
    constructor();
    create(value?: PartialMessage<ListPeersRequest>): ListPeersRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPeersRequest): ListPeersRequest;
    internalBinaryWrite(message: ListPeersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPeersRequest
 */
export declare const ListPeersRequest: ListPeersRequest$Type;
declare class ListPeersResponse$Type extends MessageType<ListPeersResponse> {
    constructor();
    create(value?: PartialMessage<ListPeersResponse>): ListPeersResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPeersResponse): ListPeersResponse;
    internalBinaryWrite(message: ListPeersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPeersResponse
 */
export declare const ListPeersResponse: ListPeersResponse$Type;
declare class PeerEventSubscription$Type extends MessageType<PeerEventSubscription> {
    constructor();
    create(value?: PartialMessage<PeerEventSubscription>): PeerEventSubscription;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerEventSubscription): PeerEventSubscription;
    internalBinaryWrite(message: PeerEventSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PeerEventSubscription
 */
export declare const PeerEventSubscription: PeerEventSubscription$Type;
declare class PeerEvent$Type extends MessageType<PeerEvent> {
    constructor();
    create(value?: PartialMessage<PeerEvent>): PeerEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerEvent): PeerEvent;
    internalBinaryWrite(message: PeerEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PeerEvent
 */
export declare const PeerEvent: PeerEvent$Type;
declare class GetInfoRequest$Type extends MessageType<GetInfoRequest> {
    constructor();
    create(value?: PartialMessage<GetInfoRequest>): GetInfoRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoRequest): GetInfoRequest;
    internalBinaryWrite(message: GetInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GetInfoRequest
 */
export declare const GetInfoRequest: GetInfoRequest$Type;
declare class GetInfoResponse$Type extends MessageType<GetInfoResponse> {
    constructor();
    create(value?: PartialMessage<GetInfoResponse>): GetInfoResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoResponse): GetInfoResponse;
    private binaryReadMap19;
    internalBinaryWrite(message: GetInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GetInfoResponse
 */
export declare const GetInfoResponse: GetInfoResponse$Type;
declare class GetRecoveryInfoRequest$Type extends MessageType<GetRecoveryInfoRequest> {
    constructor();
    create(value?: PartialMessage<GetRecoveryInfoRequest>): GetRecoveryInfoRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRecoveryInfoRequest): GetRecoveryInfoRequest;
    internalBinaryWrite(message: GetRecoveryInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GetRecoveryInfoRequest
 */
export declare const GetRecoveryInfoRequest: GetRecoveryInfoRequest$Type;
declare class GetRecoveryInfoResponse$Type extends MessageType<GetRecoveryInfoResponse> {
    constructor();
    create(value?: PartialMessage<GetRecoveryInfoResponse>): GetRecoveryInfoResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRecoveryInfoResponse): GetRecoveryInfoResponse;
    internalBinaryWrite(message: GetRecoveryInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GetRecoveryInfoResponse
 */
export declare const GetRecoveryInfoResponse: GetRecoveryInfoResponse$Type;
declare class Chain$Type extends MessageType<Chain> {
    constructor();
    create(value?: PartialMessage<Chain>): Chain;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chain): Chain;
    internalBinaryWrite(message: Chain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Chain
 */
export declare const Chain: Chain$Type;
declare class ConfirmationUpdate$Type extends MessageType<ConfirmationUpdate> {
    constructor();
    create(value?: PartialMessage<ConfirmationUpdate>): ConfirmationUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfirmationUpdate): ConfirmationUpdate;
    internalBinaryWrite(message: ConfirmationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ConfirmationUpdate
 */
export declare const ConfirmationUpdate: ConfirmationUpdate$Type;
declare class ChannelOpenUpdate$Type extends MessageType<ChannelOpenUpdate> {
    constructor();
    create(value?: PartialMessage<ChannelOpenUpdate>): ChannelOpenUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelOpenUpdate): ChannelOpenUpdate;
    internalBinaryWrite(message: ChannelOpenUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelOpenUpdate
 */
export declare const ChannelOpenUpdate: ChannelOpenUpdate$Type;
declare class ChannelCloseUpdate$Type extends MessageType<ChannelCloseUpdate> {
    constructor();
    create(value?: PartialMessage<ChannelCloseUpdate>): ChannelCloseUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelCloseUpdate): ChannelCloseUpdate;
    internalBinaryWrite(message: ChannelCloseUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelCloseUpdate
 */
export declare const ChannelCloseUpdate: ChannelCloseUpdate$Type;
declare class CloseChannelRequest$Type extends MessageType<CloseChannelRequest> {
    constructor();
    create(value?: PartialMessage<CloseChannelRequest>): CloseChannelRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseChannelRequest): CloseChannelRequest;
    internalBinaryWrite(message: CloseChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.CloseChannelRequest
 */
export declare const CloseChannelRequest: CloseChannelRequest$Type;
declare class CloseStatusUpdate$Type extends MessageType<CloseStatusUpdate> {
    constructor();
    create(value?: PartialMessage<CloseStatusUpdate>): CloseStatusUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseStatusUpdate): CloseStatusUpdate;
    internalBinaryWrite(message: CloseStatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.CloseStatusUpdate
 */
export declare const CloseStatusUpdate: CloseStatusUpdate$Type;
declare class PendingUpdate$Type extends MessageType<PendingUpdate> {
    constructor();
    create(value?: PartialMessage<PendingUpdate>): PendingUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingUpdate): PendingUpdate;
    internalBinaryWrite(message: PendingUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingUpdate
 */
export declare const PendingUpdate: PendingUpdate$Type;
declare class ReadyForPsbtFunding$Type extends MessageType<ReadyForPsbtFunding> {
    constructor();
    create(value?: PartialMessage<ReadyForPsbtFunding>): ReadyForPsbtFunding;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadyForPsbtFunding): ReadyForPsbtFunding;
    internalBinaryWrite(message: ReadyForPsbtFunding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ReadyForPsbtFunding
 */
export declare const ReadyForPsbtFunding: ReadyForPsbtFunding$Type;
declare class BatchOpenChannelRequest$Type extends MessageType<BatchOpenChannelRequest> {
    constructor();
    create(value?: PartialMessage<BatchOpenChannelRequest>): BatchOpenChannelRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOpenChannelRequest): BatchOpenChannelRequest;
    internalBinaryWrite(message: BatchOpenChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.BatchOpenChannelRequest
 */
export declare const BatchOpenChannelRequest: BatchOpenChannelRequest$Type;
declare class BatchOpenChannel$Type extends MessageType<BatchOpenChannel> {
    constructor();
    create(value?: PartialMessage<BatchOpenChannel>): BatchOpenChannel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOpenChannel): BatchOpenChannel;
    internalBinaryWrite(message: BatchOpenChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.BatchOpenChannel
 */
export declare const BatchOpenChannel: BatchOpenChannel$Type;
declare class BatchOpenChannelResponse$Type extends MessageType<BatchOpenChannelResponse> {
    constructor();
    create(value?: PartialMessage<BatchOpenChannelResponse>): BatchOpenChannelResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOpenChannelResponse): BatchOpenChannelResponse;
    internalBinaryWrite(message: BatchOpenChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.BatchOpenChannelResponse
 */
export declare const BatchOpenChannelResponse: BatchOpenChannelResponse$Type;
declare class OpenChannelRequest$Type extends MessageType<OpenChannelRequest> {
    constructor();
    create(value?: PartialMessage<OpenChannelRequest>): OpenChannelRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenChannelRequest): OpenChannelRequest;
    internalBinaryWrite(message: OpenChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.OpenChannelRequest
 */
export declare const OpenChannelRequest: OpenChannelRequest$Type;
declare class OpenStatusUpdate$Type extends MessageType<OpenStatusUpdate> {
    constructor();
    create(value?: PartialMessage<OpenStatusUpdate>): OpenStatusUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenStatusUpdate): OpenStatusUpdate;
    internalBinaryWrite(message: OpenStatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.OpenStatusUpdate
 */
export declare const OpenStatusUpdate: OpenStatusUpdate$Type;
declare class KeyLocator$Type extends MessageType<KeyLocator> {
    constructor();
    create(value?: PartialMessage<KeyLocator>): KeyLocator;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyLocator): KeyLocator;
    internalBinaryWrite(message: KeyLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.KeyLocator
 */
export declare const KeyLocator: KeyLocator$Type;
declare class KeyDescriptor$Type extends MessageType<KeyDescriptor> {
    constructor();
    create(value?: PartialMessage<KeyDescriptor>): KeyDescriptor;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyDescriptor): KeyDescriptor;
    internalBinaryWrite(message: KeyDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.KeyDescriptor
 */
export declare const KeyDescriptor: KeyDescriptor$Type;
declare class ChanPointShim$Type extends MessageType<ChanPointShim> {
    constructor();
    create(value?: PartialMessage<ChanPointShim>): ChanPointShim;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanPointShim): ChanPointShim;
    internalBinaryWrite(message: ChanPointShim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanPointShim
 */
export declare const ChanPointShim: ChanPointShim$Type;
declare class PsbtShim$Type extends MessageType<PsbtShim> {
    constructor();
    create(value?: PartialMessage<PsbtShim>): PsbtShim;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PsbtShim): PsbtShim;
    internalBinaryWrite(message: PsbtShim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PsbtShim
 */
export declare const PsbtShim: PsbtShim$Type;
declare class FundingShim$Type extends MessageType<FundingShim> {
    constructor();
    create(value?: PartialMessage<FundingShim>): FundingShim;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingShim): FundingShim;
    internalBinaryWrite(message: FundingShim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingShim
 */
export declare const FundingShim: FundingShim$Type;
declare class FundingShimCancel$Type extends MessageType<FundingShimCancel> {
    constructor();
    create(value?: PartialMessage<FundingShimCancel>): FundingShimCancel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingShimCancel): FundingShimCancel;
    internalBinaryWrite(message: FundingShimCancel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingShimCancel
 */
export declare const FundingShimCancel: FundingShimCancel$Type;
declare class FundingPsbtVerify$Type extends MessageType<FundingPsbtVerify> {
    constructor();
    create(value?: PartialMessage<FundingPsbtVerify>): FundingPsbtVerify;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPsbtVerify): FundingPsbtVerify;
    internalBinaryWrite(message: FundingPsbtVerify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingPsbtVerify
 */
export declare const FundingPsbtVerify: FundingPsbtVerify$Type;
declare class FundingPsbtFinalize$Type extends MessageType<FundingPsbtFinalize> {
    constructor();
    create(value?: PartialMessage<FundingPsbtFinalize>): FundingPsbtFinalize;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPsbtFinalize): FundingPsbtFinalize;
    internalBinaryWrite(message: FundingPsbtFinalize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingPsbtFinalize
 */
export declare const FundingPsbtFinalize: FundingPsbtFinalize$Type;
declare class FundingTransitionMsg$Type extends MessageType<FundingTransitionMsg> {
    constructor();
    create(value?: PartialMessage<FundingTransitionMsg>): FundingTransitionMsg;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingTransitionMsg): FundingTransitionMsg;
    internalBinaryWrite(message: FundingTransitionMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingTransitionMsg
 */
export declare const FundingTransitionMsg: FundingTransitionMsg$Type;
declare class FundingStateStepResp$Type extends MessageType<FundingStateStepResp> {
    constructor();
    create(value?: PartialMessage<FundingStateStepResp>): FundingStateStepResp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingStateStepResp): FundingStateStepResp;
    internalBinaryWrite(message: FundingStateStepResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingStateStepResp
 */
export declare const FundingStateStepResp: FundingStateStepResp$Type;
declare class PendingHTLC$Type extends MessageType<PendingHTLC> {
    constructor();
    create(value?: PartialMessage<PendingHTLC>): PendingHTLC;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingHTLC): PendingHTLC;
    internalBinaryWrite(message: PendingHTLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingHTLC
 */
export declare const PendingHTLC: PendingHTLC$Type;
declare class PendingChannelsRequest$Type extends MessageType<PendingChannelsRequest> {
    constructor();
    create(value?: PartialMessage<PendingChannelsRequest>): PendingChannelsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsRequest): PendingChannelsRequest;
    internalBinaryWrite(message: PendingChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsRequest
 */
export declare const PendingChannelsRequest: PendingChannelsRequest$Type;
declare class PendingChannelsResponse$Type extends MessageType<PendingChannelsResponse> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse>): PendingChannelsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse): PendingChannelsResponse;
    internalBinaryWrite(message: PendingChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse
 */
export declare const PendingChannelsResponse: PendingChannelsResponse$Type;
declare class PendingChannelsResponse_PendingChannel$Type extends MessageType<PendingChannelsResponse_PendingChannel> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse_PendingChannel>): PendingChannelsResponse_PendingChannel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_PendingChannel): PendingChannelsResponse_PendingChannel;
    internalBinaryWrite(message: PendingChannelsResponse_PendingChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.PendingChannel
 */
export declare const PendingChannelsResponse_PendingChannel: PendingChannelsResponse_PendingChannel$Type;
declare class PendingChannelsResponse_PendingOpenChannel$Type extends MessageType<PendingChannelsResponse_PendingOpenChannel> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse_PendingOpenChannel>): PendingChannelsResponse_PendingOpenChannel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_PendingOpenChannel): PendingChannelsResponse_PendingOpenChannel;
    internalBinaryWrite(message: PendingChannelsResponse_PendingOpenChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.PendingOpenChannel
 */
export declare const PendingChannelsResponse_PendingOpenChannel: PendingChannelsResponse_PendingOpenChannel$Type;
declare class PendingChannelsResponse_WaitingCloseChannel$Type extends MessageType<PendingChannelsResponse_WaitingCloseChannel> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse_WaitingCloseChannel>): PendingChannelsResponse_WaitingCloseChannel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_WaitingCloseChannel): PendingChannelsResponse_WaitingCloseChannel;
    internalBinaryWrite(message: PendingChannelsResponse_WaitingCloseChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.WaitingCloseChannel
 */
export declare const PendingChannelsResponse_WaitingCloseChannel: PendingChannelsResponse_WaitingCloseChannel$Type;
declare class PendingChannelsResponse_Commitments$Type extends MessageType<PendingChannelsResponse_Commitments> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse_Commitments>): PendingChannelsResponse_Commitments;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_Commitments): PendingChannelsResponse_Commitments;
    internalBinaryWrite(message: PendingChannelsResponse_Commitments, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.Commitments
 */
export declare const PendingChannelsResponse_Commitments: PendingChannelsResponse_Commitments$Type;
declare class PendingChannelsResponse_ClosedChannel$Type extends MessageType<PendingChannelsResponse_ClosedChannel> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse_ClosedChannel>): PendingChannelsResponse_ClosedChannel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_ClosedChannel): PendingChannelsResponse_ClosedChannel;
    internalBinaryWrite(message: PendingChannelsResponse_ClosedChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.ClosedChannel
 */
export declare const PendingChannelsResponse_ClosedChannel: PendingChannelsResponse_ClosedChannel$Type;
declare class PendingChannelsResponse_ForceClosedChannel$Type extends MessageType<PendingChannelsResponse_ForceClosedChannel> {
    constructor();
    create(value?: PartialMessage<PendingChannelsResponse_ForceClosedChannel>): PendingChannelsResponse_ForceClosedChannel;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_ForceClosedChannel): PendingChannelsResponse_ForceClosedChannel;
    internalBinaryWrite(message: PendingChannelsResponse_ForceClosedChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.ForceClosedChannel
 */
export declare const PendingChannelsResponse_ForceClosedChannel: PendingChannelsResponse_ForceClosedChannel$Type;
declare class ChannelEventSubscription$Type extends MessageType<ChannelEventSubscription> {
    constructor();
    create(value?: PartialMessage<ChannelEventSubscription>): ChannelEventSubscription;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEventSubscription): ChannelEventSubscription;
    internalBinaryWrite(message: ChannelEventSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEventSubscription
 */
export declare const ChannelEventSubscription: ChannelEventSubscription$Type;
declare class ChannelEventUpdate$Type extends MessageType<ChannelEventUpdate> {
    constructor();
    create(value?: PartialMessage<ChannelEventUpdate>): ChannelEventUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEventUpdate): ChannelEventUpdate;
    internalBinaryWrite(message: ChannelEventUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEventUpdate
 */
export declare const ChannelEventUpdate: ChannelEventUpdate$Type;
declare class WalletAccountBalance$Type extends MessageType<WalletAccountBalance> {
    constructor();
    create(value?: PartialMessage<WalletAccountBalance>): WalletAccountBalance;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WalletAccountBalance): WalletAccountBalance;
    internalBinaryWrite(message: WalletAccountBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.WalletAccountBalance
 */
export declare const WalletAccountBalance: WalletAccountBalance$Type;
declare class WalletBalanceRequest$Type extends MessageType<WalletBalanceRequest> {
    constructor();
    create(value?: PartialMessage<WalletBalanceRequest>): WalletBalanceRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WalletBalanceRequest): WalletBalanceRequest;
    internalBinaryWrite(message: WalletBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.WalletBalanceRequest
 */
export declare const WalletBalanceRequest: WalletBalanceRequest$Type;
declare class WalletBalanceResponse$Type extends MessageType<WalletBalanceResponse> {
    constructor();
    create(value?: PartialMessage<WalletBalanceResponse>): WalletBalanceResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WalletBalanceResponse): WalletBalanceResponse;
    private binaryReadMap4;
    internalBinaryWrite(message: WalletBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.WalletBalanceResponse
 */
export declare const WalletBalanceResponse: WalletBalanceResponse$Type;
declare class Amount$Type extends MessageType<Amount> {
    constructor();
    create(value?: PartialMessage<Amount>): Amount;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Amount): Amount;
    internalBinaryWrite(message: Amount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Amount
 */
export declare const Amount: Amount$Type;
declare class ChannelBalanceRequest$Type extends MessageType<ChannelBalanceRequest> {
    constructor();
    create(value?: PartialMessage<ChannelBalanceRequest>): ChannelBalanceRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBalanceRequest): ChannelBalanceRequest;
    internalBinaryWrite(message: ChannelBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBalanceRequest
 */
export declare const ChannelBalanceRequest: ChannelBalanceRequest$Type;
declare class ChannelBalanceResponse$Type extends MessageType<ChannelBalanceResponse> {
    constructor();
    create(value?: PartialMessage<ChannelBalanceResponse>): ChannelBalanceResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBalanceResponse): ChannelBalanceResponse;
    internalBinaryWrite(message: ChannelBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBalanceResponse
 */
export declare const ChannelBalanceResponse: ChannelBalanceResponse$Type;
declare class QueryRoutesRequest$Type extends MessageType<QueryRoutesRequest> {
    constructor();
    create(value?: PartialMessage<QueryRoutesRequest>): QueryRoutesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRoutesRequest): QueryRoutesRequest;
    private binaryReadMap13;
    internalBinaryWrite(message: QueryRoutesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.QueryRoutesRequest
 */
export declare const QueryRoutesRequest: QueryRoutesRequest$Type;
declare class NodePair$Type extends MessageType<NodePair> {
    constructor();
    create(value?: PartialMessage<NodePair>): NodePair;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodePair): NodePair;
    internalBinaryWrite(message: NodePair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodePair
 */
export declare const NodePair: NodePair$Type;
declare class EdgeLocator$Type extends MessageType<EdgeLocator> {
    constructor();
    create(value?: PartialMessage<EdgeLocator>): EdgeLocator;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EdgeLocator): EdgeLocator;
    internalBinaryWrite(message: EdgeLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.EdgeLocator
 */
export declare const EdgeLocator: EdgeLocator$Type;
declare class QueryRoutesResponse$Type extends MessageType<QueryRoutesResponse> {
    constructor();
    create(value?: PartialMessage<QueryRoutesResponse>): QueryRoutesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRoutesResponse): QueryRoutesResponse;
    internalBinaryWrite(message: QueryRoutesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.QueryRoutesResponse
 */
export declare const QueryRoutesResponse: QueryRoutesResponse$Type;
declare class Hop$Type extends MessageType<Hop> {
    constructor();
    create(value?: PartialMessage<Hop>): Hop;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Hop): Hop;
    private binaryReadMap11;
    internalBinaryWrite(message: Hop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Hop
 */
export declare const Hop: Hop$Type;
declare class MPPRecord$Type extends MessageType<MPPRecord> {
    constructor();
    create(value?: PartialMessage<MPPRecord>): MPPRecord;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MPPRecord): MPPRecord;
    internalBinaryWrite(message: MPPRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.MPPRecord
 */
export declare const MPPRecord: MPPRecord$Type;
declare class AMPRecord$Type extends MessageType<AMPRecord> {
    constructor();
    create(value?: PartialMessage<AMPRecord>): AMPRecord;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AMPRecord): AMPRecord;
    internalBinaryWrite(message: AMPRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AMPRecord
 */
export declare const AMPRecord: AMPRecord$Type;
declare class Route$Type extends MessageType<Route> {
    constructor();
    create(value?: PartialMessage<Route>): Route;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Route): Route;
    internalBinaryWrite(message: Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Route
 */
export declare const Route: Route$Type;
declare class NodeInfoRequest$Type extends MessageType<NodeInfoRequest> {
    constructor();
    create(value?: PartialMessage<NodeInfoRequest>): NodeInfoRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeInfoRequest): NodeInfoRequest;
    internalBinaryWrite(message: NodeInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeInfoRequest
 */
export declare const NodeInfoRequest: NodeInfoRequest$Type;
declare class NodeInfo$Type extends MessageType<NodeInfo> {
    constructor();
    create(value?: PartialMessage<NodeInfo>): NodeInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeInfo): NodeInfo;
    internalBinaryWrite(message: NodeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeInfo
 */
export declare const NodeInfo: NodeInfo$Type;
declare class LightningNode$Type extends MessageType<LightningNode> {
    constructor();
    create(value?: PartialMessage<LightningNode>): LightningNode;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightningNode): LightningNode;
    private binaryReadMap6;
    private binaryReadMap7;
    internalBinaryWrite(message: LightningNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.LightningNode
 */
export declare const LightningNode: LightningNode$Type;
declare class NodeAddress$Type extends MessageType<NodeAddress> {
    constructor();
    create(value?: PartialMessage<NodeAddress>): NodeAddress;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeAddress): NodeAddress;
    internalBinaryWrite(message: NodeAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeAddress
 */
export declare const NodeAddress: NodeAddress$Type;
declare class RoutingPolicy$Type extends MessageType<RoutingPolicy> {
    constructor();
    create(value?: PartialMessage<RoutingPolicy>): RoutingPolicy;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutingPolicy): RoutingPolicy;
    private binaryReadMap8;
    internalBinaryWrite(message: RoutingPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RoutingPolicy
 */
export declare const RoutingPolicy: RoutingPolicy$Type;
declare class ChannelEdge$Type extends MessageType<ChannelEdge> {
    constructor();
    create(value?: PartialMessage<ChannelEdge>): ChannelEdge;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEdge): ChannelEdge;
    private binaryReadMap9;
    internalBinaryWrite(message: ChannelEdge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEdge
 */
export declare const ChannelEdge: ChannelEdge$Type;
declare class ChannelGraphRequest$Type extends MessageType<ChannelGraphRequest> {
    constructor();
    create(value?: PartialMessage<ChannelGraphRequest>): ChannelGraphRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelGraphRequest): ChannelGraphRequest;
    internalBinaryWrite(message: ChannelGraphRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelGraphRequest
 */
export declare const ChannelGraphRequest: ChannelGraphRequest$Type;
declare class ChannelGraph$Type extends MessageType<ChannelGraph> {
    constructor();
    create(value?: PartialMessage<ChannelGraph>): ChannelGraph;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelGraph): ChannelGraph;
    internalBinaryWrite(message: ChannelGraph, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelGraph
 */
export declare const ChannelGraph: ChannelGraph$Type;
declare class NodeMetricsRequest$Type extends MessageType<NodeMetricsRequest> {
    constructor();
    create(value?: PartialMessage<NodeMetricsRequest>): NodeMetricsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeMetricsRequest): NodeMetricsRequest;
    internalBinaryWrite(message: NodeMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeMetricsRequest
 */
export declare const NodeMetricsRequest: NodeMetricsRequest$Type;
declare class NodeMetricsResponse$Type extends MessageType<NodeMetricsResponse> {
    constructor();
    create(value?: PartialMessage<NodeMetricsResponse>): NodeMetricsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeMetricsResponse): NodeMetricsResponse;
    private binaryReadMap1;
    internalBinaryWrite(message: NodeMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeMetricsResponse
 */
export declare const NodeMetricsResponse: NodeMetricsResponse$Type;
declare class FloatMetric$Type extends MessageType<FloatMetric> {
    constructor();
    create(value?: PartialMessage<FloatMetric>): FloatMetric;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FloatMetric): FloatMetric;
    internalBinaryWrite(message: FloatMetric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FloatMetric
 */
export declare const FloatMetric: FloatMetric$Type;
declare class ChanInfoRequest$Type extends MessageType<ChanInfoRequest> {
    constructor();
    create(value?: PartialMessage<ChanInfoRequest>): ChanInfoRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanInfoRequest): ChanInfoRequest;
    internalBinaryWrite(message: ChanInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanInfoRequest
 */
export declare const ChanInfoRequest: ChanInfoRequest$Type;
declare class NetworkInfoRequest$Type extends MessageType<NetworkInfoRequest> {
    constructor();
    create(value?: PartialMessage<NetworkInfoRequest>): NetworkInfoRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkInfoRequest): NetworkInfoRequest;
    internalBinaryWrite(message: NetworkInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NetworkInfoRequest
 */
export declare const NetworkInfoRequest: NetworkInfoRequest$Type;
declare class NetworkInfo$Type extends MessageType<NetworkInfo> {
    constructor();
    create(value?: PartialMessage<NetworkInfo>): NetworkInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkInfo): NetworkInfo;
    internalBinaryWrite(message: NetworkInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NetworkInfo
 */
export declare const NetworkInfo: NetworkInfo$Type;
declare class StopRequest$Type extends MessageType<StopRequest> {
    constructor();
    create(value?: PartialMessage<StopRequest>): StopRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopRequest): StopRequest;
    internalBinaryWrite(message: StopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.StopRequest
 */
export declare const StopRequest: StopRequest$Type;
declare class StopResponse$Type extends MessageType<StopResponse> {
    constructor();
    create(value?: PartialMessage<StopResponse>): StopResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopResponse): StopResponse;
    internalBinaryWrite(message: StopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.StopResponse
 */
export declare const StopResponse: StopResponse$Type;
declare class GraphTopologySubscription$Type extends MessageType<GraphTopologySubscription> {
    constructor();
    create(value?: PartialMessage<GraphTopologySubscription>): GraphTopologySubscription;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GraphTopologySubscription): GraphTopologySubscription;
    internalBinaryWrite(message: GraphTopologySubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GraphTopologySubscription
 */
export declare const GraphTopologySubscription: GraphTopologySubscription$Type;
declare class GraphTopologyUpdate$Type extends MessageType<GraphTopologyUpdate> {
    constructor();
    create(value?: PartialMessage<GraphTopologyUpdate>): GraphTopologyUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GraphTopologyUpdate): GraphTopologyUpdate;
    internalBinaryWrite(message: GraphTopologyUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.GraphTopologyUpdate
 */
export declare const GraphTopologyUpdate: GraphTopologyUpdate$Type;
declare class NodeUpdate$Type extends MessageType<NodeUpdate> {
    constructor();
    create(value?: PartialMessage<NodeUpdate>): NodeUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeUpdate): NodeUpdate;
    private binaryReadMap6;
    internalBinaryWrite(message: NodeUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeUpdate
 */
export declare const NodeUpdate: NodeUpdate$Type;
declare class ChannelEdgeUpdate$Type extends MessageType<ChannelEdgeUpdate> {
    constructor();
    create(value?: PartialMessage<ChannelEdgeUpdate>): ChannelEdgeUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEdgeUpdate): ChannelEdgeUpdate;
    internalBinaryWrite(message: ChannelEdgeUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEdgeUpdate
 */
export declare const ChannelEdgeUpdate: ChannelEdgeUpdate$Type;
declare class ClosedChannelUpdate$Type extends MessageType<ClosedChannelUpdate> {
    constructor();
    create(value?: PartialMessage<ClosedChannelUpdate>): ClosedChannelUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClosedChannelUpdate): ClosedChannelUpdate;
    internalBinaryWrite(message: ClosedChannelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ClosedChannelUpdate
 */
export declare const ClosedChannelUpdate: ClosedChannelUpdate$Type;
declare class HopHint$Type extends MessageType<HopHint> {
    constructor();
    create(value?: PartialMessage<HopHint>): HopHint;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HopHint): HopHint;
    internalBinaryWrite(message: HopHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.HopHint
 */
export declare const HopHint: HopHint$Type;
declare class SetID$Type extends MessageType<SetID> {
    constructor();
    create(value?: PartialMessage<SetID>): SetID;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetID): SetID;
    internalBinaryWrite(message: SetID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.SetID
 */
export declare const SetID: SetID$Type;
declare class RouteHint$Type extends MessageType<RouteHint> {
    constructor();
    create(value?: PartialMessage<RouteHint>): RouteHint;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteHint): RouteHint;
    internalBinaryWrite(message: RouteHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RouteHint
 */
export declare const RouteHint: RouteHint$Type;
declare class AMPInvoiceState$Type extends MessageType<AMPInvoiceState> {
    constructor();
    create(value?: PartialMessage<AMPInvoiceState>): AMPInvoiceState;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AMPInvoiceState): AMPInvoiceState;
    internalBinaryWrite(message: AMPInvoiceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AMPInvoiceState
 */
export declare const AMPInvoiceState: AMPInvoiceState$Type;
declare class Invoice$Type extends MessageType<Invoice> {
    constructor();
    create(value?: PartialMessage<Invoice>): Invoice;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Invoice): Invoice;
    private binaryReadMap24;
    private binaryReadMap28;
    internalBinaryWrite(message: Invoice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Invoice
 */
export declare const Invoice: Invoice$Type;
declare class InvoiceHTLC$Type extends MessageType<InvoiceHTLC> {
    constructor();
    create(value?: PartialMessage<InvoiceHTLC>): InvoiceHTLC;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvoiceHTLC): InvoiceHTLC;
    private binaryReadMap9;
    internalBinaryWrite(message: InvoiceHTLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.InvoiceHTLC
 */
export declare const InvoiceHTLC: InvoiceHTLC$Type;
declare class AMP$Type extends MessageType<AMP> {
    constructor();
    create(value?: PartialMessage<AMP>): AMP;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AMP): AMP;
    internalBinaryWrite(message: AMP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AMP
 */
export declare const AMP: AMP$Type;
declare class AddInvoiceResponse$Type extends MessageType<AddInvoiceResponse> {
    constructor();
    create(value?: PartialMessage<AddInvoiceResponse>): AddInvoiceResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddInvoiceResponse): AddInvoiceResponse;
    internalBinaryWrite(message: AddInvoiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AddInvoiceResponse
 */
export declare const AddInvoiceResponse: AddInvoiceResponse$Type;
declare class PaymentHash$Type extends MessageType<PaymentHash> {
    constructor();
    create(value?: PartialMessage<PaymentHash>): PaymentHash;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaymentHash): PaymentHash;
    internalBinaryWrite(message: PaymentHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PaymentHash
 */
export declare const PaymentHash: PaymentHash$Type;
declare class ListInvoiceRequest$Type extends MessageType<ListInvoiceRequest> {
    constructor();
    create(value?: PartialMessage<ListInvoiceRequest>): ListInvoiceRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListInvoiceRequest): ListInvoiceRequest;
    internalBinaryWrite(message: ListInvoiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListInvoiceRequest
 */
export declare const ListInvoiceRequest: ListInvoiceRequest$Type;
declare class ListInvoiceResponse$Type extends MessageType<ListInvoiceResponse> {
    constructor();
    create(value?: PartialMessage<ListInvoiceResponse>): ListInvoiceResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListInvoiceResponse): ListInvoiceResponse;
    internalBinaryWrite(message: ListInvoiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListInvoiceResponse
 */
export declare const ListInvoiceResponse: ListInvoiceResponse$Type;
declare class InvoiceSubscription$Type extends MessageType<InvoiceSubscription> {
    constructor();
    create(value?: PartialMessage<InvoiceSubscription>): InvoiceSubscription;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvoiceSubscription): InvoiceSubscription;
    internalBinaryWrite(message: InvoiceSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.InvoiceSubscription
 */
export declare const InvoiceSubscription: InvoiceSubscription$Type;
declare class Payment$Type extends MessageType<Payment> {
    constructor();
    create(value?: PartialMessage<Payment>): Payment;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payment): Payment;
    internalBinaryWrite(message: Payment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Payment
 */
export declare const Payment: Payment$Type;
declare class HTLCAttempt$Type extends MessageType<HTLCAttempt> {
    constructor();
    create(value?: PartialMessage<HTLCAttempt>): HTLCAttempt;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTLCAttempt): HTLCAttempt;
    internalBinaryWrite(message: HTLCAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.HTLCAttempt
 */
export declare const HTLCAttempt: HTLCAttempt$Type;
declare class ListPaymentsRequest$Type extends MessageType<ListPaymentsRequest> {
    constructor();
    create(value?: PartialMessage<ListPaymentsRequest>): ListPaymentsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaymentsRequest): ListPaymentsRequest;
    internalBinaryWrite(message: ListPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPaymentsRequest
 */
export declare const ListPaymentsRequest: ListPaymentsRequest$Type;
declare class ListPaymentsResponse$Type extends MessageType<ListPaymentsResponse> {
    constructor();
    create(value?: PartialMessage<ListPaymentsResponse>): ListPaymentsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaymentsResponse): ListPaymentsResponse;
    internalBinaryWrite(message: ListPaymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPaymentsResponse
 */
export declare const ListPaymentsResponse: ListPaymentsResponse$Type;
declare class DeletePaymentRequest$Type extends MessageType<DeletePaymentRequest> {
    constructor();
    create(value?: PartialMessage<DeletePaymentRequest>): DeletePaymentRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaymentRequest): DeletePaymentRequest;
    internalBinaryWrite(message: DeletePaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DeletePaymentRequest
 */
export declare const DeletePaymentRequest: DeletePaymentRequest$Type;
declare class DeleteAllPaymentsRequest$Type extends MessageType<DeleteAllPaymentsRequest> {
    constructor();
    create(value?: PartialMessage<DeleteAllPaymentsRequest>): DeleteAllPaymentsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllPaymentsRequest): DeleteAllPaymentsRequest;
    internalBinaryWrite(message: DeleteAllPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteAllPaymentsRequest
 */
export declare const DeleteAllPaymentsRequest: DeleteAllPaymentsRequest$Type;
declare class DeletePaymentResponse$Type extends MessageType<DeletePaymentResponse> {
    constructor();
    create(value?: PartialMessage<DeletePaymentResponse>): DeletePaymentResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaymentResponse): DeletePaymentResponse;
    internalBinaryWrite(message: DeletePaymentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DeletePaymentResponse
 */
export declare const DeletePaymentResponse: DeletePaymentResponse$Type;
declare class DeleteAllPaymentsResponse$Type extends MessageType<DeleteAllPaymentsResponse> {
    constructor();
    create(value?: PartialMessage<DeleteAllPaymentsResponse>): DeleteAllPaymentsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllPaymentsResponse): DeleteAllPaymentsResponse;
    internalBinaryWrite(message: DeleteAllPaymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteAllPaymentsResponse
 */
export declare const DeleteAllPaymentsResponse: DeleteAllPaymentsResponse$Type;
declare class AbandonChannelRequest$Type extends MessageType<AbandonChannelRequest> {
    constructor();
    create(value?: PartialMessage<AbandonChannelRequest>): AbandonChannelRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbandonChannelRequest): AbandonChannelRequest;
    internalBinaryWrite(message: AbandonChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AbandonChannelRequest
 */
export declare const AbandonChannelRequest: AbandonChannelRequest$Type;
declare class AbandonChannelResponse$Type extends MessageType<AbandonChannelResponse> {
    constructor();
    create(value?: PartialMessage<AbandonChannelResponse>): AbandonChannelResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbandonChannelResponse): AbandonChannelResponse;
    internalBinaryWrite(message: AbandonChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.AbandonChannelResponse
 */
export declare const AbandonChannelResponse: AbandonChannelResponse$Type;
declare class DebugLevelRequest$Type extends MessageType<DebugLevelRequest> {
    constructor();
    create(value?: PartialMessage<DebugLevelRequest>): DebugLevelRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DebugLevelRequest): DebugLevelRequest;
    internalBinaryWrite(message: DebugLevelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DebugLevelRequest
 */
export declare const DebugLevelRequest: DebugLevelRequest$Type;
declare class DebugLevelResponse$Type extends MessageType<DebugLevelResponse> {
    constructor();
    create(value?: PartialMessage<DebugLevelResponse>): DebugLevelResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DebugLevelResponse): DebugLevelResponse;
    internalBinaryWrite(message: DebugLevelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DebugLevelResponse
 */
export declare const DebugLevelResponse: DebugLevelResponse$Type;
declare class PayReqString$Type extends MessageType<PayReqString> {
    constructor();
    create(value?: PartialMessage<PayReqString>): PayReqString;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PayReqString): PayReqString;
    internalBinaryWrite(message: PayReqString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PayReqString
 */
export declare const PayReqString: PayReqString$Type;
declare class PayReq$Type extends MessageType<PayReq> {
    constructor();
    create(value?: PartialMessage<PayReq>): PayReq;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PayReq): PayReq;
    private binaryReadMap13;
    internalBinaryWrite(message: PayReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PayReq
 */
export declare const PayReq: PayReq$Type;
declare class Feature$Type extends MessageType<Feature> {
    constructor();
    create(value?: PartialMessage<Feature>): Feature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Feature): Feature;
    internalBinaryWrite(message: Feature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Feature
 */
export declare const Feature: Feature$Type;
declare class FeeReportRequest$Type extends MessageType<FeeReportRequest> {
    constructor();
    create(value?: PartialMessage<FeeReportRequest>): FeeReportRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeReportRequest): FeeReportRequest;
    internalBinaryWrite(message: FeeReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FeeReportRequest
 */
export declare const FeeReportRequest: FeeReportRequest$Type;
declare class ChannelFeeReport$Type extends MessageType<ChannelFeeReport> {
    constructor();
    create(value?: PartialMessage<ChannelFeeReport>): ChannelFeeReport;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelFeeReport): ChannelFeeReport;
    internalBinaryWrite(message: ChannelFeeReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelFeeReport
 */
export declare const ChannelFeeReport: ChannelFeeReport$Type;
declare class FeeReportResponse$Type extends MessageType<FeeReportResponse> {
    constructor();
    create(value?: PartialMessage<FeeReportResponse>): FeeReportResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeReportResponse): FeeReportResponse;
    internalBinaryWrite(message: FeeReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FeeReportResponse
 */
export declare const FeeReportResponse: FeeReportResponse$Type;
declare class PolicyUpdateRequest$Type extends MessageType<PolicyUpdateRequest> {
    constructor();
    create(value?: PartialMessage<PolicyUpdateRequest>): PolicyUpdateRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyUpdateRequest): PolicyUpdateRequest;
    internalBinaryWrite(message: PolicyUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PolicyUpdateRequest
 */
export declare const PolicyUpdateRequest: PolicyUpdateRequest$Type;
declare class FailedUpdate$Type extends MessageType<FailedUpdate> {
    constructor();
    create(value?: PartialMessage<FailedUpdate>): FailedUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FailedUpdate): FailedUpdate;
    internalBinaryWrite(message: FailedUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.FailedUpdate
 */
export declare const FailedUpdate: FailedUpdate$Type;
declare class PolicyUpdateResponse$Type extends MessageType<PolicyUpdateResponse> {
    constructor();
    create(value?: PartialMessage<PolicyUpdateResponse>): PolicyUpdateResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyUpdateResponse): PolicyUpdateResponse;
    internalBinaryWrite(message: PolicyUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.PolicyUpdateResponse
 */
export declare const PolicyUpdateResponse: PolicyUpdateResponse$Type;
declare class ForwardingHistoryRequest$Type extends MessageType<ForwardingHistoryRequest> {
    constructor();
    create(value?: PartialMessage<ForwardingHistoryRequest>): ForwardingHistoryRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardingHistoryRequest): ForwardingHistoryRequest;
    internalBinaryWrite(message: ForwardingHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ForwardingHistoryRequest
 */
export declare const ForwardingHistoryRequest: ForwardingHistoryRequest$Type;
declare class ForwardingEvent$Type extends MessageType<ForwardingEvent> {
    constructor();
    create(value?: PartialMessage<ForwardingEvent>): ForwardingEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardingEvent): ForwardingEvent;
    internalBinaryWrite(message: ForwardingEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ForwardingEvent
 */
export declare const ForwardingEvent: ForwardingEvent$Type;
declare class ForwardingHistoryResponse$Type extends MessageType<ForwardingHistoryResponse> {
    constructor();
    create(value?: PartialMessage<ForwardingHistoryResponse>): ForwardingHistoryResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardingHistoryResponse): ForwardingHistoryResponse;
    internalBinaryWrite(message: ForwardingHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ForwardingHistoryResponse
 */
export declare const ForwardingHistoryResponse: ForwardingHistoryResponse$Type;
declare class ExportChannelBackupRequest$Type extends MessageType<ExportChannelBackupRequest> {
    constructor();
    create(value?: PartialMessage<ExportChannelBackupRequest>): ExportChannelBackupRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExportChannelBackupRequest): ExportChannelBackupRequest;
    internalBinaryWrite(message: ExportChannelBackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ExportChannelBackupRequest
 */
export declare const ExportChannelBackupRequest: ExportChannelBackupRequest$Type;
declare class ChannelBackup$Type extends MessageType<ChannelBackup> {
    constructor();
    create(value?: PartialMessage<ChannelBackup>): ChannelBackup;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBackup): ChannelBackup;
    internalBinaryWrite(message: ChannelBackup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBackup
 */
export declare const ChannelBackup: ChannelBackup$Type;
declare class MultiChanBackup$Type extends MessageType<MultiChanBackup> {
    constructor();
    create(value?: PartialMessage<MultiChanBackup>): MultiChanBackup;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiChanBackup): MultiChanBackup;
    internalBinaryWrite(message: MultiChanBackup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.MultiChanBackup
 */
export declare const MultiChanBackup: MultiChanBackup$Type;
declare class ChanBackupExportRequest$Type extends MessageType<ChanBackupExportRequest> {
    constructor();
    create(value?: PartialMessage<ChanBackupExportRequest>): ChanBackupExportRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanBackupExportRequest): ChanBackupExportRequest;
    internalBinaryWrite(message: ChanBackupExportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanBackupExportRequest
 */
export declare const ChanBackupExportRequest: ChanBackupExportRequest$Type;
declare class ChanBackupSnapshot$Type extends MessageType<ChanBackupSnapshot> {
    constructor();
    create(value?: PartialMessage<ChanBackupSnapshot>): ChanBackupSnapshot;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanBackupSnapshot): ChanBackupSnapshot;
    internalBinaryWrite(message: ChanBackupSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanBackupSnapshot
 */
export declare const ChanBackupSnapshot: ChanBackupSnapshot$Type;
declare class ChannelBackups$Type extends MessageType<ChannelBackups> {
    constructor();
    create(value?: PartialMessage<ChannelBackups>): ChannelBackups;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBackups): ChannelBackups;
    internalBinaryWrite(message: ChannelBackups, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBackups
 */
export declare const ChannelBackups: ChannelBackups$Type;
declare class RestoreChanBackupRequest$Type extends MessageType<RestoreChanBackupRequest> {
    constructor();
    create(value?: PartialMessage<RestoreChanBackupRequest>): RestoreChanBackupRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreChanBackupRequest): RestoreChanBackupRequest;
    internalBinaryWrite(message: RestoreChanBackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RestoreChanBackupRequest
 */
export declare const RestoreChanBackupRequest: RestoreChanBackupRequest$Type;
declare class RestoreBackupResponse$Type extends MessageType<RestoreBackupResponse> {
    constructor();
    create(value?: PartialMessage<RestoreBackupResponse>): RestoreBackupResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreBackupResponse): RestoreBackupResponse;
    internalBinaryWrite(message: RestoreBackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RestoreBackupResponse
 */
export declare const RestoreBackupResponse: RestoreBackupResponse$Type;
declare class ChannelBackupSubscription$Type extends MessageType<ChannelBackupSubscription> {
    constructor();
    create(value?: PartialMessage<ChannelBackupSubscription>): ChannelBackupSubscription;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBackupSubscription): ChannelBackupSubscription;
    internalBinaryWrite(message: ChannelBackupSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBackupSubscription
 */
export declare const ChannelBackupSubscription: ChannelBackupSubscription$Type;
declare class VerifyChanBackupResponse$Type extends MessageType<VerifyChanBackupResponse> {
    constructor();
    create(value?: PartialMessage<VerifyChanBackupResponse>): VerifyChanBackupResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyChanBackupResponse): VerifyChanBackupResponse;
    internalBinaryWrite(message: VerifyChanBackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.VerifyChanBackupResponse
 */
export declare const VerifyChanBackupResponse: VerifyChanBackupResponse$Type;
declare class MacaroonPermission$Type extends MessageType<MacaroonPermission> {
    constructor();
    create(value?: PartialMessage<MacaroonPermission>): MacaroonPermission;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacaroonPermission): MacaroonPermission;
    internalBinaryWrite(message: MacaroonPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.MacaroonPermission
 */
export declare const MacaroonPermission: MacaroonPermission$Type;
declare class BakeMacaroonRequest$Type extends MessageType<BakeMacaroonRequest> {
    constructor();
    create(value?: PartialMessage<BakeMacaroonRequest>): BakeMacaroonRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BakeMacaroonRequest): BakeMacaroonRequest;
    internalBinaryWrite(message: BakeMacaroonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.BakeMacaroonRequest
 */
export declare const BakeMacaroonRequest: BakeMacaroonRequest$Type;
declare class BakeMacaroonResponse$Type extends MessageType<BakeMacaroonResponse> {
    constructor();
    create(value?: PartialMessage<BakeMacaroonResponse>): BakeMacaroonResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BakeMacaroonResponse): BakeMacaroonResponse;
    internalBinaryWrite(message: BakeMacaroonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.BakeMacaroonResponse
 */
export declare const BakeMacaroonResponse: BakeMacaroonResponse$Type;
declare class ListMacaroonIDsRequest$Type extends MessageType<ListMacaroonIDsRequest> {
    constructor();
    create(value?: PartialMessage<ListMacaroonIDsRequest>): ListMacaroonIDsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMacaroonIDsRequest): ListMacaroonIDsRequest;
    internalBinaryWrite(message: ListMacaroonIDsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListMacaroonIDsRequest
 */
export declare const ListMacaroonIDsRequest: ListMacaroonIDsRequest$Type;
declare class ListMacaroonIDsResponse$Type extends MessageType<ListMacaroonIDsResponse> {
    constructor();
    create(value?: PartialMessage<ListMacaroonIDsResponse>): ListMacaroonIDsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMacaroonIDsResponse): ListMacaroonIDsResponse;
    internalBinaryWrite(message: ListMacaroonIDsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListMacaroonIDsResponse
 */
export declare const ListMacaroonIDsResponse: ListMacaroonIDsResponse$Type;
declare class DeleteMacaroonIDRequest$Type extends MessageType<DeleteMacaroonIDRequest> {
    constructor();
    create(value?: PartialMessage<DeleteMacaroonIDRequest>): DeleteMacaroonIDRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMacaroonIDRequest): DeleteMacaroonIDRequest;
    internalBinaryWrite(message: DeleteMacaroonIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteMacaroonIDRequest
 */
export declare const DeleteMacaroonIDRequest: DeleteMacaroonIDRequest$Type;
declare class DeleteMacaroonIDResponse$Type extends MessageType<DeleteMacaroonIDResponse> {
    constructor();
    create(value?: PartialMessage<DeleteMacaroonIDResponse>): DeleteMacaroonIDResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMacaroonIDResponse): DeleteMacaroonIDResponse;
    internalBinaryWrite(message: DeleteMacaroonIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteMacaroonIDResponse
 */
export declare const DeleteMacaroonIDResponse: DeleteMacaroonIDResponse$Type;
declare class MacaroonPermissionList$Type extends MessageType<MacaroonPermissionList> {
    constructor();
    create(value?: PartialMessage<MacaroonPermissionList>): MacaroonPermissionList;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacaroonPermissionList): MacaroonPermissionList;
    internalBinaryWrite(message: MacaroonPermissionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.MacaroonPermissionList
 */
export declare const MacaroonPermissionList: MacaroonPermissionList$Type;
declare class ListPermissionsRequest$Type extends MessageType<ListPermissionsRequest> {
    constructor();
    create(value?: PartialMessage<ListPermissionsRequest>): ListPermissionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPermissionsRequest): ListPermissionsRequest;
    internalBinaryWrite(message: ListPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPermissionsRequest
 */
export declare const ListPermissionsRequest: ListPermissionsRequest$Type;
declare class ListPermissionsResponse$Type extends MessageType<ListPermissionsResponse> {
    constructor();
    create(value?: PartialMessage<ListPermissionsResponse>): ListPermissionsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPermissionsResponse): ListPermissionsResponse;
    private binaryReadMap1;
    internalBinaryWrite(message: ListPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPermissionsResponse
 */
export declare const ListPermissionsResponse: ListPermissionsResponse$Type;
declare class Failure$Type extends MessageType<Failure> {
    constructor();
    create(value?: PartialMessage<Failure>): Failure;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Failure): Failure;
    internalBinaryWrite(message: Failure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Failure
 */
export declare const Failure: Failure$Type;
declare class ChannelUpdate$Type extends MessageType<ChannelUpdate> {
    constructor();
    create(value?: PartialMessage<ChannelUpdate>): ChannelUpdate;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelUpdate): ChannelUpdate;
    internalBinaryWrite(message: ChannelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelUpdate
 */
export declare const ChannelUpdate: ChannelUpdate$Type;
declare class MacaroonId$Type extends MessageType<MacaroonId> {
    constructor();
    create(value?: PartialMessage<MacaroonId>): MacaroonId;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacaroonId): MacaroonId;
    internalBinaryWrite(message: MacaroonId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.MacaroonId
 */
export declare const MacaroonId: MacaroonId$Type;
declare class Op$Type extends MessageType<Op> {
    constructor();
    create(value?: PartialMessage<Op>): Op;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Op): Op;
    internalBinaryWrite(message: Op, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.Op
 */
export declare const Op: Op$Type;
declare class CheckMacPermRequest$Type extends MessageType<CheckMacPermRequest> {
    constructor();
    create(value?: PartialMessage<CheckMacPermRequest>): CheckMacPermRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckMacPermRequest): CheckMacPermRequest;
    internalBinaryWrite(message: CheckMacPermRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.CheckMacPermRequest
 */
export declare const CheckMacPermRequest: CheckMacPermRequest$Type;
declare class CheckMacPermResponse$Type extends MessageType<CheckMacPermResponse> {
    constructor();
    create(value?: PartialMessage<CheckMacPermResponse>): CheckMacPermResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckMacPermResponse): CheckMacPermResponse;
    internalBinaryWrite(message: CheckMacPermResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.CheckMacPermResponse
 */
export declare const CheckMacPermResponse: CheckMacPermResponse$Type;
declare class RPCMiddlewareRequest$Type extends MessageType<RPCMiddlewareRequest> {
    constructor();
    create(value?: PartialMessage<RPCMiddlewareRequest>): RPCMiddlewareRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPCMiddlewareRequest): RPCMiddlewareRequest;
    internalBinaryWrite(message: RPCMiddlewareRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RPCMiddlewareRequest
 */
export declare const RPCMiddlewareRequest: RPCMiddlewareRequest$Type;
declare class StreamAuth$Type extends MessageType<StreamAuth> {
    constructor();
    create(value?: PartialMessage<StreamAuth>): StreamAuth;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAuth): StreamAuth;
    internalBinaryWrite(message: StreamAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.StreamAuth
 */
export declare const StreamAuth: StreamAuth$Type;
declare class RPCMessage$Type extends MessageType<RPCMessage> {
    constructor();
    create(value?: PartialMessage<RPCMessage>): RPCMessage;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPCMessage): RPCMessage;
    internalBinaryWrite(message: RPCMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RPCMessage
 */
export declare const RPCMessage: RPCMessage$Type;
declare class RPCMiddlewareResponse$Type extends MessageType<RPCMiddlewareResponse> {
    constructor();
    create(value?: PartialMessage<RPCMiddlewareResponse>): RPCMiddlewareResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPCMiddlewareResponse): RPCMiddlewareResponse;
    internalBinaryWrite(message: RPCMiddlewareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.RPCMiddlewareResponse
 */
export declare const RPCMiddlewareResponse: RPCMiddlewareResponse$Type;
declare class MiddlewareRegistration$Type extends MessageType<MiddlewareRegistration> {
    constructor();
    create(value?: PartialMessage<MiddlewareRegistration>): MiddlewareRegistration;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MiddlewareRegistration): MiddlewareRegistration;
    internalBinaryWrite(message: MiddlewareRegistration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.MiddlewareRegistration
 */
export declare const MiddlewareRegistration: MiddlewareRegistration$Type;
declare class InterceptFeedback$Type extends MessageType<InterceptFeedback> {
    constructor();
    create(value?: PartialMessage<InterceptFeedback>): InterceptFeedback;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterceptFeedback): InterceptFeedback;
    internalBinaryWrite(message: InterceptFeedback, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message lnrpc.InterceptFeedback
 */
export declare const InterceptFeedback: InterceptFeedback$Type;
/**
 * @generated ServiceType for protobuf service lnrpc.Lightning
 */
export declare const Lightning: any;
export {};
