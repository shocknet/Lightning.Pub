// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "chainnotifier.proto" (package "chainrpc", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ChainNotifier } from "./chainnotifier.js";
import type { BlockEpoch } from "./chainnotifier.js";
import type { SpendEvent } from "./chainnotifier.js";
import type { SpendRequest } from "./chainnotifier.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ConfEvent } from "./chainnotifier";
import type { ConfRequest } from "./chainnotifier";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * ChainNotifier is a service that can be used to get information about the
 * chain backend by registering notifiers for chain events.
 *
 * @generated from protobuf service chainrpc.ChainNotifier
 */
export interface IChainNotifierClient {
    /**
     *
     * RegisterConfirmationsNtfn is a synchronous response-streaming RPC that
     * registers an intent for a client to be notified once a confirmation request
     * has reached its required number of confirmations on-chain.
     *
     * A confirmation request must have a valid output script. It is also possible
     * to give a transaction ID. If the transaction ID is not set, a notification
     * is sent once the output script confirms. If the transaction ID is also set,
     * a notification is sent once the output script confirms in the given
     * transaction.
     *
     * @generated from protobuf rpc: RegisterConfirmationsNtfn(chainrpc.ConfRequest) returns (stream chainrpc.ConfEvent);
     */
    registerConfirmationsNtfn(input: ConfRequest, options?: RpcOptions): ServerStreamingCall<ConfRequest, ConfEvent>;
    /**
     *
     * RegisterSpendNtfn is a synchronous response-streaming RPC that registers an
     * intent for a client to be notification once a spend request has been spent
     * by a transaction that has confirmed on-chain.
     *
     * A client can specify whether the spend request should be for a particular
     * outpoint  or for an output script by specifying a zero outpoint.
     *
     * @generated from protobuf rpc: RegisterSpendNtfn(chainrpc.SpendRequest) returns (stream chainrpc.SpendEvent);
     */
    registerSpendNtfn(input: SpendRequest, options?: RpcOptions): ServerStreamingCall<SpendRequest, SpendEvent>;
    /**
     *
     * RegisterBlockEpochNtfn is a synchronous response-streaming RPC that
     * registers an intent for a client to be notified of blocks in the chain. The
     * stream will return a hash and height tuple of a block for each new/stale
     * block in the chain. It is the client's responsibility to determine whether
     * the tuple returned is for a new or stale block in the chain.
     *
     * A client can also request a historical backlog of blocks from a particular
     * point. This allows clients to be idempotent by ensuring that they do not
     * missing processing a single block within the chain.
     *
     * @generated from protobuf rpc: RegisterBlockEpochNtfn(chainrpc.BlockEpoch) returns (stream chainrpc.BlockEpoch);
     */
    registerBlockEpochNtfn(input: BlockEpoch, options?: RpcOptions): ServerStreamingCall<BlockEpoch, BlockEpoch>;
}
/**
 * ChainNotifier is a service that can be used to get information about the
 * chain backend by registering notifiers for chain events.
 *
 * @generated from protobuf service chainrpc.ChainNotifier
 */
export class ChainNotifierClient implements IChainNotifierClient, ServiceInfo {
    typeName = ChainNotifier.typeName;
    methods = ChainNotifier.methods;
    options = ChainNotifier.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     *
     * RegisterConfirmationsNtfn is a synchronous response-streaming RPC that
     * registers an intent for a client to be notified once a confirmation request
     * has reached its required number of confirmations on-chain.
     *
     * A confirmation request must have a valid output script. It is also possible
     * to give a transaction ID. If the transaction ID is not set, a notification
     * is sent once the output script confirms. If the transaction ID is also set,
     * a notification is sent once the output script confirms in the given
     * transaction.
     *
     * @generated from protobuf rpc: RegisterConfirmationsNtfn(chainrpc.ConfRequest) returns (stream chainrpc.ConfEvent);
     */
    registerConfirmationsNtfn(input: ConfRequest, options?: RpcOptions): ServerStreamingCall<ConfRequest, ConfEvent> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ConfRequest, ConfEvent>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     *
     * RegisterSpendNtfn is a synchronous response-streaming RPC that registers an
     * intent for a client to be notification once a spend request has been spent
     * by a transaction that has confirmed on-chain.
     *
     * A client can specify whether the spend request should be for a particular
     * outpoint  or for an output script by specifying a zero outpoint.
     *
     * @generated from protobuf rpc: RegisterSpendNtfn(chainrpc.SpendRequest) returns (stream chainrpc.SpendEvent);
     */
    registerSpendNtfn(input: SpendRequest, options?: RpcOptions): ServerStreamingCall<SpendRequest, SpendEvent> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<SpendRequest, SpendEvent>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     *
     * RegisterBlockEpochNtfn is a synchronous response-streaming RPC that
     * registers an intent for a client to be notified of blocks in the chain. The
     * stream will return a hash and height tuple of a block for each new/stale
     * block in the chain. It is the client's responsibility to determine whether
     * the tuple returned is for a new or stale block in the chain.
     *
     * A client can also request a historical backlog of blocks from a particular
     * point. This allows clients to be idempotent by ensuring that they do not
     * missing processing a single block within the chain.
     *
     * @generated from protobuf rpc: RegisterBlockEpochNtfn(chainrpc.BlockEpoch) returns (stream chainrpc.BlockEpoch);
     */
    registerBlockEpochNtfn(input: BlockEpoch, options?: RpcOptions): ServerStreamingCall<BlockEpoch, BlockEpoch> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockEpoch, BlockEpoch>("serverStreaming", this._transport, method, opt, input);
    }
}
