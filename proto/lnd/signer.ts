// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "signer.proto" (package "signrpc", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message signrpc.KeyLocator
 */
export interface KeyLocator {
    /**
     * The family of key being identified.
     *
     * @generated from protobuf field: int32 key_family = 1;
     */
    keyFamily: number;
    /**
     * The precise index of the key being identified.
     *
     * @generated from protobuf field: int32 key_index = 2;
     */
    keyIndex: number;
}
/**
 * @generated from protobuf message signrpc.KeyDescriptor
 */
export interface KeyDescriptor {
    /**
     *
     * The raw bytes of the public key in the key pair being identified. Either
     * this or the KeyLocator must be specified.
     *
     * @generated from protobuf field: bytes raw_key_bytes = 1;
     */
    rawKeyBytes: Uint8Array;
    /**
     *
     * The key locator that identifies which private key to use for signing.
     * Either this or the raw bytes of the target public key must be specified.
     *
     * @generated from protobuf field: signrpc.KeyLocator key_loc = 2;
     */
    keyLoc?: KeyLocator;
}
/**
 * @generated from protobuf message signrpc.TxOut
 */
export interface TxOut {
    /**
     * The value of the output being spent.
     *
     * @generated from protobuf field: int64 value = 1;
     */
    value: bigint;
    /**
     * The script of the output being spent.
     *
     * @generated from protobuf field: bytes pk_script = 2;
     */
    pkScript: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.SignDescriptor
 */
export interface SignDescriptor {
    /**
     *
     * A descriptor that precisely describes *which* key to use for signing. This
     * may provide the raw public key directly, or require the Signer to re-derive
     * the key according to the populated derivation path.
     *
     * Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     * then the key locator MUST always be provided, since the derived keys are not
     * persisted unlike with DeriveNextKey.
     *
     * @generated from protobuf field: signrpc.KeyDescriptor key_desc = 1;
     */
    keyDesc?: KeyDescriptor;
    /**
     *
     * A scalar value that will be added to the private key corresponding to the
     * above public key to obtain the private key to be used to sign this input.
     * This value is typically derived via the following computation:
     *
     * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
     *
     * @generated from protobuf field: bytes single_tweak = 2;
     */
    singleTweak: Uint8Array;
    /**
     *
     * A private key that will be used in combination with its corresponding
     * private key to derive the private key that is to be used to sign the target
     * input. Within the Lightning protocol, this value is typically the
     * commitment secret from a previously revoked commitment transaction. This
     * value is in combination with two hash values, and the original private key
     * to derive the private key to be used when signing.
     *
     * k = (privKey*sha256(pubKey || tweakPub) +
     * tweakPriv*sha256(tweakPub || pubKey)) mod N
     *
     * @generated from protobuf field: bytes double_tweak = 3;
     */
    doubleTweak: Uint8Array;
    /**
     *
     * The 32 byte input to the taproot tweak derivation that is used to derive
     * the output key from an internal key: outputKey = internalKey +
     * tagged_hash("tapTweak", internalKey || tapTweak).
     *
     * When doing a BIP 86 spend, this field can be an empty byte slice.
     *
     * When doing a normal key path spend, with the output key committing to an
     * actual script root, then this field should be: the tapscript root hash.
     *
     * @generated from protobuf field: bytes tap_tweak = 10;
     */
    tapTweak: Uint8Array;
    /**
     *
     * The full script required to properly redeem the output. This field will
     * only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
     * taproot script path spend is being attempted, then this should be the raw
     * leaf script.
     *
     * @generated from protobuf field: bytes witness_script = 4;
     */
    witnessScript: Uint8Array;
    /**
     *
     * A description of the output being spent. The value and script MUST be
     * provided.
     *
     * @generated from protobuf field: signrpc.TxOut output = 5;
     */
    output?: TxOut;
    /**
     *
     * The target sighash type that should be used when generating the final
     * sighash, and signature.
     *
     * @generated from protobuf field: uint32 sighash = 7;
     */
    sighash: number;
    /**
     *
     * The target input within the transaction that should be signed.
     *
     * @generated from protobuf field: int32 input_index = 8;
     */
    inputIndex: number;
    /**
     *
     * The sign method specifies how the input should be signed. Depending on the
     * method, either the tap_tweak, witness_script or both need to be specified.
     * Defaults to SegWit v0 signing to be backward compatible with older RPC
     * clients.
     *
     * @generated from protobuf field: signrpc.SignMethod sign_method = 9;
     */
    signMethod: SignMethod;
}
/**
 * @generated from protobuf message signrpc.SignReq
 */
export interface SignReq {
    /**
     * The raw bytes of the transaction to be signed.
     *
     * @generated from protobuf field: bytes raw_tx_bytes = 1;
     */
    rawTxBytes: Uint8Array;
    /**
     * A set of sign descriptors, for each input to be signed.
     *
     * @generated from protobuf field: repeated signrpc.SignDescriptor sign_descs = 2;
     */
    signDescs: SignDescriptor[];
    /**
     *
     * The full list of UTXO information for each of the inputs being spent. This
     * is required when spending one or more taproot (SegWit v1) outputs.
     *
     * @generated from protobuf field: repeated signrpc.TxOut prev_outputs = 3;
     */
    prevOutputs: TxOut[];
}
/**
 * @generated from protobuf message signrpc.SignResp
 */
export interface SignResp {
    /**
     *
     * A set of signatures realized in a fixed 64-byte format ordered in ascending
     * input order.
     *
     * @generated from protobuf field: repeated bytes raw_sigs = 1;
     */
    rawSigs: Uint8Array[];
}
/**
 * @generated from protobuf message signrpc.InputScript
 */
export interface InputScript {
    /**
     * The serializes witness stack for the specified input.
     *
     * @generated from protobuf field: repeated bytes witness = 1;
     */
    witness: Uint8Array[];
    /**
     *
     * The optional sig script for the specified witness that will only be set if
     * the input specified is a nested p2sh witness program.
     *
     * @generated from protobuf field: bytes sig_script = 2;
     */
    sigScript: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.InputScriptResp
 */
export interface InputScriptResp {
    /**
     * The set of fully valid input scripts requested.
     *
     * @generated from protobuf field: repeated signrpc.InputScript input_scripts = 1;
     */
    inputScripts: InputScript[];
}
/**
 * @generated from protobuf message signrpc.SignMessageReq
 */
export interface SignMessageReq {
    /**
     *
     * The message to be signed. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     * The key locator that identifies which key to use for signing.
     *
     * @generated from protobuf field: signrpc.KeyLocator key_loc = 2;
     */
    keyLoc?: KeyLocator;
    /**
     * Double-SHA256 hash instead of just the default single round.
     *
     * @generated from protobuf field: bool double_hash = 3;
     */
    doubleHash: boolean;
    /**
     *
     * Use the compact (pubkey recoverable) format instead of the raw lnwire
     * format. This option cannot be used with Schnorr signatures.
     *
     * @generated from protobuf field: bool compact_sig = 4;
     */
    compactSig: boolean;
    /**
     *
     * Use Schnorr signature. This option cannot be used with compact format.
     *
     * @generated from protobuf field: bool schnorr_sig = 5;
     */
    schnorrSig: boolean;
    /**
     *
     * The optional Taproot tweak bytes to apply to the private key before creating
     * a Schnorr signature. The private key is tweaked as described in BIP-341:
     * privKey + h_tapTweak(internalKey || tapTweak)
     *
     * @generated from protobuf field: bytes schnorr_sig_tap_tweak = 6;
     */
    schnorrSigTapTweak: Uint8Array;
    /**
     *
     * An optional tag that can be provided when taking a tagged hash of a
     * message. This option can only be used when schnorr_sig is true.
     *
     * @generated from protobuf field: bytes tag = 7;
     */
    tag: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.SignMessageResp
 */
export interface SignMessageResp {
    /**
     *
     * The signature for the given message in the fixed-size LN wire format.
     *
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.VerifyMessageReq
 */
export interface VerifyMessageReq {
    /**
     * The message over which the signature is to be verified. When using
     * REST, this field must be encoded as base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     *
     * The fixed-size LN wire encoded signature to be verified over the given
     * message. When using REST, this field must be encoded as base64.
     *
     * @generated from protobuf field: bytes signature = 2;
     */
    signature: Uint8Array;
    /**
     *
     * The public key the signature has to be valid for. When using REST, this
     * field must be encoded as base64. If the is_schnorr_sig option is true, then
     * the public key is expected to be in the 32-byte x-only serialization
     * according to BIP-340.
     *
     * @generated from protobuf field: bytes pubkey = 3;
     */
    pubkey: Uint8Array;
    /**
     *
     * Specifies if the signature is a Schnorr signature.
     *
     * @generated from protobuf field: bool is_schnorr_sig = 4;
     */
    isSchnorrSig: boolean;
    /**
     *
     * An optional tag that can be provided when taking a tagged hash of a
     * message. This option can only be used when is_schnorr_sig is true.
     *
     * @generated from protobuf field: bytes tag = 5;
     */
    tag: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.VerifyMessageResp
 */
export interface VerifyMessageResp {
    /**
     * Whether the signature was valid over the given message.
     *
     * @generated from protobuf field: bool valid = 1;
     */
    valid: boolean;
}
/**
 * @generated from protobuf message signrpc.SharedKeyRequest
 */
export interface SharedKeyRequest {
    /**
     * The ephemeral public key to use for the DH key derivation.
     *
     * @generated from protobuf field: bytes ephemeral_pubkey = 1;
     */
    ephemeralPubkey: Uint8Array;
    /**
     *
     * Deprecated. The optional key locator of the local key that should be used.
     * If this parameter is not set then the node's identity private key will be
     * used.
     *
     * @deprecated
     * @generated from protobuf field: signrpc.KeyLocator key_loc = 2 [deprecated = true];
     */
    keyLoc?: KeyLocator;
    /**
     *
     * A key descriptor describes the key used for performing ECDH. Either a key
     * locator or a raw public key is expected, if neither is supplied, defaults to
     * the node's identity private key.
     *
     * @generated from protobuf field: signrpc.KeyDescriptor key_desc = 3;
     */
    keyDesc?: KeyDescriptor;
}
/**
 * @generated from protobuf message signrpc.SharedKeyResponse
 */
export interface SharedKeyResponse {
    /**
     * The shared public key, hashed with sha256.
     *
     * @generated from protobuf field: bytes shared_key = 1;
     */
    sharedKey: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.TweakDesc
 */
export interface TweakDesc {
    /**
     *
     * Tweak is the 32-byte value that will modify the public key.
     *
     * @generated from protobuf field: bytes tweak = 1;
     */
    tweak: Uint8Array;
    /**
     *
     * Specifies if the target key should be converted to an x-only public key
     * before tweaking. If true, then the public key will be mapped to an x-only
     * key before the tweaking operation is applied.
     *
     * @generated from protobuf field: bool is_x_only = 2;
     */
    isXOnly: boolean;
}
/**
 * @generated from protobuf message signrpc.TaprootTweakDesc
 */
export interface TaprootTweakDesc {
    /**
     *
     * The root hash of the tapscript tree if a script path is committed to. If
     * the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
     * key spend only), then this needs to be empty and the key_spend_only field
     * below must be set to true. This is required because gRPC cannot
     * differentiate between a zero-size byte slice and a nil byte slice (both
     * would be serialized the same way). So the extra boolean is required.
     *
     * @generated from protobuf field: bytes script_root = 1;
     */
    scriptRoot: Uint8Array;
    /**
     *
     * Indicates that the above script_root is expected to be empty because this
     * is a BIP-0086 key spend only commitment where only the internal key is
     * committed to instead of also including a script root hash.
     *
     * @generated from protobuf field: bool key_spend_only = 2;
     */
    keySpendOnly: boolean;
}
/**
 * @generated from protobuf message signrpc.MuSig2CombineKeysRequest
 */
export interface MuSig2CombineKeysRequest {
    /**
     *
     * A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     * and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     * session. The list will always be sorted lexicographically internally. This
     * must include the local key which is described by the above key_loc.
     *
     * @generated from protobuf field: repeated bytes all_signer_pubkeys = 1;
     */
    allSignerPubkeys: Uint8Array[];
    /**
     *
     * A series of optional generic tweaks to be applied to the aggregated
     * public key.
     *
     * @generated from protobuf field: repeated signrpc.TweakDesc tweaks = 2;
     */
    tweaks: TweakDesc[];
    /**
     *
     * An optional taproot specific tweak that must be specified if the MuSig2
     * combined key will be used as the main taproot key of a taproot output
     * on-chain.
     *
     * @generated from protobuf field: signrpc.TaprootTweakDesc taproot_tweak = 3;
     */
    taprootTweak?: TaprootTweakDesc;
    /**
     *
     * The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     * differentiate between the changes that were made to the BIP while this
     * experimental RPC was already released. Some of those changes affect how the
     * combined key and nonces are created.
     *
     * @generated from protobuf field: signrpc.MuSig2Version version = 4;
     */
    version: MuSig2Version;
}
/**
 * @generated from protobuf message signrpc.MuSig2CombineKeysResponse
 */
export interface MuSig2CombineKeysResponse {
    /**
     *
     * The combined public key (in the 32-byte x-only format) with all tweaks
     * applied to it. If a taproot tweak is specified, this corresponds to the
     * taproot key that can be put into the on-chain output.
     *
     * @generated from protobuf field: bytes combined_key = 1;
     */
    combinedKey: Uint8Array;
    /**
     *
     * The raw combined public key (in the 32-byte x-only format) before any tweaks
     * are applied to it. If a taproot tweak is specified, this corresponds to the
     * internal key that needs to be put into the witness if the script spend path
     * is used.
     *
     * @generated from protobuf field: bytes taproot_internal_key = 2;
     */
    taprootInternalKey: Uint8Array;
    /**
     *
     * The version of the MuSig2 BIP that was used to combine the keys.
     *
     * @generated from protobuf field: signrpc.MuSig2Version version = 4;
     */
    version: MuSig2Version;
}
/**
 * @generated from protobuf message signrpc.MuSig2SessionRequest
 */
export interface MuSig2SessionRequest {
    /**
     *
     * The key locator that identifies which key to use for signing.
     *
     * @generated from protobuf field: signrpc.KeyLocator key_loc = 1;
     */
    keyLoc?: KeyLocator;
    /**
     *
     * A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     * and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     * session. The list will always be sorted lexicographically internally. This
     * must include the local key which is described by the above key_loc.
     *
     * @generated from protobuf field: repeated bytes all_signer_pubkeys = 2;
     */
    allSignerPubkeys: Uint8Array[];
    /**
     *
     * An optional list of all public nonces of other signing participants that
     * might already be known.
     *
     * @generated from protobuf field: repeated bytes other_signer_public_nonces = 3;
     */
    otherSignerPublicNonces: Uint8Array[];
    /**
     *
     * A series of optional generic tweaks to be applied to the aggregated
     * public key.
     *
     * @generated from protobuf field: repeated signrpc.TweakDesc tweaks = 4;
     */
    tweaks: TweakDesc[];
    /**
     *
     * An optional taproot specific tweak that must be specified if the MuSig2
     * combined key will be used as the main taproot key of a taproot output
     * on-chain.
     *
     * @generated from protobuf field: signrpc.TaprootTweakDesc taproot_tweak = 5;
     */
    taprootTweak?: TaprootTweakDesc;
    /**
     *
     * The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     * differentiate between the changes that were made to the BIP while this
     * experimental RPC was already released. Some of those changes affect how the
     * combined key and nonces are created.
     *
     * @generated from protobuf field: signrpc.MuSig2Version version = 6;
     */
    version: MuSig2Version;
    /**
     *
     * A set of pre generated secret local nonces to use in the musig2 session.
     * This field is optional. This can be useful for protocols that need to send
     * nonces ahead of time before the set of signer keys are known. This value
     * MUST be 97 bytes and be the concatenation of two CSPRNG generated 32 byte
     * values and local public key used for signing as specified in the key_loc
     * field.
     *
     * @generated from protobuf field: bytes pregenerated_local_nonce = 7;
     */
    pregeneratedLocalNonce: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.MuSig2SessionResponse
 */
export interface MuSig2SessionResponse {
    /**
     *
     * The unique ID that represents this signing session. A session can be used
     * for producing a signature a single time. If the signing fails for any
     * reason, a new session with the same participants needs to be created.
     *
     * @generated from protobuf field: bytes session_id = 1;
     */
    sessionId: Uint8Array;
    /**
     *
     * The combined public key (in the 32-byte x-only format) with all tweaks
     * applied to it. If a taproot tweak is specified, this corresponds to the
     * taproot key that can be put into the on-chain output.
     *
     * @generated from protobuf field: bytes combined_key = 2;
     */
    combinedKey: Uint8Array;
    /**
     *
     * The raw combined public key (in the 32-byte x-only format) before any tweaks
     * are applied to it. If a taproot tweak is specified, this corresponds to the
     * internal key that needs to be put into the witness if the script spend path
     * is used.
     *
     * @generated from protobuf field: bytes taproot_internal_key = 3;
     */
    taprootInternalKey: Uint8Array;
    /**
     *
     * The two public nonces the local signer uses, combined into a single value
     * of 66 bytes. Can be split into the two 33-byte points to get the individual
     * nonces.
     *
     * @generated from protobuf field: bytes local_public_nonces = 4;
     */
    localPublicNonces: Uint8Array;
    /**
     *
     * Indicates whether all nonces required to start the signing process are known
     * now.
     *
     * @generated from protobuf field: bool have_all_nonces = 5;
     */
    haveAllNonces: boolean;
    /**
     *
     * The version of the MuSig2 BIP that was used to create the session.
     *
     * @generated from protobuf field: signrpc.MuSig2Version version = 6;
     */
    version: MuSig2Version;
}
/**
 * @generated from protobuf message signrpc.MuSig2RegisterNoncesRequest
 */
export interface MuSig2RegisterNoncesRequest {
    /**
     *
     * The unique ID of the signing session those nonces should be registered with.
     *
     * @generated from protobuf field: bytes session_id = 1;
     */
    sessionId: Uint8Array;
    /**
     *
     * A list of all public nonces of other signing participants that should be
     * registered.
     *
     * @generated from protobuf field: repeated bytes other_signer_public_nonces = 3;
     */
    otherSignerPublicNonces: Uint8Array[];
}
/**
 * @generated from protobuf message signrpc.MuSig2RegisterNoncesResponse
 */
export interface MuSig2RegisterNoncesResponse {
    /**
     *
     * Indicates whether all nonces required to start the signing process are known
     * now.
     *
     * @generated from protobuf field: bool have_all_nonces = 1;
     */
    haveAllNonces: boolean;
}
/**
 * @generated from protobuf message signrpc.MuSig2SignRequest
 */
export interface MuSig2SignRequest {
    /**
     *
     * The unique ID of the signing session to use for signing.
     *
     * @generated from protobuf field: bytes session_id = 1;
     */
    sessionId: Uint8Array;
    /**
     *
     * The 32-byte SHA256 digest of the message to sign.
     *
     * @generated from protobuf field: bytes message_digest = 2;
     */
    messageDigest: Uint8Array;
    /**
     *
     * Cleanup indicates that after signing, the session state can be cleaned up,
     * since another participant is going to be responsible for combining the
     * partial signatures.
     *
     * @generated from protobuf field: bool cleanup = 3;
     */
    cleanup: boolean;
}
/**
 * @generated from protobuf message signrpc.MuSig2SignResponse
 */
export interface MuSig2SignResponse {
    /**
     *
     * The partial signature created by the local signer.
     *
     * @generated from protobuf field: bytes local_partial_signature = 1;
     */
    localPartialSignature: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.MuSig2CombineSigRequest
 */
export interface MuSig2CombineSigRequest {
    /**
     *
     * The unique ID of the signing session to combine the signatures for.
     *
     * @generated from protobuf field: bytes session_id = 1;
     */
    sessionId: Uint8Array;
    /**
     *
     * The list of all other participants' partial signatures to add to the current
     * session.
     *
     * @generated from protobuf field: repeated bytes other_partial_signatures = 2;
     */
    otherPartialSignatures: Uint8Array[];
}
/**
 * @generated from protobuf message signrpc.MuSig2CombineSigResponse
 */
export interface MuSig2CombineSigResponse {
    /**
     *
     * Indicates whether all partial signatures required to create a final, full
     * signature are known yet. If this is true, then the final_signature field is
     * set, otherwise it is empty.
     *
     * @generated from protobuf field: bool have_all_signatures = 1;
     */
    haveAllSignatures: boolean;
    /**
     *
     * The final, full signature that is valid for the combined public key.
     *
     * @generated from protobuf field: bytes final_signature = 2;
     */
    finalSignature: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.MuSig2CleanupRequest
 */
export interface MuSig2CleanupRequest {
    /**
     *
     * The unique ID of the signing session that should be removed/cleaned up.
     *
     * @generated from protobuf field: bytes session_id = 1;
     */
    sessionId: Uint8Array;
}
/**
 * @generated from protobuf message signrpc.MuSig2CleanupResponse
 */
export interface MuSig2CleanupResponse {
}
/**
 * @generated from protobuf enum signrpc.SignMethod
 */
export enum SignMethod {
    /**
     *
     * Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be
     * signed.
     *
     * @generated from protobuf enum value: SIGN_METHOD_WITNESS_V0 = 0;
     */
    WITNESS_V0 = 0,
    /**
     *
     * Specifies that a SegWit v1 (p2tr) input should be signed by using the
     * BIP0086 method (commit to internal key only).
     *
     * @generated from protobuf enum value: SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086 = 1;
     */
    TAPROOT_KEY_SPEND_BIP0086 = 1,
    /**
     *
     * Specifies that a SegWit v1 (p2tr) input should be signed by using a given
     * taproot hash to commit to in addition to the internal key.
     *
     * @generated from protobuf enum value: SIGN_METHOD_TAPROOT_KEY_SPEND = 2;
     */
    TAPROOT_KEY_SPEND = 2,
    /**
     *
     * Specifies that a SegWit v1 (p2tr) input should be spent using the script
     * path and that a specific leaf script should be signed for.
     *
     * @generated from protobuf enum value: SIGN_METHOD_TAPROOT_SCRIPT_SPEND = 3;
     */
    TAPROOT_SCRIPT_SPEND = 3
}
/**
 * @generated from protobuf enum signrpc.MuSig2Version
 */
export enum MuSig2Version {
    /**
     *
     * The default value on the RPC is zero for enums so we need to represent an
     * invalid/undefined version by default to make sure clients upgrade their
     * software to set the version explicitly.
     *
     * @generated from protobuf enum value: MUSIG2_VERSION_UNDEFINED = 0;
     */
    MUSIG2_VERSION_UNDEFINED = 0,
    /**
     *
     * The version of MuSig2 that lnd 0.15.x shipped with, which corresponds to the
     * version v0.4.0 of the MuSig2 BIP draft.
     *
     * @generated from protobuf enum value: MUSIG2_VERSION_V040 = 1;
     */
    MUSIG2_VERSION_V040 = 1,
    /**
     *
     * The current version of MuSig2 which corresponds to the version v1.0.0rc2 of
     * the MuSig2 BIP draft.
     *
     * @generated from protobuf enum value: MUSIG2_VERSION_V100RC2 = 2;
     */
    MUSIG2_VERSION_V100RC2 = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class KeyLocator$Type extends MessageType<KeyLocator> {
    constructor() {
        super("signrpc.KeyLocator", [
            { no: 1, name: "key_family", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "key_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<KeyLocator>): KeyLocator {
        const message = { keyFamily: 0, keyIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyLocator): KeyLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 key_family */ 1:
                    message.keyFamily = reader.int32();
                    break;
                case /* int32 key_index */ 2:
                    message.keyIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 key_family = 1; */
        if (message.keyFamily !== 0)
            writer.tag(1, WireType.Varint).int32(message.keyFamily);
        /* int32 key_index = 2; */
        if (message.keyIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.keyIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.KeyLocator
 */
export const KeyLocator = new KeyLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyDescriptor$Type extends MessageType<KeyDescriptor> {
    constructor() {
        super("signrpc.KeyDescriptor", [
            { no: 1, name: "raw_key_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key_loc", kind: "message", T: () => KeyLocator }
        ]);
    }
    create(value?: PartialMessage<KeyDescriptor>): KeyDescriptor {
        const message = { rawKeyBytes: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyDescriptor): KeyDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes raw_key_bytes */ 1:
                    message.rawKeyBytes = reader.bytes();
                    break;
                case /* signrpc.KeyLocator key_loc */ 2:
                    message.keyLoc = KeyLocator.internalBinaryRead(reader, reader.uint32(), options, message.keyLoc);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes raw_key_bytes = 1; */
        if (message.rawKeyBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rawKeyBytes);
        /* signrpc.KeyLocator key_loc = 2; */
        if (message.keyLoc)
            KeyLocator.internalBinaryWrite(message.keyLoc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.KeyDescriptor
 */
export const KeyDescriptor = new KeyDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxOut$Type extends MessageType<TxOut> {
    constructor() {
        super("signrpc.TxOut", [
            { no: 1, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "pk_script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TxOut>): TxOut {
        const message = { value: 0n, pkScript: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxOut): TxOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 value */ 1:
                    message.value = reader.int64().toBigInt();
                    break;
                case /* bytes pk_script */ 2:
                    message.pkScript = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).int64(message.value);
        /* bytes pk_script = 2; */
        if (message.pkScript.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pkScript);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.TxOut
 */
export const TxOut = new TxOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignDescriptor$Type extends MessageType<SignDescriptor> {
    constructor() {
        super("signrpc.SignDescriptor", [
            { no: 1, name: "key_desc", kind: "message", T: () => KeyDescriptor },
            { no: 2, name: "single_tweak", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "double_tweak", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "tap_tweak", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "witness_script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "output", kind: "message", T: () => TxOut },
            { no: 7, name: "sighash", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "input_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "sign_method", kind: "enum", T: () => ["signrpc.SignMethod", SignMethod, "SIGN_METHOD_"] }
        ]);
    }
    create(value?: PartialMessage<SignDescriptor>): SignDescriptor {
        const message = { singleTweak: new Uint8Array(0), doubleTweak: new Uint8Array(0), tapTweak: new Uint8Array(0), witnessScript: new Uint8Array(0), sighash: 0, inputIndex: 0, signMethod: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignDescriptor): SignDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* signrpc.KeyDescriptor key_desc */ 1:
                    message.keyDesc = KeyDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.keyDesc);
                    break;
                case /* bytes single_tweak */ 2:
                    message.singleTweak = reader.bytes();
                    break;
                case /* bytes double_tweak */ 3:
                    message.doubleTweak = reader.bytes();
                    break;
                case /* bytes tap_tweak */ 10:
                    message.tapTweak = reader.bytes();
                    break;
                case /* bytes witness_script */ 4:
                    message.witnessScript = reader.bytes();
                    break;
                case /* signrpc.TxOut output */ 5:
                    message.output = TxOut.internalBinaryRead(reader, reader.uint32(), options, message.output);
                    break;
                case /* uint32 sighash */ 7:
                    message.sighash = reader.uint32();
                    break;
                case /* int32 input_index */ 8:
                    message.inputIndex = reader.int32();
                    break;
                case /* signrpc.SignMethod sign_method */ 9:
                    message.signMethod = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* signrpc.KeyDescriptor key_desc = 1; */
        if (message.keyDesc)
            KeyDescriptor.internalBinaryWrite(message.keyDesc, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes single_tweak = 2; */
        if (message.singleTweak.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.singleTweak);
        /* bytes double_tweak = 3; */
        if (message.doubleTweak.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.doubleTweak);
        /* bytes tap_tweak = 10; */
        if (message.tapTweak.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.tapTweak);
        /* bytes witness_script = 4; */
        if (message.witnessScript.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.witnessScript);
        /* signrpc.TxOut output = 5; */
        if (message.output)
            TxOut.internalBinaryWrite(message.output, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 sighash = 7; */
        if (message.sighash !== 0)
            writer.tag(7, WireType.Varint).uint32(message.sighash);
        /* int32 input_index = 8; */
        if (message.inputIndex !== 0)
            writer.tag(8, WireType.Varint).int32(message.inputIndex);
        /* signrpc.SignMethod sign_method = 9; */
        if (message.signMethod !== 0)
            writer.tag(9, WireType.Varint).int32(message.signMethod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SignDescriptor
 */
export const SignDescriptor = new SignDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignReq$Type extends MessageType<SignReq> {
    constructor() {
        super("signrpc.SignReq", [
            { no: 1, name: "raw_tx_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sign_descs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SignDescriptor },
            { no: 3, name: "prev_outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TxOut }
        ]);
    }
    create(value?: PartialMessage<SignReq>): SignReq {
        const message = { rawTxBytes: new Uint8Array(0), signDescs: [], prevOutputs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignReq): SignReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes raw_tx_bytes */ 1:
                    message.rawTxBytes = reader.bytes();
                    break;
                case /* repeated signrpc.SignDescriptor sign_descs */ 2:
                    message.signDescs.push(SignDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated signrpc.TxOut prev_outputs */ 3:
                    message.prevOutputs.push(TxOut.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes raw_tx_bytes = 1; */
        if (message.rawTxBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rawTxBytes);
        /* repeated signrpc.SignDescriptor sign_descs = 2; */
        for (let i = 0; i < message.signDescs.length; i++)
            SignDescriptor.internalBinaryWrite(message.signDescs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated signrpc.TxOut prev_outputs = 3; */
        for (let i = 0; i < message.prevOutputs.length; i++)
            TxOut.internalBinaryWrite(message.prevOutputs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SignReq
 */
export const SignReq = new SignReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignResp$Type extends MessageType<SignResp> {
    constructor() {
        super("signrpc.SignResp", [
            { no: 1, name: "raw_sigs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignResp>): SignResp {
        const message = { rawSigs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignResp): SignResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes raw_sigs */ 1:
                    message.rawSigs.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes raw_sigs = 1; */
        for (let i = 0; i < message.rawSigs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rawSigs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SignResp
 */
export const SignResp = new SignResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputScript$Type extends MessageType<InputScript> {
    constructor() {
        super("signrpc.InputScript", [
            { no: 1, name: "witness", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sig_script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<InputScript>): InputScript {
        const message = { witness: [], sigScript: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InputScript>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputScript): InputScript {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes witness */ 1:
                    message.witness.push(reader.bytes());
                    break;
                case /* bytes sig_script */ 2:
                    message.sigScript = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputScript, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes witness = 1; */
        for (let i = 0; i < message.witness.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.witness[i]);
        /* bytes sig_script = 2; */
        if (message.sigScript.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sigScript);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.InputScript
 */
export const InputScript = new InputScript$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputScriptResp$Type extends MessageType<InputScriptResp> {
    constructor() {
        super("signrpc.InputScriptResp", [
            { no: 1, name: "input_scripts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InputScript }
        ]);
    }
    create(value?: PartialMessage<InputScriptResp>): InputScriptResp {
        const message = { inputScripts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InputScriptResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputScriptResp): InputScriptResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated signrpc.InputScript input_scripts */ 1:
                    message.inputScripts.push(InputScript.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputScriptResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated signrpc.InputScript input_scripts = 1; */
        for (let i = 0; i < message.inputScripts.length; i++)
            InputScript.internalBinaryWrite(message.inputScripts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.InputScriptResp
 */
export const InputScriptResp = new InputScriptResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessageReq$Type extends MessageType<SignMessageReq> {
    constructor() {
        super("signrpc.SignMessageReq", [
            { no: 1, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key_loc", kind: "message", T: () => KeyLocator },
            { no: 3, name: "double_hash", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "compact_sig", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "schnorr_sig", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "schnorr_sig_tap_tweak", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "tag", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignMessageReq>): SignMessageReq {
        const message = { msg: new Uint8Array(0), doubleHash: false, compactSig: false, schnorrSig: false, schnorrSigTapTweak: new Uint8Array(0), tag: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignMessageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageReq): SignMessageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msg */ 1:
                    message.msg = reader.bytes();
                    break;
                case /* signrpc.KeyLocator key_loc */ 2:
                    message.keyLoc = KeyLocator.internalBinaryRead(reader, reader.uint32(), options, message.keyLoc);
                    break;
                case /* bool double_hash */ 3:
                    message.doubleHash = reader.bool();
                    break;
                case /* bool compact_sig */ 4:
                    message.compactSig = reader.bool();
                    break;
                case /* bool schnorr_sig */ 5:
                    message.schnorrSig = reader.bool();
                    break;
                case /* bytes schnorr_sig_tap_tweak */ 6:
                    message.schnorrSigTapTweak = reader.bytes();
                    break;
                case /* bytes tag */ 7:
                    message.tag = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignMessageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msg = 1; */
        if (message.msg.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.msg);
        /* signrpc.KeyLocator key_loc = 2; */
        if (message.keyLoc)
            KeyLocator.internalBinaryWrite(message.keyLoc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool double_hash = 3; */
        if (message.doubleHash !== false)
            writer.tag(3, WireType.Varint).bool(message.doubleHash);
        /* bool compact_sig = 4; */
        if (message.compactSig !== false)
            writer.tag(4, WireType.Varint).bool(message.compactSig);
        /* bool schnorr_sig = 5; */
        if (message.schnorrSig !== false)
            writer.tag(5, WireType.Varint).bool(message.schnorrSig);
        /* bytes schnorr_sig_tap_tweak = 6; */
        if (message.schnorrSigTapTweak.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.schnorrSigTapTweak);
        /* bytes tag = 7; */
        if (message.tag.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.tag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SignMessageReq
 */
export const SignMessageReq = new SignMessageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessageResp$Type extends MessageType<SignMessageResp> {
    constructor() {
        super("signrpc.SignMessageResp", [
            { no: 1, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignMessageResp>): SignMessageResp {
        const message = { signature: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignMessageResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageResp): SignMessageResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signature */ 1:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignMessageResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signature = 1; */
        if (message.signature.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SignMessageResp
 */
export const SignMessageResp = new SignMessageResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyMessageReq$Type extends MessageType<VerifyMessageReq> {
    constructor() {
        super("signrpc.VerifyMessageReq", [
            { no: 1, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "is_schnorr_sig", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tag", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyMessageReq>): VerifyMessageReq {
        const message = { msg: new Uint8Array(0), signature: new Uint8Array(0), pubkey: new Uint8Array(0), isSchnorrSig: false, tag: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyMessageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageReq): VerifyMessageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msg */ 1:
                    message.msg = reader.bytes();
                    break;
                case /* bytes signature */ 2:
                    message.signature = reader.bytes();
                    break;
                case /* bytes pubkey */ 3:
                    message.pubkey = reader.bytes();
                    break;
                case /* bool is_schnorr_sig */ 4:
                    message.isSchnorrSig = reader.bool();
                    break;
                case /* bytes tag */ 5:
                    message.tag = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyMessageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msg = 1; */
        if (message.msg.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.msg);
        /* bytes signature = 2; */
        if (message.signature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
        /* bytes pubkey = 3; */
        if (message.pubkey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.pubkey);
        /* bool is_schnorr_sig = 4; */
        if (message.isSchnorrSig !== false)
            writer.tag(4, WireType.Varint).bool(message.isSchnorrSig);
        /* bytes tag = 5; */
        if (message.tag.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.tag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.VerifyMessageReq
 */
export const VerifyMessageReq = new VerifyMessageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyMessageResp$Type extends MessageType<VerifyMessageResp> {
    constructor() {
        super("signrpc.VerifyMessageResp", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyMessageResp>): VerifyMessageResp {
        const message = { valid: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyMessageResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageResp): VerifyMessageResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyMessageResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.VerifyMessageResp
 */
export const VerifyMessageResp = new VerifyMessageResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedKeyRequest$Type extends MessageType<SharedKeyRequest> {
    constructor() {
        super("signrpc.SharedKeyRequest", [
            { no: 1, name: "ephemeral_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key_loc", kind: "message", T: () => KeyLocator },
            { no: 3, name: "key_desc", kind: "message", T: () => KeyDescriptor }
        ]);
    }
    create(value?: PartialMessage<SharedKeyRequest>): SharedKeyRequest {
        const message = { ephemeralPubkey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SharedKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedKeyRequest): SharedKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ephemeral_pubkey */ 1:
                    message.ephemeralPubkey = reader.bytes();
                    break;
                case /* signrpc.KeyLocator key_loc = 2 [deprecated = true];*/ 2:
                    message.keyLoc = KeyLocator.internalBinaryRead(reader, reader.uint32(), options, message.keyLoc);
                    break;
                case /* signrpc.KeyDescriptor key_desc */ 3:
                    message.keyDesc = KeyDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.keyDesc);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ephemeral_pubkey = 1; */
        if (message.ephemeralPubkey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ephemeralPubkey);
        /* signrpc.KeyLocator key_loc = 2 [deprecated = true]; */
        if (message.keyLoc)
            KeyLocator.internalBinaryWrite(message.keyLoc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* signrpc.KeyDescriptor key_desc = 3; */
        if (message.keyDesc)
            KeyDescriptor.internalBinaryWrite(message.keyDesc, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SharedKeyRequest
 */
export const SharedKeyRequest = new SharedKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedKeyResponse$Type extends MessageType<SharedKeyResponse> {
    constructor() {
        super("signrpc.SharedKeyResponse", [
            { no: 1, name: "shared_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SharedKeyResponse>): SharedKeyResponse {
        const message = { sharedKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SharedKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedKeyResponse): SharedKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes shared_key */ 1:
                    message.sharedKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes shared_key = 1; */
        if (message.sharedKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sharedKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.SharedKeyResponse
 */
export const SharedKeyResponse = new SharedKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TweakDesc$Type extends MessageType<TweakDesc> {
    constructor() {
        super("signrpc.TweakDesc", [
            { no: 1, name: "tweak", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "is_x_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TweakDesc>): TweakDesc {
        const message = { tweak: new Uint8Array(0), isXOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TweakDesc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TweakDesc): TweakDesc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tweak */ 1:
                    message.tweak = reader.bytes();
                    break;
                case /* bool is_x_only */ 2:
                    message.isXOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TweakDesc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tweak = 1; */
        if (message.tweak.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tweak);
        /* bool is_x_only = 2; */
        if (message.isXOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.isXOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.TweakDesc
 */
export const TweakDesc = new TweakDesc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaprootTweakDesc$Type extends MessageType<TaprootTweakDesc> {
    constructor() {
        super("signrpc.TaprootTweakDesc", [
            { no: 1, name: "script_root", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key_spend_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TaprootTweakDesc>): TaprootTweakDesc {
        const message = { scriptRoot: new Uint8Array(0), keySpendOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TaprootTweakDesc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaprootTweakDesc): TaprootTweakDesc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes script_root */ 1:
                    message.scriptRoot = reader.bytes();
                    break;
                case /* bool key_spend_only */ 2:
                    message.keySpendOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaprootTweakDesc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes script_root = 1; */
        if (message.scriptRoot.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.scriptRoot);
        /* bool key_spend_only = 2; */
        if (message.keySpendOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.keySpendOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.TaprootTweakDesc
 */
export const TaprootTweakDesc = new TaprootTweakDesc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2CombineKeysRequest$Type extends MessageType<MuSig2CombineKeysRequest> {
    constructor() {
        super("signrpc.MuSig2CombineKeysRequest", [
            { no: 1, name: "all_signer_pubkeys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "tweaks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TweakDesc },
            { no: 3, name: "taproot_tweak", kind: "message", T: () => TaprootTweakDesc },
            { no: 4, name: "version", kind: "enum", T: () => ["signrpc.MuSig2Version", MuSig2Version] }
        ]);
    }
    create(value?: PartialMessage<MuSig2CombineKeysRequest>): MuSig2CombineKeysRequest {
        const message = { allSignerPubkeys: [], tweaks: [], version: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2CombineKeysRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2CombineKeysRequest): MuSig2CombineKeysRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes all_signer_pubkeys */ 1:
                    message.allSignerPubkeys.push(reader.bytes());
                    break;
                case /* repeated signrpc.TweakDesc tweaks */ 2:
                    message.tweaks.push(TweakDesc.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* signrpc.TaprootTweakDesc taproot_tweak */ 3:
                    message.taprootTweak = TaprootTweakDesc.internalBinaryRead(reader, reader.uint32(), options, message.taprootTweak);
                    break;
                case /* signrpc.MuSig2Version version */ 4:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2CombineKeysRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes all_signer_pubkeys = 1; */
        for (let i = 0; i < message.allSignerPubkeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.allSignerPubkeys[i]);
        /* repeated signrpc.TweakDesc tweaks = 2; */
        for (let i = 0; i < message.tweaks.length; i++)
            TweakDesc.internalBinaryWrite(message.tweaks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* signrpc.TaprootTweakDesc taproot_tweak = 3; */
        if (message.taprootTweak)
            TaprootTweakDesc.internalBinaryWrite(message.taprootTweak, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* signrpc.MuSig2Version version = 4; */
        if (message.version !== 0)
            writer.tag(4, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2CombineKeysRequest
 */
export const MuSig2CombineKeysRequest = new MuSig2CombineKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2CombineKeysResponse$Type extends MessageType<MuSig2CombineKeysResponse> {
    constructor() {
        super("signrpc.MuSig2CombineKeysResponse", [
            { no: 1, name: "combined_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "taproot_internal_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "version", kind: "enum", T: () => ["signrpc.MuSig2Version", MuSig2Version] }
        ]);
    }
    create(value?: PartialMessage<MuSig2CombineKeysResponse>): MuSig2CombineKeysResponse {
        const message = { combinedKey: new Uint8Array(0), taprootInternalKey: new Uint8Array(0), version: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2CombineKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2CombineKeysResponse): MuSig2CombineKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes combined_key */ 1:
                    message.combinedKey = reader.bytes();
                    break;
                case /* bytes taproot_internal_key */ 2:
                    message.taprootInternalKey = reader.bytes();
                    break;
                case /* signrpc.MuSig2Version version */ 4:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2CombineKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes combined_key = 1; */
        if (message.combinedKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.combinedKey);
        /* bytes taproot_internal_key = 2; */
        if (message.taprootInternalKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.taprootInternalKey);
        /* signrpc.MuSig2Version version = 4; */
        if (message.version !== 0)
            writer.tag(4, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2CombineKeysResponse
 */
export const MuSig2CombineKeysResponse = new MuSig2CombineKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2SessionRequest$Type extends MessageType<MuSig2SessionRequest> {
    constructor() {
        super("signrpc.MuSig2SessionRequest", [
            { no: 1, name: "key_loc", kind: "message", T: () => KeyLocator },
            { no: 2, name: "all_signer_pubkeys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "other_signer_public_nonces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "tweaks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TweakDesc },
            { no: 5, name: "taproot_tweak", kind: "message", T: () => TaprootTweakDesc },
            { no: 6, name: "version", kind: "enum", T: () => ["signrpc.MuSig2Version", MuSig2Version] },
            { no: 7, name: "pregenerated_local_nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2SessionRequest>): MuSig2SessionRequest {
        const message = { allSignerPubkeys: [], otherSignerPublicNonces: [], tweaks: [], version: 0, pregeneratedLocalNonce: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2SessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2SessionRequest): MuSig2SessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* signrpc.KeyLocator key_loc */ 1:
                    message.keyLoc = KeyLocator.internalBinaryRead(reader, reader.uint32(), options, message.keyLoc);
                    break;
                case /* repeated bytes all_signer_pubkeys */ 2:
                    message.allSignerPubkeys.push(reader.bytes());
                    break;
                case /* repeated bytes other_signer_public_nonces */ 3:
                    message.otherSignerPublicNonces.push(reader.bytes());
                    break;
                case /* repeated signrpc.TweakDesc tweaks */ 4:
                    message.tweaks.push(TweakDesc.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* signrpc.TaprootTweakDesc taproot_tweak */ 5:
                    message.taprootTweak = TaprootTweakDesc.internalBinaryRead(reader, reader.uint32(), options, message.taprootTweak);
                    break;
                case /* signrpc.MuSig2Version version */ 6:
                    message.version = reader.int32();
                    break;
                case /* bytes pregenerated_local_nonce */ 7:
                    message.pregeneratedLocalNonce = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2SessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* signrpc.KeyLocator key_loc = 1; */
        if (message.keyLoc)
            KeyLocator.internalBinaryWrite(message.keyLoc, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes all_signer_pubkeys = 2; */
        for (let i = 0; i < message.allSignerPubkeys.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.allSignerPubkeys[i]);
        /* repeated bytes other_signer_public_nonces = 3; */
        for (let i = 0; i < message.otherSignerPublicNonces.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.otherSignerPublicNonces[i]);
        /* repeated signrpc.TweakDesc tweaks = 4; */
        for (let i = 0; i < message.tweaks.length; i++)
            TweakDesc.internalBinaryWrite(message.tweaks[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* signrpc.TaprootTweakDesc taproot_tweak = 5; */
        if (message.taprootTweak)
            TaprootTweakDesc.internalBinaryWrite(message.taprootTweak, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* signrpc.MuSig2Version version = 6; */
        if (message.version !== 0)
            writer.tag(6, WireType.Varint).int32(message.version);
        /* bytes pregenerated_local_nonce = 7; */
        if (message.pregeneratedLocalNonce.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.pregeneratedLocalNonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2SessionRequest
 */
export const MuSig2SessionRequest = new MuSig2SessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2SessionResponse$Type extends MessageType<MuSig2SessionResponse> {
    constructor() {
        super("signrpc.MuSig2SessionResponse", [
            { no: 1, name: "session_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "combined_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "taproot_internal_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "local_public_nonces", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "have_all_nonces", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "version", kind: "enum", T: () => ["signrpc.MuSig2Version", MuSig2Version] }
        ]);
    }
    create(value?: PartialMessage<MuSig2SessionResponse>): MuSig2SessionResponse {
        const message = { sessionId: new Uint8Array(0), combinedKey: new Uint8Array(0), taprootInternalKey: new Uint8Array(0), localPublicNonces: new Uint8Array(0), haveAllNonces: false, version: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2SessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2SessionResponse): MuSig2SessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes session_id */ 1:
                    message.sessionId = reader.bytes();
                    break;
                case /* bytes combined_key */ 2:
                    message.combinedKey = reader.bytes();
                    break;
                case /* bytes taproot_internal_key */ 3:
                    message.taprootInternalKey = reader.bytes();
                    break;
                case /* bytes local_public_nonces */ 4:
                    message.localPublicNonces = reader.bytes();
                    break;
                case /* bool have_all_nonces */ 5:
                    message.haveAllNonces = reader.bool();
                    break;
                case /* signrpc.MuSig2Version version */ 6:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2SessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes session_id = 1; */
        if (message.sessionId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sessionId);
        /* bytes combined_key = 2; */
        if (message.combinedKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.combinedKey);
        /* bytes taproot_internal_key = 3; */
        if (message.taprootInternalKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.taprootInternalKey);
        /* bytes local_public_nonces = 4; */
        if (message.localPublicNonces.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.localPublicNonces);
        /* bool have_all_nonces = 5; */
        if (message.haveAllNonces !== false)
            writer.tag(5, WireType.Varint).bool(message.haveAllNonces);
        /* signrpc.MuSig2Version version = 6; */
        if (message.version !== 0)
            writer.tag(6, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2SessionResponse
 */
export const MuSig2SessionResponse = new MuSig2SessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2RegisterNoncesRequest$Type extends MessageType<MuSig2RegisterNoncesRequest> {
    constructor() {
        super("signrpc.MuSig2RegisterNoncesRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "other_signer_public_nonces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2RegisterNoncesRequest>): MuSig2RegisterNoncesRequest {
        const message = { sessionId: new Uint8Array(0), otherSignerPublicNonces: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2RegisterNoncesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2RegisterNoncesRequest): MuSig2RegisterNoncesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes session_id */ 1:
                    message.sessionId = reader.bytes();
                    break;
                case /* repeated bytes other_signer_public_nonces */ 3:
                    message.otherSignerPublicNonces.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2RegisterNoncesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes session_id = 1; */
        if (message.sessionId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sessionId);
        /* repeated bytes other_signer_public_nonces = 3; */
        for (let i = 0; i < message.otherSignerPublicNonces.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.otherSignerPublicNonces[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2RegisterNoncesRequest
 */
export const MuSig2RegisterNoncesRequest = new MuSig2RegisterNoncesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2RegisterNoncesResponse$Type extends MessageType<MuSig2RegisterNoncesResponse> {
    constructor() {
        super("signrpc.MuSig2RegisterNoncesResponse", [
            { no: 1, name: "have_all_nonces", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2RegisterNoncesResponse>): MuSig2RegisterNoncesResponse {
        const message = { haveAllNonces: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2RegisterNoncesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2RegisterNoncesResponse): MuSig2RegisterNoncesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool have_all_nonces */ 1:
                    message.haveAllNonces = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2RegisterNoncesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool have_all_nonces = 1; */
        if (message.haveAllNonces !== false)
            writer.tag(1, WireType.Varint).bool(message.haveAllNonces);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2RegisterNoncesResponse
 */
export const MuSig2RegisterNoncesResponse = new MuSig2RegisterNoncesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2SignRequest$Type extends MessageType<MuSig2SignRequest> {
    constructor() {
        super("signrpc.MuSig2SignRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "message_digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "cleanup", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2SignRequest>): MuSig2SignRequest {
        const message = { sessionId: new Uint8Array(0), messageDigest: new Uint8Array(0), cleanup: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2SignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2SignRequest): MuSig2SignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes session_id */ 1:
                    message.sessionId = reader.bytes();
                    break;
                case /* bytes message_digest */ 2:
                    message.messageDigest = reader.bytes();
                    break;
                case /* bool cleanup */ 3:
                    message.cleanup = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2SignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes session_id = 1; */
        if (message.sessionId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sessionId);
        /* bytes message_digest = 2; */
        if (message.messageDigest.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.messageDigest);
        /* bool cleanup = 3; */
        if (message.cleanup !== false)
            writer.tag(3, WireType.Varint).bool(message.cleanup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2SignRequest
 */
export const MuSig2SignRequest = new MuSig2SignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2SignResponse$Type extends MessageType<MuSig2SignResponse> {
    constructor() {
        super("signrpc.MuSig2SignResponse", [
            { no: 1, name: "local_partial_signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2SignResponse>): MuSig2SignResponse {
        const message = { localPartialSignature: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2SignResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2SignResponse): MuSig2SignResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes local_partial_signature */ 1:
                    message.localPartialSignature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2SignResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes local_partial_signature = 1; */
        if (message.localPartialSignature.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.localPartialSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2SignResponse
 */
export const MuSig2SignResponse = new MuSig2SignResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2CombineSigRequest$Type extends MessageType<MuSig2CombineSigRequest> {
    constructor() {
        super("signrpc.MuSig2CombineSigRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "other_partial_signatures", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2CombineSigRequest>): MuSig2CombineSigRequest {
        const message = { sessionId: new Uint8Array(0), otherPartialSignatures: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2CombineSigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2CombineSigRequest): MuSig2CombineSigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes session_id */ 1:
                    message.sessionId = reader.bytes();
                    break;
                case /* repeated bytes other_partial_signatures */ 2:
                    message.otherPartialSignatures.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2CombineSigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes session_id = 1; */
        if (message.sessionId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sessionId);
        /* repeated bytes other_partial_signatures = 2; */
        for (let i = 0; i < message.otherPartialSignatures.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.otherPartialSignatures[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2CombineSigRequest
 */
export const MuSig2CombineSigRequest = new MuSig2CombineSigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2CombineSigResponse$Type extends MessageType<MuSig2CombineSigResponse> {
    constructor() {
        super("signrpc.MuSig2CombineSigResponse", [
            { no: 1, name: "have_all_signatures", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "final_signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2CombineSigResponse>): MuSig2CombineSigResponse {
        const message = { haveAllSignatures: false, finalSignature: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2CombineSigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2CombineSigResponse): MuSig2CombineSigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool have_all_signatures */ 1:
                    message.haveAllSignatures = reader.bool();
                    break;
                case /* bytes final_signature */ 2:
                    message.finalSignature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2CombineSigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool have_all_signatures = 1; */
        if (message.haveAllSignatures !== false)
            writer.tag(1, WireType.Varint).bool(message.haveAllSignatures);
        /* bytes final_signature = 2; */
        if (message.finalSignature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.finalSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2CombineSigResponse
 */
export const MuSig2CombineSigResponse = new MuSig2CombineSigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2CleanupRequest$Type extends MessageType<MuSig2CleanupRequest> {
    constructor() {
        super("signrpc.MuSig2CleanupRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MuSig2CleanupRequest>): MuSig2CleanupRequest {
        const message = { sessionId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2CleanupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2CleanupRequest): MuSig2CleanupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes session_id */ 1:
                    message.sessionId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MuSig2CleanupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes session_id = 1; */
        if (message.sessionId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2CleanupRequest
 */
export const MuSig2CleanupRequest = new MuSig2CleanupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MuSig2CleanupResponse$Type extends MessageType<MuSig2CleanupResponse> {
    constructor() {
        super("signrpc.MuSig2CleanupResponse", []);
    }
    create(value?: PartialMessage<MuSig2CleanupResponse>): MuSig2CleanupResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MuSig2CleanupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MuSig2CleanupResponse): MuSig2CleanupResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MuSig2CleanupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message signrpc.MuSig2CleanupResponse
 */
export const MuSig2CleanupResponse = new MuSig2CleanupResponse$Type();
/**
 * @generated ServiceType for protobuf service signrpc.Signer
 */
export const Signer = new ServiceType("signrpc.Signer", [
    { name: "SignOutputRaw", options: {}, I: SignReq, O: SignResp },
    { name: "ComputeInputScript", options: {}, I: SignReq, O: InputScriptResp },
    { name: "SignMessage", options: {}, I: SignMessageReq, O: SignMessageResp },
    { name: "VerifyMessage", options: {}, I: VerifyMessageReq, O: VerifyMessageResp },
    { name: "DeriveSharedKey", options: {}, I: SharedKeyRequest, O: SharedKeyResponse },
    { name: "MuSig2CombineKeys", options: {}, I: MuSig2CombineKeysRequest, O: MuSig2CombineKeysResponse },
    { name: "MuSig2CreateSession", options: {}, I: MuSig2SessionRequest, O: MuSig2SessionResponse },
    { name: "MuSig2RegisterNonces", options: {}, I: MuSig2RegisterNoncesRequest, O: MuSig2RegisterNoncesResponse },
    { name: "MuSig2Sign", options: {}, I: MuSig2SignRequest, O: MuSig2SignResponse },
    { name: "MuSig2CombineSig", options: {}, I: MuSig2CombineSigRequest, O: MuSig2CombineSigResponse },
    { name: "MuSig2Cleanup", options: {}, I: MuSig2CleanupRequest, O: MuSig2CleanupResponse }
]);
