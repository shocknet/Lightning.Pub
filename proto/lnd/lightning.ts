// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "lightning.proto" (package "lnrpc", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message lnrpc.LookupHtlcRequest
 */
export interface LookupHtlcRequest {
    /**
     * @generated from protobuf field: uint64 chan_id = 1;
     */
    chanId: bigint;
    /**
     * @generated from protobuf field: uint64 htlc_index = 2;
     */
    htlcIndex: bigint;
}
/**
 * @generated from protobuf message lnrpc.LookupHtlcResponse
 */
export interface LookupHtlcResponse {
    /**
     * @generated from protobuf field: bool settled = 1;
     */
    settled: boolean;
    /**
     * @generated from protobuf field: bool offchain = 2;
     */
    offchain: boolean;
}
/**
 * @generated from protobuf message lnrpc.SubscribeCustomMessagesRequest
 */
export interface SubscribeCustomMessagesRequest {
}
/**
 * @generated from protobuf message lnrpc.CustomMessage
 */
export interface CustomMessage {
    /**
     * Peer from which the message originates
     *
     * @generated from protobuf field: bytes peer = 1;
     */
    peer: Uint8Array;
    /**
     * Message type. This value will be in the custom range (>= 32768).
     *
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
    /**
     * Raw message data
     *
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendCustomMessageRequest
 */
export interface SendCustomMessageRequest {
    /**
     * Peer to send the message to
     *
     * @generated from protobuf field: bytes peer = 1;
     */
    peer: Uint8Array;
    /**
     * Message type. This value needs to be in the custom range (>= 32768).
     *
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
    /**
     * Raw message data.
     *
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendCustomMessageResponse
 */
export interface SendCustomMessageResponse {
}
/**
 * @generated from protobuf message lnrpc.Utxo
 */
export interface Utxo {
    /**
     * The type of address
     *
     * @generated from protobuf field: lnrpc.AddressType address_type = 1;
     */
    addressType: AddressType;
    /**
     * The address
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * The value of the unspent coin in satoshis
     *
     * @generated from protobuf field: int64 amount_sat = 3;
     */
    amountSat: bigint;
    /**
     * The pkscript in hex
     *
     * @generated from protobuf field: string pk_script = 4;
     */
    pkScript: string;
    /**
     * The outpoint in format txid:n
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 5;
     */
    outpoint?: OutPoint;
    /**
     * The number of confirmations for the Utxo
     *
     * @generated from protobuf field: int64 confirmations = 6;
     */
    confirmations: bigint;
}
/**
 * @generated from protobuf message lnrpc.OutputDetail
 */
export interface OutputDetail {
    /**
     * The type of the output
     *
     * @generated from protobuf field: lnrpc.OutputScriptType output_type = 1;
     */
    outputType: OutputScriptType;
    /**
     * The address
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * The pkscript in hex
     *
     * @generated from protobuf field: string pk_script = 3;
     */
    pkScript: string;
    /**
     * The output index used in the raw transaction
     *
     * @generated from protobuf field: int64 output_index = 4;
     */
    outputIndex: bigint;
    /**
     * The value of the output coin in satoshis
     *
     * @generated from protobuf field: int64 amount = 5;
     */
    amount: bigint;
    /**
     * Denotes if the output is controlled by the internal wallet
     *
     * @generated from protobuf field: bool is_our_address = 6;
     */
    isOurAddress: boolean;
}
/**
 * @generated from protobuf message lnrpc.Transaction
 */
export interface Transaction {
    /**
     * The transaction hash
     *
     * @generated from protobuf field: string tx_hash = 1;
     */
    txHash: string;
    /**
     * The transaction amount, denominated in satoshis
     *
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: bigint;
    /**
     * The number of confirmations
     *
     * @generated from protobuf field: int32 num_confirmations = 3;
     */
    numConfirmations: number;
    /**
     * The hash of the block this transaction was included in
     *
     * @generated from protobuf field: string block_hash = 4;
     */
    blockHash: string;
    /**
     * The height of the block this transaction was included in
     *
     * @generated from protobuf field: int32 block_height = 5;
     */
    blockHeight: number;
    /**
     * Timestamp of this transaction
     *
     * @generated from protobuf field: int64 time_stamp = 6;
     */
    timeStamp: bigint;
    /**
     * Fees paid for this transaction
     *
     * @generated from protobuf field: int64 total_fees = 7;
     */
    totalFees: bigint;
    /**
     * Addresses that received funds for this transaction. Deprecated as it is
     * now incorporated in the output_details field.
     *
     * @deprecated
     * @generated from protobuf field: repeated string dest_addresses = 8 [deprecated = true];
     */
    destAddresses: string[];
    /**
     * Outputs that received funds for this transaction
     *
     * @generated from protobuf field: repeated lnrpc.OutputDetail output_details = 11;
     */
    outputDetails: OutputDetail[];
    /**
     * The raw transaction hex.
     *
     * @generated from protobuf field: string raw_tx_hex = 9;
     */
    rawTxHex: string;
    /**
     * A label that was optionally set on transaction broadcast.
     *
     * @generated from protobuf field: string label = 10;
     */
    label: string;
    /**
     * PreviousOutpoints/Inputs of this transaction.
     *
     * @generated from protobuf field: repeated lnrpc.PreviousOutPoint previous_outpoints = 12;
     */
    previousOutpoints: PreviousOutPoint[];
}
/**
 * @generated from protobuf message lnrpc.GetTransactionsRequest
 */
export interface GetTransactionsRequest {
    /**
     *
     * The height from which to list transactions, inclusive. If this value is
     * greater than end_height, transactions will be read in reverse.
     *
     * @generated from protobuf field: int32 start_height = 1;
     */
    startHeight: number;
    /**
     *
     * The height until which to list transactions, inclusive. To include
     * unconfirmed transactions, this value should be set to -1, which will
     * return transactions from start_height until the current chain tip and
     * unconfirmed transactions. If no end_height is provided, the call will
     * default to this option.
     *
     * @generated from protobuf field: int32 end_height = 2;
     */
    endHeight: number;
    /**
     * An optional filter to only include transactions relevant to an account.
     *
     * @generated from protobuf field: string account = 3;
     */
    account: string;
}
/**
 * @generated from protobuf message lnrpc.TransactionDetails
 */
export interface TransactionDetails {
    /**
     * The list of transactions relevant to the wallet.
     *
     * @generated from protobuf field: repeated lnrpc.Transaction transactions = 1;
     */
    transactions: Transaction[];
}
/**
 * @generated from protobuf message lnrpc.FeeLimit
 */
export interface FeeLimit {
    /**
     * @generated from protobuf oneof: limit
     */
    limit: {
        oneofKind: "fixed";
        /**
         *
         * The fee limit expressed as a fixed amount of satoshis.
         *
         * The fields fixed and fixed_msat are mutually exclusive.
         *
         * @generated from protobuf field: int64 fixed = 1;
         */
        fixed: bigint;
    } | {
        oneofKind: "fixedMsat";
        /**
         *
         * The fee limit expressed as a fixed amount of millisatoshis.
         *
         * The fields fixed and fixed_msat are mutually exclusive.
         *
         * @generated from protobuf field: int64 fixed_msat = 3;
         */
        fixedMsat: bigint;
    } | {
        oneofKind: "percent";
        /**
         * The fee limit expressed as a percentage of the payment amount.
         *
         * @generated from protobuf field: int64 percent = 2;
         */
        percent: bigint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.SendRequest
 */
export interface SendRequest {
    /**
     *
     * The identity pubkey of the payment recipient. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes dest = 1;
     */
    dest: Uint8Array;
    /**
     *
     * The hex-encoded identity pubkey of the payment recipient. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string dest_string = 2 [deprecated = true];
     */
    destString: string;
    /**
     *
     * The amount to send expressed in satoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt = 3;
     */
    amt: bigint;
    /**
     *
     * The amount to send expressed in millisatoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt_msat = 12;
     */
    amtMsat: bigint;
    /**
     *
     * The hash to use within the payment's HTLC. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes payment_hash = 4;
     */
    paymentHash: Uint8Array;
    /**
     *
     * The hex-encoded hash to use within the payment's HTLC. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string payment_hash_string = 5 [deprecated = true];
     */
    paymentHashString: string;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network. With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient.
     *
     * @generated from protobuf field: string payment_request = 6;
     */
    paymentRequest: string;
    /**
     *
     * The CLTV delta from the current height that should be used to set the
     * timelock for the final hop.
     *
     * @generated from protobuf field: int32 final_cltv_delta = 7;
     */
    finalCltvDelta: number;
    /**
     *
     * The maximum number of satoshis that will be paid as a fee of the payment.
     * This value can be represented either as a percentage of the amount being
     * sent, or as a fixed amount of the maximum fee the user is willing the pay to
     * send the payment. If not specified, lnd will use a default value of 100%
     * fees for small amounts (<=1k sat) or 5% fees for larger amounts.
     *
     * @generated from protobuf field: lnrpc.FeeLimit fee_limit = 8;
     */
    feeLimit?: FeeLimit;
    /**
     *
     * The channel id of the channel that must be taken to the first hop. If zero,
     * any channel may be used.
     *
     * @generated from protobuf field: uint64 outgoing_chan_id = 9 [jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @generated from protobuf field: bytes last_hop_pubkey = 13;
     */
    lastHopPubkey: Uint8Array;
    /**
     *
     * An optional maximum total time lock for the route. This should not exceed
     * lnd's `--max-cltv-expiry` setting. If zero, then the value of
     * `--max-cltv-expiry` is enforced.
     *
     * @generated from protobuf field: uint32 cltv_limit = 10;
     */
    cltvLimit: number;
    /**
     *
     * An optional field that can be used to pass an arbitrary set of TLV records
     * to a peer which understands the new records. This can be used to pass
     * application specific data during the payment attempt. Record types are
     * required to be in the custom range >= 65536. When using REST, the values
     * must be encoded as base64.
     *
     * @generated from protobuf field: map<uint64, bytes> dest_custom_records = 11;
     */
    destCustomRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * If set, circular payments to self are permitted.
     *
     * @generated from protobuf field: bool allow_self_payment = 14;
     */
    allowSelfPayment: boolean;
    /**
     *
     * Features assumed to be supported by the final node. All transitive feature
     * dependencies must also be set properly. For a given feature bit pair, either
     * optional or remote may be set, but not both. If this field is nil or empty,
     * the router will try to load destination features from the graph as a
     * fallback.
     *
     * @generated from protobuf field: repeated lnrpc.FeatureBit dest_features = 15;
     */
    destFeatures: FeatureBit[];
    /**
     *
     * The payment address of the generated invoice.
     *
     * @generated from protobuf field: bytes payment_addr = 16;
     */
    paymentAddr: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendResponse
 */
export interface SendResponse {
    /**
     * @generated from protobuf field: string payment_error = 1;
     */
    paymentError: string;
    /**
     * @generated from protobuf field: bytes payment_preimage = 2;
     */
    paymentPreimage: Uint8Array;
    /**
     * @generated from protobuf field: lnrpc.Route payment_route = 3;
     */
    paymentRoute?: Route;
    /**
     * @generated from protobuf field: bytes payment_hash = 4;
     */
    paymentHash: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.SendToRouteRequest
 */
export interface SendToRouteRequest {
    /**
     *
     * The payment hash to use for the HTLC. When using REST, this field must be
     * encoded as base64.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     *
     * An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string payment_hash_string = 2 [deprecated = true];
     */
    paymentHashString: string;
    /**
     * Route that should be used to attempt to complete the payment.
     *
     * @generated from protobuf field: lnrpc.Route route = 4;
     */
    route?: Route;
}
/**
 * @generated from protobuf message lnrpc.ChannelAcceptRequest
 */
export interface ChannelAcceptRequest {
    /**
     * The pubkey of the node that wishes to open an inbound channel.
     *
     * @generated from protobuf field: bytes node_pubkey = 1;
     */
    nodePubkey: Uint8Array;
    /**
     * The hash of the genesis block that the proposed channel resides in.
     *
     * @generated from protobuf field: bytes chain_hash = 2;
     */
    chainHash: Uint8Array;
    /**
     * The pending channel id.
     *
     * @generated from protobuf field: bytes pending_chan_id = 3;
     */
    pendingChanId: Uint8Array;
    /**
     * The funding amount in satoshis that initiator wishes to use in the
     * channel.
     *
     * @generated from protobuf field: uint64 funding_amt = 4;
     */
    fundingAmt: bigint;
    /**
     * The push amount of the proposed channel in millisatoshis.
     *
     * @generated from protobuf field: uint64 push_amt = 5;
     */
    pushAmt: bigint;
    /**
     * The dust limit of the initiator's commitment tx.
     *
     * @generated from protobuf field: uint64 dust_limit = 6;
     */
    dustLimit: bigint;
    /**
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     *
     * @generated from protobuf field: uint64 max_value_in_flight = 7;
     */
    maxValueInFlight: bigint;
    /**
     * The minimum amount of satoshis the initiator requires us to have at all
     * times.
     *
     * @generated from protobuf field: uint64 channel_reserve = 8;
     */
    channelReserve: bigint;
    /**
     * The smallest HTLC in millisatoshis that the initiator will accept.
     *
     * @generated from protobuf field: uint64 min_htlc = 9;
     */
    minHtlc: bigint;
    /**
     * The initial fee rate that the initiator suggests for both commitment
     * transactions.
     *
     * @generated from protobuf field: uint64 fee_per_kw = 10;
     */
    feePerKw: bigint;
    /**
     *
     * The number of blocks to use for the relative time lock in the pay-to-self
     * output of both commitment transactions.
     *
     * @generated from protobuf field: uint32 csv_delay = 11;
     */
    csvDelay: number;
    /**
     * The total number of incoming HTLC's that the initiator will accept.
     *
     * @generated from protobuf field: uint32 max_accepted_htlcs = 12;
     */
    maxAcceptedHtlcs: number;
    /**
     * A bit-field which the initiator uses to specify proposed channel
     * behavior.
     *
     * @generated from protobuf field: uint32 channel_flags = 13;
     */
    channelFlags: number;
    /**
     * The commitment type the initiator wishes to use for the proposed channel.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 14;
     */
    commitmentType: CommitmentType;
    /**
     * Whether the initiator wants to open a zero-conf channel via the channel
     * type.
     *
     * @generated from protobuf field: bool wants_zero_conf = 15;
     */
    wantsZeroConf: boolean;
    /**
     * Whether the initiator wants to use the scid-alias channel type. This is
     * separate from the feature bit.
     *
     * @generated from protobuf field: bool wants_scid_alias = 16;
     */
    wantsScidAlias: boolean;
}
/**
 * @generated from protobuf message lnrpc.ChannelAcceptResponse
 */
export interface ChannelAcceptResponse {
    /**
     * Whether or not the client accepts the channel.
     *
     * @generated from protobuf field: bool accept = 1;
     */
    accept: boolean;
    /**
     * The pending channel id to which this response applies.
     *
     * @generated from protobuf field: bytes pending_chan_id = 2;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * An optional error to send the initiating party to indicate why the channel
     * was rejected. This field *should not* contain sensitive information, it will
     * be sent to the initiating party. This field should only be set if accept is
     * false, the channel will be rejected if an error is set with accept=true
     * because the meaning of this response is ambiguous. Limited to 500
     * characters.
     *
     * @generated from protobuf field: string error = 3;
     */
    error: string;
    /**
     *
     * The upfront shutdown address to use if the initiating peer supports option
     * upfront shutdown script (see ListPeers for the features supported). Note
     * that the channel open will fail if this value is set for a peer that does
     * not support this feature bit.
     *
     * @generated from protobuf field: string upfront_shutdown = 4;
     */
    upfrontShutdown: string;
    /**
     *
     * The csv delay (in blocks) that we require for the remote party.
     *
     * @generated from protobuf field: uint32 csv_delay = 5;
     */
    csvDelay: number;
    /**
     *
     * The reserve amount in satoshis that we require the remote peer to adhere to.
     * We require that the remote peer always have some reserve amount allocated to
     * them so that there is always a disincentive to broadcast old state (if they
     * hold 0 sats on their side of the channel, there is nothing to lose).
     *
     * @generated from protobuf field: uint64 reserve_sat = 6;
     */
    reserveSat: bigint;
    /**
     *
     * The maximum amount of funds in millisatoshis that we allow the remote peer
     * to have in outstanding htlcs.
     *
     * @generated from protobuf field: uint64 in_flight_max_msat = 7;
     */
    inFlightMaxMsat: bigint;
    /**
     *
     * The maximum number of htlcs that the remote peer can offer us.
     *
     * @generated from protobuf field: uint32 max_htlc_count = 8;
     */
    maxHtlcCount: number;
    /**
     *
     * The minimum value in millisatoshis for incoming htlcs on the channel.
     *
     * @generated from protobuf field: uint64 min_htlc_in = 9;
     */
    minHtlcIn: bigint;
    /**
     *
     * The number of confirmations we require before we consider the channel open.
     *
     * @generated from protobuf field: uint32 min_accept_depth = 10;
     */
    minAcceptDepth: number;
    /**
     *
     * Whether the responder wants this to be a zero-conf channel. This will fail
     * if either side does not have the scid-alias feature bit set. The minimum
     * depth field must be zero if this is true.
     *
     * @generated from protobuf field: bool zero_conf = 11;
     */
    zeroConf: boolean;
}
/**
 * @generated from protobuf message lnrpc.ChannelPoint
 */
export interface ChannelPoint {
    /**
     * @generated from protobuf oneof: funding_txid
     */
    fundingTxid: {
        oneofKind: "fundingTxidBytes";
        /**
         *
         * Txid of the funding transaction. When using REST, this field must be
         * encoded as base64.
         *
         * @generated from protobuf field: bytes funding_txid_bytes = 1;
         */
        fundingTxidBytes: Uint8Array;
    } | {
        oneofKind: "fundingTxidStr";
        /**
         *
         * Hex-encoded string representing the byte-reversed hash of the funding
         * transaction.
         *
         * @generated from protobuf field: string funding_txid_str = 2;
         */
        fundingTxidStr: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * The index of the output of the funding transaction
     *
     * @generated from protobuf field: uint32 output_index = 3;
     */
    outputIndex: number;
}
/**
 * @generated from protobuf message lnrpc.OutPoint
 */
export interface OutPoint {
    /**
     * Raw bytes representing the transaction id.
     *
     * @generated from protobuf field: bytes txid_bytes = 1;
     */
    txidBytes: Uint8Array;
    /**
     * Reversed, hex-encoded string representing the transaction id.
     *
     * @generated from protobuf field: string txid_str = 2;
     */
    txidStr: string;
    /**
     * The index of the output on the transaction.
     *
     * @generated from protobuf field: uint32 output_index = 3;
     */
    outputIndex: number;
}
/**
 * @generated from protobuf message lnrpc.PreviousOutPoint
 */
export interface PreviousOutPoint {
    /**
     * The outpoint in format txid:n.
     *
     * @generated from protobuf field: string outpoint = 1;
     */
    outpoint: string;
    /**
     * Denotes if the outpoint is controlled by the internal wallet.
     * The flag will only detect p2wkh, np2wkh and p2tr inputs as its own.
     *
     * @generated from protobuf field: bool is_our_output = 2;
     */
    isOurOutput: boolean;
}
/**
 * @generated from protobuf message lnrpc.LightningAddress
 */
export interface LightningAddress {
    /**
     * The identity pubkey of the Lightning node.
     *
     * @generated from protobuf field: string pubkey = 1;
     */
    pubkey: string;
    /**
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`.
     *
     * @generated from protobuf field: string host = 2;
     */
    host: string;
}
/**
 * @generated from protobuf message lnrpc.EstimateFeeRequest
 */
export interface EstimateFeeRequest {
    /**
     * The map from addresses to amounts for the transaction.
     *
     * @generated from protobuf field: map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"];
     */
    addrToAmount: {
        [key: string]: bigint;
    };
    /**
     * The target number of blocks that this transaction should be confirmed
     * by.
     *
     * @generated from protobuf field: int32 target_conf = 2;
     */
    targetConf: number;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 3;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 4;
     */
    spendUnconfirmed: boolean;
}
/**
 * @generated from protobuf message lnrpc.EstimateFeeResponse
 */
export interface EstimateFeeResponse {
    /**
     * The total fee in satoshis.
     *
     * @generated from protobuf field: int64 fee_sat = 1;
     */
    feeSat: bigint;
    /**
     * Deprecated, use sat_per_vbyte.
     * The fee rate in satoshi/vbyte.
     *
     * @deprecated
     * @generated from protobuf field: int64 feerate_sat_per_byte = 2 [deprecated = true];
     */
    feerateSatPerByte: bigint;
    /**
     * The fee rate in satoshi/vbyte.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 3;
     */
    satPerVbyte: bigint;
}
/**
 * @generated from protobuf message lnrpc.SendManyRequest
 */
export interface SendManyRequest {
    /**
     * The map from addresses to amounts
     *
     * @generated from protobuf field: map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"];
     */
    addrToAmount: {
        [key: string]: bigint;
    };
    /**
     * The target number of blocks that this transaction should be confirmed
     * by.
     *
     * @generated from protobuf field: int32 target_conf = 3;
     */
    targetConf: number;
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 4;
     */
    satPerVbyte: bigint;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 5 [deprecated = true];
     */
    satPerByte: bigint;
    /**
     * An optional label for the transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 6;
     */
    label: string;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 7;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 8;
     */
    spendUnconfirmed: boolean;
}
/**
 * @generated from protobuf message lnrpc.SendManyResponse
 */
export interface SendManyResponse {
    /**
     * The id of the transaction
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message lnrpc.SendCoinsRequest
 */
export interface SendCoinsRequest {
    /**
     * The address to send coins to
     *
     * @generated from protobuf field: string addr = 1;
     */
    addr: string;
    /**
     * The amount in satoshis to send
     *
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: bigint;
    /**
     * The target number of blocks that this transaction should be confirmed
     * by.
     *
     * @generated from protobuf field: int32 target_conf = 3;
     */
    targetConf: number;
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 4;
     */
    satPerVbyte: bigint;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 5 [deprecated = true];
     */
    satPerByte: bigint;
    /**
     *
     * If set, then the amount field will be ignored, and lnd will attempt to
     * send all the coins under control of the internal wallet to the specified
     * address.
     *
     * @generated from protobuf field: bool send_all = 6;
     */
    sendAll: boolean;
    /**
     * An optional label for the transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 7;
     */
    label: string;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 8;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 9;
     */
    spendUnconfirmed: boolean;
}
/**
 * @generated from protobuf message lnrpc.SendCoinsResponse
 */
export interface SendCoinsResponse {
    /**
     * The transaction ID of the transaction
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message lnrpc.ListUnspentRequest
 */
export interface ListUnspentRequest {
    /**
     * The minimum number of confirmations to be included.
     *
     * @generated from protobuf field: int32 min_confs = 1;
     */
    minConfs: number;
    /**
     * The maximum number of confirmations to be included.
     *
     * @generated from protobuf field: int32 max_confs = 2;
     */
    maxConfs: number;
    /**
     * An optional filter to only include outputs belonging to an account.
     *
     * @generated from protobuf field: string account = 3;
     */
    account: string;
}
/**
 * @generated from protobuf message lnrpc.ListUnspentResponse
 */
export interface ListUnspentResponse {
    /**
     * A list of utxos
     *
     * @generated from protobuf field: repeated lnrpc.Utxo utxos = 1;
     */
    utxos: Utxo[];
}
/**
 * @generated from protobuf message lnrpc.NewAddressRequest
 */
export interface NewAddressRequest {
    /**
     * The type of address to generate.
     *
     * @generated from protobuf field: lnrpc.AddressType type = 1;
     */
    type: AddressType;
    /**
     *
     * The name of the account to generate a new address for. If empty, the
     * default wallet account is used.
     *
     * @generated from protobuf field: string account = 2;
     */
    account: string;
}
/**
 * @generated from protobuf message lnrpc.NewAddressResponse
 */
export interface NewAddressResponse {
    /**
     * The newly generated wallet address
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message lnrpc.SignMessageRequest
 */
export interface SignMessageRequest {
    /**
     *
     * The message to be signed. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     *
     * Instead of the default double-SHA256 hashing of the message before signing,
     * only use one round of hashing instead.
     *
     * @generated from protobuf field: bool single_hash = 2;
     */
    singleHash: boolean;
}
/**
 * @generated from protobuf message lnrpc.SignMessageResponse
 */
export interface SignMessageResponse {
    /**
     * The signature for the given message
     *
     * @generated from protobuf field: string signature = 1;
     */
    signature: string;
}
/**
 * @generated from protobuf message lnrpc.VerifyMessageRequest
 */
export interface VerifyMessageRequest {
    /**
     *
     * The message over which the signature is to be verified. When using REST,
     * this field must be encoded as base64.
     *
     * @generated from protobuf field: bytes msg = 1;
     */
    msg: Uint8Array;
    /**
     * The signature to be verified over the given message
     *
     * @generated from protobuf field: string signature = 2;
     */
    signature: string;
}
/**
 * @generated from protobuf message lnrpc.VerifyMessageResponse
 */
export interface VerifyMessageResponse {
    /**
     * Whether the signature was valid over the given message
     *
     * @generated from protobuf field: bool valid = 1;
     */
    valid: boolean;
    /**
     * The pubkey recovered from the signature
     *
     * @generated from protobuf field: string pubkey = 2;
     */
    pubkey: string;
}
/**
 * @generated from protobuf message lnrpc.ConnectPeerRequest
 */
export interface ConnectPeerRequest {
    /**
     *
     * Lightning address of the peer to connect to.
     *
     * @generated from protobuf field: lnrpc.LightningAddress addr = 1;
     */
    addr?: LightningAddress;
    /**
     *
     * If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous.
     *
     * @generated from protobuf field: bool perm = 2;
     */
    perm: boolean;
    /**
     *
     * The connection timeout value (in seconds) for this request. It won't affect
     * other requests.
     *
     * @generated from protobuf field: uint64 timeout = 3;
     */
    timeout: bigint;
}
/**
 * @generated from protobuf message lnrpc.ConnectPeerResponse
 */
export interface ConnectPeerResponse {
}
/**
 * @generated from protobuf message lnrpc.DisconnectPeerRequest
 */
export interface DisconnectPeerRequest {
    /**
     * The pubkey of the node to disconnect from
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
}
/**
 * @generated from protobuf message lnrpc.DisconnectPeerResponse
 */
export interface DisconnectPeerResponse {
}
/**
 * @generated from protobuf message lnrpc.HTLC
 */
export interface HTLC {
    /**
     * @generated from protobuf field: bool incoming = 1;
     */
    incoming: boolean;
    /**
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: bigint;
    /**
     * @generated from protobuf field: bytes hash_lock = 3;
     */
    hashLock: Uint8Array;
    /**
     * @generated from protobuf field: uint32 expiration_height = 4;
     */
    expirationHeight: number;
    /**
     * Index identifying the htlc on the channel.
     *
     * @generated from protobuf field: uint64 htlc_index = 5;
     */
    htlcIndex: bigint;
    /**
     * If this HTLC is involved in a forwarding operation, this field indicates
     * the forwarding channel. For an outgoing htlc, it is the incoming channel.
     * For an incoming htlc, it is the outgoing channel. When the htlc
     * originates from this node or this node is the final destination,
     * forwarding_channel will be zero. The forwarding channel will also be zero
     * for htlcs that need to be forwarded but don't have a forwarding decision
     * persisted yet.
     *
     * @generated from protobuf field: uint64 forwarding_channel = 6;
     */
    forwardingChannel: bigint;
    /**
     * Index identifying the htlc on the forwarding channel.
     *
     * @generated from protobuf field: uint64 forwarding_htlc_index = 7;
     */
    forwardingHtlcIndex: bigint;
}
/**
 * @generated from protobuf message lnrpc.ChannelConstraints
 */
export interface ChannelConstraints {
    /**
     *
     * The CSV delay expressed in relative blocks. If the channel is force closed,
     * we will need to wait for this many blocks before we can regain our funds.
     *
     * @generated from protobuf field: uint32 csv_delay = 1;
     */
    csvDelay: number;
    /**
     * The minimum satoshis this node is required to reserve in its balance.
     *
     * @generated from protobuf field: uint64 chan_reserve_sat = 2;
     */
    chanReserveSat: bigint;
    /**
     * The dust limit (in satoshis) of the initiator's commitment tx.
     *
     * @generated from protobuf field: uint64 dust_limit_sat = 3;
     */
    dustLimitSat: bigint;
    /**
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     *
     * @generated from protobuf field: uint64 max_pending_amt_msat = 4;
     */
    maxPendingAmtMsat: bigint;
    /**
     * The smallest HTLC in millisatoshis that the initiator will accept.
     *
     * @generated from protobuf field: uint64 min_htlc_msat = 5;
     */
    minHtlcMsat: bigint;
    /**
     * The total number of incoming HTLC's that the initiator will accept.
     *
     * @generated from protobuf field: uint32 max_accepted_htlcs = 6;
     */
    maxAcceptedHtlcs: number;
}
/**
 * @generated from protobuf message lnrpc.Channel
 */
export interface Channel {
    /**
     * Whether this channel is active or not
     *
     * @generated from protobuf field: bool active = 1;
     */
    active: boolean;
    /**
     * The identity pubkey of the remote node
     *
     * @generated from protobuf field: string remote_pubkey = 2;
     */
    remotePubkey: string;
    /**
     *
     * The outpoint (txid:index) of the funding transaction. With this value, Bob
     * will be able to generate a signature for Alice's version of the commitment
     * transaction.
     *
     * @generated from protobuf field: string channel_point = 3;
     */
    channelPoint: string;
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 4 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The total amount of funds held in this channel
     *
     * @generated from protobuf field: int64 capacity = 5;
     */
    capacity: bigint;
    /**
     * This node's current balance in this channel
     *
     * @generated from protobuf field: int64 local_balance = 6;
     */
    localBalance: bigint;
    /**
     * The counterparty's current balance in this channel
     *
     * @generated from protobuf field: int64 remote_balance = 7;
     */
    remoteBalance: bigint;
    /**
     *
     * The amount calculated to be paid in fees for the current set of commitment
     * transactions. The fee amount is persisted with the channel in order to
     * allow the fee amount to be removed and recalculated with each channel state
     * update, including updates that happen after a system restart.
     *
     * @generated from protobuf field: int64 commit_fee = 8;
     */
    commitFee: bigint;
    /**
     * The weight of the commitment transaction
     *
     * @generated from protobuf field: int64 commit_weight = 9;
     */
    commitWeight: bigint;
    /**
     *
     * The required number of satoshis per kilo-weight that the requester will pay
     * at all times, for both the funding transaction and commitment transaction.
     * This value can later be updated once the channel is open.
     *
     * @generated from protobuf field: int64 fee_per_kw = 10;
     */
    feePerKw: bigint;
    /**
     * The unsettled balance in this channel
     *
     * @generated from protobuf field: int64 unsettled_balance = 11;
     */
    unsettledBalance: bigint;
    /**
     *
     * The total number of satoshis we've sent within this channel.
     *
     * @generated from protobuf field: int64 total_satoshis_sent = 12;
     */
    totalSatoshisSent: bigint;
    /**
     *
     * The total number of satoshis we've received within this channel.
     *
     * @generated from protobuf field: int64 total_satoshis_received = 13;
     */
    totalSatoshisReceived: bigint;
    /**
     *
     * The total number of updates conducted within this channel.
     *
     * @generated from protobuf field: uint64 num_updates = 14;
     */
    numUpdates: bigint;
    /**
     *
     * The list of active, uncleared HTLCs currently pending within the channel.
     *
     * @generated from protobuf field: repeated lnrpc.HTLC pending_htlcs = 15;
     */
    pendingHtlcs: HTLC[];
    /**
     *
     * Deprecated. The CSV delay expressed in relative blocks. If the channel is
     * force closed, we will need to wait for this many blocks before we can regain
     * our funds.
     *
     * @deprecated
     * @generated from protobuf field: uint32 csv_delay = 16 [deprecated = true];
     */
    csvDelay: number;
    /**
     * Whether this channel is advertised to the network or not.
     *
     * @generated from protobuf field: bool private = 17;
     */
    private: boolean;
    /**
     * True if we were the ones that created the channel.
     *
     * @generated from protobuf field: bool initiator = 18;
     */
    initiator: boolean;
    /**
     * A set of flags showing the current state of the channel.
     *
     * @generated from protobuf field: string chan_status_flags = 19;
     */
    chanStatusFlags: string;
    /**
     * Deprecated. The minimum satoshis this node is required to reserve in its
     * balance.
     *
     * @deprecated
     * @generated from protobuf field: int64 local_chan_reserve_sat = 20 [deprecated = true];
     */
    localChanReserveSat: bigint;
    /**
     *
     * Deprecated. The minimum satoshis the other node is required to reserve in
     * its balance.
     *
     * @deprecated
     * @generated from protobuf field: int64 remote_chan_reserve_sat = 21 [deprecated = true];
     */
    remoteChanReserveSat: bigint;
    /**
     * Deprecated. Use commitment_type.
     *
     * @deprecated
     * @generated from protobuf field: bool static_remote_key = 22 [deprecated = true];
     */
    staticRemoteKey: boolean;
    /**
     * The commitment type used by this channel.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 26;
     */
    commitmentType: CommitmentType;
    /**
     *
     * The number of seconds that the channel has been monitored by the channel
     * scoring system. Scores are currently not persisted, so this value may be
     * less than the lifetime of the channel [EXPERIMENTAL].
     *
     * @generated from protobuf field: int64 lifetime = 23;
     */
    lifetime: bigint;
    /**
     *
     * The number of seconds that the remote peer has been observed as being online
     * by the channel scoring system over the lifetime of the channel
     * [EXPERIMENTAL].
     *
     * @generated from protobuf field: int64 uptime = 24;
     */
    uptime: bigint;
    /**
     *
     * Close address is the address that we will enforce payout to on cooperative
     * close if the channel was opened utilizing option upfront shutdown. This
     * value can be set on channel open by setting close_address in an open channel
     * request. If this value is not set, you can still choose a payout address by
     * cooperatively closing with the delivery_address field set.
     *
     * @generated from protobuf field: string close_address = 25;
     */
    closeAddress: string;
    /**
     *
     * The amount that the initiator of the channel optionally pushed to the remote
     * party on channel open. This amount will be zero if the channel initiator did
     * not push any funds to the remote peer. If the initiator field is true, we
     * pushed this amount to our peer, if it is false, the remote peer pushed this
     * amount to us.
     *
     * @generated from protobuf field: uint64 push_amount_sat = 27;
     */
    pushAmountSat: bigint;
    /**
     *
     * This uint32 indicates if this channel is to be considered 'frozen'. A
     * frozen channel doest not allow a cooperative channel close by the
     * initiator. The thaw_height is the height that this restriction stops
     * applying to the channel. This field is optional, not setting it or using a
     * value of zero will mean the channel has no additional restrictions. The
     * height can be interpreted in two ways: as a relative height if the value is
     * less than 500,000, or as an absolute height otherwise.
     *
     * @generated from protobuf field: uint32 thaw_height = 28;
     */
    thawHeight: number;
    /**
     * List constraints for the local node.
     *
     * @generated from protobuf field: lnrpc.ChannelConstraints local_constraints = 29;
     */
    localConstraints?: ChannelConstraints;
    /**
     * List constraints for the remote node.
     *
     * @generated from protobuf field: lnrpc.ChannelConstraints remote_constraints = 30;
     */
    remoteConstraints?: ChannelConstraints;
    /**
     *
     * This lists out the set of alias short channel ids that exist for a channel.
     * This may be empty.
     *
     * @generated from protobuf field: repeated uint64 alias_scids = 31;
     */
    aliasScids: bigint[];
    /**
     * Whether or not this is a zero-conf channel.
     *
     * @generated from protobuf field: bool zero_conf = 32;
     */
    zeroConf: boolean;
    /**
     * This is the confirmed / on-chain zero-conf SCID.
     *
     * @generated from protobuf field: uint64 zero_conf_confirmed_scid = 33;
     */
    zeroConfConfirmedScid: bigint;
}
/**
 * @generated from protobuf message lnrpc.ListChannelsRequest
 */
export interface ListChannelsRequest {
    /**
     * @generated from protobuf field: bool active_only = 1;
     */
    activeOnly: boolean;
    /**
     * @generated from protobuf field: bool inactive_only = 2;
     */
    inactiveOnly: boolean;
    /**
     * @generated from protobuf field: bool public_only = 3;
     */
    publicOnly: boolean;
    /**
     * @generated from protobuf field: bool private_only = 4;
     */
    privateOnly: boolean;
    /**
     *
     * Filters the response for channels with a target peer's pubkey. If peer is
     * empty, all channels will be returned.
     *
     * @generated from protobuf field: bytes peer = 5;
     */
    peer: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.ListChannelsResponse
 */
export interface ListChannelsResponse {
    /**
     * The list of active channels
     *
     * @generated from protobuf field: repeated lnrpc.Channel channels = 11;
     */
    channels: Channel[];
}
/**
 * @generated from protobuf message lnrpc.AliasMap
 */
export interface AliasMap {
    /**
     *
     * For non-zero-conf channels, this is the confirmed SCID. Otherwise, this is
     * the first assigned "base" alias.
     *
     * @generated from protobuf field: uint64 base_scid = 1;
     */
    baseScid: bigint;
    /**
     * The set of all aliases stored for the base SCID.
     *
     * @generated from protobuf field: repeated uint64 aliases = 2;
     */
    aliases: bigint[];
}
/**
 * @generated from protobuf message lnrpc.ListAliasesRequest
 */
export interface ListAliasesRequest {
}
/**
 * @generated from protobuf message lnrpc.ListAliasesResponse
 */
export interface ListAliasesResponse {
    /**
     * @generated from protobuf field: repeated lnrpc.AliasMap alias_maps = 1;
     */
    aliasMaps: AliasMap[];
}
/**
 * @generated from protobuf message lnrpc.ChannelCloseSummary
 */
export interface ChannelCloseSummary {
    /**
     * The outpoint (txid:index) of the funding transaction.
     *
     * @generated from protobuf field: string channel_point = 1;
     */
    channelPoint: string;
    /**
     *  The unique channel ID for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 2 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The hash of the genesis block that this channel resides within.
     *
     * @generated from protobuf field: string chain_hash = 3;
     */
    chainHash: string;
    /**
     * The txid of the transaction which ultimately closed this channel.
     *
     * @generated from protobuf field: string closing_tx_hash = 4;
     */
    closingTxHash: string;
    /**
     * Public key of the remote peer that we formerly had a channel with.
     *
     * @generated from protobuf field: string remote_pubkey = 5;
     */
    remotePubkey: string;
    /**
     * Total capacity of the channel.
     *
     * @generated from protobuf field: int64 capacity = 6;
     */
    capacity: bigint;
    /**
     * Height at which the funding transaction was spent.
     *
     * @generated from protobuf field: uint32 close_height = 7;
     */
    closeHeight: number;
    /**
     * Settled balance at the time of channel closure
     *
     * @generated from protobuf field: int64 settled_balance = 8;
     */
    settledBalance: bigint;
    /**
     * The sum of all the time-locked outputs at the time of channel closure
     *
     * @generated from protobuf field: int64 time_locked_balance = 9;
     */
    timeLockedBalance: bigint;
    /**
     * Details on how the channel was closed.
     *
     * @generated from protobuf field: lnrpc.ChannelCloseSummary.ClosureType close_type = 10;
     */
    closeType: ChannelCloseSummary_ClosureType;
    /**
     *
     * Open initiator is the party that initiated opening the channel. Note that
     * this value may be unknown if the channel was closed before we migrated to
     * store open channel information after close.
     *
     * @generated from protobuf field: lnrpc.Initiator open_initiator = 11;
     */
    openInitiator: Initiator;
    /**
     *
     * Close initiator indicates which party initiated the close. This value will
     * be unknown for channels that were cooperatively closed before we started
     * tracking cooperative close initiators. Note that this indicates which party
     * initiated a close, and it is possible for both to initiate cooperative or
     * force closes, although only one party's close will be confirmed on chain.
     *
     * @generated from protobuf field: lnrpc.Initiator close_initiator = 12;
     */
    closeInitiator: Initiator;
    /**
     * @generated from protobuf field: repeated lnrpc.Resolution resolutions = 13;
     */
    resolutions: Resolution[];
    /**
     *
     * This lists out the set of alias short channel ids that existed for the
     * closed channel. This may be empty.
     *
     * @generated from protobuf field: repeated uint64 alias_scids = 14;
     */
    aliasScids: bigint[];
    /**
     *  The confirmed SCID for a zero-conf channel.
     *
     * @generated from protobuf field: uint64 zero_conf_confirmed_scid = 15 [jstype = JS_STRING];
     */
    zeroConfConfirmedScid: string;
}
/**
 * @generated from protobuf enum lnrpc.ChannelCloseSummary.ClosureType
 */
export enum ChannelCloseSummary_ClosureType {
    /**
     * @generated from protobuf enum value: COOPERATIVE_CLOSE = 0;
     */
    COOPERATIVE_CLOSE = 0,
    /**
     * @generated from protobuf enum value: LOCAL_FORCE_CLOSE = 1;
     */
    LOCAL_FORCE_CLOSE = 1,
    /**
     * @generated from protobuf enum value: REMOTE_FORCE_CLOSE = 2;
     */
    REMOTE_FORCE_CLOSE = 2,
    /**
     * @generated from protobuf enum value: BREACH_CLOSE = 3;
     */
    BREACH_CLOSE = 3,
    /**
     * @generated from protobuf enum value: FUNDING_CANCELED = 4;
     */
    FUNDING_CANCELED = 4,
    /**
     * @generated from protobuf enum value: ABANDONED = 5;
     */
    ABANDONED = 5
}
/**
 * @generated from protobuf message lnrpc.Resolution
 */
export interface Resolution {
    /**
     * The type of output we are resolving.
     *
     * @generated from protobuf field: lnrpc.ResolutionType resolution_type = 1;
     */
    resolutionType: ResolutionType;
    /**
     * The outcome of our on chain action that resolved the outpoint.
     *
     * @generated from protobuf field: lnrpc.ResolutionOutcome outcome = 2;
     */
    outcome: ResolutionOutcome;
    /**
     * The outpoint that was spent by the resolution.
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 3;
     */
    outpoint?: OutPoint;
    /**
     * The amount that was claimed by the resolution.
     *
     * @generated from protobuf field: uint64 amount_sat = 4;
     */
    amountSat: bigint;
    /**
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     *
     * @generated from protobuf field: string sweep_txid = 5;
     */
    sweepTxid: string;
}
/**
 * @generated from protobuf message lnrpc.ClosedChannelsRequest
 */
export interface ClosedChannelsRequest {
    /**
     * @generated from protobuf field: bool cooperative = 1;
     */
    cooperative: boolean;
    /**
     * @generated from protobuf field: bool local_force = 2;
     */
    localForce: boolean;
    /**
     * @generated from protobuf field: bool remote_force = 3;
     */
    remoteForce: boolean;
    /**
     * @generated from protobuf field: bool breach = 4;
     */
    breach: boolean;
    /**
     * @generated from protobuf field: bool funding_canceled = 5;
     */
    fundingCanceled: boolean;
    /**
     * @generated from protobuf field: bool abandoned = 6;
     */
    abandoned: boolean;
}
/**
 * @generated from protobuf message lnrpc.ClosedChannelsResponse
 */
export interface ClosedChannelsResponse {
    /**
     * @generated from protobuf field: repeated lnrpc.ChannelCloseSummary channels = 1;
     */
    channels: ChannelCloseSummary[];
}
/**
 * @generated from protobuf message lnrpc.Peer
 */
export interface Peer {
    /**
     * The identity pubkey of the peer
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     * Network address of the peer; eg `127.0.0.1:10011`
     *
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * Bytes of data transmitted to this peer
     *
     * @generated from protobuf field: uint64 bytes_sent = 4;
     */
    bytesSent: bigint;
    /**
     * Bytes of data transmitted from this peer
     *
     * @generated from protobuf field: uint64 bytes_recv = 5;
     */
    bytesRecv: bigint;
    /**
     * Satoshis sent to this peer
     *
     * @generated from protobuf field: int64 sat_sent = 6;
     */
    satSent: bigint;
    /**
     * Satoshis received from this peer
     *
     * @generated from protobuf field: int64 sat_recv = 7;
     */
    satRecv: bigint;
    /**
     * A channel is inbound if the counterparty initiated the channel
     *
     * @generated from protobuf field: bool inbound = 8;
     */
    inbound: boolean;
    /**
     * Ping time to this peer
     *
     * @generated from protobuf field: int64 ping_time = 9;
     */
    pingTime: bigint;
    /**
     * The type of sync we are currently performing with this peer.
     *
     * @generated from protobuf field: lnrpc.Peer.SyncType sync_type = 10;
     */
    syncType: Peer_SyncType;
    /**
     * Features advertised by the remote peer in their init message.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 11;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     *
     * The latest errors received from our peer with timestamps, limited to the 10
     * most recent errors. These errors are tracked across peer connections, but
     * are not persisted across lnd restarts. Note that these errors are only
     * stored for peers that we have channels open with, to prevent peers from
     * spamming us with errors at no cost.
     *
     * @generated from protobuf field: repeated lnrpc.TimestampedError errors = 12;
     */
    errors: TimestampedError[];
    /**
     *
     * The number of times we have recorded this peer going offline or coming
     * online, recorded across restarts. Note that this value is decreased over
     * time if the peer has not recently flapped, so that we can forgive peers
     * with historically high flap counts.
     *
     * @generated from protobuf field: int32 flap_count = 13;
     */
    flapCount: number;
    /**
     *
     * The timestamp of the last flap we observed for this peer. If this value is
     * zero, we have not observed any flaps for this peer.
     *
     * @generated from protobuf field: int64 last_flap_ns = 14;
     */
    lastFlapNs: bigint;
    /**
     *
     * The last ping payload the peer has sent to us.
     *
     * @generated from protobuf field: bytes last_ping_payload = 15;
     */
    lastPingPayload: Uint8Array;
}
/**
 * @generated from protobuf enum lnrpc.Peer.SyncType
 */
export enum Peer_SyncType {
    /**
     *
     * Denotes that we cannot determine the peer's current sync type.
     *
     * @generated from protobuf enum value: UNKNOWN_SYNC = 0;
     */
    UNKNOWN_SYNC = 0,
    /**
     *
     * Denotes that we are actively receiving new graph updates from the peer.
     *
     * @generated from protobuf enum value: ACTIVE_SYNC = 1;
     */
    ACTIVE_SYNC = 1,
    /**
     *
     * Denotes that we are not receiving new graph updates from the peer.
     *
     * @generated from protobuf enum value: PASSIVE_SYNC = 2;
     */
    PASSIVE_SYNC = 2,
    /**
     *
     * Denotes that this peer is pinned into an active sync.
     *
     * @generated from protobuf enum value: PINNED_SYNC = 3;
     */
    PINNED_SYNC = 3
}
/**
 * @generated from protobuf message lnrpc.TimestampedError
 */
export interface TimestampedError {
    /**
     * The unix timestamp in seconds when the error occurred.
     *
     * @generated from protobuf field: uint64 timestamp = 1;
     */
    timestamp: bigint;
    /**
     * The string representation of the error sent by our peer.
     *
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message lnrpc.ListPeersRequest
 */
export interface ListPeersRequest {
    /**
     *
     * If true, only the last error that our peer sent us will be returned with
     * the peer's information, rather than the full set of historic errors we have
     * stored.
     *
     * @generated from protobuf field: bool latest_error = 1;
     */
    latestError: boolean;
}
/**
 * @generated from protobuf message lnrpc.ListPeersResponse
 */
export interface ListPeersResponse {
    /**
     * The list of currently connected peers
     *
     * @generated from protobuf field: repeated lnrpc.Peer peers = 1;
     */
    peers: Peer[];
}
/**
 * @generated from protobuf message lnrpc.PeerEventSubscription
 */
export interface PeerEventSubscription {
}
/**
 * @generated from protobuf message lnrpc.PeerEvent
 */
export interface PeerEvent {
    /**
     * The identity pubkey of the peer.
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     * @generated from protobuf field: lnrpc.PeerEvent.EventType type = 2;
     */
    type: PeerEvent_EventType;
}
/**
 * @generated from protobuf enum lnrpc.PeerEvent.EventType
 */
export enum PeerEvent_EventType {
    /**
     * @generated from protobuf enum value: PEER_ONLINE = 0;
     */
    PEER_ONLINE = 0,
    /**
     * @generated from protobuf enum value: PEER_OFFLINE = 1;
     */
    PEER_OFFLINE = 1
}
/**
 * @generated from protobuf message lnrpc.GetInfoRequest
 */
export interface GetInfoRequest {
}
/**
 * @generated from protobuf message lnrpc.GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * The version of the LND software that the node is running.
     *
     * @generated from protobuf field: string version = 14;
     */
    version: string;
    /**
     * The SHA1 commit hash that the daemon is compiled with.
     *
     * @generated from protobuf field: string commit_hash = 20;
     */
    commitHash: string;
    /**
     * The identity pubkey of the current node.
     *
     * @generated from protobuf field: string identity_pubkey = 1;
     */
    identityPubkey: string;
    /**
     * If applicable, the alias of the current node, e.g. "bob"
     *
     * @generated from protobuf field: string alias = 2;
     */
    alias: string;
    /**
     * The color of the current node in hex code format
     *
     * @generated from protobuf field: string color = 17;
     */
    color: string;
    /**
     * Number of pending channels
     *
     * @generated from protobuf field: uint32 num_pending_channels = 3;
     */
    numPendingChannels: number;
    /**
     * Number of active channels
     *
     * @generated from protobuf field: uint32 num_active_channels = 4;
     */
    numActiveChannels: number;
    /**
     * Number of inactive channels
     *
     * @generated from protobuf field: uint32 num_inactive_channels = 15;
     */
    numInactiveChannels: number;
    /**
     * Number of peers
     *
     * @generated from protobuf field: uint32 num_peers = 5;
     */
    numPeers: number;
    /**
     * The node's current view of the height of the best block
     *
     * @generated from protobuf field: uint32 block_height = 6;
     */
    blockHeight: number;
    /**
     * The node's current view of the hash of the best block
     *
     * @generated from protobuf field: string block_hash = 8;
     */
    blockHash: string;
    /**
     * Timestamp of the block best known to the wallet
     *
     * @generated from protobuf field: int64 best_header_timestamp = 13;
     */
    bestHeaderTimestamp: bigint;
    /**
     * Whether the wallet's view is synced to the main chain
     *
     * @generated from protobuf field: bool synced_to_chain = 9;
     */
    syncedToChain: boolean;
    /**
     * Whether we consider ourselves synced with the public channel graph.
     *
     * @generated from protobuf field: bool synced_to_graph = 18;
     */
    syncedToGraph: boolean;
    /**
     *
     * Whether the current node is connected to testnet. This field is
     * deprecated and the network field should be used instead
     *
     * @deprecated
     * @generated from protobuf field: bool testnet = 10 [deprecated = true];
     */
    testnet: boolean;
    /**
     * A list of active chains the node is connected to
     *
     * @generated from protobuf field: repeated lnrpc.Chain chains = 16;
     */
    chains: Chain[];
    /**
     * The URIs of the current node.
     *
     * @generated from protobuf field: repeated string uris = 12;
     */
    uris: string[];
    /**
     *
     * Features that our node has advertised in our init message, node
     * announcements and invoices.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 19;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     *
     * Indicates whether the HTLC interceptor API is in always-on mode.
     *
     * @generated from protobuf field: bool require_htlc_interceptor = 21;
     */
    requireHtlcInterceptor: boolean;
}
/**
 * @generated from protobuf message lnrpc.GetRecoveryInfoRequest
 */
export interface GetRecoveryInfoRequest {
}
/**
 * @generated from protobuf message lnrpc.GetRecoveryInfoResponse
 */
export interface GetRecoveryInfoResponse {
    /**
     * Whether the wallet is in recovery mode
     *
     * @generated from protobuf field: bool recovery_mode = 1;
     */
    recoveryMode: boolean;
    /**
     * Whether the wallet recovery progress is finished
     *
     * @generated from protobuf field: bool recovery_finished = 2;
     */
    recoveryFinished: boolean;
    /**
     * The recovery progress, ranging from 0 to 1.
     *
     * @generated from protobuf field: double progress = 3;
     */
    progress: number;
}
/**
 * @generated from protobuf message lnrpc.Chain
 */
export interface Chain {
    /**
     * The blockchain the node is on (eg bitcoin, litecoin)
     *
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * The network the node is on (eg regtest, testnet, mainnet)
     *
     * @generated from protobuf field: string network = 2;
     */
    network: string;
}
/**
 * @generated from protobuf message lnrpc.ConfirmationUpdate
 */
export interface ConfirmationUpdate {
    /**
     * @generated from protobuf field: bytes block_sha = 1;
     */
    blockSha: Uint8Array;
    /**
     * @generated from protobuf field: int32 block_height = 2;
     */
    blockHeight: number;
    /**
     * @generated from protobuf field: uint32 num_confs_left = 3;
     */
    numConfsLeft: number;
}
/**
 * @generated from protobuf message lnrpc.ChannelOpenUpdate
 */
export interface ChannelOpenUpdate {
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint channel_point = 1;
     */
    channelPoint?: ChannelPoint;
}
/**
 * @generated from protobuf message lnrpc.ChannelCloseUpdate
 */
export interface ChannelCloseUpdate {
    /**
     * @generated from protobuf field: bytes closing_txid = 1;
     */
    closingTxid: Uint8Array;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
}
/**
 * @generated from protobuf message lnrpc.CloseChannelRequest
 */
export interface CloseChannelRequest {
    /**
     *
     * The outpoint (txid:index) of the funding transaction. With this value, Bob
     * will be able to generate a signature for Alice's version of the commitment
     * transaction.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint channel_point = 1;
     */
    channelPoint?: ChannelPoint;
    /**
     * If true, then the channel will be closed forcibly. This means the
     * current commitment transaction will be signed and broadcast.
     *
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean;
    /**
     * The target number of blocks that the closure transaction should be
     * confirmed by.
     *
     * @generated from protobuf field: int32 target_conf = 3;
     */
    targetConf: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * closure transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 4 [deprecated = true];
     */
    satPerByte: bigint;
    /**
     *
     * An optional address to send funds to in the case of a cooperative close.
     * If the channel was opened with an upfront shutdown script and this field
     * is set, the request to close will fail because the channel must pay out
     * to the upfront shutdown addresss.
     *
     * @generated from protobuf field: string delivery_address = 5;
     */
    deliveryAddress: string;
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * closure transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 6;
     */
    satPerVbyte: bigint;
    /**
     * The maximum fee rate the closer is willing to pay.
     *
     * NOTE: This field is only respected if we're the initiator of the channel.
     *
     * @generated from protobuf field: uint64 max_fee_per_vbyte = 7;
     */
    maxFeePerVbyte: bigint;
}
/**
 * @generated from protobuf message lnrpc.CloseStatusUpdate
 */
export interface CloseStatusUpdate {
    /**
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "closePending";
        /**
         * @generated from protobuf field: lnrpc.PendingUpdate close_pending = 1;
         */
        closePending: PendingUpdate;
    } | {
        oneofKind: "chanClose";
        /**
         * @generated from protobuf field: lnrpc.ChannelCloseUpdate chan_close = 3;
         */
        chanClose: ChannelCloseUpdate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.PendingUpdate
 */
export interface PendingUpdate {
    /**
     * @generated from protobuf field: bytes txid = 1;
     */
    txid: Uint8Array;
    /**
     * @generated from protobuf field: uint32 output_index = 2;
     */
    outputIndex: number;
}
/**
 * @generated from protobuf message lnrpc.ReadyForPsbtFunding
 */
export interface ReadyForPsbtFunding {
    /**
     *
     * The P2WSH address of the channel funding multisig address that the below
     * specified amount in satoshis needs to be sent to.
     *
     * @generated from protobuf field: string funding_address = 1;
     */
    fundingAddress: string;
    /**
     *
     * The exact amount in satoshis that needs to be sent to the above address to
     * fund the pending channel.
     *
     * @generated from protobuf field: int64 funding_amount = 2;
     */
    fundingAmount: bigint;
    /**
     *
     * A raw PSBT that contains the pending channel output. If a base PSBT was
     * provided in the PsbtShim, this is the base PSBT with one additional output.
     * If no base PSBT was specified, this is an otherwise empty PSBT with exactly
     * one output.
     *
     * @generated from protobuf field: bytes psbt = 3;
     */
    psbt: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.BatchOpenChannelRequest
 */
export interface BatchOpenChannelRequest {
    /**
     * The list of channels to open.
     *
     * @generated from protobuf field: repeated lnrpc.BatchOpenChannel channels = 1;
     */
    channels: BatchOpenChannel[];
    /**
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     *
     * @generated from protobuf field: int32 target_conf = 2;
     */
    targetConf: number;
    /**
     * A manual fee rate set in sat/vByte that should be used when crafting the
     * funding transaction.
     *
     * @generated from protobuf field: int64 sat_per_vbyte = 3;
     */
    satPerVbyte: bigint;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 4;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 5;
     */
    spendUnconfirmed: boolean;
    /**
     * An optional label for the batch transaction, limited to 500 characters.
     *
     * @generated from protobuf field: string label = 6;
     */
    label: string;
}
/**
 * @generated from protobuf message lnrpc.BatchOpenChannel
 */
export interface BatchOpenChannel {
    /**
     * The pubkey of the node to open a channel with. When using REST, this
     * field must be encoded as base64.
     *
     * @generated from protobuf field: bytes node_pubkey = 1;
     */
    nodePubkey: Uint8Array;
    /**
     * The number of satoshis the wallet should commit to the channel.
     *
     * @generated from protobuf field: int64 local_funding_amount = 2;
     */
    localFundingAmount: bigint;
    /**
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state.
     *
     * @generated from protobuf field: int64 push_sat = 3;
     */
    pushSat: bigint;
    /**
     * Whether this channel should be private, not announced to the greater
     * network.
     *
     * @generated from protobuf field: bool private = 4;
     */
    private: boolean;
    /**
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     *
     * @generated from protobuf field: int64 min_htlc_msat = 5;
     */
    minHtlcMsat: bigint;
    /**
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     *
     * @generated from protobuf field: uint32 remote_csv_delay = 6;
     */
    remoteCsvDelay: number;
    /**
     *
     * Close address is an optional address which specifies the address to which
     * funds should be paid out to upon cooperative close. This field may only be
     * set if the peer supports the option upfront feature bit (call listpeers
     * to check). The remote peer will only accept cooperative closes to this
     * address if it is set.
     *
     * Note: If this value is set on channel creation, you will *not* be able to
     * cooperatively close out to a different address.
     *
     * @generated from protobuf field: string close_address = 7;
     */
    closeAddress: string;
    /**
     *
     * An optional, unique identifier of 32 random bytes that will be used as the
     * pending channel ID to identify the channel while it is in the pre-pending
     * state.
     *
     * @generated from protobuf field: bytes pending_chan_id = 8;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * The explicit commitment type to use. Note this field will only be used if
     * the remote peer supports explicit channel negotiation.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 9;
     */
    commitmentType: CommitmentType;
}
/**
 * @generated from protobuf message lnrpc.BatchOpenChannelResponse
 */
export interface BatchOpenChannelResponse {
    /**
     * @generated from protobuf field: repeated lnrpc.PendingUpdate pending_channels = 1;
     */
    pendingChannels: PendingUpdate[];
}
/**
 * @generated from protobuf message lnrpc.OpenChannelRequest
 */
export interface OpenChannelRequest {
    /**
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * funding transaction.
     *
     * @generated from protobuf field: uint64 sat_per_vbyte = 1;
     */
    satPerVbyte: bigint;
    /**
     *
     * The pubkey of the node to open a channel with. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes node_pubkey = 2;
     */
    nodePubkey: Uint8Array;
    /**
     *
     * The hex encoded pubkey of the node to open a channel with. Deprecated now
     * that the REST gateway supports base64 encoding of bytes fields.
     *
     * @deprecated
     * @generated from protobuf field: string node_pubkey_string = 3 [deprecated = true];
     */
    nodePubkeyString: string;
    /**
     * The number of satoshis the wallet should commit to the channel
     *
     * @generated from protobuf field: int64 local_funding_amount = 4;
     */
    localFundingAmount: bigint;
    /**
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state
     *
     * @generated from protobuf field: int64 push_sat = 5;
     */
    pushSat: bigint;
    /**
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     *
     * @generated from protobuf field: int32 target_conf = 6;
     */
    targetConf: number;
    /**
     * Deprecated, use sat_per_vbyte.
     * A manual fee rate set in sat/vbyte that should be used when crafting the
     * funding transaction.
     *
     * @deprecated
     * @generated from protobuf field: int64 sat_per_byte = 7 [deprecated = true];
     */
    satPerByte: bigint;
    /**
     * Whether this channel should be private, not announced to the greater
     * network.
     *
     * @generated from protobuf field: bool private = 8;
     */
    private: boolean;
    /**
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     *
     * @generated from protobuf field: int64 min_htlc_msat = 9;
     */
    minHtlcMsat: bigint;
    /**
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     *
     * @generated from protobuf field: uint32 remote_csv_delay = 10;
     */
    remoteCsvDelay: number;
    /**
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     *
     * @generated from protobuf field: int32 min_confs = 11;
     */
    minConfs: number;
    /**
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     *
     * @generated from protobuf field: bool spend_unconfirmed = 12;
     */
    spendUnconfirmed: boolean;
    /**
     *
     * Close address is an optional address which specifies the address to which
     * funds should be paid out to upon cooperative close. This field may only be
     * set if the peer supports the option upfront feature bit (call listpeers
     * to check). The remote peer will only accept cooperative closes to this
     * address if it is set.
     *
     * Note: If this value is set on channel creation, you will *not* be able to
     * cooperatively close out to a different address.
     *
     * @generated from protobuf field: string close_address = 13;
     */
    closeAddress: string;
    /**
     *
     * Funding shims are an optional argument that allow the caller to intercept
     * certain funding functionality. For example, a shim can be provided to use a
     * particular key for the commitment key (ideally cold) rather than use one
     * that is generated by the wallet as normal, or signal that signing will be
     * carried out in an interactive manner (PSBT based).
     *
     * @generated from protobuf field: lnrpc.FundingShim funding_shim = 14;
     */
    fundingShim?: FundingShim;
    /**
     *
     * The maximum amount of coins in millisatoshi that can be pending within
     * the channel. It only applies to the remote party.
     *
     * @generated from protobuf field: uint64 remote_max_value_in_flight_msat = 15;
     */
    remoteMaxValueInFlightMsat: bigint;
    /**
     *
     * The maximum number of concurrent HTLCs we will allow the remote party to add
     * to the commitment transaction.
     *
     * @generated from protobuf field: uint32 remote_max_htlcs = 16;
     */
    remoteMaxHtlcs: number;
    /**
     *
     * Max local csv is the maximum csv delay we will allow for our own commitment
     * transaction.
     *
     * @generated from protobuf field: uint32 max_local_csv = 17;
     */
    maxLocalCsv: number;
    /**
     *
     * The explicit commitment type to use. Note this field will only be used if
     * the remote peer supports explicit channel negotiation.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 18;
     */
    commitmentType: CommitmentType;
    /**
     *
     * If this is true, then a zero-conf channel open will be attempted.
     *
     * @generated from protobuf field: bool zero_conf = 19;
     */
    zeroConf: boolean;
    /**
     *
     * If this is true, then an option-scid-alias channel-type open will be
     * attempted.
     *
     * @generated from protobuf field: bool scid_alias = 20;
     */
    scidAlias: boolean;
    /**
     *
     * The base fee charged regardless of the number of milli-satoshis sent.
     *
     * @generated from protobuf field: uint64 base_fee = 21;
     */
    baseFee: bigint;
    /**
     *
     * The fee rate in ppm (parts per million) that will be charged in
     * proportion of the value of each forwarded HTLC.
     *
     * @generated from protobuf field: uint64 fee_rate = 22;
     */
    feeRate: bigint;
    /**
     *
     * If use_base_fee is true the open channel announcement will update the
     * channel base fee with the value specified in base_fee. In the case of
     * a base_fee of 0 use_base_fee is needed downstream to distinguish whether
     * to use the default base fee value specified in the config or 0.
     *
     * @generated from protobuf field: bool use_base_fee = 23;
     */
    useBaseFee: boolean;
    /**
     *
     * If use_fee_rate is true the open channel announcement will update the
     * channel fee rate with the value specified in fee_rate. In the case of
     * a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
     * to use the default fee rate value specified in the config or 0.
     *
     * @generated from protobuf field: bool use_fee_rate = 24;
     */
    useFeeRate: boolean;
    /**
     *
     * The number of satoshis we require the remote peer to reserve. This value,
     * if specified, must be above the dust limit and below 20% of the channel
     * capacity.
     *
     * @generated from protobuf field: uint64 remote_chan_reserve_sat = 25;
     */
    remoteChanReserveSat: bigint;
}
/**
 * @generated from protobuf message lnrpc.OpenStatusUpdate
 */
export interface OpenStatusUpdate {
    /**
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "chanPending";
        /**
         *
         * Signals that the channel is now fully negotiated and the funding
         * transaction published.
         *
         * @generated from protobuf field: lnrpc.PendingUpdate chan_pending = 1;
         */
        chanPending: PendingUpdate;
    } | {
        oneofKind: "chanOpen";
        /**
         *
         * Signals that the channel's funding transaction has now reached the
         * required number of confirmations on chain and can be used.
         *
         * @generated from protobuf field: lnrpc.ChannelOpenUpdate chan_open = 3;
         */
        chanOpen: ChannelOpenUpdate;
    } | {
        oneofKind: "psbtFund";
        /**
         *
         * Signals that the funding process has been suspended and the construction
         * of a PSBT that funds the channel PK script is now required.
         *
         * @generated from protobuf field: lnrpc.ReadyForPsbtFunding psbt_fund = 5;
         */
        psbtFund: ReadyForPsbtFunding;
    } | {
        oneofKind: undefined;
    };
    /**
     *
     * The pending channel ID of the created channel. This value may be used to
     * further the funding flow manually via the FundingStateStep method.
     *
     * @generated from protobuf field: bytes pending_chan_id = 4;
     */
    pendingChanId: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.KeyLocator
 */
export interface KeyLocator {
    /**
     * The family of key being identified.
     *
     * @generated from protobuf field: int32 key_family = 1;
     */
    keyFamily: number;
    /**
     * The precise index of the key being identified.
     *
     * @generated from protobuf field: int32 key_index = 2;
     */
    keyIndex: number;
}
/**
 * @generated from protobuf message lnrpc.KeyDescriptor
 */
export interface KeyDescriptor {
    /**
     *
     * The raw bytes of the key being identified.
     *
     * @generated from protobuf field: bytes raw_key_bytes = 1;
     */
    rawKeyBytes: Uint8Array;
    /**
     *
     * The key locator that identifies which key to use for signing.
     *
     * @generated from protobuf field: lnrpc.KeyLocator key_loc = 2;
     */
    keyLoc?: KeyLocator;
}
/**
 * @generated from protobuf message lnrpc.ChanPointShim
 */
export interface ChanPointShim {
    /**
     *
     * The size of the pre-crafted output to be used as the channel point for this
     * channel funding.
     *
     * @generated from protobuf field: int64 amt = 1;
     */
    amt: bigint;
    /**
     * The target channel point to refrence in created commitment transactions.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 2;
     */
    chanPoint?: ChannelPoint;
    /**
     * Our local key to use when creating the multi-sig output.
     *
     * @generated from protobuf field: lnrpc.KeyDescriptor local_key = 3;
     */
    localKey?: KeyDescriptor;
    /**
     * The key of the remote party to use when creating the multi-sig output.
     *
     * @generated from protobuf field: bytes remote_key = 4;
     */
    remoteKey: Uint8Array;
    /**
     *
     * If non-zero, then this will be used as the pending channel ID on the wire
     * protocol to initate the funding request. This is an optional field, and
     * should only be set if the responder is already expecting a specific pending
     * channel ID.
     *
     * @generated from protobuf field: bytes pending_chan_id = 5;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * This uint32 indicates if this channel is to be considered 'frozen'. A frozen
     * channel does not allow a cooperative channel close by the initiator. The
     * thaw_height is the height that this restriction stops applying to the
     * channel. The height can be interpreted in two ways: as a relative height if
     * the value is less than 500,000, or as an absolute height otherwise.
     *
     * @generated from protobuf field: uint32 thaw_height = 6;
     */
    thawHeight: number;
}
/**
 * @generated from protobuf message lnrpc.PsbtShim
 */
export interface PsbtShim {
    /**
     *
     * A unique identifier of 32 random bytes that will be used as the pending
     * channel ID to identify the PSBT state machine when interacting with it and
     * on the wire protocol to initiate the funding request.
     *
     * @generated from protobuf field: bytes pending_chan_id = 1;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * An optional base PSBT the new channel output will be added to. If this is
     * non-empty, it must be a binary serialized PSBT.
     *
     * @generated from protobuf field: bytes base_psbt = 2;
     */
    basePsbt: Uint8Array;
    /**
     *
     * If a channel should be part of a batch (multiple channel openings in one
     * transaction), it can be dangerous if the whole batch transaction is
     * published too early before all channel opening negotiations are completed.
     * This flag prevents this particular channel from broadcasting the transaction
     * after the negotiation with the remote peer. In a batch of channel openings
     * this flag should be set to true for every channel but the very last.
     *
     * @generated from protobuf field: bool no_publish = 3;
     */
    noPublish: boolean;
}
/**
 * @generated from protobuf message lnrpc.FundingShim
 */
export interface FundingShim {
    /**
     * @generated from protobuf oneof: shim
     */
    shim: {
        oneofKind: "chanPointShim";
        /**
         *
         * A channel shim where the channel point was fully constructed outside
         * of lnd's wallet and the transaction might already be published.
         *
         * @generated from protobuf field: lnrpc.ChanPointShim chan_point_shim = 1;
         */
        chanPointShim: ChanPointShim;
    } | {
        oneofKind: "psbtShim";
        /**
         *
         * A channel shim that uses a PSBT to fund and sign the channel funding
         * transaction.
         *
         * @generated from protobuf field: lnrpc.PsbtShim psbt_shim = 2;
         */
        psbtShim: PsbtShim;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.FundingShimCancel
 */
export interface FundingShimCancel {
    /**
     * The pending channel ID of the channel to cancel the funding shim for.
     *
     * @generated from protobuf field: bytes pending_chan_id = 1;
     */
    pendingChanId: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.FundingPsbtVerify
 */
export interface FundingPsbtVerify {
    /**
     *
     * The funded but not yet signed PSBT that sends the exact channel capacity
     * amount to the PK script returned in the open channel message in a previous
     * step.
     *
     * @generated from protobuf field: bytes funded_psbt = 1;
     */
    fundedPsbt: Uint8Array;
    /**
     * The pending channel ID of the channel to get the PSBT for.
     *
     * @generated from protobuf field: bytes pending_chan_id = 2;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * Can only be used if the no_publish flag was set to true in the OpenChannel
     * call meaning that the caller is solely responsible for publishing the final
     * funding transaction. If skip_finalize is set to true then lnd will not wait
     * for a FundingPsbtFinalize state step and instead assumes that a transaction
     * with the same TXID as the passed in PSBT will eventually confirm.
     * IT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is
     * eventually published does have the _same TXID_ as the verified PSBT. That
     * means no inputs or outputs can change, only signatures can be added. If the
     * TXID changes between this call and the publish step then the channel will
     * never be created and the funds will be in limbo.
     *
     * @generated from protobuf field: bool skip_finalize = 3;
     */
    skipFinalize: boolean;
}
/**
 * @generated from protobuf message lnrpc.FundingPsbtFinalize
 */
export interface FundingPsbtFinalize {
    /**
     *
     * The funded PSBT that contains all witness data to send the exact channel
     * capacity amount to the PK script returned in the open channel message in a
     * previous step. Cannot be set at the same time as final_raw_tx.
     *
     * @generated from protobuf field: bytes signed_psbt = 1;
     */
    signedPsbt: Uint8Array;
    /**
     * The pending channel ID of the channel to get the PSBT for.
     *
     * @generated from protobuf field: bytes pending_chan_id = 2;
     */
    pendingChanId: Uint8Array;
    /**
     *
     * As an alternative to the signed PSBT with all witness data, the final raw
     * wire format transaction can also be specified directly. Cannot be set at the
     * same time as signed_psbt.
     *
     * @generated from protobuf field: bytes final_raw_tx = 3;
     */
    finalRawTx: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.FundingTransitionMsg
 */
export interface FundingTransitionMsg {
    /**
     * @generated from protobuf oneof: trigger
     */
    trigger: {
        oneofKind: "shimRegister";
        /**
         *
         * The funding shim to register. This should be used before any
         * channel funding has began by the remote party, as it is intended as a
         * preparatory step for the full channel funding.
         *
         * @generated from protobuf field: lnrpc.FundingShim shim_register = 1;
         */
        shimRegister: FundingShim;
    } | {
        oneofKind: "shimCancel";
        /**
         * Used to cancel an existing registered funding shim.
         *
         * @generated from protobuf field: lnrpc.FundingShimCancel shim_cancel = 2;
         */
        shimCancel: FundingShimCancel;
    } | {
        oneofKind: "psbtVerify";
        /**
         *
         * Used to continue a funding flow that was initiated to be executed
         * through a PSBT. This step verifies that the PSBT contains the correct
         * outputs to fund the channel.
         *
         * @generated from protobuf field: lnrpc.FundingPsbtVerify psbt_verify = 3;
         */
        psbtVerify: FundingPsbtVerify;
    } | {
        oneofKind: "psbtFinalize";
        /**
         *
         * Used to continue a funding flow that was initiated to be executed
         * through a PSBT. This step finalizes the funded and signed PSBT, finishes
         * negotiation with the peer and finally publishes the resulting funding
         * transaction.
         *
         * @generated from protobuf field: lnrpc.FundingPsbtFinalize psbt_finalize = 4;
         */
        psbtFinalize: FundingPsbtFinalize;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.FundingStateStepResp
 */
export interface FundingStateStepResp {
}
/**
 * @generated from protobuf message lnrpc.PendingHTLC
 */
export interface PendingHTLC {
    /**
     * The direction within the channel that the htlc was sent
     *
     * @generated from protobuf field: bool incoming = 1;
     */
    incoming: boolean;
    /**
     * The total value of the htlc
     *
     * @generated from protobuf field: int64 amount = 2;
     */
    amount: bigint;
    /**
     * The final output to be swept back to the user's wallet
     *
     * @generated from protobuf field: string outpoint = 3;
     */
    outpoint: string;
    /**
     * The next block height at which we can spend the current stage
     *
     * @generated from protobuf field: uint32 maturity_height = 4;
     */
    maturityHeight: number;
    /**
     *
     * The number of blocks remaining until the current stage can be swept.
     * Negative values indicate how many blocks have passed since becoming
     * mature.
     *
     * @generated from protobuf field: int32 blocks_til_maturity = 5;
     */
    blocksTilMaturity: number;
    /**
     * Indicates whether the htlc is in its first or second stage of recovery
     *
     * @generated from protobuf field: uint32 stage = 6;
     */
    stage: number;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsRequest
 */
export interface PendingChannelsRequest {
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse
 */
export interface PendingChannelsResponse {
    /**
     * The balance in satoshis encumbered in pending channels
     *
     * @generated from protobuf field: int64 total_limbo_balance = 1;
     */
    totalLimboBalance: bigint;
    /**
     * Channels pending opening
     *
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;
     */
    pendingOpenChannels: PendingChannelsResponse_PendingOpenChannel[];
    /**
     *
     * Deprecated: Channels pending closing previously contained cooperatively
     * closed channels with a single confirmation. These channels are now
     * considered closed from the time we see them on chain.
     *
     * @deprecated
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];
     */
    pendingClosingChannels: PendingChannelsResponse_ClosedChannel[];
    /**
     * Channels pending force closing
     *
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;
     */
    pendingForceClosingChannels: PendingChannelsResponse_ForceClosedChannel[];
    /**
     * Channels waiting for closing tx to confirm
     *
     * @generated from protobuf field: repeated lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;
     */
    waitingCloseChannels: PendingChannelsResponse_WaitingCloseChannel[];
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.PendingChannel
 */
export interface PendingChannelsResponse_PendingChannel {
    /**
     * @generated from protobuf field: string remote_node_pub = 1;
     */
    remoteNodePub: string;
    /**
     * @generated from protobuf field: string channel_point = 2;
     */
    channelPoint: string;
    /**
     * @generated from protobuf field: int64 capacity = 3;
     */
    capacity: bigint;
    /**
     * @generated from protobuf field: int64 local_balance = 4;
     */
    localBalance: bigint;
    /**
     * @generated from protobuf field: int64 remote_balance = 5;
     */
    remoteBalance: bigint;
    /**
     * The minimum satoshis this node is required to reserve in its
     * balance.
     *
     * @generated from protobuf field: int64 local_chan_reserve_sat = 6;
     */
    localChanReserveSat: bigint;
    /**
     *
     * The minimum satoshis the other node is required to reserve in its
     * balance.
     *
     * @generated from protobuf field: int64 remote_chan_reserve_sat = 7;
     */
    remoteChanReserveSat: bigint;
    /**
     * The party that initiated opening the channel.
     *
     * @generated from protobuf field: lnrpc.Initiator initiator = 8;
     */
    initiator: Initiator;
    /**
     * The commitment type used by this channel.
     *
     * @generated from protobuf field: lnrpc.CommitmentType commitment_type = 9;
     */
    commitmentType: CommitmentType;
    /**
     * Total number of forwarding packages created in this channel.
     *
     * @generated from protobuf field: int64 num_forwarding_packages = 10;
     */
    numForwardingPackages: bigint;
    /**
     * A set of flags showing the current state of the channel.
     *
     * @generated from protobuf field: string chan_status_flags = 11;
     */
    chanStatusFlags: string;
    /**
     * Whether this channel is advertised to the network or not.
     *
     * @generated from protobuf field: bool private = 12;
     */
    private: boolean;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.PendingOpenChannel
 */
export interface PendingChannelsResponse_PendingOpenChannel {
    /**
     * The pending channel
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     *
     * The amount calculated to be paid in fees for the current set of
     * commitment transactions. The fee amount is persisted with the channel
     * in order to allow the fee amount to be removed and recalculated with
     * each channel state update, including updates that happen after a system
     * restart.
     *
     * @generated from protobuf field: int64 commit_fee = 4;
     */
    commitFee: bigint;
    /**
     * The weight of the commitment transaction
     *
     * @generated from protobuf field: int64 commit_weight = 5;
     */
    commitWeight: bigint;
    /**
     *
     * The required number of satoshis per kilo-weight that the requester will
     * pay at all times, for both the funding transaction and commitment
     * transaction. This value can later be updated once the channel is open.
     *
     * @generated from protobuf field: int64 fee_per_kw = 6;
     */
    feePerKw: bigint;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.WaitingCloseChannel
 */
export interface PendingChannelsResponse_WaitingCloseChannel {
    /**
     * The pending channel waiting for closing tx to confirm
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     * The balance in satoshis encumbered in this channel
     *
     * @generated from protobuf field: int64 limbo_balance = 2;
     */
    limboBalance: bigint;
    /**
     *
     * A list of valid commitment transactions. Any of these can confirm at
     * this point.
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.Commitments commitments = 3;
     */
    commitments?: PendingChannelsResponse_Commitments;
    /**
     * The transaction id of the closing transaction
     *
     * @generated from protobuf field: string closing_txid = 4;
     */
    closingTxid: string;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.Commitments
 */
export interface PendingChannelsResponse_Commitments {
    /**
     * Hash of the local version of the commitment tx.
     *
     * @generated from protobuf field: string local_txid = 1;
     */
    localTxid: string;
    /**
     * Hash of the remote version of the commitment tx.
     *
     * @generated from protobuf field: string remote_txid = 2;
     */
    remoteTxid: string;
    /**
     * Hash of the remote pending version of the commitment tx.
     *
     * @generated from protobuf field: string remote_pending_txid = 3;
     */
    remotePendingTxid: string;
    /**
     *
     * The amount in satoshis calculated to be paid in fees for the local
     * commitment.
     *
     * @generated from protobuf field: uint64 local_commit_fee_sat = 4;
     */
    localCommitFeeSat: bigint;
    /**
     *
     * The amount in satoshis calculated to be paid in fees for the remote
     * commitment.
     *
     * @generated from protobuf field: uint64 remote_commit_fee_sat = 5;
     */
    remoteCommitFeeSat: bigint;
    /**
     *
     * The amount in satoshis calculated to be paid in fees for the remote
     * pending commitment.
     *
     * @generated from protobuf field: uint64 remote_pending_commit_fee_sat = 6;
     */
    remotePendingCommitFeeSat: bigint;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.ClosedChannel
 */
export interface PendingChannelsResponse_ClosedChannel {
    /**
     * The pending channel to be closed
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     * The transaction id of the closing transaction
     *
     * @generated from protobuf field: string closing_txid = 2;
     */
    closingTxid: string;
}
/**
 * @generated from protobuf message lnrpc.PendingChannelsResponse.ForceClosedChannel
 */
export interface PendingChannelsResponse_ForceClosedChannel {
    /**
     * The pending channel to be force closed
     *
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
     */
    channel?: PendingChannelsResponse_PendingChannel;
    /**
     * The transaction id of the closing transaction
     *
     * @generated from protobuf field: string closing_txid = 2;
     */
    closingTxid: string;
    /**
     * The balance in satoshis encumbered in this pending channel
     *
     * @generated from protobuf field: int64 limbo_balance = 3;
     */
    limboBalance: bigint;
    /**
     * The height at which funds can be swept into the wallet
     *
     * @generated from protobuf field: uint32 maturity_height = 4;
     */
    maturityHeight: number;
    /**
     *
     * Remaining # of blocks until the commitment output can be swept.
     * Negative values indicate how many blocks have passed since becoming
     * mature.
     *
     * @generated from protobuf field: int32 blocks_til_maturity = 5;
     */
    blocksTilMaturity: number;
    /**
     * The total value of funds successfully recovered from this channel
     *
     * @generated from protobuf field: int64 recovered_balance = 6;
     */
    recoveredBalance: bigint;
    /**
     * @generated from protobuf field: repeated lnrpc.PendingHTLC pending_htlcs = 8;
     */
    pendingHtlcs: PendingHTLC[];
    /**
     * @generated from protobuf field: lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;
     */
    anchor: PendingChannelsResponse_ForceClosedChannel_AnchorState;
}
/**
 *
 * There are three resolution states for the anchor:
 * limbo, lost and recovered. Derive the current state
 * from the limbo and recovered balances.
 *
 * @generated from protobuf enum lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState
 */
export enum PendingChannelsResponse_ForceClosedChannel_AnchorState {
    /**
     * The recovered_balance is zero and limbo_balance is non-zero.
     *
     * @generated from protobuf enum value: LIMBO = 0;
     */
    LIMBO = 0,
    /**
     * The recovered_balance is non-zero.
     *
     * @generated from protobuf enum value: RECOVERED = 1;
     */
    RECOVERED = 1,
    /**
     * A state that is neither LIMBO nor RECOVERED.
     *
     * @generated from protobuf enum value: LOST = 2;
     */
    LOST = 2
}
/**
 * @generated from protobuf message lnrpc.ChannelEventSubscription
 */
export interface ChannelEventSubscription {
}
/**
 * @generated from protobuf message lnrpc.ChannelEventUpdate
 */
export interface ChannelEventUpdate {
    /**
     * @generated from protobuf oneof: channel
     */
    channel: {
        oneofKind: "openChannel";
        /**
         * @generated from protobuf field: lnrpc.Channel open_channel = 1;
         */
        openChannel: Channel;
    } | {
        oneofKind: "closedChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelCloseSummary closed_channel = 2;
         */
        closedChannel: ChannelCloseSummary;
    } | {
        oneofKind: "activeChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelPoint active_channel = 3;
         */
        activeChannel: ChannelPoint;
    } | {
        oneofKind: "inactiveChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelPoint inactive_channel = 4;
         */
        inactiveChannel: ChannelPoint;
    } | {
        oneofKind: "pendingOpenChannel";
        /**
         * @generated from protobuf field: lnrpc.PendingUpdate pending_open_channel = 6;
         */
        pendingOpenChannel: PendingUpdate;
    } | {
        oneofKind: "fullyResolvedChannel";
        /**
         * @generated from protobuf field: lnrpc.ChannelPoint fully_resolved_channel = 7;
         */
        fullyResolvedChannel: ChannelPoint;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: lnrpc.ChannelEventUpdate.UpdateType type = 5;
     */
    type: ChannelEventUpdate_UpdateType;
}
/**
 * @generated from protobuf enum lnrpc.ChannelEventUpdate.UpdateType
 */
export enum ChannelEventUpdate_UpdateType {
    /**
     * @generated from protobuf enum value: OPEN_CHANNEL = 0;
     */
    OPEN_CHANNEL = 0,
    /**
     * @generated from protobuf enum value: CLOSED_CHANNEL = 1;
     */
    CLOSED_CHANNEL = 1,
    /**
     * @generated from protobuf enum value: ACTIVE_CHANNEL = 2;
     */
    ACTIVE_CHANNEL = 2,
    /**
     * @generated from protobuf enum value: INACTIVE_CHANNEL = 3;
     */
    INACTIVE_CHANNEL = 3,
    /**
     * @generated from protobuf enum value: PENDING_OPEN_CHANNEL = 4;
     */
    PENDING_OPEN_CHANNEL = 4,
    /**
     * @generated from protobuf enum value: FULLY_RESOLVED_CHANNEL = 5;
     */
    FULLY_RESOLVED_CHANNEL = 5
}
/**
 * @generated from protobuf message lnrpc.WalletAccountBalance
 */
export interface WalletAccountBalance {
    /**
     * The confirmed balance of the account (with >= 1 confirmations).
     *
     * @generated from protobuf field: int64 confirmed_balance = 1;
     */
    confirmedBalance: bigint;
    /**
     * The unconfirmed balance of the account (with 0 confirmations).
     *
     * @generated from protobuf field: int64 unconfirmed_balance = 2;
     */
    unconfirmedBalance: bigint;
}
/**
 * @generated from protobuf message lnrpc.WalletBalanceRequest
 */
export interface WalletBalanceRequest {
}
/**
 * @generated from protobuf message lnrpc.WalletBalanceResponse
 */
export interface WalletBalanceResponse {
    /**
     * The balance of the wallet
     *
     * @generated from protobuf field: int64 total_balance = 1;
     */
    totalBalance: bigint;
    /**
     * The confirmed balance of a wallet(with >= 1 confirmations)
     *
     * @generated from protobuf field: int64 confirmed_balance = 2;
     */
    confirmedBalance: bigint;
    /**
     * The unconfirmed balance of a wallet(with 0 confirmations)
     *
     * @generated from protobuf field: int64 unconfirmed_balance = 3;
     */
    unconfirmedBalance: bigint;
    /**
     * The total amount of wallet UTXOs held in outputs that are locked for
     * other usage.
     *
     * @generated from protobuf field: int64 locked_balance = 5;
     */
    lockedBalance: bigint;
    /**
     * The amount of reserve required.
     *
     * @generated from protobuf field: int64 reserved_balance_anchor_chan = 6;
     */
    reservedBalanceAnchorChan: bigint;
    /**
     * A mapping of each wallet account's name to its balance.
     *
     * @generated from protobuf field: map<string, lnrpc.WalletAccountBalance> account_balance = 4;
     */
    accountBalance: {
        [key: string]: WalletAccountBalance;
    };
}
/**
 * @generated from protobuf message lnrpc.Amount
 */
export interface Amount {
    /**
     * Value denominated in satoshis.
     *
     * @generated from protobuf field: uint64 sat = 1;
     */
    sat: bigint;
    /**
     * Value denominated in milli-satoshis.
     *
     * @generated from protobuf field: uint64 msat = 2;
     */
    msat: bigint;
}
/**
 * @generated from protobuf message lnrpc.ChannelBalanceRequest
 */
export interface ChannelBalanceRequest {
}
/**
 * @generated from protobuf message lnrpc.ChannelBalanceResponse
 */
export interface ChannelBalanceResponse {
    /**
     * Deprecated. Sum of channels balances denominated in satoshis
     *
     * @deprecated
     * @generated from protobuf field: int64 balance = 1 [deprecated = true];
     */
    balance: bigint;
    /**
     * Deprecated. Sum of channels pending balances denominated in satoshis
     *
     * @deprecated
     * @generated from protobuf field: int64 pending_open_balance = 2 [deprecated = true];
     */
    pendingOpenBalance: bigint;
    /**
     * Sum of channels local balances.
     *
     * @generated from protobuf field: lnrpc.Amount local_balance = 3;
     */
    localBalance?: Amount;
    /**
     * Sum of channels remote balances.
     *
     * @generated from protobuf field: lnrpc.Amount remote_balance = 4;
     */
    remoteBalance?: Amount;
    /**
     * Sum of channels local unsettled balances.
     *
     * @generated from protobuf field: lnrpc.Amount unsettled_local_balance = 5;
     */
    unsettledLocalBalance?: Amount;
    /**
     * Sum of channels remote unsettled balances.
     *
     * @generated from protobuf field: lnrpc.Amount unsettled_remote_balance = 6;
     */
    unsettledRemoteBalance?: Amount;
    /**
     * Sum of channels pending local balances.
     *
     * @generated from protobuf field: lnrpc.Amount pending_open_local_balance = 7;
     */
    pendingOpenLocalBalance?: Amount;
    /**
     * Sum of channels pending remote balances.
     *
     * @generated from protobuf field: lnrpc.Amount pending_open_remote_balance = 8;
     */
    pendingOpenRemoteBalance?: Amount;
}
/**
 * @generated from protobuf message lnrpc.QueryRoutesRequest
 */
export interface QueryRoutesRequest {
    /**
     * The 33-byte hex-encoded public key for the payment destination
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     *
     * The amount to send expressed in satoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt = 2;
     */
    amt: bigint;
    /**
     *
     * The amount to send expressed in millisatoshis.
     *
     * The fields amt and amt_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 amt_msat = 12;
     */
    amtMsat: bigint;
    /**
     *
     * An optional CLTV delta from the current height that should be used for the
     * timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
     * not add any additional block padding on top of final_ctlv_delta. This
     * padding of a few blocks needs to be added manually or otherwise failures may
     * happen when a block comes in while the payment is in flight.
     *
     * @generated from protobuf field: int32 final_cltv_delta = 4;
     */
    finalCltvDelta: number;
    /**
     *
     * The maximum number of satoshis that will be paid as a fee of the payment.
     * This value can be represented either as a percentage of the amount being
     * sent, or as a fixed amount of the maximum fee the user is willing the pay to
     * send the payment. If not specified, lnd will use a default value of 100%
     * fees for small amounts (<=1k sat) or 5% fees for larger amounts.
     *
     * @generated from protobuf field: lnrpc.FeeLimit fee_limit = 5;
     */
    feeLimit?: FeeLimit;
    /**
     *
     * A list of nodes to ignore during path finding. When using REST, these fields
     * must be encoded as base64.
     *
     * @generated from protobuf field: repeated bytes ignored_nodes = 6;
     */
    ignoredNodes: Uint8Array[];
    /**
     *
     * Deprecated. A list of edges to ignore during path finding.
     *
     * @deprecated
     * @generated from protobuf field: repeated lnrpc.EdgeLocator ignored_edges = 7 [deprecated = true];
     */
    ignoredEdges: EdgeLocator[];
    /**
     *
     * The source node where the request route should originated from. If empty,
     * self is assumed.
     *
     * @generated from protobuf field: string source_pub_key = 8;
     */
    sourcePubKey: string;
    /**
     *
     * If set to true, edge probabilities from mission control will be used to get
     * the optimal route.
     *
     * @generated from protobuf field: bool use_mission_control = 9;
     */
    useMissionControl: boolean;
    /**
     *
     * A list of directed node pairs that will be ignored during path finding.
     *
     * @generated from protobuf field: repeated lnrpc.NodePair ignored_pairs = 10;
     */
    ignoredPairs: NodePair[];
    /**
     *
     * An optional maximum total time lock for the route. If the source is empty or
     * ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
     * zero, then the value of `--max-cltv-expiry` is used as the limit.
     *
     * @generated from protobuf field: uint32 cltv_limit = 11;
     */
    cltvLimit: number;
    /**
     *
     * An optional field that can be used to pass an arbitrary set of TLV records
     * to a peer which understands the new records. This can be used to pass
     * application specific data during the payment attempt. If the destination
     * does not support the specified records, an error will be returned.
     * Record types are required to be in the custom range >= 65536. When using
     * REST, the values must be encoded as base64.
     *
     * @generated from protobuf field: map<uint64, bytes> dest_custom_records = 13;
     */
    destCustomRecords: {
        [key: string]: Uint8Array;
    };
    /**
     *
     * The channel id of the channel that must be taken to the first hop. If zero,
     * any channel may be used.
     *
     * @generated from protobuf field: uint64 outgoing_chan_id = 14 [jstype = JS_STRING];
     */
    outgoingChanId: string;
    /**
     *
     * The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @generated from protobuf field: bytes last_hop_pubkey = 15;
     */
    lastHopPubkey: Uint8Array;
    /**
     *
     * Optional route hints to reach the destination through private channels.
     *
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 16;
     */
    routeHints: RouteHint[];
    /**
     *
     * Features assumed to be supported by the final node. All transitive feature
     * dependencies must also be set properly. For a given feature bit pair, either
     * optional or remote may be set, but not both. If this field is nil or empty,
     * the router will try to load destination features from the graph as a
     * fallback.
     *
     * @generated from protobuf field: repeated lnrpc.FeatureBit dest_features = 17;
     */
    destFeatures: FeatureBit[];
    /**
     *
     * The time preference for this payment. Set to -1 to optimize for fees
     * only, to 1 to optimize for reliability only or a value inbetween for a mix.
     *
     * @generated from protobuf field: double time_pref = 18;
     */
    timePref: number;
}
/**
 * @generated from protobuf message lnrpc.NodePair
 */
export interface NodePair {
    /**
     *
     * The sending node of the pair. When using REST, this field must be encoded as
     * base64.
     *
     * @generated from protobuf field: bytes from = 1;
     */
    from: Uint8Array;
    /**
     *
     * The receiving node of the pair. When using REST, this field must be encoded
     * as base64.
     *
     * @generated from protobuf field: bytes to = 2;
     */
    to: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.EdgeLocator
 */
export interface EdgeLocator {
    /**
     * The short channel id of this edge.
     *
     * @generated from protobuf field: uint64 channel_id = 1 [jstype = JS_STRING];
     */
    channelId: string;
    /**
     *
     * The direction of this edge. If direction_reverse is false, the direction
     * of this edge is from the channel endpoint with the lexicographically smaller
     * pub key to the endpoint with the larger pub key. If direction_reverse is
     * is true, the edge goes the other way.
     *
     * @generated from protobuf field: bool direction_reverse = 2;
     */
    directionReverse: boolean;
}
/**
 * @generated from protobuf message lnrpc.QueryRoutesResponse
 */
export interface QueryRoutesResponse {
    /**
     *
     * The route that results from the path finding operation. This is still a
     * repeated field to retain backwards compatibility.
     *
     * @generated from protobuf field: repeated lnrpc.Route routes = 1;
     */
    routes: Route[];
    /**
     *
     * The success probability of the returned route based on the current mission
     * control state. [EXPERIMENTAL]
     *
     * @generated from protobuf field: double success_prob = 2;
     */
    successProb: number;
}
/**
 * @generated from protobuf message lnrpc.Hop
 */
export interface Hop {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * @deprecated
     * @generated from protobuf field: int64 chan_capacity = 2 [deprecated = true];
     */
    chanCapacity: bigint;
    /**
     * @deprecated
     * @generated from protobuf field: int64 amt_to_forward = 3 [deprecated = true];
     */
    amtToForward: bigint;
    /**
     * @deprecated
     * @generated from protobuf field: int64 fee = 4 [deprecated = true];
     */
    fee: bigint;
    /**
     * @generated from protobuf field: uint32 expiry = 5;
     */
    expiry: number;
    /**
     * @generated from protobuf field: int64 amt_to_forward_msat = 6;
     */
    amtToForwardMsat: bigint;
    /**
     * @generated from protobuf field: int64 fee_msat = 7;
     */
    feeMsat: bigint;
    /**
     *
     * An optional public key of the hop. If the public key is given, the payment
     * can be executed without relying on a copy of the channel graph.
     *
     * @generated from protobuf field: string pub_key = 8;
     */
    pubKey: string;
    /**
     *
     * If set to true, then this hop will be encoded using the new variable length
     * TLV format. Note that if any custom tlv_records below are specified, then
     * this field MUST be set to true for them to be encoded properly.
     *
     * @deprecated
     * @generated from protobuf field: bool tlv_payload = 9 [deprecated = true];
     */
    tlvPayload: boolean;
    /**
     *
     * An optional TLV record that signals the use of an MPP payment. If present,
     * the receiver will enforce that the same mpp_record is included in the final
     * hop payload of all non-zero payments in the HTLC set. If empty, a regular
     * single-shot payment is or was attempted.
     *
     * @generated from protobuf field: lnrpc.MPPRecord mpp_record = 10;
     */
    mppRecord?: MPPRecord;
    /**
     *
     * An optional TLV record that signals the use of an AMP payment. If present,
     * the receiver will treat all received payments including the same
     * (payment_addr, set_id) pair  as being part of one logical payment. The
     * payment will be settled by XORing the root_share's together and deriving the
     * child hashes and preimages according to BOLT XX. Must be used in conjunction
     * with mpp_record.
     *
     * @generated from protobuf field: lnrpc.AMPRecord amp_record = 12;
     */
    ampRecord?: AMPRecord;
    /**
     *
     * An optional set of key-value TLV records. This is useful within the context
     * of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     * to drop off at each hop within the onion.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 11;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * The payment metadata to send along with the payment to the payee.
     *
     * @generated from protobuf field: bytes metadata = 13;
     */
    metadata: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.MPPRecord
 */
export interface MPPRecord {
    /**
     *
     * A unique, random identifier used to authenticate the sender as the intended
     * payer of a multi-path payment. The payment_addr must be the same for all
     * subpayments, and match the payment_addr provided in the receiver's invoice.
     * The same payment_addr must be used on all subpayments.
     *
     * @generated from protobuf field: bytes payment_addr = 11;
     */
    paymentAddr: Uint8Array;
    /**
     *
     * The total amount in milli-satoshis being sent as part of a larger multi-path
     * payment. The caller is responsible for ensuring subpayments to the same node
     * and payment_hash sum exactly to total_amt_msat. The same
     * total_amt_msat must be used on all subpayments.
     *
     * @generated from protobuf field: int64 total_amt_msat = 10;
     */
    totalAmtMsat: bigint;
}
/**
 * @generated from protobuf message lnrpc.AMPRecord
 */
export interface AMPRecord {
    /**
     * @generated from protobuf field: bytes root_share = 1;
     */
    rootShare: Uint8Array;
    /**
     * @generated from protobuf field: bytes set_id = 2;
     */
    setId: Uint8Array;
    /**
     * @generated from protobuf field: uint32 child_index = 3;
     */
    childIndex: number;
}
/**
 *
 * A path through the channel graph which runs over one or more channels in
 * succession. This struct carries all the information required to craft the
 * Sphinx onion packet, and send the payment along the first hop in the path. A
 * route is only selected as valid if all the channels have sufficient capacity to
 * carry the initial payment amount after fees are accounted for.
 *
 * @generated from protobuf message lnrpc.Route
 */
export interface Route {
    /**
     *
     * The cumulative (final) time lock across the entire route. This is the CLTV
     * value that should be extended to the first hop in the route. All other hops
     * will decrement the time-lock as advertised, leaving enough time for all
     * hops to wait for or present the payment preimage to complete the payment.
     *
     * @generated from protobuf field: uint32 total_time_lock = 1;
     */
    totalTimeLock: number;
    /**
     *
     * The sum of the fees paid at each hop within the final route. In the case
     * of a one-hop payment, this value will be zero as we don't need to pay a fee
     * to ourselves.
     *
     * @deprecated
     * @generated from protobuf field: int64 total_fees = 2 [deprecated = true];
     */
    totalFees: bigint;
    /**
     *
     * The total amount of funds required to complete a payment over this route.
     * This value includes the cumulative fees at each hop. As a result, the HTLC
     * extended to the first-hop in the route will need to have at least this many
     * satoshis, otherwise the route will fail at an intermediate node due to an
     * insufficient amount of fees.
     *
     * @deprecated
     * @generated from protobuf field: int64 total_amt = 3 [deprecated = true];
     */
    totalAmt: bigint;
    /**
     *
     * Contains details concerning the specific forwarding details at each hop.
     *
     * @generated from protobuf field: repeated lnrpc.Hop hops = 4;
     */
    hops: Hop[];
    /**
     *
     * The total fees in millisatoshis.
     *
     * @generated from protobuf field: int64 total_fees_msat = 5;
     */
    totalFeesMsat: bigint;
    /**
     *
     * The total amount in millisatoshis.
     *
     * @generated from protobuf field: int64 total_amt_msat = 6;
     */
    totalAmtMsat: bigint;
}
/**
 * @generated from protobuf message lnrpc.NodeInfoRequest
 */
export interface NodeInfoRequest {
    /**
     * The 33-byte hex-encoded compressed public of the target node
     *
     * @generated from protobuf field: string pub_key = 1;
     */
    pubKey: string;
    /**
     * If true, will include all known channels associated with the node.
     *
     * @generated from protobuf field: bool include_channels = 2;
     */
    includeChannels: boolean;
}
/**
 * @generated from protobuf message lnrpc.NodeInfo
 */
export interface NodeInfo {
    /**
     *
     * An individual vertex/node within the channel graph. A node is
     * connected to other nodes by one or more channel edges emanating from it. As
     * the graph is directed, a node will also have an incoming edge attached to
     * it for each outgoing edge.
     *
     * @generated from protobuf field: lnrpc.LightningNode node = 1;
     */
    node?: LightningNode;
    /**
     * The total number of channels for the node.
     *
     * @generated from protobuf field: uint32 num_channels = 2;
     */
    numChannels: number;
    /**
     * The sum of all channels capacity for the node, denominated in satoshis.
     *
     * @generated from protobuf field: int64 total_capacity = 3;
     */
    totalCapacity: bigint;
    /**
     * A list of all public channels for the node.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelEdge channels = 4;
     */
    channels: ChannelEdge[];
}
/**
 *
 * An individual vertex/node within the channel graph. A node is
 * connected to other nodes by one or more channel edges emanating from it. As the
 * graph is directed, a node will also have an incoming edge attached to it for
 * each outgoing edge.
 *
 * @generated from protobuf message lnrpc.LightningNode
 */
export interface LightningNode {
    /**
     * @generated from protobuf field: uint32 last_update = 1;
     */
    lastUpdate: number;
    /**
     * @generated from protobuf field: string pub_key = 2;
     */
    pubKey: string;
    /**
     * @generated from protobuf field: string alias = 3;
     */
    alias: string;
    /**
     * @generated from protobuf field: repeated lnrpc.NodeAddress addresses = 4;
     */
    addresses: NodeAddress[];
    /**
     * @generated from protobuf field: string color = 5;
     */
    color: string;
    /**
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 6;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     * Custom node announcement tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 7;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
}
/**
 * @generated from protobuf message lnrpc.NodeAddress
 */
export interface NodeAddress {
    /**
     * @generated from protobuf field: string network = 1;
     */
    network: string;
    /**
     * @generated from protobuf field: string addr = 2;
     */
    addr: string;
}
/**
 * @generated from protobuf message lnrpc.RoutingPolicy
 */
export interface RoutingPolicy {
    /**
     * @generated from protobuf field: uint32 time_lock_delta = 1;
     */
    timeLockDelta: number;
    /**
     * @generated from protobuf field: int64 min_htlc = 2;
     */
    minHtlc: bigint;
    /**
     * @generated from protobuf field: int64 fee_base_msat = 3;
     */
    feeBaseMsat: bigint;
    /**
     * @generated from protobuf field: int64 fee_rate_milli_msat = 4;
     */
    feeRateMilliMsat: bigint;
    /**
     * @generated from protobuf field: bool disabled = 5;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: uint64 max_htlc_msat = 6;
     */
    maxHtlcMsat: bigint;
    /**
     * @generated from protobuf field: uint32 last_update = 7;
     */
    lastUpdate: number;
    /**
     * Custom channel update tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 8;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
}
/**
 *
 * A fully authenticated channel along with all its unique attributes.
 * Once an authenticated channel announcement has been processed on the network,
 * then an instance of ChannelEdgeInfo encapsulating the channels attributes is
 * stored. The other portions relevant to routing policy of a channel are stored
 * within a ChannelEdgePolicy for each direction of the channel.
 *
 * @generated from protobuf message lnrpc.ChannelEdge
 */
export interface ChannelEdge {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 channel_id = 1 [jstype = JS_STRING];
     */
    channelId: string;
    /**
     * @generated from protobuf field: string chan_point = 2;
     */
    chanPoint: string;
    /**
     * @deprecated
     * @generated from protobuf field: uint32 last_update = 3 [deprecated = true];
     */
    lastUpdate: number;
    /**
     * @generated from protobuf field: string node1_pub = 4;
     */
    node1Pub: string;
    /**
     * @generated from protobuf field: string node2_pub = 5;
     */
    node2Pub: string;
    /**
     * @generated from protobuf field: int64 capacity = 6;
     */
    capacity: bigint;
    /**
     * @generated from protobuf field: lnrpc.RoutingPolicy node1_policy = 7;
     */
    node1Policy?: RoutingPolicy;
    /**
     * @generated from protobuf field: lnrpc.RoutingPolicy node2_policy = 8;
     */
    node2Policy?: RoutingPolicy;
    /**
     * Custom channel announcement tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 9;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
}
/**
 * @generated from protobuf message lnrpc.ChannelGraphRequest
 */
export interface ChannelGraphRequest {
    /**
     *
     * Whether unannounced channels are included in the response or not. If set,
     * unannounced channels are included. Unannounced channels are both private
     * channels, and public channels that are not yet announced to the network.
     *
     * @generated from protobuf field: bool include_unannounced = 1;
     */
    includeUnannounced: boolean;
}
/**
 * Returns a new instance of the directed channel graph.
 *
 * @generated from protobuf message lnrpc.ChannelGraph
 */
export interface ChannelGraph {
    /**
     * The list of `LightningNode`s in this channel graph
     *
     * @generated from protobuf field: repeated lnrpc.LightningNode nodes = 1;
     */
    nodes: LightningNode[];
    /**
     * The list of `ChannelEdge`s in this channel graph
     *
     * @generated from protobuf field: repeated lnrpc.ChannelEdge edges = 2;
     */
    edges: ChannelEdge[];
}
/**
 * @generated from protobuf message lnrpc.NodeMetricsRequest
 */
export interface NodeMetricsRequest {
    /**
     * The requested node metrics.
     *
     * @generated from protobuf field: repeated lnrpc.NodeMetricType types = 1;
     */
    types: NodeMetricType[];
}
/**
 * @generated from protobuf message lnrpc.NodeMetricsResponse
 */
export interface NodeMetricsResponse {
    /**
     *
     * Betweenness centrality is the sum of the ratio of shortest paths that pass
     * through the node for each pair of nodes in the graph (not counting paths
     * starting or ending at this node).
     * Map of node pubkey to betweenness centrality of the node. Normalized
     * values are in the [0,1] closed interval.
     *
     * @generated from protobuf field: map<string, lnrpc.FloatMetric> betweenness_centrality = 1;
     */
    betweennessCentrality: {
        [key: string]: FloatMetric;
    };
}
/**
 * @generated from protobuf message lnrpc.FloatMetric
 */
export interface FloatMetric {
    /**
     * Arbitrary float value.
     *
     * @generated from protobuf field: double value = 1;
     */
    value: number;
    /**
     * The value normalized to [0,1] or [-1,1].
     *
     * @generated from protobuf field: double normalized_value = 2;
     */
    normalizedValue: number;
}
/**
 * @generated from protobuf message lnrpc.ChanInfoRequest
 */
export interface ChanInfoRequest {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
}
/**
 * @generated from protobuf message lnrpc.NetworkInfoRequest
 */
export interface NetworkInfoRequest {
}
/**
 * @generated from protobuf message lnrpc.NetworkInfo
 */
export interface NetworkInfo {
    /**
     * @generated from protobuf field: uint32 graph_diameter = 1;
     */
    graphDiameter: number;
    /**
     * @generated from protobuf field: double avg_out_degree = 2;
     */
    avgOutDegree: number;
    /**
     * @generated from protobuf field: uint32 max_out_degree = 3;
     */
    maxOutDegree: number;
    /**
     * @generated from protobuf field: uint32 num_nodes = 4;
     */
    numNodes: number;
    /**
     * @generated from protobuf field: uint32 num_channels = 5;
     */
    numChannels: number;
    /**
     * @generated from protobuf field: int64 total_network_capacity = 6;
     */
    totalNetworkCapacity: bigint;
    /**
     * @generated from protobuf field: double avg_channel_size = 7;
     */
    avgChannelSize: number;
    /**
     * @generated from protobuf field: int64 min_channel_size = 8;
     */
    minChannelSize: bigint;
    /**
     * @generated from protobuf field: int64 max_channel_size = 9;
     */
    maxChannelSize: bigint;
    /**
     * @generated from protobuf field: int64 median_channel_size_sat = 10;
     */
    medianChannelSizeSat: bigint;
    /**
     * The number of edges marked as zombies.
     *
     * @generated from protobuf field: uint64 num_zombie_chans = 11;
     */
    numZombieChans: bigint;
}
/**
 * @generated from protobuf message lnrpc.StopRequest
 */
export interface StopRequest {
}
/**
 * @generated from protobuf message lnrpc.StopResponse
 */
export interface StopResponse {
}
/**
 * @generated from protobuf message lnrpc.GraphTopologySubscription
 */
export interface GraphTopologySubscription {
}
/**
 * @generated from protobuf message lnrpc.GraphTopologyUpdate
 */
export interface GraphTopologyUpdate {
    /**
     * @generated from protobuf field: repeated lnrpc.NodeUpdate node_updates = 1;
     */
    nodeUpdates: NodeUpdate[];
    /**
     * @generated from protobuf field: repeated lnrpc.ChannelEdgeUpdate channel_updates = 2;
     */
    channelUpdates: ChannelEdgeUpdate[];
    /**
     * @generated from protobuf field: repeated lnrpc.ClosedChannelUpdate closed_chans = 3;
     */
    closedChans: ClosedChannelUpdate[];
}
/**
 * @generated from protobuf message lnrpc.NodeUpdate
 */
export interface NodeUpdate {
    /**
     *
     * Deprecated, use node_addresses.
     *
     * @deprecated
     * @generated from protobuf field: repeated string addresses = 1 [deprecated = true];
     */
    addresses: string[];
    /**
     * @generated from protobuf field: string identity_key = 2;
     */
    identityKey: string;
    /**
     *
     * Deprecated, use features.
     *
     * @deprecated
     * @generated from protobuf field: bytes global_features = 3 [deprecated = true];
     */
    globalFeatures: Uint8Array;
    /**
     * @generated from protobuf field: string alias = 4;
     */
    alias: string;
    /**
     * @generated from protobuf field: string color = 5;
     */
    color: string;
    /**
     * @generated from protobuf field: repeated lnrpc.NodeAddress node_addresses = 7;
     */
    nodeAddresses: NodeAddress[];
    /**
     *
     * Features that the node has advertised in the init message, node
     * announcements and invoices.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 6;
     */
    features: {
        [key: number]: Feature;
    };
}
/**
 * @generated from protobuf message lnrpc.ChannelEdgeUpdate
 */
export interface ChannelEdgeUpdate {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 2;
     */
    chanPoint?: ChannelPoint;
    /**
     * @generated from protobuf field: int64 capacity = 3;
     */
    capacity: bigint;
    /**
     * @generated from protobuf field: lnrpc.RoutingPolicy routing_policy = 4;
     */
    routingPolicy?: RoutingPolicy;
    /**
     * @generated from protobuf field: string advertising_node = 5;
     */
    advertisingNode: string;
    /**
     * @generated from protobuf field: string connecting_node = 6;
     */
    connectingNode: string;
}
/**
 * @generated from protobuf message lnrpc.ClosedChannelUpdate
 */
export interface ClosedChannelUpdate {
    /**
     *
     * The unique channel ID for the channel. The first 3 bytes are the block
     * height, the next 3 the index within the block, and the last 2 bytes are the
     * output index for the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * @generated from protobuf field: int64 capacity = 2;
     */
    capacity: bigint;
    /**
     * @generated from protobuf field: uint32 closed_height = 3;
     */
    closedHeight: number;
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 4;
     */
    chanPoint?: ChannelPoint;
}
/**
 * @generated from protobuf message lnrpc.HopHint
 */
export interface HopHint {
    /**
     * The public key of the node at the start of the channel.
     *
     * @generated from protobuf field: string node_id = 1;
     */
    nodeId: string;
    /**
     * The unique identifier of the channel.
     *
     * @generated from protobuf field: uint64 chan_id = 2 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The base fee of the channel denominated in millisatoshis.
     *
     * @generated from protobuf field: uint32 fee_base_msat = 3;
     */
    feeBaseMsat: number;
    /**
     *
     * The fee rate of the channel for sending one satoshi across it denominated in
     * millionths of a satoshi.
     *
     * @generated from protobuf field: uint32 fee_proportional_millionths = 4;
     */
    feeProportionalMillionths: number;
    /**
     * The time-lock delta of the channel.
     *
     * @generated from protobuf field: uint32 cltv_expiry_delta = 5;
     */
    cltvExpiryDelta: number;
}
/**
 * @generated from protobuf message lnrpc.SetID
 */
export interface SetID {
    /**
     * @generated from protobuf field: bytes set_id = 1;
     */
    setId: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.RouteHint
 */
export interface RouteHint {
    /**
     *
     * A list of hop hints that when chained together can assist in reaching a
     * specific destination.
     *
     * @generated from protobuf field: repeated lnrpc.HopHint hop_hints = 1;
     */
    hopHints: HopHint[];
}
/**
 * @generated from protobuf message lnrpc.AMPInvoiceState
 */
export interface AMPInvoiceState {
    /**
     * The state the HTLCs associated with this setID are in.
     *
     * @generated from protobuf field: lnrpc.InvoiceHTLCState state = 1;
     */
    state: InvoiceHTLCState;
    /**
     * The settle index of this HTLC set, if the invoice state is settled.
     *
     * @generated from protobuf field: uint64 settle_index = 2;
     */
    settleIndex: bigint;
    /**
     * The time this HTLC set was settled expressed in unix epoch.
     *
     * @generated from protobuf field: int64 settle_time = 3;
     */
    settleTime: bigint;
    /**
     * The total amount paid for the sub-invoice expressed in milli satoshis.
     *
     * @generated from protobuf field: int64 amt_paid_msat = 5;
     */
    amtPaidMsat: bigint;
}
/**
 * @generated from protobuf message lnrpc.Invoice
 */
export interface Invoice {
    /**
     *
     * An optional memo to attach along with the invoice. Used for record keeping
     * purposes for the invoice's creator, and will also be set in the description
     * field of the encoded payment request if the description_hash field is not
     * being used.
     *
     * @generated from protobuf field: string memo = 1;
     */
    memo: string;
    /**
     *
     * The hex-encoded preimage (32 byte) which will allow settling an incoming
     * HTLC payable to this preimage. When using REST, this field must be encoded
     * as base64.
     *
     * @generated from protobuf field: bytes r_preimage = 3;
     */
    rPreimage: Uint8Array;
    /**
     *
     * The hash of the preimage. When using REST, this field must be encoded as
     * base64.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: bytes r_hash = 4;
     */
    rHash: Uint8Array;
    /**
     *
     * The value of this invoice in satoshis
     *
     * The fields value and value_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 value = 5;
     */
    value: bigint;
    /**
     *
     * The value of this invoice in millisatoshis
     *
     * The fields value and value_msat are mutually exclusive.
     *
     * @generated from protobuf field: int64 value_msat = 23;
     */
    valueMsat: bigint;
    /**
     *
     * Whether this invoice has been fulfilled
     *
     * The field is deprecated. Use the state field instead (compare to SETTLED).
     *
     * @deprecated
     * @generated from protobuf field: bool settled = 6 [deprecated = true];
     */
    settled: boolean;
    /**
     *
     * When this invoice was created.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 creation_date = 7;
     */
    creationDate: bigint;
    /**
     *
     * When this invoice was settled.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 settle_date = 8;
     */
    settleDate: bigint;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network. With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: string payment_request = 9;
     */
    paymentRequest: string;
    /**
     *
     * Hash (SHA-256) of a description of the payment. Used if the description of
     * payment (memo) is too long to naturally fit within the description field
     * of an encoded payment request. When using REST, this field must be encoded
     * as base64.
     *
     * @generated from protobuf field: bytes description_hash = 10;
     */
    descriptionHash: Uint8Array;
    /**
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     *
     * @generated from protobuf field: int64 expiry = 11;
     */
    expiry: bigint;
    /**
     * Fallback on-chain address.
     *
     * @generated from protobuf field: string fallback_addr = 12;
     */
    fallbackAddr: string;
    /**
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     *
     * @generated from protobuf field: uint64 cltv_expiry = 13;
     */
    cltvExpiry: bigint;
    /**
     *
     * Route hints that can each be individually used to assist in reaching the
     * invoice's destination.
     *
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 14;
     */
    routeHints: RouteHint[];
    /**
     * Whether this invoice should include routing hints for private channels.
     *
     * @generated from protobuf field: bool private = 15;
     */
    private: boolean;
    /**
     *
     * The "add" index of this invoice. Each newly created invoice will increment
     * this index making it monotonically increasing. Callers to the
     * SubscribeInvoices call can use this to instantly get notified of all added
     * invoices with an add_index greater than this one.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: uint64 add_index = 16;
     */
    addIndex: bigint;
    /**
     *
     * The "settle" index of this invoice. Each newly settled invoice will
     * increment this index making it monotonically increasing. Callers to the
     * SubscribeInvoices call can use this to instantly get notified of all
     * settled invoices with an settle_index greater than this one.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: uint64 settle_index = 17;
     */
    settleIndex: bigint;
    /**
     * Deprecated, use amt_paid_sat or amt_paid_msat.
     *
     * @deprecated
     * @generated from protobuf field: int64 amt_paid = 18 [deprecated = true];
     */
    amtPaid: bigint;
    /**
     *
     * The amount that was accepted for this invoice, in satoshis. This will ONLY
     * be set if this invoice has been settled. We provide this field as if the
     * invoice was created with a zero value, then we need to record what amount
     * was ultimately accepted. Additionally, it's possible that the sender paid
     * MORE that was specified in the original invoice. So we'll record that here
     * as well.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 amt_paid_sat = 19;
     */
    amtPaidSat: bigint;
    /**
     *
     * The amount that was accepted for this invoice, in millisatoshis. This will
     * ONLY be set if this invoice has been settled. We provide this field as if
     * the invoice was created with a zero value, then we need to record what
     * amount was ultimately accepted. Additionally, it's possible that the sender
     * paid MORE that was specified in the original invoice. So we'll record that
     * here as well.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: int64 amt_paid_msat = 20;
     */
    amtPaidMsat: bigint;
    /**
     *
     * The state the invoice is in.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: lnrpc.Invoice.InvoiceState state = 21;
     */
    state: Invoice_InvoiceState;
    /**
     *
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: repeated lnrpc.InvoiceHTLC htlcs = 22;
     */
    htlcs: InvoiceHTLC[];
    /**
     *
     * List of features advertised on the invoice.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 24;
     */
    features: {
        [key: number]: Feature;
    };
    /**
     *
     * Indicates if this invoice was a spontaneous payment that arrived via keysend
     * [EXPERIMENTAL].
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: bool is_keysend = 25;
     */
    isKeysend: boolean;
    /**
     *
     * The payment address of this invoice. This value will be used in MPP
     * payments, and also for newer invoices that always require the MPP payload
     * for added end-to-end security.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: bytes payment_addr = 26;
     */
    paymentAddr: Uint8Array;
    /**
     *
     * Signals whether or not this is an AMP invoice.
     *
     * @generated from protobuf field: bool is_amp = 27;
     */
    isAmp: boolean;
    /**
     *
     * [EXPERIMENTAL]:
     *
     * Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the
     * given set ID. This field is always populated for AMP invoices, and can be
     * used along side LookupInvoice to obtain the HTLC information related to a
     * given sub-invoice.
     * Note: Output only, don't specify for creating an invoice.
     *
     * @generated from protobuf field: map<string, lnrpc.AMPInvoiceState> amp_invoice_state = 28;
     */
    ampInvoiceState: {
        [key: string]: AMPInvoiceState;
    };
}
/**
 * @generated from protobuf enum lnrpc.Invoice.InvoiceState
 */
export enum Invoice_InvoiceState {
    /**
     * @generated from protobuf enum value: OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: SETTLED = 1;
     */
    SETTLED = 1,
    /**
     * @generated from protobuf enum value: CANCELED = 2;
     */
    CANCELED = 2,
    /**
     * @generated from protobuf enum value: ACCEPTED = 3;
     */
    ACCEPTED = 3
}
/**
 * Details of an HTLC that paid to an invoice
 *
 * @generated from protobuf message lnrpc.InvoiceHTLC
 */
export interface InvoiceHTLC {
    /**
     * Short channel id over which the htlc was received.
     *
     * @generated from protobuf field: uint64 chan_id = 1 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * Index identifying the htlc on the channel.
     *
     * @generated from protobuf field: uint64 htlc_index = 2;
     */
    htlcIndex: bigint;
    /**
     * The amount of the htlc in msat.
     *
     * @generated from protobuf field: uint64 amt_msat = 3;
     */
    amtMsat: bigint;
    /**
     * Block height at which this htlc was accepted.
     *
     * @generated from protobuf field: int32 accept_height = 4;
     */
    acceptHeight: number;
    /**
     * Time at which this htlc was accepted.
     *
     * @generated from protobuf field: int64 accept_time = 5;
     */
    acceptTime: bigint;
    /**
     * Time at which this htlc was settled or canceled.
     *
     * @generated from protobuf field: int64 resolve_time = 6;
     */
    resolveTime: bigint;
    /**
     * Block height at which this htlc expires.
     *
     * @generated from protobuf field: int32 expiry_height = 7;
     */
    expiryHeight: number;
    /**
     * Current state the htlc is in.
     *
     * @generated from protobuf field: lnrpc.InvoiceHTLCState state = 8;
     */
    state: InvoiceHTLCState;
    /**
     * Custom tlv records.
     *
     * @generated from protobuf field: map<uint64, bytes> custom_records = 9;
     */
    customRecords: {
        [key: string]: Uint8Array;
    };
    /**
     * The total amount of the mpp payment in msat.
     *
     * @generated from protobuf field: uint64 mpp_total_amt_msat = 10;
     */
    mppTotalAmtMsat: bigint;
    /**
     * Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.
     *
     * @generated from protobuf field: lnrpc.AMP amp = 11;
     */
    amp?: AMP;
}
/**
 * Details specific to AMP HTLCs.
 *
 * @generated from protobuf message lnrpc.AMP
 */
export interface AMP {
    /**
     * An n-of-n secret share of the root seed from which child payment hashes
     * and preimages are derived.
     *
     * @generated from protobuf field: bytes root_share = 1;
     */
    rootShare: Uint8Array;
    /**
     * An identifier for the HTLC set that this HTLC belongs to.
     *
     * @generated from protobuf field: bytes set_id = 2;
     */
    setId: Uint8Array;
    /**
     * A nonce used to randomize the child preimage and child hash from a given
     * root_share.
     *
     * @generated from protobuf field: uint32 child_index = 3;
     */
    childIndex: number;
    /**
     * The payment hash of the AMP HTLC.
     *
     * @generated from protobuf field: bytes hash = 4;
     */
    hash: Uint8Array;
    /**
     * The preimage used to settle this AMP htlc. This field will only be
     * populated if the invoice is in InvoiceState_ACCEPTED or
     * InvoiceState_SETTLED.
     *
     * @generated from protobuf field: bytes preimage = 5;
     */
    preimage: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.AddInvoiceResponse
 */
export interface AddInvoiceResponse {
    /**
     * @generated from protobuf field: bytes r_hash = 1;
     */
    rHash: Uint8Array;
    /**
     *
     * A bare-bones invoice for a payment within the Lightning Network. With the
     * details of the invoice, the sender has all the data necessary to send a
     * payment to the recipient.
     *
     * @generated from protobuf field: string payment_request = 2;
     */
    paymentRequest: string;
    /**
     *
     * The "add" index of this invoice. Each newly created invoice will increment
     * this index making it monotonically increasing. Callers to the
     * SubscribeInvoices call can use this to instantly get notified of all added
     * invoices with an add_index greater than this one.
     *
     * @generated from protobuf field: uint64 add_index = 16;
     */
    addIndex: bigint;
    /**
     *
     * The payment address of the generated invoice. This value should be used
     * in all payments for this invoice as we require it for end to end
     * security.
     *
     * @generated from protobuf field: bytes payment_addr = 17;
     */
    paymentAddr: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.PaymentHash
 */
export interface PaymentHash {
    /**
     *
     * The hex-encoded payment hash of the invoice to be looked up. The passed
     * payment hash must be exactly 32 bytes, otherwise an error is returned.
     * Deprecated now that the REST gateway supports base64 encoding of bytes
     * fields.
     *
     * @deprecated
     * @generated from protobuf field: string r_hash_str = 1 [deprecated = true];
     */
    rHashStr: string;
    /**
     *
     * The payment hash of the invoice to be looked up. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from protobuf field: bytes r_hash = 2;
     */
    rHash: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.ListInvoiceRequest
 */
export interface ListInvoiceRequest {
    /**
     *
     * If set, only invoices that are not settled and not canceled will be returned
     * in the response.
     *
     * @generated from protobuf field: bool pending_only = 1;
     */
    pendingOnly: boolean;
    /**
     *
     * The index of an invoice that will be used as either the start or end of a
     * query to determine which invoices should be returned in the response.
     *
     * @generated from protobuf field: uint64 index_offset = 4;
     */
    indexOffset: bigint;
    /**
     * The max number of invoices to return in the response to this query.
     *
     * @generated from protobuf field: uint64 num_max_invoices = 5;
     */
    numMaxInvoices: bigint;
    /**
     *
     * If set, the invoices returned will result from seeking backwards from the
     * specified index offset. This can be used to paginate backwards.
     *
     * @generated from protobuf field: bool reversed = 6;
     */
    reversed: boolean;
}
/**
 * @generated from protobuf message lnrpc.ListInvoiceResponse
 */
export interface ListInvoiceResponse {
    /**
     *
     * A list of invoices from the time slice of the time series specified in the
     * request.
     *
     * @generated from protobuf field: repeated lnrpc.Invoice invoices = 1;
     */
    invoices: Invoice[];
    /**
     *
     * The index of the last item in the set of returned invoices. This can be used
     * to seek further, pagination style.
     *
     * @generated from protobuf field: uint64 last_index_offset = 2;
     */
    lastIndexOffset: bigint;
    /**
     *
     * The index of the last item in the set of returned invoices. This can be used
     * to seek backwards, pagination style.
     *
     * @generated from protobuf field: uint64 first_index_offset = 3;
     */
    firstIndexOffset: bigint;
}
/**
 * @generated from protobuf message lnrpc.InvoiceSubscription
 */
export interface InvoiceSubscription {
    /**
     *
     * If specified (non-zero), then we'll first start by sending out
     * notifications for all added indexes with an add_index greater than this
     * value. This allows callers to catch up on any events they missed while they
     * weren't connected to the streaming RPC.
     *
     * @generated from protobuf field: uint64 add_index = 1;
     */
    addIndex: bigint;
    /**
     *
     * If specified (non-zero), then we'll first start by sending out
     * notifications for all settled indexes with an settle_index greater than
     * this value. This allows callers to catch up on any events they missed while
     * they weren't connected to the streaming RPC.
     *
     * @generated from protobuf field: uint64 settle_index = 2;
     */
    settleIndex: bigint;
}
/**
 * @generated from protobuf message lnrpc.Payment
 */
export interface Payment {
    /**
     * The payment hash
     *
     * @generated from protobuf field: string payment_hash = 1;
     */
    paymentHash: string;
    /**
     * Deprecated, use value_sat or value_msat.
     *
     * @deprecated
     * @generated from protobuf field: int64 value = 2 [deprecated = true];
     */
    value: bigint;
    /**
     * Deprecated, use creation_time_ns
     *
     * @deprecated
     * @generated from protobuf field: int64 creation_date = 3 [deprecated = true];
     */
    creationDate: bigint;
    /**
     * Deprecated, use fee_sat or fee_msat.
     *
     * @deprecated
     * @generated from protobuf field: int64 fee = 5 [deprecated = true];
     */
    fee: bigint;
    /**
     * The payment preimage
     *
     * @generated from protobuf field: string payment_preimage = 6;
     */
    paymentPreimage: string;
    /**
     * The value of the payment in satoshis
     *
     * @generated from protobuf field: int64 value_sat = 7;
     */
    valueSat: bigint;
    /**
     * The value of the payment in milli-satoshis
     *
     * @generated from protobuf field: int64 value_msat = 8;
     */
    valueMsat: bigint;
    /**
     * The optional payment request being fulfilled.
     *
     * @generated from protobuf field: string payment_request = 9;
     */
    paymentRequest: string;
    /**
     * The status of the payment.
     *
     * @generated from protobuf field: lnrpc.Payment.PaymentStatus status = 10;
     */
    status: Payment_PaymentStatus;
    /**
     *  The fee paid for this payment in satoshis
     *
     * @generated from protobuf field: int64 fee_sat = 11;
     */
    feeSat: bigint;
    /**
     *  The fee paid for this payment in milli-satoshis
     *
     * @generated from protobuf field: int64 fee_msat = 12;
     */
    feeMsat: bigint;
    /**
     * The time in UNIX nanoseconds at which the payment was created.
     *
     * @generated from protobuf field: int64 creation_time_ns = 13;
     */
    creationTimeNs: bigint;
    /**
     * The HTLCs made in attempt to settle the payment.
     *
     * @generated from protobuf field: repeated lnrpc.HTLCAttempt htlcs = 14;
     */
    htlcs: HTLCAttempt[];
    /**
     *
     * The creation index of this payment. Each payment can be uniquely identified
     * by this index, which may not strictly increment by 1 for payments made in
     * older versions of lnd.
     *
     * @generated from protobuf field: uint64 payment_index = 15;
     */
    paymentIndex: bigint;
    /**
     * @generated from protobuf field: lnrpc.PaymentFailureReason failure_reason = 16;
     */
    failureReason: PaymentFailureReason;
}
/**
 * @generated from protobuf enum lnrpc.Payment.PaymentStatus
 */
export enum Payment_PaymentStatus {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: IN_FLIGHT = 1;
     */
    IN_FLIGHT = 1,
    /**
     * @generated from protobuf enum value: SUCCEEDED = 2;
     */
    SUCCEEDED = 2,
    /**
     * @generated from protobuf enum value: FAILED = 3;
     */
    FAILED = 3
}
/**
 * @generated from protobuf message lnrpc.HTLCAttempt
 */
export interface HTLCAttempt {
    /**
     * The unique ID that is used for this attempt.
     *
     * @generated from protobuf field: uint64 attempt_id = 7;
     */
    attemptId: bigint;
    /**
     * The status of the HTLC.
     *
     * @generated from protobuf field: lnrpc.HTLCAttempt.HTLCStatus status = 1;
     */
    status: HTLCAttempt_HTLCStatus;
    /**
     * The route taken by this HTLC.
     *
     * @generated from protobuf field: lnrpc.Route route = 2;
     */
    route?: Route;
    /**
     * The time in UNIX nanoseconds at which this HTLC was sent.
     *
     * @generated from protobuf field: int64 attempt_time_ns = 3;
     */
    attemptTimeNs: bigint;
    /**
     *
     * The time in UNIX nanoseconds at which this HTLC was settled or failed.
     * This value will not be set if the HTLC is still IN_FLIGHT.
     *
     * @generated from protobuf field: int64 resolve_time_ns = 4;
     */
    resolveTimeNs: bigint;
    /**
     * Detailed htlc failure info.
     *
     * @generated from protobuf field: lnrpc.Failure failure = 5;
     */
    failure?: Failure;
    /**
     * The preimage that was used to settle the HTLC.
     *
     * @generated from protobuf field: bytes preimage = 6;
     */
    preimage: Uint8Array;
}
/**
 * @generated from protobuf enum lnrpc.HTLCAttempt.HTLCStatus
 */
export enum HTLCAttempt_HTLCStatus {
    /**
     * @generated from protobuf enum value: IN_FLIGHT = 0;
     */
    IN_FLIGHT = 0,
    /**
     * @generated from protobuf enum value: SUCCEEDED = 1;
     */
    SUCCEEDED = 1,
    /**
     * @generated from protobuf enum value: FAILED = 2;
     */
    FAILED = 2
}
/**
 * @generated from protobuf message lnrpc.ListPaymentsRequest
 */
export interface ListPaymentsRequest {
    /**
     *
     * If true, then return payments that have not yet fully completed. This means
     * that pending payments, as well as failed payments will show up if this
     * field is set to true. This flag doesn't change the meaning of the indices,
     * which are tied to individual payments.
     *
     * @generated from protobuf field: bool include_incomplete = 1;
     */
    includeIncomplete: boolean;
    /**
     *
     * The index of a payment that will be used as either the start or end of a
     * query to determine which payments should be returned in the response. The
     * index_offset is exclusive. In the case of a zero index_offset, the query
     * will start with the oldest payment when paginating forwards, or will end
     * with the most recent payment when paginating backwards.
     *
     * @generated from protobuf field: uint64 index_offset = 2;
     */
    indexOffset: bigint;
    /**
     * The maximal number of payments returned in the response to this query.
     *
     * @generated from protobuf field: uint64 max_payments = 3;
     */
    maxPayments: bigint;
    /**
     *
     * If set, the payments returned will result from seeking backwards from the
     * specified index offset. This can be used to paginate backwards. The order
     * of the returned payments is always oldest first (ascending index order).
     *
     * @generated from protobuf field: bool reversed = 4;
     */
    reversed: boolean;
    /**
     *
     * If set, all payments (complete and incomplete, independent of the
     * max_payments parameter) will be counted. Note that setting this to true will
     * increase the run time of the call significantly on systems that have a lot
     * of payments, as all of them have to be iterated through to be counted.
     *
     * @generated from protobuf field: bool count_total_payments = 5;
     */
    countTotalPayments: boolean;
}
/**
 * @generated from protobuf message lnrpc.ListPaymentsResponse
 */
export interface ListPaymentsResponse {
    /**
     * The list of payments
     *
     * @generated from protobuf field: repeated lnrpc.Payment payments = 1;
     */
    payments: Payment[];
    /**
     *
     * The index of the first item in the set of returned payments. This can be
     * used as the index_offset to continue seeking backwards in the next request.
     *
     * @generated from protobuf field: uint64 first_index_offset = 2;
     */
    firstIndexOffset: bigint;
    /**
     *
     * The index of the last item in the set of returned payments. This can be used
     * as the index_offset to continue seeking forwards in the next request.
     *
     * @generated from protobuf field: uint64 last_index_offset = 3;
     */
    lastIndexOffset: bigint;
    /**
     *
     * Will only be set if count_total_payments in the request was set. Represents
     * the total number of payments (complete and incomplete, independent of the
     * number of payments requested in the query) currently present in the payments
     * database.
     *
     * @generated from protobuf field: uint64 total_num_payments = 4;
     */
    totalNumPayments: bigint;
}
/**
 * @generated from protobuf message lnrpc.DeletePaymentRequest
 */
export interface DeletePaymentRequest {
    /**
     * Payment hash to delete.
     *
     * @generated from protobuf field: bytes payment_hash = 1;
     */
    paymentHash: Uint8Array;
    /**
     *
     * Only delete failed HTLCs from the payment, not the payment itself.
     *
     * @generated from protobuf field: bool failed_htlcs_only = 2;
     */
    failedHtlcsOnly: boolean;
}
/**
 * @generated from protobuf message lnrpc.DeleteAllPaymentsRequest
 */
export interface DeleteAllPaymentsRequest {
    /**
     * Only delete failed payments.
     *
     * @generated from protobuf field: bool failed_payments_only = 1;
     */
    failedPaymentsOnly: boolean;
    /**
     *
     * Only delete failed HTLCs from payments, not the payment itself.
     *
     * @generated from protobuf field: bool failed_htlcs_only = 2;
     */
    failedHtlcsOnly: boolean;
}
/**
 * @generated from protobuf message lnrpc.DeletePaymentResponse
 */
export interface DeletePaymentResponse {
}
/**
 * @generated from protobuf message lnrpc.DeleteAllPaymentsResponse
 */
export interface DeleteAllPaymentsResponse {
}
/**
 * @generated from protobuf message lnrpc.AbandonChannelRequest
 */
export interface AbandonChannelRequest {
    /**
     * @generated from protobuf field: lnrpc.ChannelPoint channel_point = 1;
     */
    channelPoint?: ChannelPoint;
    /**
     * @generated from protobuf field: bool pending_funding_shim_only = 2;
     */
    pendingFundingShimOnly: boolean;
    /**
     *
     * Override the requirement for being in dev mode by setting this to true and
     * confirming the user knows what they are doing and this is a potential foot
     * gun to lose funds if used on active channels.
     *
     * @generated from protobuf field: bool i_know_what_i_am_doing = 3;
     */
    iKnowWhatIAmDoing: boolean;
}
/**
 * @generated from protobuf message lnrpc.AbandonChannelResponse
 */
export interface AbandonChannelResponse {
}
/**
 * @generated from protobuf message lnrpc.DebugLevelRequest
 */
export interface DebugLevelRequest {
    /**
     * @generated from protobuf field: bool show = 1;
     */
    show: boolean;
    /**
     * @generated from protobuf field: string level_spec = 2;
     */
    levelSpec: string;
}
/**
 * @generated from protobuf message lnrpc.DebugLevelResponse
 */
export interface DebugLevelResponse {
    /**
     * @generated from protobuf field: string sub_systems = 1;
     */
    subSystems: string;
}
/**
 * @generated from protobuf message lnrpc.PayReqString
 */
export interface PayReqString {
    /**
     * The payment request string to be decoded
     *
     * @generated from protobuf field: string pay_req = 1;
     */
    payReq: string;
}
/**
 * @generated from protobuf message lnrpc.PayReq
 */
export interface PayReq {
    /**
     * @generated from protobuf field: string destination = 1;
     */
    destination: string;
    /**
     * @generated from protobuf field: string payment_hash = 2;
     */
    paymentHash: string;
    /**
     * @generated from protobuf field: int64 num_satoshis = 3;
     */
    numSatoshis: bigint;
    /**
     * @generated from protobuf field: int64 timestamp = 4;
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: int64 expiry = 5;
     */
    expiry: bigint;
    /**
     * @generated from protobuf field: string description = 6;
     */
    description: string;
    /**
     * @generated from protobuf field: string description_hash = 7;
     */
    descriptionHash: string;
    /**
     * @generated from protobuf field: string fallback_addr = 8;
     */
    fallbackAddr: string;
    /**
     * @generated from protobuf field: int64 cltv_expiry = 9;
     */
    cltvExpiry: bigint;
    /**
     * @generated from protobuf field: repeated lnrpc.RouteHint route_hints = 10;
     */
    routeHints: RouteHint[];
    /**
     * @generated from protobuf field: bytes payment_addr = 11;
     */
    paymentAddr: Uint8Array;
    /**
     * @generated from protobuf field: int64 num_msat = 12;
     */
    numMsat: bigint;
    /**
     * @generated from protobuf field: map<uint32, lnrpc.Feature> features = 13;
     */
    features: {
        [key: number]: Feature;
    };
}
/**
 * @generated from protobuf message lnrpc.Feature
 */
export interface Feature {
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bool is_required = 3;
     */
    isRequired: boolean;
    /**
     * @generated from protobuf field: bool is_known = 4;
     */
    isKnown: boolean;
}
/**
 * @generated from protobuf message lnrpc.FeeReportRequest
 */
export interface FeeReportRequest {
}
/**
 * @generated from protobuf message lnrpc.ChannelFeeReport
 */
export interface ChannelFeeReport {
    /**
     * The short channel id that this fee report belongs to.
     *
     * @generated from protobuf field: uint64 chan_id = 5 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     * The channel that this fee report belongs to.
     *
     * @generated from protobuf field: string channel_point = 1;
     */
    channelPoint: string;
    /**
     * The base fee charged regardless of the number of milli-satoshis sent.
     *
     * @generated from protobuf field: int64 base_fee_msat = 2;
     */
    baseFeeMsat: bigint;
    /**
     * The amount charged per milli-satoshis transferred expressed in
     * millionths of a satoshi.
     *
     * @generated from protobuf field: int64 fee_per_mil = 3;
     */
    feePerMil: bigint;
    /**
     * The effective fee rate in milli-satoshis. Computed by dividing the
     * fee_per_mil value by 1 million.
     *
     * @generated from protobuf field: double fee_rate = 4;
     */
    feeRate: number;
}
/**
 * @generated from protobuf message lnrpc.FeeReportResponse
 */
export interface FeeReportResponse {
    /**
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelFeeReport channel_fees = 1;
     */
    channelFees: ChannelFeeReport[];
    /**
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 24 hrs.
     *
     * @generated from protobuf field: uint64 day_fee_sum = 2;
     */
    dayFeeSum: bigint;
    /**
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 week.
     *
     * @generated from protobuf field: uint64 week_fee_sum = 3;
     */
    weekFeeSum: bigint;
    /**
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 month.
     *
     * @generated from protobuf field: uint64 month_fee_sum = 4;
     */
    monthFeeSum: bigint;
}
/**
 * @generated from protobuf message lnrpc.PolicyUpdateRequest
 */
export interface PolicyUpdateRequest {
    /**
     * @generated from protobuf oneof: scope
     */
    scope: {
        oneofKind: "global";
        /**
         * If set, then this update applies to all currently active channels.
         *
         * @generated from protobuf field: bool global = 1;
         */
        global: boolean;
    } | {
        oneofKind: "chanPoint";
        /**
         * If set, this update will target a specific channel.
         *
         * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 2;
         */
        chanPoint: ChannelPoint;
    } | {
        oneofKind: undefined;
    };
    /**
     * The base fee charged regardless of the number of milli-satoshis sent.
     *
     * @generated from protobuf field: int64 base_fee_msat = 3;
     */
    baseFeeMsat: bigint;
    /**
     * The effective fee rate in milli-satoshis. The precision of this value
     * goes up to 6 decimal places, so 1e-6.
     *
     * @generated from protobuf field: double fee_rate = 4;
     */
    feeRate: number;
    /**
     * The effective fee rate in micro-satoshis (parts per million).
     *
     * @generated from protobuf field: uint32 fee_rate_ppm = 9;
     */
    feeRatePpm: number;
    /**
     * The required timelock delta for HTLCs forwarded over the channel.
     *
     * @generated from protobuf field: uint32 time_lock_delta = 5;
     */
    timeLockDelta: number;
    /**
     * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
     * HTLC will be unchanged.
     *
     * @generated from protobuf field: uint64 max_htlc_msat = 6;
     */
    maxHtlcMsat: bigint;
    /**
     * The minimum HTLC size in milli-satoshis. Only applied if
     * min_htlc_msat_specified is true.
     *
     * @generated from protobuf field: uint64 min_htlc_msat = 7;
     */
    minHtlcMsat: bigint;
    /**
     * If true, min_htlc_msat is applied.
     *
     * @generated from protobuf field: bool min_htlc_msat_specified = 8;
     */
    minHtlcMsatSpecified: boolean;
}
/**
 * @generated from protobuf message lnrpc.FailedUpdate
 */
export interface FailedUpdate {
    /**
     * The outpoint in format txid:n
     *
     * @generated from protobuf field: lnrpc.OutPoint outpoint = 1;
     */
    outpoint?: OutPoint;
    /**
     * Reason for the policy update failure.
     *
     * @generated from protobuf field: lnrpc.UpdateFailure reason = 2;
     */
    reason: UpdateFailure;
    /**
     * A string representation of the policy update error.
     *
     * @generated from protobuf field: string update_error = 3;
     */
    updateError: string;
}
/**
 * @generated from protobuf message lnrpc.PolicyUpdateResponse
 */
export interface PolicyUpdateResponse {
    /**
     * List of failed policy updates.
     *
     * @generated from protobuf field: repeated lnrpc.FailedUpdate failed_updates = 1;
     */
    failedUpdates: FailedUpdate[];
}
/**
 * @generated from protobuf message lnrpc.ForwardingHistoryRequest
 */
export interface ForwardingHistoryRequest {
    /**
     * Start time is the starting point of the forwarding history request. All
     * records beyond this point will be included, respecting the end time, and
     * the index offset.
     *
     * @generated from protobuf field: uint64 start_time = 1;
     */
    startTime: bigint;
    /**
     * End time is the end point of the forwarding history request. The
     * response will carry at most 50k records between the start time and the
     * end time. The index offset can be used to implement pagination.
     *
     * @generated from protobuf field: uint64 end_time = 2;
     */
    endTime: bigint;
    /**
     * Index offset is the offset in the time series to start at. As each
     * response can only contain 50k records, callers can use this to skip
     * around within a packed time series.
     *
     * @generated from protobuf field: uint32 index_offset = 3;
     */
    indexOffset: number;
    /**
     * The max number of events to return in the response to this query.
     *
     * @generated from protobuf field: uint32 num_max_events = 4;
     */
    numMaxEvents: number;
    /**
     * Informs the server if the peer alias should be looked up for each
     * forwarding event.
     *
     * @generated from protobuf field: bool peer_alias_lookup = 5;
     */
    peerAliasLookup: boolean;
}
/**
 * @generated from protobuf message lnrpc.ForwardingEvent
 */
export interface ForwardingEvent {
    /**
     * Timestamp is the time (unix epoch offset) that this circuit was
     * completed. Deprecated by timestamp_ns.
     *
     * @deprecated
     * @generated from protobuf field: uint64 timestamp = 1 [deprecated = true];
     */
    timestamp: bigint;
    /**
     * The incoming channel ID that carried the HTLC that created the circuit.
     *
     * @generated from protobuf field: uint64 chan_id_in = 2 [jstype = JS_STRING];
     */
    chanIdIn: string;
    /**
     * The outgoing channel ID that carried the preimage that completed the
     * circuit.
     *
     * @generated from protobuf field: uint64 chan_id_out = 4 [jstype = JS_STRING];
     */
    chanIdOut: string;
    /**
     * The total amount (in satoshis) of the incoming HTLC that created half
     * the circuit.
     *
     * @generated from protobuf field: uint64 amt_in = 5;
     */
    amtIn: bigint;
    /**
     * The total amount (in satoshis) of the outgoing HTLC that created the
     * second half of the circuit.
     *
     * @generated from protobuf field: uint64 amt_out = 6;
     */
    amtOut: bigint;
    /**
     * The total fee (in satoshis) that this payment circuit carried.
     *
     * @generated from protobuf field: uint64 fee = 7;
     */
    fee: bigint;
    /**
     * The total fee (in milli-satoshis) that this payment circuit carried.
     *
     * @generated from protobuf field: uint64 fee_msat = 8;
     */
    feeMsat: bigint;
    /**
     * The total amount (in milli-satoshis) of the incoming HTLC that created
     * half the circuit.
     *
     * @generated from protobuf field: uint64 amt_in_msat = 9;
     */
    amtInMsat: bigint;
    /**
     * The total amount (in milli-satoshis) of the outgoing HTLC that created
     * the second half of the circuit.
     *
     * @generated from protobuf field: uint64 amt_out_msat = 10;
     */
    amtOutMsat: bigint;
    /**
     * The number of nanoseconds elapsed since January 1, 1970 UTC when this
     * circuit was completed.
     *
     * @generated from protobuf field: uint64 timestamp_ns = 11;
     */
    timestampNs: bigint;
    /**
     * The peer alias of the incoming channel.
     *
     * @generated from protobuf field: string peer_alias_in = 12;
     */
    peerAliasIn: string;
    /**
     * The peer alias of the outgoing channel.
     *
     * @generated from protobuf field: string peer_alias_out = 13;
     */
    peerAliasOut: string;
}
/**
 * @generated from protobuf message lnrpc.ForwardingHistoryResponse
 */
export interface ForwardingHistoryResponse {
    /**
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     *
     * @generated from protobuf field: repeated lnrpc.ForwardingEvent forwarding_events = 1;
     */
    forwardingEvents: ForwardingEvent[];
    /**
     * The index of the last time in the set of returned forwarding events. Can
     * be used to seek further, pagination style.
     *
     * @generated from protobuf field: uint32 last_offset_index = 2;
     */
    lastOffsetIndex: number;
}
/**
 * @generated from protobuf message lnrpc.ExportChannelBackupRequest
 */
export interface ExportChannelBackupRequest {
    /**
     * The target channel point to obtain a back up for.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
}
/**
 * @generated from protobuf message lnrpc.ChannelBackup
 */
export interface ChannelBackup {
    /**
     *
     * Identifies the channel that this backup belongs to.
     *
     * @generated from protobuf field: lnrpc.ChannelPoint chan_point = 1;
     */
    chanPoint?: ChannelPoint;
    /**
     *
     * Is an encrypted single-chan backup. this can be passed to
     * RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
     * order to trigger the recovery protocol. When using REST, this field must be
     * encoded as base64.
     *
     * @generated from protobuf field: bytes chan_backup = 2;
     */
    chanBackup: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.MultiChanBackup
 */
export interface MultiChanBackup {
    /**
     *
     * Is the set of all channels that are included in this multi-channel backup.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelPoint chan_points = 1;
     */
    chanPoints: ChannelPoint[];
    /**
     *
     * A single encrypted blob containing all the static channel backups of the
     * channel listed above. This can be stored as a single file or blob, and
     * safely be replaced with any prior/future versions. When using REST, this
     * field must be encoded as base64.
     *
     * @generated from protobuf field: bytes multi_chan_backup = 2;
     */
    multiChanBackup: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.ChanBackupExportRequest
 */
export interface ChanBackupExportRequest {
}
/**
 * @generated from protobuf message lnrpc.ChanBackupSnapshot
 */
export interface ChanBackupSnapshot {
    /**
     *
     * The set of new channels that have been added since the last channel backup
     * snapshot was requested.
     *
     * @generated from protobuf field: lnrpc.ChannelBackups single_chan_backups = 1;
     */
    singleChanBackups?: ChannelBackups;
    /**
     *
     * A multi-channel backup that covers all open channels currently known to
     * lnd.
     *
     * @generated from protobuf field: lnrpc.MultiChanBackup multi_chan_backup = 2;
     */
    multiChanBackup?: MultiChanBackup;
}
/**
 * @generated from protobuf message lnrpc.ChannelBackups
 */
export interface ChannelBackups {
    /**
     *
     * A set of single-chan static channel backups.
     *
     * @generated from protobuf field: repeated lnrpc.ChannelBackup chan_backups = 1;
     */
    chanBackups: ChannelBackup[];
}
/**
 * @generated from protobuf message lnrpc.RestoreChanBackupRequest
 */
export interface RestoreChanBackupRequest {
    /**
     * @generated from protobuf oneof: backup
     */
    backup: {
        oneofKind: "chanBackups";
        /**
         *
         * The channels to restore as a list of channel/backup pairs.
         *
         * @generated from protobuf field: lnrpc.ChannelBackups chan_backups = 1;
         */
        chanBackups: ChannelBackups;
    } | {
        oneofKind: "multiChanBackup";
        /**
         *
         * The channels to restore in the packed multi backup format. When using
         * REST, this field must be encoded as base64.
         *
         * @generated from protobuf field: bytes multi_chan_backup = 2;
         */
        multiChanBackup: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.RestoreBackupResponse
 */
export interface RestoreBackupResponse {
}
/**
 * @generated from protobuf message lnrpc.ChannelBackupSubscription
 */
export interface ChannelBackupSubscription {
}
/**
 * @generated from protobuf message lnrpc.VerifyChanBackupResponse
 */
export interface VerifyChanBackupResponse {
}
/**
 * @generated from protobuf message lnrpc.MacaroonPermission
 */
export interface MacaroonPermission {
    /**
     * The entity a permission grants access to.
     *
     * @generated from protobuf field: string entity = 1;
     */
    entity: string;
    /**
     * The action that is granted.
     *
     * @generated from protobuf field: string action = 2;
     */
    action: string;
}
/**
 * @generated from protobuf message lnrpc.BakeMacaroonRequest
 */
export interface BakeMacaroonRequest {
    /**
     * The list of permissions the new macaroon should grant.
     *
     * @generated from protobuf field: repeated lnrpc.MacaroonPermission permissions = 1;
     */
    permissions: MacaroonPermission[];
    /**
     * The root key ID used to create the macaroon, must be a positive integer.
     *
     * @generated from protobuf field: uint64 root_key_id = 2;
     */
    rootKeyId: bigint;
    /**
     *
     * Informs the RPC on whether to allow external permissions that LND is not
     * aware of.
     *
     * @generated from protobuf field: bool allow_external_permissions = 3;
     */
    allowExternalPermissions: boolean;
}
/**
 * @generated from protobuf message lnrpc.BakeMacaroonResponse
 */
export interface BakeMacaroonResponse {
    /**
     * The hex encoded macaroon, serialized in binary format.
     *
     * @generated from protobuf field: string macaroon = 1;
     */
    macaroon: string;
}
/**
 * @generated from protobuf message lnrpc.ListMacaroonIDsRequest
 */
export interface ListMacaroonIDsRequest {
}
/**
 * @generated from protobuf message lnrpc.ListMacaroonIDsResponse
 */
export interface ListMacaroonIDsResponse {
    /**
     * The list of root key IDs that are in use.
     *
     * @generated from protobuf field: repeated uint64 root_key_ids = 1;
     */
    rootKeyIds: bigint[];
}
/**
 * @generated from protobuf message lnrpc.DeleteMacaroonIDRequest
 */
export interface DeleteMacaroonIDRequest {
    /**
     * The root key ID to be removed.
     *
     * @generated from protobuf field: uint64 root_key_id = 1;
     */
    rootKeyId: bigint;
}
/**
 * @generated from protobuf message lnrpc.DeleteMacaroonIDResponse
 */
export interface DeleteMacaroonIDResponse {
    /**
     * A boolean indicates that the deletion is successful.
     *
     * @generated from protobuf field: bool deleted = 1;
     */
    deleted: boolean;
}
/**
 * @generated from protobuf message lnrpc.MacaroonPermissionList
 */
export interface MacaroonPermissionList {
    /**
     * A list of macaroon permissions.
     *
     * @generated from protobuf field: repeated lnrpc.MacaroonPermission permissions = 1;
     */
    permissions: MacaroonPermission[];
}
/**
 * @generated from protobuf message lnrpc.ListPermissionsRequest
 */
export interface ListPermissionsRequest {
}
/**
 * @generated from protobuf message lnrpc.ListPermissionsResponse
 */
export interface ListPermissionsResponse {
    /**
     *
     * A map between all RPC method URIs and their required macaroon permissions to
     * access them.
     *
     * @generated from protobuf field: map<string, lnrpc.MacaroonPermissionList> method_permissions = 1;
     */
    methodPermissions: {
        [key: string]: MacaroonPermissionList;
    };
}
/**
 * @generated from protobuf message lnrpc.Failure
 */
export interface Failure {
    /**
     * Failure code as defined in the Lightning spec
     *
     * @generated from protobuf field: lnrpc.Failure.FailureCode code = 1;
     */
    code: Failure_FailureCode;
    /**
     * An optional channel update message.
     *
     * @generated from protobuf field: lnrpc.ChannelUpdate channel_update = 3;
     */
    channelUpdate?: ChannelUpdate;
    /**
     * A failure type-dependent htlc value.
     *
     * @generated from protobuf field: uint64 htlc_msat = 4;
     */
    htlcMsat: bigint;
    /**
     * The sha256 sum of the onion payload.
     *
     * @generated from protobuf field: bytes onion_sha_256 = 5;
     */
    onionSha256: Uint8Array;
    /**
     * A failure type-dependent cltv expiry value.
     *
     * @generated from protobuf field: uint32 cltv_expiry = 6;
     */
    cltvExpiry: number;
    /**
     * A failure type-dependent flags value.
     *
     * @generated from protobuf field: uint32 flags = 7;
     */
    flags: number;
    /**
     *
     * The position in the path of the intermediate or final node that generated
     * the failure message. Position zero is the sender node.
     *
     * @generated from protobuf field: uint32 failure_source_index = 8;
     */
    failureSourceIndex: number;
    /**
     * A failure type-dependent block height.
     *
     * @generated from protobuf field: uint32 height = 9;
     */
    height: number;
}
/**
 * @generated from protobuf enum lnrpc.Failure.FailureCode
 */
export enum Failure_FailureCode {
    /**
     *
     * The numbers assigned in this enumeration match the failure codes as
     * defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
     * a RESERVED value is added.
     *
     * @generated from protobuf enum value: RESERVED = 0;
     */
    RESERVED = 0,
    /**
     * @generated from protobuf enum value: INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1;
     */
    INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1,
    /**
     * @generated from protobuf enum value: INCORRECT_PAYMENT_AMOUNT = 2;
     */
    INCORRECT_PAYMENT_AMOUNT = 2,
    /**
     * @generated from protobuf enum value: FINAL_INCORRECT_CLTV_EXPIRY = 3;
     */
    FINAL_INCORRECT_CLTV_EXPIRY = 3,
    /**
     * @generated from protobuf enum value: FINAL_INCORRECT_HTLC_AMOUNT = 4;
     */
    FINAL_INCORRECT_HTLC_AMOUNT = 4,
    /**
     * @generated from protobuf enum value: FINAL_EXPIRY_TOO_SOON = 5;
     */
    FINAL_EXPIRY_TOO_SOON = 5,
    /**
     * @generated from protobuf enum value: INVALID_REALM = 6;
     */
    INVALID_REALM = 6,
    /**
     * @generated from protobuf enum value: EXPIRY_TOO_SOON = 7;
     */
    EXPIRY_TOO_SOON = 7,
    /**
     * @generated from protobuf enum value: INVALID_ONION_VERSION = 8;
     */
    INVALID_ONION_VERSION = 8,
    /**
     * @generated from protobuf enum value: INVALID_ONION_HMAC = 9;
     */
    INVALID_ONION_HMAC = 9,
    /**
     * @generated from protobuf enum value: INVALID_ONION_KEY = 10;
     */
    INVALID_ONION_KEY = 10,
    /**
     * @generated from protobuf enum value: AMOUNT_BELOW_MINIMUM = 11;
     */
    AMOUNT_BELOW_MINIMUM = 11,
    /**
     * @generated from protobuf enum value: FEE_INSUFFICIENT = 12;
     */
    FEE_INSUFFICIENT = 12,
    /**
     * @generated from protobuf enum value: INCORRECT_CLTV_EXPIRY = 13;
     */
    INCORRECT_CLTV_EXPIRY = 13,
    /**
     * @generated from protobuf enum value: CHANNEL_DISABLED = 14;
     */
    CHANNEL_DISABLED = 14,
    /**
     * @generated from protobuf enum value: TEMPORARY_CHANNEL_FAILURE = 15;
     */
    TEMPORARY_CHANNEL_FAILURE = 15,
    /**
     * @generated from protobuf enum value: REQUIRED_NODE_FEATURE_MISSING = 16;
     */
    REQUIRED_NODE_FEATURE_MISSING = 16,
    /**
     * @generated from protobuf enum value: REQUIRED_CHANNEL_FEATURE_MISSING = 17;
     */
    REQUIRED_CHANNEL_FEATURE_MISSING = 17,
    /**
     * @generated from protobuf enum value: UNKNOWN_NEXT_PEER = 18;
     */
    UNKNOWN_NEXT_PEER = 18,
    /**
     * @generated from protobuf enum value: TEMPORARY_NODE_FAILURE = 19;
     */
    TEMPORARY_NODE_FAILURE = 19,
    /**
     * @generated from protobuf enum value: PERMANENT_NODE_FAILURE = 20;
     */
    PERMANENT_NODE_FAILURE = 20,
    /**
     * @generated from protobuf enum value: PERMANENT_CHANNEL_FAILURE = 21;
     */
    PERMANENT_CHANNEL_FAILURE = 21,
    /**
     * @generated from protobuf enum value: EXPIRY_TOO_FAR = 22;
     */
    EXPIRY_TOO_FAR = 22,
    /**
     * @generated from protobuf enum value: MPP_TIMEOUT = 23;
     */
    MPP_TIMEOUT = 23,
    /**
     * @generated from protobuf enum value: INVALID_ONION_PAYLOAD = 24;
     */
    INVALID_ONION_PAYLOAD = 24,
    /**
     *
     * An internal error occurred.
     *
     * @generated from protobuf enum value: INTERNAL_FAILURE = 997;
     */
    INTERNAL_FAILURE = 997,
    /**
     *
     * The error source is known, but the failure itself couldn't be decoded.
     *
     * @generated from protobuf enum value: UNKNOWN_FAILURE = 998;
     */
    UNKNOWN_FAILURE = 998,
    /**
     *
     * An unreadable failure result is returned if the received failure message
     * cannot be decrypted. In that case the error source is unknown.
     *
     * @generated from protobuf enum value: UNREADABLE_FAILURE = 999;
     */
    UNREADABLE_FAILURE = 999
}
/**
 * @generated from protobuf message lnrpc.ChannelUpdate
 */
export interface ChannelUpdate {
    /**
     *
     * The signature that validates the announced data and proves the ownership
     * of node id.
     *
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
    /**
     *
     * The target chain that this channel was opened within. This value
     * should be the genesis hash of the target chain. Along with the short
     * channel ID, this uniquely identifies the channel globally in a
     * blockchain.
     *
     * @generated from protobuf field: bytes chain_hash = 2;
     */
    chainHash: Uint8Array;
    /**
     *
     * The unique description of the funding transaction.
     *
     * @generated from protobuf field: uint64 chan_id = 3 [jstype = JS_STRING];
     */
    chanId: string;
    /**
     *
     * A timestamp that allows ordering in the case of multiple announcements.
     * We should ignore the message if timestamp is not greater than the
     * last-received.
     *
     * @generated from protobuf field: uint32 timestamp = 4;
     */
    timestamp: number;
    /**
     *
     * The bitfield that describes whether optional fields are present in this
     * update. Currently, the least-significant bit must be set to 1 if the
     * optional field MaxHtlc is present.
     *
     * @generated from protobuf field: uint32 message_flags = 10;
     */
    messageFlags: number;
    /**
     *
     * The bitfield that describes additional meta-data concerning how the
     * update is to be interpreted. Currently, the least-significant bit must be
     * set to 0 if the creating node corresponds to the first node in the
     * previously sent channel announcement and 1 otherwise. If the second bit
     * is set, then the channel is set to be disabled.
     *
     * @generated from protobuf field: uint32 channel_flags = 5;
     */
    channelFlags: number;
    /**
     *
     * The minimum number of blocks this node requires to be added to the expiry
     * of HTLCs. This is a security parameter determined by the node operator.
     * This value represents the required gap between the time locks of the
     * incoming and outgoing HTLC's set to this node.
     *
     * @generated from protobuf field: uint32 time_lock_delta = 6;
     */
    timeLockDelta: number;
    /**
     *
     * The minimum HTLC value which will be accepted.
     *
     * @generated from protobuf field: uint64 htlc_minimum_msat = 7;
     */
    htlcMinimumMsat: bigint;
    /**
     *
     * The base fee that must be used for incoming HTLC's to this particular
     * channel. This value will be tacked onto the required for a payment
     * independent of the size of the payment.
     *
     * @generated from protobuf field: uint32 base_fee = 8;
     */
    baseFee: number;
    /**
     *
     * The fee rate that will be charged per millionth of a satoshi.
     *
     * @generated from protobuf field: uint32 fee_rate = 9;
     */
    feeRate: number;
    /**
     *
     * The maximum HTLC value which will be accepted.
     *
     * @generated from protobuf field: uint64 htlc_maximum_msat = 11;
     */
    htlcMaximumMsat: bigint;
    /**
     *
     * The set of data that was appended to this message, some of which we may
     * not actually know how to iterate or parse. By holding onto this data, we
     * ensure that we're able to properly validate the set of signatures that
     * cover these new fields, and ensure we're able to make upgrades to the
     * network in a forwards compatible manner.
     *
     * @generated from protobuf field: bytes extra_opaque_data = 12;
     */
    extraOpaqueData: Uint8Array;
}
/**
 * @generated from protobuf message lnrpc.MacaroonId
 */
export interface MacaroonId {
    /**
     * @generated from protobuf field: bytes nonce = 1;
     */
    nonce: Uint8Array;
    /**
     * @generated from protobuf field: bytes storageId = 2;
     */
    storageId: Uint8Array;
    /**
     * @generated from protobuf field: repeated lnrpc.Op ops = 3;
     */
    ops: Op[];
}
/**
 * @generated from protobuf message lnrpc.Op
 */
export interface Op {
    /**
     * @generated from protobuf field: string entity = 1;
     */
    entity: string;
    /**
     * @generated from protobuf field: repeated string actions = 2;
     */
    actions: string[];
}
/**
 * @generated from protobuf message lnrpc.CheckMacPermRequest
 */
export interface CheckMacPermRequest {
    /**
     * @generated from protobuf field: bytes macaroon = 1;
     */
    macaroon: Uint8Array;
    /**
     * @generated from protobuf field: repeated lnrpc.MacaroonPermission permissions = 2;
     */
    permissions: MacaroonPermission[];
    /**
     * @generated from protobuf field: string fullMethod = 3;
     */
    fullMethod: string;
}
/**
 * @generated from protobuf message lnrpc.CheckMacPermResponse
 */
export interface CheckMacPermResponse {
    /**
     * @generated from protobuf field: bool valid = 1;
     */
    valid: boolean;
}
/**
 * @generated from protobuf message lnrpc.RPCMiddlewareRequest
 */
export interface RPCMiddlewareRequest {
    /**
     *
     * The unique ID of the intercepted original gRPC request. Useful for mapping
     * request to response when implementing full duplex message interception. For
     * streaming requests, this will be the same ID for all incoming and outgoing
     * middleware intercept messages of the _same_ stream.
     *
     * @generated from protobuf field: uint64 request_id = 1;
     */
    requestId: bigint;
    /**
     *
     * The raw bytes of the complete macaroon as sent by the gRPC client in the
     * original request. This might be empty for a request that doesn't require
     * macaroons such as the wallet unlocker RPCs.
     *
     * @generated from protobuf field: bytes raw_macaroon = 2;
     */
    rawMacaroon: Uint8Array;
    /**
     *
     * The parsed condition of the macaroon's custom caveat for convenient access.
     * This field only contains the value of the custom caveat that the handling
     * middleware has registered itself for. The condition _must_ be validated for
     * messages of intercept_type stream_auth and request!
     *
     * @generated from protobuf field: string custom_caveat_condition = 3;
     */
    customCaveatCondition: string;
    /**
     * @generated from protobuf oneof: intercept_type
     */
    interceptType: {
        oneofKind: "streamAuth";
        /**
         *
         * Intercept stream authentication: each new streaming RPC call that is
         * initiated against lnd and contains the middleware's custom macaroon
         * caveat can be approved or denied based upon the macaroon in the stream
         * header. This message will only be sent for streaming RPCs, unary RPCs
         * must handle the macaroon authentication in the request interception to
         * avoid an additional message round trip between lnd and the middleware.
         *
         * @generated from protobuf field: lnrpc.StreamAuth stream_auth = 4;
         */
        streamAuth: StreamAuth;
    } | {
        oneofKind: "request";
        /**
         *
         * Intercept incoming gRPC client request message: all incoming messages,
         * both on streaming and unary RPCs, are forwarded to the middleware for
         * inspection. For unary RPC messages the middleware is also expected to
         * validate the custom macaroon caveat of the request.
         *
         * @generated from protobuf field: lnrpc.RPCMessage request = 5;
         */
        request: RPCMessage;
    } | {
        oneofKind: "response";
        /**
         *
         * Intercept outgoing gRPC response message: all outgoing messages, both on
         * streaming and unary RPCs, are forwarded to the middleware for inspection
         * and amendment. The response in this message is the original response as
         * it was generated by the main RPC server. It can either be accepted
         * (=forwarded to the client), replaced/overwritten with a new message of
         * the same type, or replaced by an error message.
         *
         * @generated from protobuf field: lnrpc.RPCMessage response = 6;
         */
        response: RPCMessage;
    } | {
        oneofKind: "regComplete";
        /**
         *
         * This is used to indicate to the client that the server has successfully
         * registered the interceptor. This is only used in the very first message
         * that the server sends to the client after the client sends the server
         * the middleware registration message.
         *
         * @generated from protobuf field: bool reg_complete = 8;
         */
        regComplete: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     *
     * The unique message ID of this middleware intercept message. There can be
     * multiple middleware intercept messages per single gRPC request (one for the
     * incoming request and one for the outgoing response) or gRPC stream (one for
     * each incoming message and one for each outgoing response). This message ID
     * must be referenced when responding (accepting/rejecting/modifying) to an
     * intercept message.
     *
     * @generated from protobuf field: uint64 msg_id = 7;
     */
    msgId: bigint;
}
/**
 * @generated from protobuf message lnrpc.StreamAuth
 */
export interface StreamAuth {
    /**
     *
     * The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
     * example /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just
     * established.
     *
     * @generated from protobuf field: string method_full_uri = 1;
     */
    methodFullUri: string;
}
/**
 * @generated from protobuf message lnrpc.RPCMessage
 */
export interface RPCMessage {
    /**
     *
     * The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
     * example /lnrpc.Lightning/GetInfo) of the RPC method the message was sent
     * to/from.
     *
     * @generated from protobuf field: string method_full_uri = 1;
     */
    methodFullUri: string;
    /**
     *
     * Indicates whether the message was sent over a streaming RPC method or not.
     *
     * @generated from protobuf field: bool stream_rpc = 2;
     */
    streamRpc: boolean;
    /**
     *
     * The full canonical gRPC name of the message type (in the format
     * <rpcpackage>.TypeName, for example lnrpc.GetInfoRequest). In case of an
     * error being returned from lnd, this simply contains the string "error".
     *
     * @generated from protobuf field: string type_name = 3;
     */
    typeName: string;
    /**
     *
     * The full content of the gRPC message, serialized in the binary protobuf
     * format.
     *
     * @generated from protobuf field: bytes serialized = 4;
     */
    serialized: Uint8Array;
    /**
     *
     * Indicates that the response from lnd was an error, not a gRPC response. If
     * this is set to true then the type_name contains the string "error" and
     * serialized contains the error string.
     *
     * @generated from protobuf field: bool is_error = 5;
     */
    isError: boolean;
}
/**
 * @generated from protobuf message lnrpc.RPCMiddlewareResponse
 */
export interface RPCMiddlewareResponse {
    /**
     *
     * The request message ID this response refers to. Must always be set when
     * giving feedback to an intercept but is ignored for the initial registration
     * message.
     *
     * @generated from protobuf field: uint64 ref_msg_id = 1;
     */
    refMsgId: bigint;
    /**
     * @generated from protobuf oneof: middleware_message
     */
    middlewareMessage: {
        oneofKind: "register";
        /**
         *
         * The registration message identifies the middleware that's being
         * registered in lnd. The registration message must be sent immediately
         * after initiating the RegisterRpcMiddleware stream, otherwise lnd will
         * time out the attempt and terminate the request. NOTE: The middleware
         * will only receive interception messages for requests that contain a
         * macaroon with the custom caveat that the middleware declares it is
         * responsible for handling in the registration message! As a security
         * measure, _no_ middleware can intercept requests made with _unencumbered_
         * macaroons!
         *
         * @generated from protobuf field: lnrpc.MiddlewareRegistration register = 2;
         */
        register: MiddlewareRegistration;
    } | {
        oneofKind: "feedback";
        /**
         *
         * The middleware received an interception request and gives feedback to
         * it. The request_id indicates what message the feedback refers to.
         *
         * @generated from protobuf field: lnrpc.InterceptFeedback feedback = 3;
         */
        feedback: InterceptFeedback;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lnrpc.MiddlewareRegistration
 */
export interface MiddlewareRegistration {
    /**
     *
     * The name of the middleware to register. The name should be as informative
     * as possible and is logged on registration.
     *
     * @generated from protobuf field: string middleware_name = 1;
     */
    middlewareName: string;
    /**
     *
     * The name of the custom macaroon caveat that this middleware is responsible
     * for. Only requests/responses that contain a macaroon with the registered
     * custom caveat are forwarded for interception to the middleware. The
     * exception being the read-only mode: All requests/responses are forwarded to
     * a middleware that requests read-only access but such a middleware won't be
     * allowed to _alter_ responses. As a security measure, _no_ middleware can
     * change responses to requests made with _unencumbered_ macaroons!
     * NOTE: Cannot be used at the same time as read_only_mode.
     *
     * @generated from protobuf field: string custom_macaroon_caveat_name = 2;
     */
    customMacaroonCaveatName: string;
    /**
     *
     * Instead of defining a custom macaroon caveat name a middleware can register
     * itself for read-only access only. In that mode all requests/responses are
     * forwarded to the middleware but the middleware isn't allowed to alter any of
     * the responses.
     * NOTE: Cannot be used at the same time as custom_macaroon_caveat_name.
     *
     * @generated from protobuf field: bool read_only_mode = 3;
     */
    readOnlyMode: boolean;
}
/**
 * @generated from protobuf message lnrpc.InterceptFeedback
 */
export interface InterceptFeedback {
    /**
     *
     * The error to return to the user. If this is non-empty, the incoming gRPC
     * stream/request is aborted and the error is returned to the gRPC client. If
     * this value is empty, it means the middleware accepts the stream/request/
     * response and the processing of it can continue.
     *
     * @generated from protobuf field: string error = 1;
     */
    error: string;
    /**
     *
     * A boolean indicating that the gRPC message should be replaced/overwritten.
     * This boolean is needed because in protobuf an empty message is serialized as
     * a 0-length or nil byte slice and we wouldn't be able to distinguish between
     * an empty replacement message and the "don't replace anything" case.
     *
     * @generated from protobuf field: bool replace_response = 2;
     */
    replaceResponse: boolean;
    /**
     *
     * If the replace_response field is set to true, this field must contain the
     * binary serialized gRPC message in the protobuf format.
     *
     * @generated from protobuf field: bytes replacement_serialized = 3;
     */
    replacementSerialized: Uint8Array;
}
/**
 * @generated from protobuf enum lnrpc.OutputScriptType
 */
export enum OutputScriptType {
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_PUBKEY_HASH = 0;
     */
    SCRIPT_TYPE_PUBKEY_HASH = 0,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_SCRIPT_HASH = 1;
     */
    SCRIPT_TYPE_SCRIPT_HASH = 1,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 2;
     */
    SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 2,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 3;
     */
    SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 3,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_PUBKEY = 4;
     */
    SCRIPT_TYPE_PUBKEY = 4,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_MULTISIG = 5;
     */
    SCRIPT_TYPE_MULTISIG = 5,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_NULLDATA = 6;
     */
    SCRIPT_TYPE_NULLDATA = 6,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_NON_STANDARD = 7;
     */
    SCRIPT_TYPE_NON_STANDARD = 7,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_UNKNOWN = 8;
     */
    SCRIPT_TYPE_WITNESS_UNKNOWN = 8,
    /**
     * @generated from protobuf enum value: SCRIPT_TYPE_WITNESS_V1_TAPROOT = 9;
     */
    SCRIPT_TYPE_WITNESS_V1_TAPROOT = 9
}
/**
 *
 * `AddressType` has to be one of:
 *
 * - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
 * - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
 * - `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 4)
 *
 * @generated from protobuf enum lnrpc.AddressType
 */
export enum AddressType {
    /**
     * @generated from protobuf enum value: WITNESS_PUBKEY_HASH = 0;
     */
    WITNESS_PUBKEY_HASH = 0,
    /**
     * @generated from protobuf enum value: NESTED_PUBKEY_HASH = 1;
     */
    NESTED_PUBKEY_HASH = 1,
    /**
     * @generated from protobuf enum value: UNUSED_WITNESS_PUBKEY_HASH = 2;
     */
    UNUSED_WITNESS_PUBKEY_HASH = 2,
    /**
     * @generated from protobuf enum value: UNUSED_NESTED_PUBKEY_HASH = 3;
     */
    UNUSED_NESTED_PUBKEY_HASH = 3,
    /**
     * @generated from protobuf enum value: TAPROOT_PUBKEY = 4;
     */
    TAPROOT_PUBKEY = 4,
    /**
     * @generated from protobuf enum value: UNUSED_TAPROOT_PUBKEY = 5;
     */
    UNUSED_TAPROOT_PUBKEY = 5
}
/**
 * @generated from protobuf enum lnrpc.CommitmentType
 */
export enum CommitmentType {
    /**
     *
     * Returned when the commitment type isn't known or unavailable.
     *
     * @generated from protobuf enum value: UNKNOWN_COMMITMENT_TYPE = 0;
     */
    UNKNOWN_COMMITMENT_TYPE = 0,
    /**
     *
     * A channel using the legacy commitment format having tweaked to_remote
     * keys.
     *
     * @generated from protobuf enum value: LEGACY = 1;
     */
    LEGACY = 1,
    /**
     *
     * A channel that uses the modern commitment format where the key in the
     * output of the remote party does not change each state. This makes back
     * up and recovery easier as when the channel is closed, the funds go
     * directly to that key.
     *
     * @generated from protobuf enum value: STATIC_REMOTE_KEY = 2;
     */
    STATIC_REMOTE_KEY = 2,
    /**
     *
     * A channel that uses a commitment format that has anchor outputs on the
     * commitments, allowing fee bumping after a force close transaction has
     * been broadcast.
     *
     * @generated from protobuf enum value: ANCHORS = 3;
     */
    ANCHORS = 3,
    /**
     *
     * A channel that uses a commitment type that builds upon the anchors
     * commitment format, but in addition requires a CLTV clause to spend outputs
     * paying to the channel initiator. This is intended for use on leased channels
     * to guarantee that the channel initiator has no incentives to close a leased
     * channel before its maturity date.
     *
     * @generated from protobuf enum value: SCRIPT_ENFORCED_LEASE = 4;
     */
    SCRIPT_ENFORCED_LEASE = 4
}
/**
 * @generated from protobuf enum lnrpc.Initiator
 */
export enum Initiator {
    /**
     * @generated from protobuf enum value: INITIATOR_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: INITIATOR_LOCAL = 1;
     */
    LOCAL = 1,
    /**
     * @generated from protobuf enum value: INITIATOR_REMOTE = 2;
     */
    REMOTE = 2,
    /**
     * @generated from protobuf enum value: INITIATOR_BOTH = 3;
     */
    BOTH = 3
}
/**
 * @generated from protobuf enum lnrpc.ResolutionType
 */
export enum ResolutionType {
    /**
     * @generated from protobuf enum value: TYPE_UNKNOWN = 0;
     */
    TYPE_UNKNOWN = 0,
    /**
     * We resolved an anchor output.
     *
     * @generated from protobuf enum value: ANCHOR = 1;
     */
    ANCHOR = 1,
    /**
     *
     * We are resolving an incoming htlc on chain. This if this htlc is
     * claimed, we swept the incoming htlc with the preimage. If it is timed
     * out, our peer swept the timeout path.
     *
     * @generated from protobuf enum value: INCOMING_HTLC = 2;
     */
    INCOMING_HTLC = 2,
    /**
     *
     * We are resolving an outgoing htlc on chain. If this htlc is claimed,
     * the remote party swept the htlc with the preimage. If it is timed out,
     * we swept it with the timeout path.
     *
     * @generated from protobuf enum value: OUTGOING_HTLC = 3;
     */
    OUTGOING_HTLC = 3,
    /**
     * We force closed and need to sweep our time locked commitment output.
     *
     * @generated from protobuf enum value: COMMIT = 4;
     */
    COMMIT = 4
}
/**
 * @generated from protobuf enum lnrpc.ResolutionOutcome
 */
export enum ResolutionOutcome {
    /**
     * Outcome unknown.
     *
     * @generated from protobuf enum value: OUTCOME_UNKNOWN = 0;
     */
    OUTCOME_UNKNOWN = 0,
    /**
     * An output was claimed on chain.
     *
     * @generated from protobuf enum value: CLAIMED = 1;
     */
    CLAIMED = 1,
    /**
     * An output was left unclaimed on chain.
     *
     * @generated from protobuf enum value: UNCLAIMED = 2;
     */
    UNCLAIMED = 2,
    /**
     *
     * ResolverOutcomeAbandoned indicates that an output that we did not
     * claim on chain, for example an anchor that we did not sweep and a
     * third party claimed on chain, or a htlc that we could not decode
     * so left unclaimed.
     *
     * @generated from protobuf enum value: ABANDONED = 3;
     */
    ABANDONED = 3,
    /**
     *
     * If we force closed our channel, our htlcs need to be claimed in two
     * stages. This outcome represents the broadcast of a timeout or success
     * transaction for this two stage htlc claim.
     *
     * @generated from protobuf enum value: FIRST_STAGE = 4;
     */
    FIRST_STAGE = 4,
    /**
     * A htlc was timed out on chain.
     *
     * @generated from protobuf enum value: TIMEOUT = 5;
     */
    TIMEOUT = 5
}
/**
 * @generated from protobuf enum lnrpc.NodeMetricType
 */
export enum NodeMetricType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: BETWEENNESS_CENTRALITY = 1;
     */
    BETWEENNESS_CENTRALITY = 1
}
/**
 * @generated from protobuf enum lnrpc.InvoiceHTLCState
 */
export enum InvoiceHTLCState {
    /**
     * @generated from protobuf enum value: ACCEPTED = 0;
     */
    ACCEPTED = 0,
    /**
     * @generated from protobuf enum value: SETTLED = 1;
     */
    SETTLED = 1,
    /**
     * @generated from protobuf enum value: CANCELED = 2;
     */
    CANCELED = 2
}
/**
 * @generated from protobuf enum lnrpc.PaymentFailureReason
 */
export enum PaymentFailureReason {
    /**
     *
     * Payment isn't failed (yet).
     *
     * @generated from protobuf enum value: FAILURE_REASON_NONE = 0;
     */
    FAILURE_REASON_NONE = 0,
    /**
     *
     * There are more routes to try, but the payment timeout was exceeded.
     *
     * @generated from protobuf enum value: FAILURE_REASON_TIMEOUT = 1;
     */
    FAILURE_REASON_TIMEOUT = 1,
    /**
     *
     * All possible routes were tried and failed permanently. Or were no
     * routes to the destination at all.
     *
     * @generated from protobuf enum value: FAILURE_REASON_NO_ROUTE = 2;
     */
    FAILURE_REASON_NO_ROUTE = 2,
    /**
     *
     * A non-recoverable error has occured.
     *
     * @generated from protobuf enum value: FAILURE_REASON_ERROR = 3;
     */
    FAILURE_REASON_ERROR = 3,
    /**
     *
     * Payment details incorrect (unknown hash, invalid amt or
     * invalid final cltv delta)
     *
     * @generated from protobuf enum value: FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4;
     */
    FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4,
    /**
     *
     * Insufficient local balance.
     *
     * @generated from protobuf enum value: FAILURE_REASON_INSUFFICIENT_BALANCE = 5;
     */
    FAILURE_REASON_INSUFFICIENT_BALANCE = 5
}
/**
 * @generated from protobuf enum lnrpc.FeatureBit
 */
export enum FeatureBit {
    /**
     * @generated from protobuf enum value: DATALOSS_PROTECT_REQ = 0;
     */
    DATALOSS_PROTECT_REQ = 0,
    /**
     * @generated from protobuf enum value: DATALOSS_PROTECT_OPT = 1;
     */
    DATALOSS_PROTECT_OPT = 1,
    /**
     * @generated from protobuf enum value: INITIAL_ROUING_SYNC = 3;
     */
    INITIAL_ROUING_SYNC = 3,
    /**
     * @generated from protobuf enum value: UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;
     */
    UPFRONT_SHUTDOWN_SCRIPT_REQ = 4,
    /**
     * @generated from protobuf enum value: UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;
     */
    UPFRONT_SHUTDOWN_SCRIPT_OPT = 5,
    /**
     * @generated from protobuf enum value: GOSSIP_QUERIES_REQ = 6;
     */
    GOSSIP_QUERIES_REQ = 6,
    /**
     * @generated from protobuf enum value: GOSSIP_QUERIES_OPT = 7;
     */
    GOSSIP_QUERIES_OPT = 7,
    /**
     * @generated from protobuf enum value: TLV_ONION_REQ = 8;
     */
    TLV_ONION_REQ = 8,
    /**
     * @generated from protobuf enum value: TLV_ONION_OPT = 9;
     */
    TLV_ONION_OPT = 9,
    /**
     * @generated from protobuf enum value: EXT_GOSSIP_QUERIES_REQ = 10;
     */
    EXT_GOSSIP_QUERIES_REQ = 10,
    /**
     * @generated from protobuf enum value: EXT_GOSSIP_QUERIES_OPT = 11;
     */
    EXT_GOSSIP_QUERIES_OPT = 11,
    /**
     * @generated from protobuf enum value: STATIC_REMOTE_KEY_REQ = 12;
     */
    STATIC_REMOTE_KEY_REQ = 12,
    /**
     * @generated from protobuf enum value: STATIC_REMOTE_KEY_OPT = 13;
     */
    STATIC_REMOTE_KEY_OPT = 13,
    /**
     * @generated from protobuf enum value: PAYMENT_ADDR_REQ = 14;
     */
    PAYMENT_ADDR_REQ = 14,
    /**
     * @generated from protobuf enum value: PAYMENT_ADDR_OPT = 15;
     */
    PAYMENT_ADDR_OPT = 15,
    /**
     * @generated from protobuf enum value: MPP_REQ = 16;
     */
    MPP_REQ = 16,
    /**
     * @generated from protobuf enum value: MPP_OPT = 17;
     */
    MPP_OPT = 17,
    /**
     * @generated from protobuf enum value: WUMBO_CHANNELS_REQ = 18;
     */
    WUMBO_CHANNELS_REQ = 18,
    /**
     * @generated from protobuf enum value: WUMBO_CHANNELS_OPT = 19;
     */
    WUMBO_CHANNELS_OPT = 19,
    /**
     * @generated from protobuf enum value: ANCHORS_REQ = 20;
     */
    ANCHORS_REQ = 20,
    /**
     * @generated from protobuf enum value: ANCHORS_OPT = 21;
     */
    ANCHORS_OPT = 21,
    /**
     * @generated from protobuf enum value: ANCHORS_ZERO_FEE_HTLC_REQ = 22;
     */
    ANCHORS_ZERO_FEE_HTLC_REQ = 22,
    /**
     * @generated from protobuf enum value: ANCHORS_ZERO_FEE_HTLC_OPT = 23;
     */
    ANCHORS_ZERO_FEE_HTLC_OPT = 23,
    /**
     * @generated from protobuf enum value: AMP_REQ = 30;
     */
    AMP_REQ = 30,
    /**
     * @generated from protobuf enum value: AMP_OPT = 31;
     */
    AMP_OPT = 31
}
/**
 * @generated from protobuf enum lnrpc.UpdateFailure
 */
export enum UpdateFailure {
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_NOT_FOUND = 2;
     */
    NOT_FOUND = 2,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_INTERNAL_ERR = 3;
     */
    INTERNAL_ERR = 3,
    /**
     * @generated from protobuf enum value: UPDATE_FAILURE_INVALID_PARAMETER = 4;
     */
    INVALID_PARAMETER = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class LookupHtlcRequest$Type extends MessageType<LookupHtlcRequest> {
    constructor() {
        super("lnrpc.LookupHtlcRequest", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "htlc_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LookupHtlcRequest>): LookupHtlcRequest {
        const message = { chanId: 0n, htlcIndex: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupHtlcRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupHtlcRequest): LookupHtlcRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id */ 1:
                    message.chanId = reader.uint64().toBigInt();
                    break;
                case /* uint64 htlc_index */ 2:
                    message.htlcIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupHtlcRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1; */
        if (message.chanId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* uint64 htlc_index = 2; */
        if (message.htlcIndex !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.htlcIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.LookupHtlcRequest
 */
export const LookupHtlcRequest = new LookupHtlcRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupHtlcResponse$Type extends MessageType<LookupHtlcResponse> {
    constructor() {
        super("lnrpc.LookupHtlcResponse", [
            { no: 1, name: "settled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "offchain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LookupHtlcResponse>): LookupHtlcResponse {
        const message = { settled: false, offchain: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupHtlcResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupHtlcResponse): LookupHtlcResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool settled */ 1:
                    message.settled = reader.bool();
                    break;
                case /* bool offchain */ 2:
                    message.offchain = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupHtlcResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool settled = 1; */
        if (message.settled !== false)
            writer.tag(1, WireType.Varint).bool(message.settled);
        /* bool offchain = 2; */
        if (message.offchain !== false)
            writer.tag(2, WireType.Varint).bool(message.offchain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.LookupHtlcResponse
 */
export const LookupHtlcResponse = new LookupHtlcResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeCustomMessagesRequest$Type extends MessageType<SubscribeCustomMessagesRequest> {
    constructor() {
        super("lnrpc.SubscribeCustomMessagesRequest", []);
    }
    create(value?: PartialMessage<SubscribeCustomMessagesRequest>): SubscribeCustomMessagesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeCustomMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCustomMessagesRequest): SubscribeCustomMessagesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeCustomMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SubscribeCustomMessagesRequest
 */
export const SubscribeCustomMessagesRequest = new SubscribeCustomMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomMessage$Type extends MessageType<CustomMessage> {
    constructor() {
        super("lnrpc.CustomMessage", [
            { no: 1, name: "peer", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CustomMessage>): CustomMessage {
        const message = { peer: new Uint8Array(0), type: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomMessage): CustomMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes peer */ 1:
                    message.peer = reader.bytes();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes peer = 1; */
        if (message.peer.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.peer);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.CustomMessage
 */
export const CustomMessage = new CustomMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendCustomMessageRequest$Type extends MessageType<SendCustomMessageRequest> {
    constructor() {
        super("lnrpc.SendCustomMessageRequest", [
            { no: 1, name: "peer", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SendCustomMessageRequest>): SendCustomMessageRequest {
        const message = { peer: new Uint8Array(0), type: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendCustomMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCustomMessageRequest): SendCustomMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes peer */ 1:
                    message.peer = reader.bytes();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendCustomMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes peer = 1; */
        if (message.peer.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.peer);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCustomMessageRequest
 */
export const SendCustomMessageRequest = new SendCustomMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendCustomMessageResponse$Type extends MessageType<SendCustomMessageResponse> {
    constructor() {
        super("lnrpc.SendCustomMessageResponse", []);
    }
    create(value?: PartialMessage<SendCustomMessageResponse>): SendCustomMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendCustomMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCustomMessageResponse): SendCustomMessageResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SendCustomMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCustomMessageResponse
 */
export const SendCustomMessageResponse = new SendCustomMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Utxo$Type extends MessageType<Utxo> {
    constructor() {
        super("lnrpc.Utxo", [
            { no: 1, name: "address_type", kind: "enum", T: () => ["lnrpc.AddressType", AddressType] },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "pk_script", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 6, name: "confirmations", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Utxo>): Utxo {
        const message = { addressType: 0, address: "", amountSat: 0n, pkScript: "", confirmations: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Utxo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Utxo): Utxo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.AddressType address_type */ 1:
                    message.addressType = reader.int32();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* int64 amount_sat */ 3:
                    message.amountSat = reader.int64().toBigInt();
                    break;
                case /* string pk_script */ 4:
                    message.pkScript = reader.string();
                    break;
                case /* lnrpc.OutPoint outpoint */ 5:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* int64 confirmations */ 6:
                    message.confirmations = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Utxo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.AddressType address_type = 1; */
        if (message.addressType !== 0)
            writer.tag(1, WireType.Varint).int32(message.addressType);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* int64 amount_sat = 3; */
        if (message.amountSat !== 0n)
            writer.tag(3, WireType.Varint).int64(message.amountSat);
        /* string pk_script = 4; */
        if (message.pkScript !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pkScript);
        /* lnrpc.OutPoint outpoint = 5; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 confirmations = 6; */
        if (message.confirmations !== 0n)
            writer.tag(6, WireType.Varint).int64(message.confirmations);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Utxo
 */
export const Utxo = new Utxo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutputDetail$Type extends MessageType<OutputDetail> {
    constructor() {
        super("lnrpc.OutputDetail", [
            { no: 1, name: "output_type", kind: "enum", T: () => ["lnrpc.OutputScriptType", OutputScriptType] },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pk_script", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "output_index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "is_our_address", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OutputDetail>): OutputDetail {
        const message = { outputType: 0, address: "", pkScript: "", outputIndex: 0n, amount: 0n, isOurAddress: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OutputDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutputDetail): OutputDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.OutputScriptType output_type */ 1:
                    message.outputType = reader.int32();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string pk_script */ 3:
                    message.pkScript = reader.string();
                    break;
                case /* int64 output_index */ 4:
                    message.outputIndex = reader.int64().toBigInt();
                    break;
                case /* int64 amount */ 5:
                    message.amount = reader.int64().toBigInt();
                    break;
                case /* bool is_our_address */ 6:
                    message.isOurAddress = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutputDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.OutputScriptType output_type = 1; */
        if (message.outputType !== 0)
            writer.tag(1, WireType.Varint).int32(message.outputType);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string pk_script = 3; */
        if (message.pkScript !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pkScript);
        /* int64 output_index = 4; */
        if (message.outputIndex !== 0n)
            writer.tag(4, WireType.Varint).int64(message.outputIndex);
        /* int64 amount = 5; */
        if (message.amount !== 0n)
            writer.tag(5, WireType.Varint).int64(message.amount);
        /* bool is_our_address = 6; */
        if (message.isOurAddress !== false)
            writer.tag(6, WireType.Varint).bool(message.isOurAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.OutputDetail
 */
export const OutputDetail = new OutputDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("lnrpc.Transaction", [
            { no: 1, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "num_confirmations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "block_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "block_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "time_stamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "total_fees", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "dest_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "output_details", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OutputDetail },
            { no: 9, name: "raw_tx_hex", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "previous_outpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PreviousOutPoint }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { txHash: "", amount: 0n, numConfirmations: 0, blockHash: "", blockHeight: 0, timeStamp: 0n, totalFees: 0n, destAddresses: [], outputDetails: [], rawTxHex: "", label: "", previousOutpoints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tx_hash */ 1:
                    message.txHash = reader.string();
                    break;
                case /* int64 amount */ 2:
                    message.amount = reader.int64().toBigInt();
                    break;
                case /* int32 num_confirmations */ 3:
                    message.numConfirmations = reader.int32();
                    break;
                case /* string block_hash */ 4:
                    message.blockHash = reader.string();
                    break;
                case /* int32 block_height */ 5:
                    message.blockHeight = reader.int32();
                    break;
                case /* int64 time_stamp */ 6:
                    message.timeStamp = reader.int64().toBigInt();
                    break;
                case /* int64 total_fees */ 7:
                    message.totalFees = reader.int64().toBigInt();
                    break;
                case /* repeated string dest_addresses = 8 [deprecated = true];*/ 8:
                    message.destAddresses.push(reader.string());
                    break;
                case /* repeated lnrpc.OutputDetail output_details */ 11:
                    message.outputDetails.push(OutputDetail.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string raw_tx_hex */ 9:
                    message.rawTxHex = reader.string();
                    break;
                case /* string label */ 10:
                    message.label = reader.string();
                    break;
                case /* repeated lnrpc.PreviousOutPoint previous_outpoints */ 12:
                    message.previousOutpoints.push(PreviousOutPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tx_hash = 1; */
        if (message.txHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txHash);
        /* int64 amount = 2; */
        if (message.amount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amount);
        /* int32 num_confirmations = 3; */
        if (message.numConfirmations !== 0)
            writer.tag(3, WireType.Varint).int32(message.numConfirmations);
        /* string block_hash = 4; */
        if (message.blockHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
        /* int32 block_height = 5; */
        if (message.blockHeight !== 0)
            writer.tag(5, WireType.Varint).int32(message.blockHeight);
        /* int64 time_stamp = 6; */
        if (message.timeStamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.timeStamp);
        /* int64 total_fees = 7; */
        if (message.totalFees !== 0n)
            writer.tag(7, WireType.Varint).int64(message.totalFees);
        /* repeated string dest_addresses = 8 [deprecated = true]; */
        for (let i = 0; i < message.destAddresses.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.destAddresses[i]);
        /* repeated lnrpc.OutputDetail output_details = 11; */
        for (let i = 0; i < message.outputDetails.length; i++)
            OutputDetail.internalBinaryWrite(message.outputDetails[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string raw_tx_hex = 9; */
        if (message.rawTxHex !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.rawTxHex);
        /* string label = 10; */
        if (message.label !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.label);
        /* repeated lnrpc.PreviousOutPoint previous_outpoints = 12; */
        for (let i = 0; i < message.previousOutpoints.length; i++)
            PreviousOutPoint.internalBinaryWrite(message.previousOutpoints[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTransactionsRequest$Type extends MessageType<GetTransactionsRequest> {
    constructor() {
        super("lnrpc.GetTransactionsRequest", [
            { no: 1, name: "start_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "end_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTransactionsRequest>): GetTransactionsRequest {
        const message = { startHeight: 0, endHeight: 0, account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionsRequest): GetTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 start_height */ 1:
                    message.startHeight = reader.int32();
                    break;
                case /* int32 end_height */ 2:
                    message.endHeight = reader.int32();
                    break;
                case /* string account */ 3:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 start_height = 1; */
        if (message.startHeight !== 0)
            writer.tag(1, WireType.Varint).int32(message.startHeight);
        /* int32 end_height = 2; */
        if (message.endHeight !== 0)
            writer.tag(2, WireType.Varint).int32(message.endHeight);
        /* string account = 3; */
        if (message.account !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GetTransactionsRequest
 */
export const GetTransactionsRequest = new GetTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionDetails$Type extends MessageType<TransactionDetails> {
    constructor() {
        super("lnrpc.TransactionDetails", [
            { no: 1, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<TransactionDetails>): TransactionDetails {
        const message = { transactions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionDetails): TransactionDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Transaction transactions */ 1:
                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Transaction transactions = 1; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.TransactionDetails
 */
export const TransactionDetails = new TransactionDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeLimit$Type extends MessageType<FeeLimit> {
    constructor() {
        super("lnrpc.FeeLimit", [
            { no: 1, name: "fixed", kind: "scalar", oneof: "limit", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "fixed_msat", kind: "scalar", oneof: "limit", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "percent", kind: "scalar", oneof: "limit", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeeLimit>): FeeLimit {
        const message = { limit: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeLimit): FeeLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 fixed */ 1:
                    message.limit = {
                        oneofKind: "fixed",
                        fixed: reader.int64().toBigInt()
                    };
                    break;
                case /* int64 fixed_msat */ 3:
                    message.limit = {
                        oneofKind: "fixedMsat",
                        fixedMsat: reader.int64().toBigInt()
                    };
                    break;
                case /* int64 percent */ 2:
                    message.limit = {
                        oneofKind: "percent",
                        percent: reader.int64().toBigInt()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 fixed = 1; */
        if (message.limit.oneofKind === "fixed")
            writer.tag(1, WireType.Varint).int64(message.limit.fixed);
        /* int64 fixed_msat = 3; */
        if (message.limit.oneofKind === "fixedMsat")
            writer.tag(3, WireType.Varint).int64(message.limit.fixedMsat);
        /* int64 percent = 2; */
        if (message.limit.oneofKind === "percent")
            writer.tag(2, WireType.Varint).int64(message.limit.percent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FeeLimit
 */
export const FeeLimit = new FeeLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendRequest$Type extends MessageType<SendRequest> {
    constructor() {
        super("lnrpc.SendRequest", [
            { no: 1, name: "dest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "dest_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "payment_hash_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "fee_limit", kind: "message", T: () => FeeLimit },
            { no: 9, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 13, name: "last_hop_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "cltv_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "dest_custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 14, name: "allow_self_payment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "dest_features", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["lnrpc.FeatureBit", FeatureBit] },
            { no: 16, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SendRequest>): SendRequest {
        const message = { dest: new Uint8Array(0), destString: "", amt: 0n, amtMsat: 0n, paymentHash: new Uint8Array(0), paymentHashString: "", paymentRequest: "", finalCltvDelta: 0, outgoingChanId: "0", lastHopPubkey: new Uint8Array(0), cltvLimit: 0, destCustomRecords: {}, allowSelfPayment: false, destFeatures: [], paymentAddr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendRequest): SendRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes dest */ 1:
                    message.dest = reader.bytes();
                    break;
                case /* string dest_string = 2 [deprecated = true];*/ 2:
                    message.destString = reader.string();
                    break;
                case /* int64 amt */ 3:
                    message.amt = reader.int64().toBigInt();
                    break;
                case /* int64 amt_msat */ 12:
                    message.amtMsat = reader.int64().toBigInt();
                    break;
                case /* bytes payment_hash */ 4:
                    message.paymentHash = reader.bytes();
                    break;
                case /* string payment_hash_string = 5 [deprecated = true];*/ 5:
                    message.paymentHashString = reader.string();
                    break;
                case /* string payment_request */ 6:
                    message.paymentRequest = reader.string();
                    break;
                case /* int32 final_cltv_delta */ 7:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* lnrpc.FeeLimit fee_limit */ 8:
                    message.feeLimit = FeeLimit.internalBinaryRead(reader, reader.uint32(), options, message.feeLimit);
                    break;
                case /* uint64 outgoing_chan_id = 9 [jstype = JS_STRING];*/ 9:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* bytes last_hop_pubkey */ 13:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case /* uint32 cltv_limit */ 10:
                    message.cltvLimit = reader.uint32();
                    break;
                case /* map<uint64, bytes> dest_custom_records */ 11:
                    this.binaryReadMap11(message.destCustomRecords, reader, options);
                    break;
                case /* bool allow_self_payment */ 14:
                    message.allowSelfPayment = reader.bool();
                    break;
                case /* repeated lnrpc.FeatureBit dest_features */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.destFeatures.push(reader.int32());
                    else
                        message.destFeatures.push(reader.int32());
                    break;
                case /* bytes payment_addr */ 16:
                    message.paymentAddr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: SendRequest["destCustomRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendRequest["destCustomRecords"] | undefined, val: SendRequest["destCustomRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.SendRequest.dest_custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: SendRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes dest = 1; */
        if (message.dest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.dest);
        /* string dest_string = 2 [deprecated = true]; */
        if (message.destString !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.destString);
        /* int64 amt = 3; */
        if (message.amt !== 0n)
            writer.tag(3, WireType.Varint).int64(message.amt);
        /* int64 amt_msat = 12; */
        if (message.amtMsat !== 0n)
            writer.tag(12, WireType.Varint).int64(message.amtMsat);
        /* bytes payment_hash = 4; */
        if (message.paymentHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.paymentHash);
        /* string payment_hash_string = 5 [deprecated = true]; */
        if (message.paymentHashString !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paymentHashString);
        /* string payment_request = 6; */
        if (message.paymentRequest !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.paymentRequest);
        /* int32 final_cltv_delta = 7; */
        if (message.finalCltvDelta !== 0)
            writer.tag(7, WireType.Varint).int32(message.finalCltvDelta);
        /* lnrpc.FeeLimit fee_limit = 8; */
        if (message.feeLimit)
            FeeLimit.internalBinaryWrite(message.feeLimit, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint64 outgoing_chan_id = 9 [jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(9, WireType.Varint).uint64(message.outgoingChanId);
        /* bytes last_hop_pubkey = 13; */
        if (message.lastHopPubkey.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.lastHopPubkey);
        /* uint32 cltv_limit = 10; */
        if (message.cltvLimit !== 0)
            writer.tag(10, WireType.Varint).uint32(message.cltvLimit);
        /* map<uint64, bytes> dest_custom_records = 11; */
        for (let k of Object.keys(message.destCustomRecords))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.destCustomRecords[k]).join();
        /* bool allow_self_payment = 14; */
        if (message.allowSelfPayment !== false)
            writer.tag(14, WireType.Varint).bool(message.allowSelfPayment);
        /* repeated lnrpc.FeatureBit dest_features = 15; */
        if (message.destFeatures.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.destFeatures.length; i++)
                writer.int32(message.destFeatures[i]);
            writer.join();
        }
        /* bytes payment_addr = 16; */
        if (message.paymentAddr.length)
            writer.tag(16, WireType.LengthDelimited).bytes(message.paymentAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendRequest
 */
export const SendRequest = new SendRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendResponse$Type extends MessageType<SendResponse> {
    constructor() {
        super("lnrpc.SendResponse", [
            { no: 1, name: "payment_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payment_preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "payment_route", kind: "message", T: () => Route },
            { no: 4, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SendResponse>): SendResponse {
        const message = { paymentError: "", paymentPreimage: new Uint8Array(0), paymentHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendResponse): SendResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_error */ 1:
                    message.paymentError = reader.string();
                    break;
                case /* bytes payment_preimage */ 2:
                    message.paymentPreimage = reader.bytes();
                    break;
                case /* lnrpc.Route payment_route */ 3:
                    message.paymentRoute = Route.internalBinaryRead(reader, reader.uint32(), options, message.paymentRoute);
                    break;
                case /* bytes payment_hash */ 4:
                    message.paymentHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_error = 1; */
        if (message.paymentError !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentError);
        /* bytes payment_preimage = 2; */
        if (message.paymentPreimage.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.paymentPreimage);
        /* lnrpc.Route payment_route = 3; */
        if (message.paymentRoute)
            Route.internalBinaryWrite(message.paymentRoute, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes payment_hash = 4; */
        if (message.paymentHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.paymentHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendResponse
 */
export const SendResponse = new SendResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendToRouteRequest$Type extends MessageType<SendToRouteRequest> {
    constructor() {
        super("lnrpc.SendToRouteRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "payment_hash_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "route", kind: "message", T: () => Route }
        ]);
    }
    create(value?: PartialMessage<SendToRouteRequest>): SendToRouteRequest {
        const message = { paymentHash: new Uint8Array(0), paymentHashString: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendToRouteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendToRouteRequest): SendToRouteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* string payment_hash_string = 2 [deprecated = true];*/ 2:
                    message.paymentHashString = reader.string();
                    break;
                case /* lnrpc.Route route */ 4:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendToRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paymentHash);
        /* string payment_hash_string = 2 [deprecated = true]; */
        if (message.paymentHashString !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paymentHashString);
        /* lnrpc.Route route = 4; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendToRouteRequest
 */
export const SendToRouteRequest = new SendToRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelAcceptRequest$Type extends MessageType<ChannelAcceptRequest> {
    constructor() {
        super("lnrpc.ChannelAcceptRequest", [
            { no: 1, name: "node_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "chain_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "funding_amt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "push_amt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "dust_limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "max_value_in_flight", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "channel_reserve", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "min_htlc", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "fee_per_kw", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "csv_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "max_accepted_htlcs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "channel_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "commitment_type", kind: "enum", T: () => ["lnrpc.CommitmentType", CommitmentType] },
            { no: 15, name: "wants_zero_conf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "wants_scid_alias", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelAcceptRequest>): ChannelAcceptRequest {
        const message = { nodePubkey: new Uint8Array(0), chainHash: new Uint8Array(0), pendingChanId: new Uint8Array(0), fundingAmt: 0n, pushAmt: 0n, dustLimit: 0n, maxValueInFlight: 0n, channelReserve: 0n, minHtlc: 0n, feePerKw: 0n, csvDelay: 0, maxAcceptedHtlcs: 0, channelFlags: 0, commitmentType: 0, wantsZeroConf: false, wantsScidAlias: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelAcceptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelAcceptRequest): ChannelAcceptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes node_pubkey */ 1:
                    message.nodePubkey = reader.bytes();
                    break;
                case /* bytes chain_hash */ 2:
                    message.chainHash = reader.bytes();
                    break;
                case /* bytes pending_chan_id */ 3:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* uint64 funding_amt */ 4:
                    message.fundingAmt = reader.uint64().toBigInt();
                    break;
                case /* uint64 push_amt */ 5:
                    message.pushAmt = reader.uint64().toBigInt();
                    break;
                case /* uint64 dust_limit */ 6:
                    message.dustLimit = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_value_in_flight */ 7:
                    message.maxValueInFlight = reader.uint64().toBigInt();
                    break;
                case /* uint64 channel_reserve */ 8:
                    message.channelReserve = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_htlc */ 9:
                    message.minHtlc = reader.uint64().toBigInt();
                    break;
                case /* uint64 fee_per_kw */ 10:
                    message.feePerKw = reader.uint64().toBigInt();
                    break;
                case /* uint32 csv_delay */ 11:
                    message.csvDelay = reader.uint32();
                    break;
                case /* uint32 max_accepted_htlcs */ 12:
                    message.maxAcceptedHtlcs = reader.uint32();
                    break;
                case /* uint32 channel_flags */ 13:
                    message.channelFlags = reader.uint32();
                    break;
                case /* lnrpc.CommitmentType commitment_type */ 14:
                    message.commitmentType = reader.int32();
                    break;
                case /* bool wants_zero_conf */ 15:
                    message.wantsZeroConf = reader.bool();
                    break;
                case /* bool wants_scid_alias */ 16:
                    message.wantsScidAlias = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelAcceptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes node_pubkey = 1; */
        if (message.nodePubkey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nodePubkey);
        /* bytes chain_hash = 2; */
        if (message.chainHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chainHash);
        /* bytes pending_chan_id = 3; */
        if (message.pendingChanId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* uint64 funding_amt = 4; */
        if (message.fundingAmt !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.fundingAmt);
        /* uint64 push_amt = 5; */
        if (message.pushAmt !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.pushAmt);
        /* uint64 dust_limit = 6; */
        if (message.dustLimit !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.dustLimit);
        /* uint64 max_value_in_flight = 7; */
        if (message.maxValueInFlight !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.maxValueInFlight);
        /* uint64 channel_reserve = 8; */
        if (message.channelReserve !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.channelReserve);
        /* uint64 min_htlc = 9; */
        if (message.minHtlc !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.minHtlc);
        /* uint64 fee_per_kw = 10; */
        if (message.feePerKw !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.feePerKw);
        /* uint32 csv_delay = 11; */
        if (message.csvDelay !== 0)
            writer.tag(11, WireType.Varint).uint32(message.csvDelay);
        /* uint32 max_accepted_htlcs = 12; */
        if (message.maxAcceptedHtlcs !== 0)
            writer.tag(12, WireType.Varint).uint32(message.maxAcceptedHtlcs);
        /* uint32 channel_flags = 13; */
        if (message.channelFlags !== 0)
            writer.tag(13, WireType.Varint).uint32(message.channelFlags);
        /* lnrpc.CommitmentType commitment_type = 14; */
        if (message.commitmentType !== 0)
            writer.tag(14, WireType.Varint).int32(message.commitmentType);
        /* bool wants_zero_conf = 15; */
        if (message.wantsZeroConf !== false)
            writer.tag(15, WireType.Varint).bool(message.wantsZeroConf);
        /* bool wants_scid_alias = 16; */
        if (message.wantsScidAlias !== false)
            writer.tag(16, WireType.Varint).bool(message.wantsScidAlias);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelAcceptRequest
 */
export const ChannelAcceptRequest = new ChannelAcceptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelAcceptResponse$Type extends MessageType<ChannelAcceptResponse> {
    constructor() {
        super("lnrpc.ChannelAcceptResponse", [
            { no: 1, name: "accept", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "upfront_shutdown", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "csv_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "reserve_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "in_flight_max_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "max_htlc_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "min_htlc_in", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "min_accept_depth", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "zero_conf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelAcceptResponse>): ChannelAcceptResponse {
        const message = { accept: false, pendingChanId: new Uint8Array(0), error: "", upfrontShutdown: "", csvDelay: 0, reserveSat: 0n, inFlightMaxMsat: 0n, maxHtlcCount: 0, minHtlcIn: 0n, minAcceptDepth: 0, zeroConf: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelAcceptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelAcceptResponse): ChannelAcceptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool accept */ 1:
                    message.accept = reader.bool();
                    break;
                case /* bytes pending_chan_id */ 2:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* string error */ 3:
                    message.error = reader.string();
                    break;
                case /* string upfront_shutdown */ 4:
                    message.upfrontShutdown = reader.string();
                    break;
                case /* uint32 csv_delay */ 5:
                    message.csvDelay = reader.uint32();
                    break;
                case /* uint64 reserve_sat */ 6:
                    message.reserveSat = reader.uint64().toBigInt();
                    break;
                case /* uint64 in_flight_max_msat */ 7:
                    message.inFlightMaxMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 max_htlc_count */ 8:
                    message.maxHtlcCount = reader.uint32();
                    break;
                case /* uint64 min_htlc_in */ 9:
                    message.minHtlcIn = reader.uint64().toBigInt();
                    break;
                case /* uint32 min_accept_depth */ 10:
                    message.minAcceptDepth = reader.uint32();
                    break;
                case /* bool zero_conf */ 11:
                    message.zeroConf = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelAcceptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool accept = 1; */
        if (message.accept !== false)
            writer.tag(1, WireType.Varint).bool(message.accept);
        /* bytes pending_chan_id = 2; */
        if (message.pendingChanId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* string error = 3; */
        if (message.error !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        /* string upfront_shutdown = 4; */
        if (message.upfrontShutdown !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.upfrontShutdown);
        /* uint32 csv_delay = 5; */
        if (message.csvDelay !== 0)
            writer.tag(5, WireType.Varint).uint32(message.csvDelay);
        /* uint64 reserve_sat = 6; */
        if (message.reserveSat !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.reserveSat);
        /* uint64 in_flight_max_msat = 7; */
        if (message.inFlightMaxMsat !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.inFlightMaxMsat);
        /* uint32 max_htlc_count = 8; */
        if (message.maxHtlcCount !== 0)
            writer.tag(8, WireType.Varint).uint32(message.maxHtlcCount);
        /* uint64 min_htlc_in = 9; */
        if (message.minHtlcIn !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.minHtlcIn);
        /* uint32 min_accept_depth = 10; */
        if (message.minAcceptDepth !== 0)
            writer.tag(10, WireType.Varint).uint32(message.minAcceptDepth);
        /* bool zero_conf = 11; */
        if (message.zeroConf !== false)
            writer.tag(11, WireType.Varint).bool(message.zeroConf);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelAcceptResponse
 */
export const ChannelAcceptResponse = new ChannelAcceptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelPoint$Type extends MessageType<ChannelPoint> {
    constructor() {
        super("lnrpc.ChannelPoint", [
            { no: 1, name: "funding_txid_bytes", kind: "scalar", oneof: "fundingTxid", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "funding_txid_str", kind: "scalar", oneof: "fundingTxid", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "output_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelPoint>): ChannelPoint {
        const message = { fundingTxid: { oneofKind: undefined }, outputIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelPoint): ChannelPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes funding_txid_bytes */ 1:
                    message.fundingTxid = {
                        oneofKind: "fundingTxidBytes",
                        fundingTxidBytes: reader.bytes()
                    };
                    break;
                case /* string funding_txid_str */ 2:
                    message.fundingTxid = {
                        oneofKind: "fundingTxidStr",
                        fundingTxidStr: reader.string()
                    };
                    break;
                case /* uint32 output_index */ 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes funding_txid_bytes = 1; */
        if (message.fundingTxid.oneofKind === "fundingTxidBytes")
            writer.tag(1, WireType.LengthDelimited).bytes(message.fundingTxid.fundingTxidBytes);
        /* string funding_txid_str = 2; */
        if (message.fundingTxid.oneofKind === "fundingTxidStr")
            writer.tag(2, WireType.LengthDelimited).string(message.fundingTxid.fundingTxidStr);
        /* uint32 output_index = 3; */
        if (message.outputIndex !== 0)
            writer.tag(3, WireType.Varint).uint32(message.outputIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelPoint
 */
export const ChannelPoint = new ChannelPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutPoint$Type extends MessageType<OutPoint> {
    constructor() {
        super("lnrpc.OutPoint", [
            { no: 1, name: "txid_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "txid_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "output_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OutPoint>): OutPoint {
        const message = { txidBytes: new Uint8Array(0), txidStr: "", outputIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OutPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutPoint): OutPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes txid_bytes */ 1:
                    message.txidBytes = reader.bytes();
                    break;
                case /* string txid_str */ 2:
                    message.txidStr = reader.string();
                    break;
                case /* uint32 output_index */ 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes txid_bytes = 1; */
        if (message.txidBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txidBytes);
        /* string txid_str = 2; */
        if (message.txidStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.txidStr);
        /* uint32 output_index = 3; */
        if (message.outputIndex !== 0)
            writer.tag(3, WireType.Varint).uint32(message.outputIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.OutPoint
 */
export const OutPoint = new OutPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreviousOutPoint$Type extends MessageType<PreviousOutPoint> {
    constructor() {
        super("lnrpc.PreviousOutPoint", [
            { no: 1, name: "outpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_our_output", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PreviousOutPoint>): PreviousOutPoint {
        const message = { outpoint: "", isOurOutput: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PreviousOutPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreviousOutPoint): PreviousOutPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string outpoint */ 1:
                    message.outpoint = reader.string();
                    break;
                case /* bool is_our_output */ 2:
                    message.isOurOutput = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PreviousOutPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string outpoint = 1; */
        if (message.outpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.outpoint);
        /* bool is_our_output = 2; */
        if (message.isOurOutput !== false)
            writer.tag(2, WireType.Varint).bool(message.isOurOutput);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PreviousOutPoint
 */
export const PreviousOutPoint = new PreviousOutPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightningAddress$Type extends MessageType<LightningAddress> {
    constructor() {
        super("lnrpc.LightningAddress", [
            { no: 1, name: "pubkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LightningAddress>): LightningAddress {
        const message = { pubkey: "", host: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LightningAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightningAddress): LightningAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pubkey */ 1:
                    message.pubkey = reader.string();
                    break;
                case /* string host */ 2:
                    message.host = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LightningAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pubkey = 1; */
        if (message.pubkey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubkey);
        /* string host = 2; */
        if (message.host !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.host);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.LightningAddress
 */
export const LightningAddress = new LightningAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateFeeRequest$Type extends MessageType<EstimateFeeRequest> {
    constructor() {
        super("lnrpc.EstimateFeeRequest", [
            { no: 1, name: "AddrToAmount", kind: "map", jsonName: "AddrToAmount", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } },
            { no: 2, name: "target_conf", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateFeeRequest>): EstimateFeeRequest {
        const message = { addrToAmount: {}, targetConf: 0, minConfs: 0, spendUnconfirmed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateFeeRequest): EstimateFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"];*/ 1:
                    this.binaryReadMap1(message.addrToAmount, reader, options);
                    break;
                case /* int32 target_conf */ 2:
                    message.targetConf = reader.int32();
                    break;
                case /* int32 min_confs */ 3:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 4:
                    message.spendUnconfirmed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: EstimateFeeRequest["addrToAmount"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EstimateFeeRequest["addrToAmount"] | undefined, val: EstimateFeeRequest["addrToAmount"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.EstimateFeeRequest.AddrToAmount");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: EstimateFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"]; */
        for (let k of Object.keys(message.addrToAmount))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.addrToAmount[k]).join();
        /* int32 target_conf = 2; */
        if (message.targetConf !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetConf);
        /* int32 min_confs = 3; */
        if (message.minConfs !== 0)
            writer.tag(3, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 4; */
        if (message.spendUnconfirmed !== false)
            writer.tag(4, WireType.Varint).bool(message.spendUnconfirmed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.EstimateFeeRequest
 */
export const EstimateFeeRequest = new EstimateFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateFeeResponse$Type extends MessageType<EstimateFeeResponse> {
    constructor() {
        super("lnrpc.EstimateFeeResponse", [
            { no: 1, name: "fee_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "feerate_sat_per_byte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateFeeResponse>): EstimateFeeResponse {
        const message = { feeSat: 0n, feerateSatPerByte: 0n, satPerVbyte: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateFeeResponse): EstimateFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 fee_sat */ 1:
                    message.feeSat = reader.int64().toBigInt();
                    break;
                case /* int64 feerate_sat_per_byte = 2 [deprecated = true];*/ 2:
                    message.feerateSatPerByte = reader.int64().toBigInt();
                    break;
                case /* uint64 sat_per_vbyte */ 3:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 fee_sat = 1; */
        if (message.feeSat !== 0n)
            writer.tag(1, WireType.Varint).int64(message.feeSat);
        /* int64 feerate_sat_per_byte = 2 [deprecated = true]; */
        if (message.feerateSatPerByte !== 0n)
            writer.tag(2, WireType.Varint).int64(message.feerateSatPerByte);
        /* uint64 sat_per_vbyte = 3; */
        if (message.satPerVbyte !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.satPerVbyte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.EstimateFeeResponse
 */
export const EstimateFeeResponse = new EstimateFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendManyRequest$Type extends MessageType<SendManyRequest> {
    constructor() {
        super("lnrpc.SendManyRequest", [
            { no: 1, name: "AddrToAmount", kind: "map", jsonName: "AddrToAmount", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } },
            { no: 3, name: "target_conf", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "sat_per_byte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SendManyRequest>): SendManyRequest {
        const message = { addrToAmount: {}, targetConf: 0, satPerVbyte: 0n, satPerByte: 0n, label: "", minConfs: 0, spendUnconfirmed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendManyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendManyRequest): SendManyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"];*/ 1:
                    this.binaryReadMap1(message.addrToAmount, reader, options);
                    break;
                case /* int32 target_conf */ 3:
                    message.targetConf = reader.int32();
                    break;
                case /* uint64 sat_per_vbyte */ 4:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* int64 sat_per_byte = 5 [deprecated = true];*/ 5:
                    message.satPerByte = reader.int64().toBigInt();
                    break;
                case /* string label */ 6:
                    message.label = reader.string();
                    break;
                case /* int32 min_confs */ 7:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 8:
                    message.spendUnconfirmed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SendManyRequest["addrToAmount"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendManyRequest["addrToAmount"] | undefined, val: SendManyRequest["addrToAmount"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.SendManyRequest.AddrToAmount");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: SendManyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, int64> AddrToAmount = 1 [json_name = "AddrToAmount"]; */
        for (let k of Object.keys(message.addrToAmount))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.addrToAmount[k]).join();
        /* int32 target_conf = 3; */
        if (message.targetConf !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetConf);
        /* uint64 sat_per_vbyte = 4; */
        if (message.satPerVbyte !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.satPerVbyte);
        /* int64 sat_per_byte = 5 [deprecated = true]; */
        if (message.satPerByte !== 0n)
            writer.tag(5, WireType.Varint).int64(message.satPerByte);
        /* string label = 6; */
        if (message.label !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.label);
        /* int32 min_confs = 7; */
        if (message.minConfs !== 0)
            writer.tag(7, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 8; */
        if (message.spendUnconfirmed !== false)
            writer.tag(8, WireType.Varint).bool(message.spendUnconfirmed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendManyRequest
 */
export const SendManyRequest = new SendManyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendManyResponse$Type extends MessageType<SendManyResponse> {
    constructor() {
        super("lnrpc.SendManyResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendManyResponse>): SendManyResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendManyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendManyResponse): SendManyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendManyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendManyResponse
 */
export const SendManyResponse = new SendManyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendCoinsRequest$Type extends MessageType<SendCoinsRequest> {
    constructor() {
        super("lnrpc.SendCoinsRequest", [
            { no: 1, name: "addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "target_conf", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "sat_per_byte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "send_all", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SendCoinsRequest>): SendCoinsRequest {
        const message = { addr: "", amount: 0n, targetConf: 0, satPerVbyte: 0n, satPerByte: 0n, sendAll: false, label: "", minConfs: 0, spendUnconfirmed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendCoinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCoinsRequest): SendCoinsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string addr */ 1:
                    message.addr = reader.string();
                    break;
                case /* int64 amount */ 2:
                    message.amount = reader.int64().toBigInt();
                    break;
                case /* int32 target_conf */ 3:
                    message.targetConf = reader.int32();
                    break;
                case /* uint64 sat_per_vbyte */ 4:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* int64 sat_per_byte = 5 [deprecated = true];*/ 5:
                    message.satPerByte = reader.int64().toBigInt();
                    break;
                case /* bool send_all */ 6:
                    message.sendAll = reader.bool();
                    break;
                case /* string label */ 7:
                    message.label = reader.string();
                    break;
                case /* int32 min_confs */ 8:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 9:
                    message.spendUnconfirmed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string addr = 1; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        /* int64 amount = 2; */
        if (message.amount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amount);
        /* int32 target_conf = 3; */
        if (message.targetConf !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetConf);
        /* uint64 sat_per_vbyte = 4; */
        if (message.satPerVbyte !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.satPerVbyte);
        /* int64 sat_per_byte = 5 [deprecated = true]; */
        if (message.satPerByte !== 0n)
            writer.tag(5, WireType.Varint).int64(message.satPerByte);
        /* bool send_all = 6; */
        if (message.sendAll !== false)
            writer.tag(6, WireType.Varint).bool(message.sendAll);
        /* string label = 7; */
        if (message.label !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.label);
        /* int32 min_confs = 8; */
        if (message.minConfs !== 0)
            writer.tag(8, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 9; */
        if (message.spendUnconfirmed !== false)
            writer.tag(9, WireType.Varint).bool(message.spendUnconfirmed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCoinsRequest
 */
export const SendCoinsRequest = new SendCoinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendCoinsResponse$Type extends MessageType<SendCoinsResponse> {
    constructor() {
        super("lnrpc.SendCoinsResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendCoinsResponse>): SendCoinsResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendCoinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendCoinsResponse): SendCoinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SendCoinsResponse
 */
export const SendCoinsResponse = new SendCoinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUnspentRequest$Type extends MessageType<ListUnspentRequest> {
    constructor() {
        super("lnrpc.ListUnspentRequest", [
            { no: 1, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "max_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListUnspentRequest>): ListUnspentRequest {
        const message = { minConfs: 0, maxConfs: 0, account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUnspentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnspentRequest): ListUnspentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 min_confs */ 1:
                    message.minConfs = reader.int32();
                    break;
                case /* int32 max_confs */ 2:
                    message.maxConfs = reader.int32();
                    break;
                case /* string account */ 3:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUnspentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 min_confs = 1; */
        if (message.minConfs !== 0)
            writer.tag(1, WireType.Varint).int32(message.minConfs);
        /* int32 max_confs = 2; */
        if (message.maxConfs !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxConfs);
        /* string account = 3; */
        if (message.account !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListUnspentRequest
 */
export const ListUnspentRequest = new ListUnspentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUnspentResponse$Type extends MessageType<ListUnspentResponse> {
    constructor() {
        super("lnrpc.ListUnspentResponse", [
            { no: 1, name: "utxos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Utxo }
        ]);
    }
    create(value?: PartialMessage<ListUnspentResponse>): ListUnspentResponse {
        const message = { utxos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUnspentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnspentResponse): ListUnspentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Utxo utxos */ 1:
                    message.utxos.push(Utxo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUnspentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Utxo utxos = 1; */
        for (let i = 0; i < message.utxos.length; i++)
            Utxo.internalBinaryWrite(message.utxos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListUnspentResponse
 */
export const ListUnspentResponse = new ListUnspentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewAddressRequest$Type extends MessageType<NewAddressRequest> {
    constructor() {
        super("lnrpc.NewAddressRequest", [
            { no: 1, name: "type", kind: "enum", T: () => ["lnrpc.AddressType", AddressType] },
            { no: 2, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NewAddressRequest>): NewAddressRequest {
        const message = { type: 0, account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewAddressRequest): NewAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.AddressType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string account */ 2:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.AddressType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string account = 2; */
        if (message.account !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NewAddressRequest
 */
export const NewAddressRequest = new NewAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewAddressResponse$Type extends MessageType<NewAddressResponse> {
    constructor() {
        super("lnrpc.NewAddressResponse", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NewAddressResponse>): NewAddressResponse {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewAddressResponse): NewAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NewAddressResponse
 */
export const NewAddressResponse = new NewAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessageRequest$Type extends MessageType<SignMessageRequest> {
    constructor() {
        super("lnrpc.SignMessageRequest", [
            { no: 1, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "single_hash", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SignMessageRequest>): SignMessageRequest {
        const message = { msg: new Uint8Array(0), singleHash: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageRequest): SignMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msg */ 1:
                    message.msg = reader.bytes();
                    break;
                case /* bool single_hash */ 2:
                    message.singleHash = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msg = 1; */
        if (message.msg.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.msg);
        /* bool single_hash = 2; */
        if (message.singleHash !== false)
            writer.tag(2, WireType.Varint).bool(message.singleHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SignMessageRequest
 */
export const SignMessageRequest = new SignMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessageResponse$Type extends MessageType<SignMessageResponse> {
    constructor() {
        super("lnrpc.SignMessageResponse", [
            { no: 1, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SignMessageResponse>): SignMessageResponse {
        const message = { signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignMessageResponse): SignMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signature */ 1:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signature = 1; */
        if (message.signature !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SignMessageResponse
 */
export const SignMessageResponse = new SignMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyMessageRequest$Type extends MessageType<VerifyMessageRequest> {
    constructor() {
        super("lnrpc.VerifyMessageRequest", [
            { no: 1, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyMessageRequest>): VerifyMessageRequest {
        const message = { msg: new Uint8Array(0), signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageRequest): VerifyMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msg */ 1:
                    message.msg = reader.bytes();
                    break;
                case /* string signature */ 2:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msg = 1; */
        if (message.msg.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.msg);
        /* string signature = 2; */
        if (message.signature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.VerifyMessageRequest
 */
export const VerifyMessageRequest = new VerifyMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyMessageResponse$Type extends MessageType<VerifyMessageResponse> {
    constructor() {
        super("lnrpc.VerifyMessageResponse", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "pubkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyMessageResponse>): VerifyMessageResponse {
        const message = { valid: false, pubkey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyMessageResponse): VerifyMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                case /* string pubkey */ 2:
                    message.pubkey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        /* string pubkey = 2; */
        if (message.pubkey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pubkey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.VerifyMessageResponse
 */
export const VerifyMessageResponse = new VerifyMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectPeerRequest$Type extends MessageType<ConnectPeerRequest> {
    constructor() {
        super("lnrpc.ConnectPeerRequest", [
            { no: 1, name: "addr", kind: "message", T: () => LightningAddress },
            { no: 2, name: "perm", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "timeout", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectPeerRequest>): ConnectPeerRequest {
        const message = { perm: false, timeout: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConnectPeerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectPeerRequest): ConnectPeerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.LightningAddress addr */ 1:
                    message.addr = LightningAddress.internalBinaryRead(reader, reader.uint32(), options, message.addr);
                    break;
                case /* bool perm */ 2:
                    message.perm = reader.bool();
                    break;
                case /* uint64 timeout */ 3:
                    message.timeout = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectPeerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.LightningAddress addr = 1; */
        if (message.addr)
            LightningAddress.internalBinaryWrite(message.addr, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool perm = 2; */
        if (message.perm !== false)
            writer.tag(2, WireType.Varint).bool(message.perm);
        /* uint64 timeout = 3; */
        if (message.timeout !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.timeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ConnectPeerRequest
 */
export const ConnectPeerRequest = new ConnectPeerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectPeerResponse$Type extends MessageType<ConnectPeerResponse> {
    constructor() {
        super("lnrpc.ConnectPeerResponse", []);
    }
    create(value?: PartialMessage<ConnectPeerResponse>): ConnectPeerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConnectPeerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectPeerResponse): ConnectPeerResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ConnectPeerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ConnectPeerResponse
 */
export const ConnectPeerResponse = new ConnectPeerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectPeerRequest$Type extends MessageType<DisconnectPeerRequest> {
    constructor() {
        super("lnrpc.DisconnectPeerRequest", [
            { no: 1, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DisconnectPeerRequest>): DisconnectPeerRequest {
        const message = { pubKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisconnectPeerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectPeerRequest): DisconnectPeerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pub_key */ 1:
                    message.pubKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisconnectPeerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pub_key = 1; */
        if (message.pubKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DisconnectPeerRequest
 */
export const DisconnectPeerRequest = new DisconnectPeerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectPeerResponse$Type extends MessageType<DisconnectPeerResponse> {
    constructor() {
        super("lnrpc.DisconnectPeerResponse", []);
    }
    create(value?: PartialMessage<DisconnectPeerResponse>): DisconnectPeerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisconnectPeerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectPeerResponse): DisconnectPeerResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DisconnectPeerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DisconnectPeerResponse
 */
export const DisconnectPeerResponse = new DisconnectPeerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTLC$Type extends MessageType<HTLC> {
    constructor() {
        super("lnrpc.HTLC", [
            { no: 1, name: "incoming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "hash_lock", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "expiration_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "htlc_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "forwarding_channel", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "forwarding_htlc_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HTLC>): HTLC {
        const message = { incoming: false, amount: 0n, hashLock: new Uint8Array(0), expirationHeight: 0, htlcIndex: 0n, forwardingChannel: 0n, forwardingHtlcIndex: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTLC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTLC): HTLC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool incoming */ 1:
                    message.incoming = reader.bool();
                    break;
                case /* int64 amount */ 2:
                    message.amount = reader.int64().toBigInt();
                    break;
                case /* bytes hash_lock */ 3:
                    message.hashLock = reader.bytes();
                    break;
                case /* uint32 expiration_height */ 4:
                    message.expirationHeight = reader.uint32();
                    break;
                case /* uint64 htlc_index */ 5:
                    message.htlcIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 forwarding_channel */ 6:
                    message.forwardingChannel = reader.uint64().toBigInt();
                    break;
                case /* uint64 forwarding_htlc_index */ 7:
                    message.forwardingHtlcIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool incoming = 1; */
        if (message.incoming !== false)
            writer.tag(1, WireType.Varint).bool(message.incoming);
        /* int64 amount = 2; */
        if (message.amount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amount);
        /* bytes hash_lock = 3; */
        if (message.hashLock.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hashLock);
        /* uint32 expiration_height = 4; */
        if (message.expirationHeight !== 0)
            writer.tag(4, WireType.Varint).uint32(message.expirationHeight);
        /* uint64 htlc_index = 5; */
        if (message.htlcIndex !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.htlcIndex);
        /* uint64 forwarding_channel = 6; */
        if (message.forwardingChannel !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.forwardingChannel);
        /* uint64 forwarding_htlc_index = 7; */
        if (message.forwardingHtlcIndex !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.forwardingHtlcIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.HTLC
 */
export const HTLC = new HTLC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelConstraints$Type extends MessageType<ChannelConstraints> {
    constructor() {
        super("lnrpc.ChannelConstraints", [
            { no: 1, name: "csv_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chan_reserve_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "dust_limit_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "max_pending_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "min_htlc_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "max_accepted_htlcs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelConstraints>): ChannelConstraints {
        const message = { csvDelay: 0, chanReserveSat: 0n, dustLimitSat: 0n, maxPendingAmtMsat: 0n, minHtlcMsat: 0n, maxAcceptedHtlcs: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelConstraints): ChannelConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 csv_delay */ 1:
                    message.csvDelay = reader.uint32();
                    break;
                case /* uint64 chan_reserve_sat */ 2:
                    message.chanReserveSat = reader.uint64().toBigInt();
                    break;
                case /* uint64 dust_limit_sat */ 3:
                    message.dustLimitSat = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_pending_amt_msat */ 4:
                    message.maxPendingAmtMsat = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_htlc_msat */ 5:
                    message.minHtlcMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 max_accepted_htlcs */ 6:
                    message.maxAcceptedHtlcs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 csv_delay = 1; */
        if (message.csvDelay !== 0)
            writer.tag(1, WireType.Varint).uint32(message.csvDelay);
        /* uint64 chan_reserve_sat = 2; */
        if (message.chanReserveSat !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.chanReserveSat);
        /* uint64 dust_limit_sat = 3; */
        if (message.dustLimitSat !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.dustLimitSat);
        /* uint64 max_pending_amt_msat = 4; */
        if (message.maxPendingAmtMsat !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.maxPendingAmtMsat);
        /* uint64 min_htlc_msat = 5; */
        if (message.minHtlcMsat !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.minHtlcMsat);
        /* uint32 max_accepted_htlcs = 6; */
        if (message.maxAcceptedHtlcs !== 0)
            writer.tag(6, WireType.Varint).uint32(message.maxAcceptedHtlcs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelConstraints
 */
export const ChannelConstraints = new ChannelConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Channel$Type extends MessageType<Channel> {
    constructor() {
        super("lnrpc.Channel", [
            { no: 1, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "remote_pubkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channel_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "local_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "remote_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "commit_fee", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "commit_weight", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "fee_per_kw", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "unsettled_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "total_satoshis_sent", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "total_satoshis_received", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "num_updates", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "pending_htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HTLC },
            { no: 16, name: "csv_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "private", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "initiator", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "chan_status_flags", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "local_chan_reserve_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "remote_chan_reserve_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "static_remote_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "commitment_type", kind: "enum", T: () => ["lnrpc.CommitmentType", CommitmentType] },
            { no: 23, name: "lifetime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 24, name: "uptime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 25, name: "close_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "push_amount_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 28, name: "thaw_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "local_constraints", kind: "message", T: () => ChannelConstraints },
            { no: 30, name: "remote_constraints", kind: "message", T: () => ChannelConstraints },
            { no: 31, name: "alias_scids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 32, name: "zero_conf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "zero_conf_confirmed_scid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Channel>): Channel {
        const message = { active: false, remotePubkey: "", channelPoint: "", chanId: "0", capacity: 0n, localBalance: 0n, remoteBalance: 0n, commitFee: 0n, commitWeight: 0n, feePerKw: 0n, unsettledBalance: 0n, totalSatoshisSent: 0n, totalSatoshisReceived: 0n, numUpdates: 0n, pendingHtlcs: [], csvDelay: 0, private: false, initiator: false, chanStatusFlags: "", localChanReserveSat: 0n, remoteChanReserveSat: 0n, staticRemoteKey: false, commitmentType: 0, lifetime: 0n, uptime: 0n, closeAddress: "", pushAmountSat: 0n, thawHeight: 0, aliasScids: [], zeroConf: false, zeroConfConfirmedScid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Channel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Channel): Channel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool active */ 1:
                    message.active = reader.bool();
                    break;
                case /* string remote_pubkey */ 2:
                    message.remotePubkey = reader.string();
                    break;
                case /* string channel_point */ 3:
                    message.channelPoint = reader.string();
                    break;
                case /* uint64 chan_id = 4 [jstype = JS_STRING];*/ 4:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* int64 capacity */ 5:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* int64 local_balance */ 6:
                    message.localBalance = reader.int64().toBigInt();
                    break;
                case /* int64 remote_balance */ 7:
                    message.remoteBalance = reader.int64().toBigInt();
                    break;
                case /* int64 commit_fee */ 8:
                    message.commitFee = reader.int64().toBigInt();
                    break;
                case /* int64 commit_weight */ 9:
                    message.commitWeight = reader.int64().toBigInt();
                    break;
                case /* int64 fee_per_kw */ 10:
                    message.feePerKw = reader.int64().toBigInt();
                    break;
                case /* int64 unsettled_balance */ 11:
                    message.unsettledBalance = reader.int64().toBigInt();
                    break;
                case /* int64 total_satoshis_sent */ 12:
                    message.totalSatoshisSent = reader.int64().toBigInt();
                    break;
                case /* int64 total_satoshis_received */ 13:
                    message.totalSatoshisReceived = reader.int64().toBigInt();
                    break;
                case /* uint64 num_updates */ 14:
                    message.numUpdates = reader.uint64().toBigInt();
                    break;
                case /* repeated lnrpc.HTLC pending_htlcs */ 15:
                    message.pendingHtlcs.push(HTLC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 csv_delay = 16 [deprecated = true];*/ 16:
                    message.csvDelay = reader.uint32();
                    break;
                case /* bool private */ 17:
                    message.private = reader.bool();
                    break;
                case /* bool initiator */ 18:
                    message.initiator = reader.bool();
                    break;
                case /* string chan_status_flags */ 19:
                    message.chanStatusFlags = reader.string();
                    break;
                case /* int64 local_chan_reserve_sat = 20 [deprecated = true];*/ 20:
                    message.localChanReserveSat = reader.int64().toBigInt();
                    break;
                case /* int64 remote_chan_reserve_sat = 21 [deprecated = true];*/ 21:
                    message.remoteChanReserveSat = reader.int64().toBigInt();
                    break;
                case /* bool static_remote_key = 22 [deprecated = true];*/ 22:
                    message.staticRemoteKey = reader.bool();
                    break;
                case /* lnrpc.CommitmentType commitment_type */ 26:
                    message.commitmentType = reader.int32();
                    break;
                case /* int64 lifetime */ 23:
                    message.lifetime = reader.int64().toBigInt();
                    break;
                case /* int64 uptime */ 24:
                    message.uptime = reader.int64().toBigInt();
                    break;
                case /* string close_address */ 25:
                    message.closeAddress = reader.string();
                    break;
                case /* uint64 push_amount_sat */ 27:
                    message.pushAmountSat = reader.uint64().toBigInt();
                    break;
                case /* uint32 thaw_height */ 28:
                    message.thawHeight = reader.uint32();
                    break;
                case /* lnrpc.ChannelConstraints local_constraints */ 29:
                    message.localConstraints = ChannelConstraints.internalBinaryRead(reader, reader.uint32(), options, message.localConstraints);
                    break;
                case /* lnrpc.ChannelConstraints remote_constraints */ 30:
                    message.remoteConstraints = ChannelConstraints.internalBinaryRead(reader, reader.uint32(), options, message.remoteConstraints);
                    break;
                case /* repeated uint64 alias_scids */ 31:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aliasScids.push(reader.uint64().toBigInt());
                    else
                        message.aliasScids.push(reader.uint64().toBigInt());
                    break;
                case /* bool zero_conf */ 32:
                    message.zeroConf = reader.bool();
                    break;
                case /* uint64 zero_conf_confirmed_scid */ 33:
                    message.zeroConfConfirmedScid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Channel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool active = 1; */
        if (message.active !== false)
            writer.tag(1, WireType.Varint).bool(message.active);
        /* string remote_pubkey = 2; */
        if (message.remotePubkey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remotePubkey);
        /* string channel_point = 3; */
        if (message.channelPoint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.channelPoint);
        /* uint64 chan_id = 4 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(4, WireType.Varint).uint64(message.chanId);
        /* int64 capacity = 5; */
        if (message.capacity !== 0n)
            writer.tag(5, WireType.Varint).int64(message.capacity);
        /* int64 local_balance = 6; */
        if (message.localBalance !== 0n)
            writer.tag(6, WireType.Varint).int64(message.localBalance);
        /* int64 remote_balance = 7; */
        if (message.remoteBalance !== 0n)
            writer.tag(7, WireType.Varint).int64(message.remoteBalance);
        /* int64 commit_fee = 8; */
        if (message.commitFee !== 0n)
            writer.tag(8, WireType.Varint).int64(message.commitFee);
        /* int64 commit_weight = 9; */
        if (message.commitWeight !== 0n)
            writer.tag(9, WireType.Varint).int64(message.commitWeight);
        /* int64 fee_per_kw = 10; */
        if (message.feePerKw !== 0n)
            writer.tag(10, WireType.Varint).int64(message.feePerKw);
        /* int64 unsettled_balance = 11; */
        if (message.unsettledBalance !== 0n)
            writer.tag(11, WireType.Varint).int64(message.unsettledBalance);
        /* int64 total_satoshis_sent = 12; */
        if (message.totalSatoshisSent !== 0n)
            writer.tag(12, WireType.Varint).int64(message.totalSatoshisSent);
        /* int64 total_satoshis_received = 13; */
        if (message.totalSatoshisReceived !== 0n)
            writer.tag(13, WireType.Varint).int64(message.totalSatoshisReceived);
        /* uint64 num_updates = 14; */
        if (message.numUpdates !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.numUpdates);
        /* repeated lnrpc.HTLC pending_htlcs = 15; */
        for (let i = 0; i < message.pendingHtlcs.length; i++)
            HTLC.internalBinaryWrite(message.pendingHtlcs[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* uint32 csv_delay = 16 [deprecated = true]; */
        if (message.csvDelay !== 0)
            writer.tag(16, WireType.Varint).uint32(message.csvDelay);
        /* bool private = 17; */
        if (message.private !== false)
            writer.tag(17, WireType.Varint).bool(message.private);
        /* bool initiator = 18; */
        if (message.initiator !== false)
            writer.tag(18, WireType.Varint).bool(message.initiator);
        /* string chan_status_flags = 19; */
        if (message.chanStatusFlags !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.chanStatusFlags);
        /* int64 local_chan_reserve_sat = 20 [deprecated = true]; */
        if (message.localChanReserveSat !== 0n)
            writer.tag(20, WireType.Varint).int64(message.localChanReserveSat);
        /* int64 remote_chan_reserve_sat = 21 [deprecated = true]; */
        if (message.remoteChanReserveSat !== 0n)
            writer.tag(21, WireType.Varint).int64(message.remoteChanReserveSat);
        /* bool static_remote_key = 22 [deprecated = true]; */
        if (message.staticRemoteKey !== false)
            writer.tag(22, WireType.Varint).bool(message.staticRemoteKey);
        /* lnrpc.CommitmentType commitment_type = 26; */
        if (message.commitmentType !== 0)
            writer.tag(26, WireType.Varint).int32(message.commitmentType);
        /* int64 lifetime = 23; */
        if (message.lifetime !== 0n)
            writer.tag(23, WireType.Varint).int64(message.lifetime);
        /* int64 uptime = 24; */
        if (message.uptime !== 0n)
            writer.tag(24, WireType.Varint).int64(message.uptime);
        /* string close_address = 25; */
        if (message.closeAddress !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.closeAddress);
        /* uint64 push_amount_sat = 27; */
        if (message.pushAmountSat !== 0n)
            writer.tag(27, WireType.Varint).uint64(message.pushAmountSat);
        /* uint32 thaw_height = 28; */
        if (message.thawHeight !== 0)
            writer.tag(28, WireType.Varint).uint32(message.thawHeight);
        /* lnrpc.ChannelConstraints local_constraints = 29; */
        if (message.localConstraints)
            ChannelConstraints.internalBinaryWrite(message.localConstraints, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelConstraints remote_constraints = 30; */
        if (message.remoteConstraints)
            ChannelConstraints.internalBinaryWrite(message.remoteConstraints, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 alias_scids = 31; */
        if (message.aliasScids.length) {
            writer.tag(31, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aliasScids.length; i++)
                writer.uint64(message.aliasScids[i]);
            writer.join();
        }
        /* bool zero_conf = 32; */
        if (message.zeroConf !== false)
            writer.tag(32, WireType.Varint).bool(message.zeroConf);
        /* uint64 zero_conf_confirmed_scid = 33; */
        if (message.zeroConfConfirmedScid !== 0n)
            writer.tag(33, WireType.Varint).uint64(message.zeroConfConfirmedScid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Channel
 */
export const Channel = new Channel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListChannelsRequest$Type extends MessageType<ListChannelsRequest> {
    constructor() {
        super("lnrpc.ListChannelsRequest", [
            { no: 1, name: "active_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "inactive_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "public_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "private_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "peer", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ListChannelsRequest>): ListChannelsRequest {
        const message = { activeOnly: false, inactiveOnly: false, publicOnly: false, privateOnly: false, peer: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListChannelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListChannelsRequest): ListChannelsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool active_only */ 1:
                    message.activeOnly = reader.bool();
                    break;
                case /* bool inactive_only */ 2:
                    message.inactiveOnly = reader.bool();
                    break;
                case /* bool public_only */ 3:
                    message.publicOnly = reader.bool();
                    break;
                case /* bool private_only */ 4:
                    message.privateOnly = reader.bool();
                    break;
                case /* bytes peer */ 5:
                    message.peer = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool active_only = 1; */
        if (message.activeOnly !== false)
            writer.tag(1, WireType.Varint).bool(message.activeOnly);
        /* bool inactive_only = 2; */
        if (message.inactiveOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.inactiveOnly);
        /* bool public_only = 3; */
        if (message.publicOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.publicOnly);
        /* bool private_only = 4; */
        if (message.privateOnly !== false)
            writer.tag(4, WireType.Varint).bool(message.privateOnly);
        /* bytes peer = 5; */
        if (message.peer.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.peer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListChannelsRequest
 */
export const ListChannelsRequest = new ListChannelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListChannelsResponse$Type extends MessageType<ListChannelsResponse> {
    constructor() {
        super("lnrpc.ListChannelsResponse", [
            { no: 11, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Channel }
        ]);
    }
    create(value?: PartialMessage<ListChannelsResponse>): ListChannelsResponse {
        const message = { channels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListChannelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListChannelsResponse): ListChannelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Channel channels */ 11:
                    message.channels.push(Channel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Channel channels = 11; */
        for (let i = 0; i < message.channels.length; i++)
            Channel.internalBinaryWrite(message.channels[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListChannelsResponse
 */
export const ListChannelsResponse = new ListChannelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AliasMap$Type extends MessageType<AliasMap> {
    constructor() {
        super("lnrpc.AliasMap", [
            { no: 1, name: "base_scid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "aliases", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AliasMap>): AliasMap {
        const message = { baseScid: 0n, aliases: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AliasMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AliasMap): AliasMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 base_scid */ 1:
                    message.baseScid = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 aliases */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aliases.push(reader.uint64().toBigInt());
                    else
                        message.aliases.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AliasMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 base_scid = 1; */
        if (message.baseScid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.baseScid);
        /* repeated uint64 aliases = 2; */
        if (message.aliases.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aliases.length; i++)
                writer.uint64(message.aliases[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AliasMap
 */
export const AliasMap = new AliasMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAliasesRequest$Type extends MessageType<ListAliasesRequest> {
    constructor() {
        super("lnrpc.ListAliasesRequest", []);
    }
    create(value?: PartialMessage<ListAliasesRequest>): ListAliasesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListAliasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAliasesRequest): ListAliasesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListAliasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListAliasesRequest
 */
export const ListAliasesRequest = new ListAliasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAliasesResponse$Type extends MessageType<ListAliasesResponse> {
    constructor() {
        super("lnrpc.ListAliasesResponse", [
            { no: 1, name: "alias_maps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AliasMap }
        ]);
    }
    create(value?: PartialMessage<ListAliasesResponse>): ListAliasesResponse {
        const message = { aliasMaps: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListAliasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAliasesResponse): ListAliasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.AliasMap alias_maps */ 1:
                    message.aliasMaps.push(AliasMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAliasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.AliasMap alias_maps = 1; */
        for (let i = 0; i < message.aliasMaps.length; i++)
            AliasMap.internalBinaryWrite(message.aliasMaps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListAliasesResponse
 */
export const ListAliasesResponse = new ListAliasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelCloseSummary$Type extends MessageType<ChannelCloseSummary> {
    constructor() {
        super("lnrpc.ChannelCloseSummary", [
            { no: 1, name: "channel_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "chain_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "closing_tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "remote_pubkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "close_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "settled_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "time_locked_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "close_type", kind: "enum", T: () => ["lnrpc.ChannelCloseSummary.ClosureType", ChannelCloseSummary_ClosureType] },
            { no: 11, name: "open_initiator", kind: "enum", T: () => ["lnrpc.Initiator", Initiator, "INITIATOR_"] },
            { no: 12, name: "close_initiator", kind: "enum", T: () => ["lnrpc.Initiator", Initiator, "INITIATOR_"] },
            { no: 13, name: "resolutions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Resolution },
            { no: 14, name: "alias_scids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "zero_conf_confirmed_scid", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelCloseSummary>): ChannelCloseSummary {
        const message = { channelPoint: "", chanId: "0", chainHash: "", closingTxHash: "", remotePubkey: "", capacity: 0n, closeHeight: 0, settledBalance: 0n, timeLockedBalance: 0n, closeType: 0, openInitiator: 0, closeInitiator: 0, resolutions: [], aliasScids: [], zeroConfConfirmedScid: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelCloseSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelCloseSummary): ChannelCloseSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string channel_point */ 1:
                    message.channelPoint = reader.string();
                    break;
                case /* uint64 chan_id = 2 [jstype = JS_STRING];*/ 2:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* string chain_hash */ 3:
                    message.chainHash = reader.string();
                    break;
                case /* string closing_tx_hash */ 4:
                    message.closingTxHash = reader.string();
                    break;
                case /* string remote_pubkey */ 5:
                    message.remotePubkey = reader.string();
                    break;
                case /* int64 capacity */ 6:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* uint32 close_height */ 7:
                    message.closeHeight = reader.uint32();
                    break;
                case /* int64 settled_balance */ 8:
                    message.settledBalance = reader.int64().toBigInt();
                    break;
                case /* int64 time_locked_balance */ 9:
                    message.timeLockedBalance = reader.int64().toBigInt();
                    break;
                case /* lnrpc.ChannelCloseSummary.ClosureType close_type */ 10:
                    message.closeType = reader.int32();
                    break;
                case /* lnrpc.Initiator open_initiator */ 11:
                    message.openInitiator = reader.int32();
                    break;
                case /* lnrpc.Initiator close_initiator */ 12:
                    message.closeInitiator = reader.int32();
                    break;
                case /* repeated lnrpc.Resolution resolutions */ 13:
                    message.resolutions.push(Resolution.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint64 alias_scids */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aliasScids.push(reader.uint64().toBigInt());
                    else
                        message.aliasScids.push(reader.uint64().toBigInt());
                    break;
                case /* uint64 zero_conf_confirmed_scid = 15 [jstype = JS_STRING];*/ 15:
                    message.zeroConfConfirmedScid = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelCloseSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string channel_point = 1; */
        if (message.channelPoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelPoint);
        /* uint64 chan_id = 2 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.chanId);
        /* string chain_hash = 3; */
        if (message.chainHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.chainHash);
        /* string closing_tx_hash = 4; */
        if (message.closingTxHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.closingTxHash);
        /* string remote_pubkey = 5; */
        if (message.remotePubkey !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.remotePubkey);
        /* int64 capacity = 6; */
        if (message.capacity !== 0n)
            writer.tag(6, WireType.Varint).int64(message.capacity);
        /* uint32 close_height = 7; */
        if (message.closeHeight !== 0)
            writer.tag(7, WireType.Varint).uint32(message.closeHeight);
        /* int64 settled_balance = 8; */
        if (message.settledBalance !== 0n)
            writer.tag(8, WireType.Varint).int64(message.settledBalance);
        /* int64 time_locked_balance = 9; */
        if (message.timeLockedBalance !== 0n)
            writer.tag(9, WireType.Varint).int64(message.timeLockedBalance);
        /* lnrpc.ChannelCloseSummary.ClosureType close_type = 10; */
        if (message.closeType !== 0)
            writer.tag(10, WireType.Varint).int32(message.closeType);
        /* lnrpc.Initiator open_initiator = 11; */
        if (message.openInitiator !== 0)
            writer.tag(11, WireType.Varint).int32(message.openInitiator);
        /* lnrpc.Initiator close_initiator = 12; */
        if (message.closeInitiator !== 0)
            writer.tag(12, WireType.Varint).int32(message.closeInitiator);
        /* repeated lnrpc.Resolution resolutions = 13; */
        for (let i = 0; i < message.resolutions.length; i++)
            Resolution.internalBinaryWrite(message.resolutions[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 alias_scids = 14; */
        if (message.aliasScids.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aliasScids.length; i++)
                writer.uint64(message.aliasScids[i]);
            writer.join();
        }
        /* uint64 zero_conf_confirmed_scid = 15 [jstype = JS_STRING]; */
        if (message.zeroConfConfirmedScid !== "0")
            writer.tag(15, WireType.Varint).uint64(message.zeroConfConfirmedScid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelCloseSummary
 */
export const ChannelCloseSummary = new ChannelCloseSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resolution$Type extends MessageType<Resolution> {
    constructor() {
        super("lnrpc.Resolution", [
            { no: 1, name: "resolution_type", kind: "enum", T: () => ["lnrpc.ResolutionType", ResolutionType] },
            { no: 2, name: "outcome", kind: "enum", T: () => ["lnrpc.ResolutionOutcome", ResolutionOutcome] },
            { no: 3, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 4, name: "amount_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "sweep_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Resolution>): Resolution {
        const message = { resolutionType: 0, outcome: 0, amountSat: 0n, sweepTxid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Resolution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resolution): Resolution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ResolutionType resolution_type */ 1:
                    message.resolutionType = reader.int32();
                    break;
                case /* lnrpc.ResolutionOutcome outcome */ 2:
                    message.outcome = reader.int32();
                    break;
                case /* lnrpc.OutPoint outpoint */ 3:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* uint64 amount_sat */ 4:
                    message.amountSat = reader.uint64().toBigInt();
                    break;
                case /* string sweep_txid */ 5:
                    message.sweepTxid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resolution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ResolutionType resolution_type = 1; */
        if (message.resolutionType !== 0)
            writer.tag(1, WireType.Varint).int32(message.resolutionType);
        /* lnrpc.ResolutionOutcome outcome = 2; */
        if (message.outcome !== 0)
            writer.tag(2, WireType.Varint).int32(message.outcome);
        /* lnrpc.OutPoint outpoint = 3; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 amount_sat = 4; */
        if (message.amountSat !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.amountSat);
        /* string sweep_txid = 5; */
        if (message.sweepTxid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sweepTxid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Resolution
 */
export const Resolution = new Resolution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClosedChannelsRequest$Type extends MessageType<ClosedChannelsRequest> {
    constructor() {
        super("lnrpc.ClosedChannelsRequest", [
            { no: 1, name: "cooperative", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "local_force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "remote_force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "breach", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "funding_canceled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "abandoned", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClosedChannelsRequest>): ClosedChannelsRequest {
        const message = { cooperative: false, localForce: false, remoteForce: false, breach: false, fundingCanceled: false, abandoned: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClosedChannelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClosedChannelsRequest): ClosedChannelsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool cooperative */ 1:
                    message.cooperative = reader.bool();
                    break;
                case /* bool local_force */ 2:
                    message.localForce = reader.bool();
                    break;
                case /* bool remote_force */ 3:
                    message.remoteForce = reader.bool();
                    break;
                case /* bool breach */ 4:
                    message.breach = reader.bool();
                    break;
                case /* bool funding_canceled */ 5:
                    message.fundingCanceled = reader.bool();
                    break;
                case /* bool abandoned */ 6:
                    message.abandoned = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClosedChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool cooperative = 1; */
        if (message.cooperative !== false)
            writer.tag(1, WireType.Varint).bool(message.cooperative);
        /* bool local_force = 2; */
        if (message.localForce !== false)
            writer.tag(2, WireType.Varint).bool(message.localForce);
        /* bool remote_force = 3; */
        if (message.remoteForce !== false)
            writer.tag(3, WireType.Varint).bool(message.remoteForce);
        /* bool breach = 4; */
        if (message.breach !== false)
            writer.tag(4, WireType.Varint).bool(message.breach);
        /* bool funding_canceled = 5; */
        if (message.fundingCanceled !== false)
            writer.tag(5, WireType.Varint).bool(message.fundingCanceled);
        /* bool abandoned = 6; */
        if (message.abandoned !== false)
            writer.tag(6, WireType.Varint).bool(message.abandoned);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ClosedChannelsRequest
 */
export const ClosedChannelsRequest = new ClosedChannelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClosedChannelsResponse$Type extends MessageType<ClosedChannelsResponse> {
    constructor() {
        super("lnrpc.ClosedChannelsResponse", [
            { no: 1, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelCloseSummary }
        ]);
    }
    create(value?: PartialMessage<ClosedChannelsResponse>): ClosedChannelsResponse {
        const message = { channels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClosedChannelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClosedChannelsResponse): ClosedChannelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.ChannelCloseSummary channels */ 1:
                    message.channels.push(ChannelCloseSummary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClosedChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.ChannelCloseSummary channels = 1; */
        for (let i = 0; i < message.channels.length; i++)
            ChannelCloseSummary.internalBinaryWrite(message.channels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ClosedChannelsResponse
 */
export const ClosedChannelsResponse = new ClosedChannelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Peer$Type extends MessageType<Peer> {
    constructor() {
        super("lnrpc.Peer", [
            { no: 1, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "bytes_sent", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "bytes_recv", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "sat_sent", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "sat_recv", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "inbound", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "ping_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "sync_type", kind: "enum", T: () => ["lnrpc.Peer.SyncType", Peer_SyncType] },
            { no: 11, name: "features", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => Feature } },
            { no: 12, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TimestampedError },
            { no: 13, name: "flap_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "last_flap_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "last_ping_payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Peer>): Peer {
        const message = { pubKey: "", address: "", bytesSent: 0n, bytesRecv: 0n, satSent: 0n, satRecv: 0n, inbound: false, pingTime: 0n, syncType: 0, features: {}, errors: [], flapCount: 0, lastFlapNs: 0n, lastPingPayload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Peer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Peer): Peer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pub_key */ 1:
                    message.pubKey = reader.string();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* uint64 bytes_sent */ 4:
                    message.bytesSent = reader.uint64().toBigInt();
                    break;
                case /* uint64 bytes_recv */ 5:
                    message.bytesRecv = reader.uint64().toBigInt();
                    break;
                case /* int64 sat_sent */ 6:
                    message.satSent = reader.int64().toBigInt();
                    break;
                case /* int64 sat_recv */ 7:
                    message.satRecv = reader.int64().toBigInt();
                    break;
                case /* bool inbound */ 8:
                    message.inbound = reader.bool();
                    break;
                case /* int64 ping_time */ 9:
                    message.pingTime = reader.int64().toBigInt();
                    break;
                case /* lnrpc.Peer.SyncType sync_type */ 10:
                    message.syncType = reader.int32();
                    break;
                case /* map<uint32, lnrpc.Feature> features */ 11:
                    this.binaryReadMap11(message.features, reader, options);
                    break;
                case /* repeated lnrpc.TimestampedError errors */ 12:
                    message.errors.push(TimestampedError.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 flap_count */ 13:
                    message.flapCount = reader.int32();
                    break;
                case /* int64 last_flap_ns */ 14:
                    message.lastFlapNs = reader.int64().toBigInt();
                    break;
                case /* bytes last_ping_payload */ 15:
                    message.lastPingPayload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: Peer["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Peer["features"] | undefined, val: Peer["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = Feature.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.Peer.features");
            }
        }
        map[key ?? 0] = val ?? Feature.create();
    }
    internalBinaryWrite(message: Peer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pub_key = 1; */
        if (message.pubKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubKey);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* uint64 bytes_sent = 4; */
        if (message.bytesSent !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.bytesSent);
        /* uint64 bytes_recv = 5; */
        if (message.bytesRecv !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.bytesRecv);
        /* int64 sat_sent = 6; */
        if (message.satSent !== 0n)
            writer.tag(6, WireType.Varint).int64(message.satSent);
        /* int64 sat_recv = 7; */
        if (message.satRecv !== 0n)
            writer.tag(7, WireType.Varint).int64(message.satRecv);
        /* bool inbound = 8; */
        if (message.inbound !== false)
            writer.tag(8, WireType.Varint).bool(message.inbound);
        /* int64 ping_time = 9; */
        if (message.pingTime !== 0n)
            writer.tag(9, WireType.Varint).int64(message.pingTime);
        /* lnrpc.Peer.SyncType sync_type = 10; */
        if (message.syncType !== 0)
            writer.tag(10, WireType.Varint).int32(message.syncType);
        /* map<uint32, lnrpc.Feature> features = 11; */
        for (let k of Object.keys(message.features)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Feature.internalBinaryWrite(message.features[k as any], writer, options);
            writer.join().join();
        }
        /* repeated lnrpc.TimestampedError errors = 12; */
        for (let i = 0; i < message.errors.length; i++)
            TimestampedError.internalBinaryWrite(message.errors[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* int32 flap_count = 13; */
        if (message.flapCount !== 0)
            writer.tag(13, WireType.Varint).int32(message.flapCount);
        /* int64 last_flap_ns = 14; */
        if (message.lastFlapNs !== 0n)
            writer.tag(14, WireType.Varint).int64(message.lastFlapNs);
        /* bytes last_ping_payload = 15; */
        if (message.lastPingPayload.length)
            writer.tag(15, WireType.LengthDelimited).bytes(message.lastPingPayload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Peer
 */
export const Peer = new Peer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimestampedError$Type extends MessageType<TimestampedError> {
    constructor() {
        super("lnrpc.TimestampedError", [
            { no: 1, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TimestampedError>): TimestampedError {
        const message = { timestamp: 0n, error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimestampedError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimestampedError): TimestampedError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp */ 1:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimestampedError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestamp);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.TimestampedError
 */
export const TimestampedError = new TimestampedError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPeersRequest$Type extends MessageType<ListPeersRequest> {
    constructor() {
        super("lnrpc.ListPeersRequest", [
            { no: 1, name: "latest_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListPeersRequest>): ListPeersRequest {
        const message = { latestError: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPeersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPeersRequest): ListPeersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool latest_error */ 1:
                    message.latestError = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPeersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool latest_error = 1; */
        if (message.latestError !== false)
            writer.tag(1, WireType.Varint).bool(message.latestError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPeersRequest
 */
export const ListPeersRequest = new ListPeersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPeersResponse$Type extends MessageType<ListPeersResponse> {
    constructor() {
        super("lnrpc.ListPeersResponse", [
            { no: 1, name: "peers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Peer }
        ]);
    }
    create(value?: PartialMessage<ListPeersResponse>): ListPeersResponse {
        const message = { peers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPeersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPeersResponse): ListPeersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Peer peers */ 1:
                    message.peers.push(Peer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPeersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Peer peers = 1; */
        for (let i = 0; i < message.peers.length; i++)
            Peer.internalBinaryWrite(message.peers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPeersResponse
 */
export const ListPeersResponse = new ListPeersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeerEventSubscription$Type extends MessageType<PeerEventSubscription> {
    constructor() {
        super("lnrpc.PeerEventSubscription", []);
    }
    create(value?: PartialMessage<PeerEventSubscription>): PeerEventSubscription {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PeerEventSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerEventSubscription): PeerEventSubscription {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PeerEventSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PeerEventSubscription
 */
export const PeerEventSubscription = new PeerEventSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeerEvent$Type extends MessageType<PeerEvent> {
    constructor() {
        super("lnrpc.PeerEvent", [
            { no: 1, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["lnrpc.PeerEvent.EventType", PeerEvent_EventType] }
        ]);
    }
    create(value?: PartialMessage<PeerEvent>): PeerEvent {
        const message = { pubKey: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PeerEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerEvent): PeerEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pub_key */ 1:
                    message.pubKey = reader.string();
                    break;
                case /* lnrpc.PeerEvent.EventType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeerEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pub_key = 1; */
        if (message.pubKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubKey);
        /* lnrpc.PeerEvent.EventType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PeerEvent
 */
export const PeerEvent = new PeerEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoRequest$Type extends MessageType<GetInfoRequest> {
    constructor() {
        super("lnrpc.GetInfoRequest", []);
    }
    create(value?: PartialMessage<GetInfoRequest>): GetInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoRequest): GetInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GetInfoRequest
 */
export const GetInfoRequest = new GetInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoResponse$Type extends MessageType<GetInfoResponse> {
    constructor() {
        super("lnrpc.GetInfoResponse", [
            { no: 14, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "commit_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "identity_pubkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "alias", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "num_pending_channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "num_active_channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "num_inactive_channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "num_peers", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "block_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "block_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "best_header_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "synced_to_chain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "synced_to_graph", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "testnet", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "chains", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Chain },
            { no: 12, name: "uris", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "features", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => Feature } },
            { no: 21, name: "require_htlc_interceptor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetInfoResponse>): GetInfoResponse {
        const message = { version: "", commitHash: "", identityPubkey: "", alias: "", color: "", numPendingChannels: 0, numActiveChannels: 0, numInactiveChannels: 0, numPeers: 0, blockHeight: 0, blockHash: "", bestHeaderTimestamp: 0n, syncedToChain: false, syncedToGraph: false, testnet: false, chains: [], uris: [], features: {}, requireHtlcInterceptor: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoResponse): GetInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 14:
                    message.version = reader.string();
                    break;
                case /* string commit_hash */ 20:
                    message.commitHash = reader.string();
                    break;
                case /* string identity_pubkey */ 1:
                    message.identityPubkey = reader.string();
                    break;
                case /* string alias */ 2:
                    message.alias = reader.string();
                    break;
                case /* string color */ 17:
                    message.color = reader.string();
                    break;
                case /* uint32 num_pending_channels */ 3:
                    message.numPendingChannels = reader.uint32();
                    break;
                case /* uint32 num_active_channels */ 4:
                    message.numActiveChannels = reader.uint32();
                    break;
                case /* uint32 num_inactive_channels */ 15:
                    message.numInactiveChannels = reader.uint32();
                    break;
                case /* uint32 num_peers */ 5:
                    message.numPeers = reader.uint32();
                    break;
                case /* uint32 block_height */ 6:
                    message.blockHeight = reader.uint32();
                    break;
                case /* string block_hash */ 8:
                    message.blockHash = reader.string();
                    break;
                case /* int64 best_header_timestamp */ 13:
                    message.bestHeaderTimestamp = reader.int64().toBigInt();
                    break;
                case /* bool synced_to_chain */ 9:
                    message.syncedToChain = reader.bool();
                    break;
                case /* bool synced_to_graph */ 18:
                    message.syncedToGraph = reader.bool();
                    break;
                case /* bool testnet = 10 [deprecated = true];*/ 10:
                    message.testnet = reader.bool();
                    break;
                case /* repeated lnrpc.Chain chains */ 16:
                    message.chains.push(Chain.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string uris */ 12:
                    message.uris.push(reader.string());
                    break;
                case /* map<uint32, lnrpc.Feature> features */ 19:
                    this.binaryReadMap19(message.features, reader, options);
                    break;
                case /* bool require_htlc_interceptor */ 21:
                    message.requireHtlcInterceptor = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap19(map: GetInfoResponse["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetInfoResponse["features"] | undefined, val: GetInfoResponse["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = Feature.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.GetInfoResponse.features");
            }
        }
        map[key ?? 0] = val ?? Feature.create();
    }
    internalBinaryWrite(message: GetInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 14; */
        if (message.version !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.version);
        /* string commit_hash = 20; */
        if (message.commitHash !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.commitHash);
        /* string identity_pubkey = 1; */
        if (message.identityPubkey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.identityPubkey);
        /* string alias = 2; */
        if (message.alias !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.alias);
        /* string color = 17; */
        if (message.color !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.color);
        /* uint32 num_pending_channels = 3; */
        if (message.numPendingChannels !== 0)
            writer.tag(3, WireType.Varint).uint32(message.numPendingChannels);
        /* uint32 num_active_channels = 4; */
        if (message.numActiveChannels !== 0)
            writer.tag(4, WireType.Varint).uint32(message.numActiveChannels);
        /* uint32 num_inactive_channels = 15; */
        if (message.numInactiveChannels !== 0)
            writer.tag(15, WireType.Varint).uint32(message.numInactiveChannels);
        /* uint32 num_peers = 5; */
        if (message.numPeers !== 0)
            writer.tag(5, WireType.Varint).uint32(message.numPeers);
        /* uint32 block_height = 6; */
        if (message.blockHeight !== 0)
            writer.tag(6, WireType.Varint).uint32(message.blockHeight);
        /* string block_hash = 8; */
        if (message.blockHash !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.blockHash);
        /* int64 best_header_timestamp = 13; */
        if (message.bestHeaderTimestamp !== 0n)
            writer.tag(13, WireType.Varint).int64(message.bestHeaderTimestamp);
        /* bool synced_to_chain = 9; */
        if (message.syncedToChain !== false)
            writer.tag(9, WireType.Varint).bool(message.syncedToChain);
        /* bool synced_to_graph = 18; */
        if (message.syncedToGraph !== false)
            writer.tag(18, WireType.Varint).bool(message.syncedToGraph);
        /* bool testnet = 10 [deprecated = true]; */
        if (message.testnet !== false)
            writer.tag(10, WireType.Varint).bool(message.testnet);
        /* repeated lnrpc.Chain chains = 16; */
        for (let i = 0; i < message.chains.length; i++)
            Chain.internalBinaryWrite(message.chains[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated string uris = 12; */
        for (let i = 0; i < message.uris.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.uris[i]);
        /* map<uint32, lnrpc.Feature> features = 19; */
        for (let k of Object.keys(message.features)) {
            writer.tag(19, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Feature.internalBinaryWrite(message.features[k as any], writer, options);
            writer.join().join();
        }
        /* bool require_htlc_interceptor = 21; */
        if (message.requireHtlcInterceptor !== false)
            writer.tag(21, WireType.Varint).bool(message.requireHtlcInterceptor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GetInfoResponse
 */
export const GetInfoResponse = new GetInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRecoveryInfoRequest$Type extends MessageType<GetRecoveryInfoRequest> {
    constructor() {
        super("lnrpc.GetRecoveryInfoRequest", []);
    }
    create(value?: PartialMessage<GetRecoveryInfoRequest>): GetRecoveryInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRecoveryInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRecoveryInfoRequest): GetRecoveryInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetRecoveryInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GetRecoveryInfoRequest
 */
export const GetRecoveryInfoRequest = new GetRecoveryInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRecoveryInfoResponse$Type extends MessageType<GetRecoveryInfoResponse> {
    constructor() {
        super("lnrpc.GetRecoveryInfoResponse", [
            { no: 1, name: "recovery_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "recovery_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "progress", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<GetRecoveryInfoResponse>): GetRecoveryInfoResponse {
        const message = { recoveryMode: false, recoveryFinished: false, progress: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRecoveryInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRecoveryInfoResponse): GetRecoveryInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool recovery_mode */ 1:
                    message.recoveryMode = reader.bool();
                    break;
                case /* bool recovery_finished */ 2:
                    message.recoveryFinished = reader.bool();
                    break;
                case /* double progress */ 3:
                    message.progress = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRecoveryInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool recovery_mode = 1; */
        if (message.recoveryMode !== false)
            writer.tag(1, WireType.Varint).bool(message.recoveryMode);
        /* bool recovery_finished = 2; */
        if (message.recoveryFinished !== false)
            writer.tag(2, WireType.Varint).bool(message.recoveryFinished);
        /* double progress = 3; */
        if (message.progress !== 0)
            writer.tag(3, WireType.Bit64).double(message.progress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GetRecoveryInfoResponse
 */
export const GetRecoveryInfoResponse = new GetRecoveryInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chain$Type extends MessageType<Chain> {
    constructor() {
        super("lnrpc.Chain", [
            { no: 1, name: "chain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Chain>): Chain {
        const message = { chain: "", network: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Chain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chain): Chain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string chain */ 1:
                    message.chain = reader.string();
                    break;
                case /* string network */ 2:
                    message.network = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string chain = 1; */
        if (message.chain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.chain);
        /* string network = 2; */
        if (message.network !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.network);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Chain
 */
export const Chain = new Chain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfirmationUpdate$Type extends MessageType<ConfirmationUpdate> {
    constructor() {
        super("lnrpc.ConfirmationUpdate", [
            { no: 1, name: "block_sha", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "block_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "num_confs_left", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConfirmationUpdate>): ConfirmationUpdate {
        const message = { blockSha: new Uint8Array(0), blockHeight: 0, numConfsLeft: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfirmationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfirmationUpdate): ConfirmationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes block_sha */ 1:
                    message.blockSha = reader.bytes();
                    break;
                case /* int32 block_height */ 2:
                    message.blockHeight = reader.int32();
                    break;
                case /* uint32 num_confs_left */ 3:
                    message.numConfsLeft = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfirmationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes block_sha = 1; */
        if (message.blockSha.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.blockSha);
        /* int32 block_height = 2; */
        if (message.blockHeight !== 0)
            writer.tag(2, WireType.Varint).int32(message.blockHeight);
        /* uint32 num_confs_left = 3; */
        if (message.numConfsLeft !== 0)
            writer.tag(3, WireType.Varint).uint32(message.numConfsLeft);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ConfirmationUpdate
 */
export const ConfirmationUpdate = new ConfirmationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelOpenUpdate$Type extends MessageType<ChannelOpenUpdate> {
    constructor() {
        super("lnrpc.ChannelOpenUpdate", [
            { no: 1, name: "channel_point", kind: "message", T: () => ChannelPoint }
        ]);
    }
    create(value?: PartialMessage<ChannelOpenUpdate>): ChannelOpenUpdate {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelOpenUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelOpenUpdate): ChannelOpenUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint channel_point */ 1:
                    message.channelPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.channelPoint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelOpenUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint channel_point = 1; */
        if (message.channelPoint)
            ChannelPoint.internalBinaryWrite(message.channelPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelOpenUpdate
 */
export const ChannelOpenUpdate = new ChannelOpenUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelCloseUpdate$Type extends MessageType<ChannelCloseUpdate> {
    constructor() {
        super("lnrpc.ChannelCloseUpdate", [
            { no: 1, name: "closing_txid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelCloseUpdate>): ChannelCloseUpdate {
        const message = { closingTxid: new Uint8Array(0), success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelCloseUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelCloseUpdate): ChannelCloseUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes closing_txid */ 1:
                    message.closingTxid = reader.bytes();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelCloseUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes closing_txid = 1; */
        if (message.closingTxid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.closingTxid);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelCloseUpdate
 */
export const ChannelCloseUpdate = new ChannelCloseUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseChannelRequest$Type extends MessageType<CloseChannelRequest> {
    constructor() {
        super("lnrpc.CloseChannelRequest", [
            { no: 1, name: "channel_point", kind: "message", T: () => ChannelPoint },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "target_conf", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sat_per_byte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "delivery_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "max_fee_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CloseChannelRequest>): CloseChannelRequest {
        const message = { force: false, targetConf: 0, satPerByte: 0n, deliveryAddress: "", satPerVbyte: 0n, maxFeePerVbyte: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseChannelRequest): CloseChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint channel_point */ 1:
                    message.channelPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.channelPoint);
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                case /* int32 target_conf */ 3:
                    message.targetConf = reader.int32();
                    break;
                case /* int64 sat_per_byte = 4 [deprecated = true];*/ 4:
                    message.satPerByte = reader.int64().toBigInt();
                    break;
                case /* string delivery_address */ 5:
                    message.deliveryAddress = reader.string();
                    break;
                case /* uint64 sat_per_vbyte */ 6:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_fee_per_vbyte */ 7:
                    message.maxFeePerVbyte = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint channel_point = 1; */
        if (message.channelPoint)
            ChannelPoint.internalBinaryWrite(message.channelPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        /* int32 target_conf = 3; */
        if (message.targetConf !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetConf);
        /* int64 sat_per_byte = 4 [deprecated = true]; */
        if (message.satPerByte !== 0n)
            writer.tag(4, WireType.Varint).int64(message.satPerByte);
        /* string delivery_address = 5; */
        if (message.deliveryAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.deliveryAddress);
        /* uint64 sat_per_vbyte = 6; */
        if (message.satPerVbyte !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.satPerVbyte);
        /* uint64 max_fee_per_vbyte = 7; */
        if (message.maxFeePerVbyte !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.maxFeePerVbyte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.CloseChannelRequest
 */
export const CloseChannelRequest = new CloseChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseStatusUpdate$Type extends MessageType<CloseStatusUpdate> {
    constructor() {
        super("lnrpc.CloseStatusUpdate", [
            { no: 1, name: "close_pending", kind: "message", oneof: "update", T: () => PendingUpdate },
            { no: 3, name: "chan_close", kind: "message", oneof: "update", T: () => ChannelCloseUpdate }
        ]);
    }
    create(value?: PartialMessage<CloseStatusUpdate>): CloseStatusUpdate {
        const message = { update: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseStatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseStatusUpdate): CloseStatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.PendingUpdate close_pending */ 1:
                    message.update = {
                        oneofKind: "closePending",
                        closePending: PendingUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).closePending)
                    };
                    break;
                case /* lnrpc.ChannelCloseUpdate chan_close */ 3:
                    message.update = {
                        oneofKind: "chanClose",
                        chanClose: ChannelCloseUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).chanClose)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseStatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.PendingUpdate close_pending = 1; */
        if (message.update.oneofKind === "closePending")
            PendingUpdate.internalBinaryWrite(message.update.closePending, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelCloseUpdate chan_close = 3; */
        if (message.update.oneofKind === "chanClose")
            ChannelCloseUpdate.internalBinaryWrite(message.update.chanClose, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.CloseStatusUpdate
 */
export const CloseStatusUpdate = new CloseStatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingUpdate$Type extends MessageType<PendingUpdate> {
    constructor() {
        super("lnrpc.PendingUpdate", [
            { no: 1, name: "txid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "output_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PendingUpdate>): PendingUpdate {
        const message = { txid: new Uint8Array(0), outputIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingUpdate): PendingUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes txid */ 1:
                    message.txid = reader.bytes();
                    break;
                case /* uint32 output_index */ 2:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes txid = 1; */
        if (message.txid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txid);
        /* uint32 output_index = 2; */
        if (message.outputIndex !== 0)
            writer.tag(2, WireType.Varint).uint32(message.outputIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingUpdate
 */
export const PendingUpdate = new PendingUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadyForPsbtFunding$Type extends MessageType<ReadyForPsbtFunding> {
    constructor() {
        super("lnrpc.ReadyForPsbtFunding", [
            { no: 1, name: "funding_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "funding_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ReadyForPsbtFunding>): ReadyForPsbtFunding {
        const message = { fundingAddress: "", fundingAmount: 0n, psbt: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadyForPsbtFunding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadyForPsbtFunding): ReadyForPsbtFunding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string funding_address */ 1:
                    message.fundingAddress = reader.string();
                    break;
                case /* int64 funding_amount */ 2:
                    message.fundingAmount = reader.int64().toBigInt();
                    break;
                case /* bytes psbt */ 3:
                    message.psbt = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadyForPsbtFunding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string funding_address = 1; */
        if (message.fundingAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fundingAddress);
        /* int64 funding_amount = 2; */
        if (message.fundingAmount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.fundingAmount);
        /* bytes psbt = 3; */
        if (message.psbt.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.psbt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ReadyForPsbtFunding
 */
export const ReadyForPsbtFunding = new ReadyForPsbtFunding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchOpenChannelRequest$Type extends MessageType<BatchOpenChannelRequest> {
    constructor() {
        super("lnrpc.BatchOpenChannelRequest", [
            { no: 1, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BatchOpenChannel },
            { no: 2, name: "target_conf", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sat_per_vbyte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BatchOpenChannelRequest>): BatchOpenChannelRequest {
        const message = { channels: [], targetConf: 0, satPerVbyte: 0n, minConfs: 0, spendUnconfirmed: false, label: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchOpenChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOpenChannelRequest): BatchOpenChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.BatchOpenChannel channels */ 1:
                    message.channels.push(BatchOpenChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 target_conf */ 2:
                    message.targetConf = reader.int32();
                    break;
                case /* int64 sat_per_vbyte */ 3:
                    message.satPerVbyte = reader.int64().toBigInt();
                    break;
                case /* int32 min_confs */ 4:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 5:
                    message.spendUnconfirmed = reader.bool();
                    break;
                case /* string label */ 6:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchOpenChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.BatchOpenChannel channels = 1; */
        for (let i = 0; i < message.channels.length; i++)
            BatchOpenChannel.internalBinaryWrite(message.channels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 target_conf = 2; */
        if (message.targetConf !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetConf);
        /* int64 sat_per_vbyte = 3; */
        if (message.satPerVbyte !== 0n)
            writer.tag(3, WireType.Varint).int64(message.satPerVbyte);
        /* int32 min_confs = 4; */
        if (message.minConfs !== 0)
            writer.tag(4, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 5; */
        if (message.spendUnconfirmed !== false)
            writer.tag(5, WireType.Varint).bool(message.spendUnconfirmed);
        /* string label = 6; */
        if (message.label !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.BatchOpenChannelRequest
 */
export const BatchOpenChannelRequest = new BatchOpenChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchOpenChannel$Type extends MessageType<BatchOpenChannel> {
    constructor() {
        super("lnrpc.BatchOpenChannel", [
            { no: 1, name: "node_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "local_funding_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "push_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "private", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "min_htlc_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "remote_csv_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "close_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "commitment_type", kind: "enum", T: () => ["lnrpc.CommitmentType", CommitmentType] }
        ]);
    }
    create(value?: PartialMessage<BatchOpenChannel>): BatchOpenChannel {
        const message = { nodePubkey: new Uint8Array(0), localFundingAmount: 0n, pushSat: 0n, private: false, minHtlcMsat: 0n, remoteCsvDelay: 0, closeAddress: "", pendingChanId: new Uint8Array(0), commitmentType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchOpenChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOpenChannel): BatchOpenChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes node_pubkey */ 1:
                    message.nodePubkey = reader.bytes();
                    break;
                case /* int64 local_funding_amount */ 2:
                    message.localFundingAmount = reader.int64().toBigInt();
                    break;
                case /* int64 push_sat */ 3:
                    message.pushSat = reader.int64().toBigInt();
                    break;
                case /* bool private */ 4:
                    message.private = reader.bool();
                    break;
                case /* int64 min_htlc_msat */ 5:
                    message.minHtlcMsat = reader.int64().toBigInt();
                    break;
                case /* uint32 remote_csv_delay */ 6:
                    message.remoteCsvDelay = reader.uint32();
                    break;
                case /* string close_address */ 7:
                    message.closeAddress = reader.string();
                    break;
                case /* bytes pending_chan_id */ 8:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* lnrpc.CommitmentType commitment_type */ 9:
                    message.commitmentType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchOpenChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes node_pubkey = 1; */
        if (message.nodePubkey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nodePubkey);
        /* int64 local_funding_amount = 2; */
        if (message.localFundingAmount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.localFundingAmount);
        /* int64 push_sat = 3; */
        if (message.pushSat !== 0n)
            writer.tag(3, WireType.Varint).int64(message.pushSat);
        /* bool private = 4; */
        if (message.private !== false)
            writer.tag(4, WireType.Varint).bool(message.private);
        /* int64 min_htlc_msat = 5; */
        if (message.minHtlcMsat !== 0n)
            writer.tag(5, WireType.Varint).int64(message.minHtlcMsat);
        /* uint32 remote_csv_delay = 6; */
        if (message.remoteCsvDelay !== 0)
            writer.tag(6, WireType.Varint).uint32(message.remoteCsvDelay);
        /* string close_address = 7; */
        if (message.closeAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.closeAddress);
        /* bytes pending_chan_id = 8; */
        if (message.pendingChanId.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* lnrpc.CommitmentType commitment_type = 9; */
        if (message.commitmentType !== 0)
            writer.tag(9, WireType.Varint).int32(message.commitmentType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.BatchOpenChannel
 */
export const BatchOpenChannel = new BatchOpenChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchOpenChannelResponse$Type extends MessageType<BatchOpenChannelResponse> {
    constructor() {
        super("lnrpc.BatchOpenChannelResponse", [
            { no: 1, name: "pending_channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingUpdate }
        ]);
    }
    create(value?: PartialMessage<BatchOpenChannelResponse>): BatchOpenChannelResponse {
        const message = { pendingChannels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchOpenChannelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOpenChannelResponse): BatchOpenChannelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.PendingUpdate pending_channels */ 1:
                    message.pendingChannels.push(PendingUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchOpenChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.PendingUpdate pending_channels = 1; */
        for (let i = 0; i < message.pendingChannels.length; i++)
            PendingUpdate.internalBinaryWrite(message.pendingChannels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.BatchOpenChannelResponse
 */
export const BatchOpenChannelResponse = new BatchOpenChannelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenChannelRequest$Type extends MessageType<OpenChannelRequest> {
    constructor() {
        super("lnrpc.OpenChannelRequest", [
            { no: 1, name: "sat_per_vbyte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "node_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "node_pubkey_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "local_funding_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "push_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "target_conf", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "sat_per_byte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "private", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "min_htlc_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "remote_csv_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "min_confs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "spend_unconfirmed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "close_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "funding_shim", kind: "message", T: () => FundingShim },
            { no: 15, name: "remote_max_value_in_flight_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "remote_max_htlcs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "max_local_csv", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "commitment_type", kind: "enum", T: () => ["lnrpc.CommitmentType", CommitmentType] },
            { no: 19, name: "zero_conf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "scid_alias", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "base_fee", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "fee_rate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 23, name: "use_base_fee", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "use_fee_rate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "remote_chan_reserve_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OpenChannelRequest>): OpenChannelRequest {
        const message = { satPerVbyte: 0n, nodePubkey: new Uint8Array(0), nodePubkeyString: "", localFundingAmount: 0n, pushSat: 0n, targetConf: 0, satPerByte: 0n, private: false, minHtlcMsat: 0n, remoteCsvDelay: 0, minConfs: 0, spendUnconfirmed: false, closeAddress: "", remoteMaxValueInFlightMsat: 0n, remoteMaxHtlcs: 0, maxLocalCsv: 0, commitmentType: 0, zeroConf: false, scidAlias: false, baseFee: 0n, feeRate: 0n, useBaseFee: false, useFeeRate: false, remoteChanReserveSat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenChannelRequest): OpenChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 sat_per_vbyte */ 1:
                    message.satPerVbyte = reader.uint64().toBigInt();
                    break;
                case /* bytes node_pubkey */ 2:
                    message.nodePubkey = reader.bytes();
                    break;
                case /* string node_pubkey_string = 3 [deprecated = true];*/ 3:
                    message.nodePubkeyString = reader.string();
                    break;
                case /* int64 local_funding_amount */ 4:
                    message.localFundingAmount = reader.int64().toBigInt();
                    break;
                case /* int64 push_sat */ 5:
                    message.pushSat = reader.int64().toBigInt();
                    break;
                case /* int32 target_conf */ 6:
                    message.targetConf = reader.int32();
                    break;
                case /* int64 sat_per_byte = 7 [deprecated = true];*/ 7:
                    message.satPerByte = reader.int64().toBigInt();
                    break;
                case /* bool private */ 8:
                    message.private = reader.bool();
                    break;
                case /* int64 min_htlc_msat */ 9:
                    message.minHtlcMsat = reader.int64().toBigInt();
                    break;
                case /* uint32 remote_csv_delay */ 10:
                    message.remoteCsvDelay = reader.uint32();
                    break;
                case /* int32 min_confs */ 11:
                    message.minConfs = reader.int32();
                    break;
                case /* bool spend_unconfirmed */ 12:
                    message.spendUnconfirmed = reader.bool();
                    break;
                case /* string close_address */ 13:
                    message.closeAddress = reader.string();
                    break;
                case /* lnrpc.FundingShim funding_shim */ 14:
                    message.fundingShim = FundingShim.internalBinaryRead(reader, reader.uint32(), options, message.fundingShim);
                    break;
                case /* uint64 remote_max_value_in_flight_msat */ 15:
                    message.remoteMaxValueInFlightMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 remote_max_htlcs */ 16:
                    message.remoteMaxHtlcs = reader.uint32();
                    break;
                case /* uint32 max_local_csv */ 17:
                    message.maxLocalCsv = reader.uint32();
                    break;
                case /* lnrpc.CommitmentType commitment_type */ 18:
                    message.commitmentType = reader.int32();
                    break;
                case /* bool zero_conf */ 19:
                    message.zeroConf = reader.bool();
                    break;
                case /* bool scid_alias */ 20:
                    message.scidAlias = reader.bool();
                    break;
                case /* uint64 base_fee */ 21:
                    message.baseFee = reader.uint64().toBigInt();
                    break;
                case /* uint64 fee_rate */ 22:
                    message.feeRate = reader.uint64().toBigInt();
                    break;
                case /* bool use_base_fee */ 23:
                    message.useBaseFee = reader.bool();
                    break;
                case /* bool use_fee_rate */ 24:
                    message.useFeeRate = reader.bool();
                    break;
                case /* uint64 remote_chan_reserve_sat */ 25:
                    message.remoteChanReserveSat = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 sat_per_vbyte = 1; */
        if (message.satPerVbyte !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.satPerVbyte);
        /* bytes node_pubkey = 2; */
        if (message.nodePubkey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.nodePubkey);
        /* string node_pubkey_string = 3 [deprecated = true]; */
        if (message.nodePubkeyString !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nodePubkeyString);
        /* int64 local_funding_amount = 4; */
        if (message.localFundingAmount !== 0n)
            writer.tag(4, WireType.Varint).int64(message.localFundingAmount);
        /* int64 push_sat = 5; */
        if (message.pushSat !== 0n)
            writer.tag(5, WireType.Varint).int64(message.pushSat);
        /* int32 target_conf = 6; */
        if (message.targetConf !== 0)
            writer.tag(6, WireType.Varint).int32(message.targetConf);
        /* int64 sat_per_byte = 7 [deprecated = true]; */
        if (message.satPerByte !== 0n)
            writer.tag(7, WireType.Varint).int64(message.satPerByte);
        /* bool private = 8; */
        if (message.private !== false)
            writer.tag(8, WireType.Varint).bool(message.private);
        /* int64 min_htlc_msat = 9; */
        if (message.minHtlcMsat !== 0n)
            writer.tag(9, WireType.Varint).int64(message.minHtlcMsat);
        /* uint32 remote_csv_delay = 10; */
        if (message.remoteCsvDelay !== 0)
            writer.tag(10, WireType.Varint).uint32(message.remoteCsvDelay);
        /* int32 min_confs = 11; */
        if (message.minConfs !== 0)
            writer.tag(11, WireType.Varint).int32(message.minConfs);
        /* bool spend_unconfirmed = 12; */
        if (message.spendUnconfirmed !== false)
            writer.tag(12, WireType.Varint).bool(message.spendUnconfirmed);
        /* string close_address = 13; */
        if (message.closeAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.closeAddress);
        /* lnrpc.FundingShim funding_shim = 14; */
        if (message.fundingShim)
            FundingShim.internalBinaryWrite(message.fundingShim, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint64 remote_max_value_in_flight_msat = 15; */
        if (message.remoteMaxValueInFlightMsat !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.remoteMaxValueInFlightMsat);
        /* uint32 remote_max_htlcs = 16; */
        if (message.remoteMaxHtlcs !== 0)
            writer.tag(16, WireType.Varint).uint32(message.remoteMaxHtlcs);
        /* uint32 max_local_csv = 17; */
        if (message.maxLocalCsv !== 0)
            writer.tag(17, WireType.Varint).uint32(message.maxLocalCsv);
        /* lnrpc.CommitmentType commitment_type = 18; */
        if (message.commitmentType !== 0)
            writer.tag(18, WireType.Varint).int32(message.commitmentType);
        /* bool zero_conf = 19; */
        if (message.zeroConf !== false)
            writer.tag(19, WireType.Varint).bool(message.zeroConf);
        /* bool scid_alias = 20; */
        if (message.scidAlias !== false)
            writer.tag(20, WireType.Varint).bool(message.scidAlias);
        /* uint64 base_fee = 21; */
        if (message.baseFee !== 0n)
            writer.tag(21, WireType.Varint).uint64(message.baseFee);
        /* uint64 fee_rate = 22; */
        if (message.feeRate !== 0n)
            writer.tag(22, WireType.Varint).uint64(message.feeRate);
        /* bool use_base_fee = 23; */
        if (message.useBaseFee !== false)
            writer.tag(23, WireType.Varint).bool(message.useBaseFee);
        /* bool use_fee_rate = 24; */
        if (message.useFeeRate !== false)
            writer.tag(24, WireType.Varint).bool(message.useFeeRate);
        /* uint64 remote_chan_reserve_sat = 25; */
        if (message.remoteChanReserveSat !== 0n)
            writer.tag(25, WireType.Varint).uint64(message.remoteChanReserveSat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.OpenChannelRequest
 */
export const OpenChannelRequest = new OpenChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenStatusUpdate$Type extends MessageType<OpenStatusUpdate> {
    constructor() {
        super("lnrpc.OpenStatusUpdate", [
            { no: 1, name: "chan_pending", kind: "message", oneof: "update", T: () => PendingUpdate },
            { no: 3, name: "chan_open", kind: "message", oneof: "update", T: () => ChannelOpenUpdate },
            { no: 5, name: "psbt_fund", kind: "message", oneof: "update", T: () => ReadyForPsbtFunding },
            { no: 4, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<OpenStatusUpdate>): OpenStatusUpdate {
        const message = { update: { oneofKind: undefined }, pendingChanId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenStatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenStatusUpdate): OpenStatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.PendingUpdate chan_pending */ 1:
                    message.update = {
                        oneofKind: "chanPending",
                        chanPending: PendingUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).chanPending)
                    };
                    break;
                case /* lnrpc.ChannelOpenUpdate chan_open */ 3:
                    message.update = {
                        oneofKind: "chanOpen",
                        chanOpen: ChannelOpenUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).chanOpen)
                    };
                    break;
                case /* lnrpc.ReadyForPsbtFunding psbt_fund */ 5:
                    message.update = {
                        oneofKind: "psbtFund",
                        psbtFund: ReadyForPsbtFunding.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).psbtFund)
                    };
                    break;
                case /* bytes pending_chan_id */ 4:
                    message.pendingChanId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenStatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.PendingUpdate chan_pending = 1; */
        if (message.update.oneofKind === "chanPending")
            PendingUpdate.internalBinaryWrite(message.update.chanPending, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelOpenUpdate chan_open = 3; */
        if (message.update.oneofKind === "chanOpen")
            ChannelOpenUpdate.internalBinaryWrite(message.update.chanOpen, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ReadyForPsbtFunding psbt_fund = 5; */
        if (message.update.oneofKind === "psbtFund")
            ReadyForPsbtFunding.internalBinaryWrite(message.update.psbtFund, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bytes pending_chan_id = 4; */
        if (message.pendingChanId.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.pendingChanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.OpenStatusUpdate
 */
export const OpenStatusUpdate = new OpenStatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyLocator$Type extends MessageType<KeyLocator> {
    constructor() {
        super("lnrpc.KeyLocator", [
            { no: 1, name: "key_family", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "key_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<KeyLocator>): KeyLocator {
        const message = { keyFamily: 0, keyIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyLocator): KeyLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 key_family */ 1:
                    message.keyFamily = reader.int32();
                    break;
                case /* int32 key_index */ 2:
                    message.keyIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 key_family = 1; */
        if (message.keyFamily !== 0)
            writer.tag(1, WireType.Varint).int32(message.keyFamily);
        /* int32 key_index = 2; */
        if (message.keyIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.keyIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.KeyLocator
 */
export const KeyLocator = new KeyLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyDescriptor$Type extends MessageType<KeyDescriptor> {
    constructor() {
        super("lnrpc.KeyDescriptor", [
            { no: 1, name: "raw_key_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key_loc", kind: "message", T: () => KeyLocator }
        ]);
    }
    create(value?: PartialMessage<KeyDescriptor>): KeyDescriptor {
        const message = { rawKeyBytes: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyDescriptor): KeyDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes raw_key_bytes */ 1:
                    message.rawKeyBytes = reader.bytes();
                    break;
                case /* lnrpc.KeyLocator key_loc */ 2:
                    message.keyLoc = KeyLocator.internalBinaryRead(reader, reader.uint32(), options, message.keyLoc);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes raw_key_bytes = 1; */
        if (message.rawKeyBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rawKeyBytes);
        /* lnrpc.KeyLocator key_loc = 2; */
        if (message.keyLoc)
            KeyLocator.internalBinaryWrite(message.keyLoc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.KeyDescriptor
 */
export const KeyDescriptor = new KeyDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChanPointShim$Type extends MessageType<ChanPointShim> {
    constructor() {
        super("lnrpc.ChanPointShim", [
            { no: 1, name: "amt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chan_point", kind: "message", T: () => ChannelPoint },
            { no: 3, name: "local_key", kind: "message", T: () => KeyDescriptor },
            { no: 4, name: "remote_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "thaw_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChanPointShim>): ChanPointShim {
        const message = { amt: 0n, remoteKey: new Uint8Array(0), pendingChanId: new Uint8Array(0), thawHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChanPointShim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanPointShim): ChanPointShim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 amt */ 1:
                    message.amt = reader.int64().toBigInt();
                    break;
                case /* lnrpc.ChannelPoint chan_point */ 2:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* lnrpc.KeyDescriptor local_key */ 3:
                    message.localKey = KeyDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.localKey);
                    break;
                case /* bytes remote_key */ 4:
                    message.remoteKey = reader.bytes();
                    break;
                case /* bytes pending_chan_id */ 5:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* uint32 thaw_height */ 6:
                    message.thawHeight = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChanPointShim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 amt = 1; */
        if (message.amt !== 0n)
            writer.tag(1, WireType.Varint).int64(message.amt);
        /* lnrpc.ChannelPoint chan_point = 2; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.KeyDescriptor local_key = 3; */
        if (message.localKey)
            KeyDescriptor.internalBinaryWrite(message.localKey, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes remote_key = 4; */
        if (message.remoteKey.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.remoteKey);
        /* bytes pending_chan_id = 5; */
        if (message.pendingChanId.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* uint32 thaw_height = 6; */
        if (message.thawHeight !== 0)
            writer.tag(6, WireType.Varint).uint32(message.thawHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanPointShim
 */
export const ChanPointShim = new ChanPointShim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PsbtShim$Type extends MessageType<PsbtShim> {
    constructor() {
        super("lnrpc.PsbtShim", [
            { no: 1, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "base_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "no_publish", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PsbtShim>): PsbtShim {
        const message = { pendingChanId: new Uint8Array(0), basePsbt: new Uint8Array(0), noPublish: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PsbtShim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PsbtShim): PsbtShim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pending_chan_id */ 1:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* bytes base_psbt */ 2:
                    message.basePsbt = reader.bytes();
                    break;
                case /* bool no_publish */ 3:
                    message.noPublish = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PsbtShim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pending_chan_id = 1; */
        if (message.pendingChanId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* bytes base_psbt = 2; */
        if (message.basePsbt.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.basePsbt);
        /* bool no_publish = 3; */
        if (message.noPublish !== false)
            writer.tag(3, WireType.Varint).bool(message.noPublish);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PsbtShim
 */
export const PsbtShim = new PsbtShim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingShim$Type extends MessageType<FundingShim> {
    constructor() {
        super("lnrpc.FundingShim", [
            { no: 1, name: "chan_point_shim", kind: "message", oneof: "shim", T: () => ChanPointShim },
            { no: 2, name: "psbt_shim", kind: "message", oneof: "shim", T: () => PsbtShim }
        ]);
    }
    create(value?: PartialMessage<FundingShim>): FundingShim {
        const message = { shim: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundingShim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingShim): FundingShim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChanPointShim chan_point_shim */ 1:
                    message.shim = {
                        oneofKind: "chanPointShim",
                        chanPointShim: ChanPointShim.internalBinaryRead(reader, reader.uint32(), options, (message.shim as any).chanPointShim)
                    };
                    break;
                case /* lnrpc.PsbtShim psbt_shim */ 2:
                    message.shim = {
                        oneofKind: "psbtShim",
                        psbtShim: PsbtShim.internalBinaryRead(reader, reader.uint32(), options, (message.shim as any).psbtShim)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingShim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChanPointShim chan_point_shim = 1; */
        if (message.shim.oneofKind === "chanPointShim")
            ChanPointShim.internalBinaryWrite(message.shim.chanPointShim, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.PsbtShim psbt_shim = 2; */
        if (message.shim.oneofKind === "psbtShim")
            PsbtShim.internalBinaryWrite(message.shim.psbtShim, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingShim
 */
export const FundingShim = new FundingShim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingShimCancel$Type extends MessageType<FundingShimCancel> {
    constructor() {
        super("lnrpc.FundingShimCancel", [
            { no: 1, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FundingShimCancel>): FundingShimCancel {
        const message = { pendingChanId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundingShimCancel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingShimCancel): FundingShimCancel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pending_chan_id */ 1:
                    message.pendingChanId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingShimCancel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pending_chan_id = 1; */
        if (message.pendingChanId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pendingChanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingShimCancel
 */
export const FundingShimCancel = new FundingShimCancel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPsbtVerify$Type extends MessageType<FundingPsbtVerify> {
    constructor() {
        super("lnrpc.FundingPsbtVerify", [
            { no: 1, name: "funded_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "skip_finalize", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FundingPsbtVerify>): FundingPsbtVerify {
        const message = { fundedPsbt: new Uint8Array(0), pendingChanId: new Uint8Array(0), skipFinalize: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundingPsbtVerify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPsbtVerify): FundingPsbtVerify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes funded_psbt */ 1:
                    message.fundedPsbt = reader.bytes();
                    break;
                case /* bytes pending_chan_id */ 2:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* bool skip_finalize */ 3:
                    message.skipFinalize = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPsbtVerify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes funded_psbt = 1; */
        if (message.fundedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fundedPsbt);
        /* bytes pending_chan_id = 2; */
        if (message.pendingChanId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* bool skip_finalize = 3; */
        if (message.skipFinalize !== false)
            writer.tag(3, WireType.Varint).bool(message.skipFinalize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingPsbtVerify
 */
export const FundingPsbtVerify = new FundingPsbtVerify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPsbtFinalize$Type extends MessageType<FundingPsbtFinalize> {
    constructor() {
        super("lnrpc.FundingPsbtFinalize", [
            { no: 1, name: "signed_psbt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pending_chan_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "final_raw_tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FundingPsbtFinalize>): FundingPsbtFinalize {
        const message = { signedPsbt: new Uint8Array(0), pendingChanId: new Uint8Array(0), finalRawTx: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundingPsbtFinalize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPsbtFinalize): FundingPsbtFinalize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signed_psbt */ 1:
                    message.signedPsbt = reader.bytes();
                    break;
                case /* bytes pending_chan_id */ 2:
                    message.pendingChanId = reader.bytes();
                    break;
                case /* bytes final_raw_tx */ 3:
                    message.finalRawTx = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPsbtFinalize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signed_psbt = 1; */
        if (message.signedPsbt.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signedPsbt);
        /* bytes pending_chan_id = 2; */
        if (message.pendingChanId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pendingChanId);
        /* bytes final_raw_tx = 3; */
        if (message.finalRawTx.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.finalRawTx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingPsbtFinalize
 */
export const FundingPsbtFinalize = new FundingPsbtFinalize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingTransitionMsg$Type extends MessageType<FundingTransitionMsg> {
    constructor() {
        super("lnrpc.FundingTransitionMsg", [
            { no: 1, name: "shim_register", kind: "message", oneof: "trigger", T: () => FundingShim },
            { no: 2, name: "shim_cancel", kind: "message", oneof: "trigger", T: () => FundingShimCancel },
            { no: 3, name: "psbt_verify", kind: "message", oneof: "trigger", T: () => FundingPsbtVerify },
            { no: 4, name: "psbt_finalize", kind: "message", oneof: "trigger", T: () => FundingPsbtFinalize }
        ]);
    }
    create(value?: PartialMessage<FundingTransitionMsg>): FundingTransitionMsg {
        const message = { trigger: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundingTransitionMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingTransitionMsg): FundingTransitionMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.FundingShim shim_register */ 1:
                    message.trigger = {
                        oneofKind: "shimRegister",
                        shimRegister: FundingShim.internalBinaryRead(reader, reader.uint32(), options, (message.trigger as any).shimRegister)
                    };
                    break;
                case /* lnrpc.FundingShimCancel shim_cancel */ 2:
                    message.trigger = {
                        oneofKind: "shimCancel",
                        shimCancel: FundingShimCancel.internalBinaryRead(reader, reader.uint32(), options, (message.trigger as any).shimCancel)
                    };
                    break;
                case /* lnrpc.FundingPsbtVerify psbt_verify */ 3:
                    message.trigger = {
                        oneofKind: "psbtVerify",
                        psbtVerify: FundingPsbtVerify.internalBinaryRead(reader, reader.uint32(), options, (message.trigger as any).psbtVerify)
                    };
                    break;
                case /* lnrpc.FundingPsbtFinalize psbt_finalize */ 4:
                    message.trigger = {
                        oneofKind: "psbtFinalize",
                        psbtFinalize: FundingPsbtFinalize.internalBinaryRead(reader, reader.uint32(), options, (message.trigger as any).psbtFinalize)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingTransitionMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.FundingShim shim_register = 1; */
        if (message.trigger.oneofKind === "shimRegister")
            FundingShim.internalBinaryWrite(message.trigger.shimRegister, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.FundingShimCancel shim_cancel = 2; */
        if (message.trigger.oneofKind === "shimCancel")
            FundingShimCancel.internalBinaryWrite(message.trigger.shimCancel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.FundingPsbtVerify psbt_verify = 3; */
        if (message.trigger.oneofKind === "psbtVerify")
            FundingPsbtVerify.internalBinaryWrite(message.trigger.psbtVerify, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.FundingPsbtFinalize psbt_finalize = 4; */
        if (message.trigger.oneofKind === "psbtFinalize")
            FundingPsbtFinalize.internalBinaryWrite(message.trigger.psbtFinalize, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingTransitionMsg
 */
export const FundingTransitionMsg = new FundingTransitionMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingStateStepResp$Type extends MessageType<FundingStateStepResp> {
    constructor() {
        super("lnrpc.FundingStateStepResp", []);
    }
    create(value?: PartialMessage<FundingStateStepResp>): FundingStateStepResp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FundingStateStepResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingStateStepResp): FundingStateStepResp {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FundingStateStepResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FundingStateStepResp
 */
export const FundingStateStepResp = new FundingStateStepResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingHTLC$Type extends MessageType<PendingHTLC> {
    constructor() {
        super("lnrpc.PendingHTLC", [
            { no: 1, name: "incoming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "outpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "maturity_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "blocks_til_maturity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "stage", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PendingHTLC>): PendingHTLC {
        const message = { incoming: false, amount: 0n, outpoint: "", maturityHeight: 0, blocksTilMaturity: 0, stage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingHTLC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingHTLC): PendingHTLC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool incoming */ 1:
                    message.incoming = reader.bool();
                    break;
                case /* int64 amount */ 2:
                    message.amount = reader.int64().toBigInt();
                    break;
                case /* string outpoint */ 3:
                    message.outpoint = reader.string();
                    break;
                case /* uint32 maturity_height */ 4:
                    message.maturityHeight = reader.uint32();
                    break;
                case /* int32 blocks_til_maturity */ 5:
                    message.blocksTilMaturity = reader.int32();
                    break;
                case /* uint32 stage */ 6:
                    message.stage = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingHTLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool incoming = 1; */
        if (message.incoming !== false)
            writer.tag(1, WireType.Varint).bool(message.incoming);
        /* int64 amount = 2; */
        if (message.amount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amount);
        /* string outpoint = 3; */
        if (message.outpoint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.outpoint);
        /* uint32 maturity_height = 4; */
        if (message.maturityHeight !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maturityHeight);
        /* int32 blocks_til_maturity = 5; */
        if (message.blocksTilMaturity !== 0)
            writer.tag(5, WireType.Varint).int32(message.blocksTilMaturity);
        /* uint32 stage = 6; */
        if (message.stage !== 0)
            writer.tag(6, WireType.Varint).uint32(message.stage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingHTLC
 */
export const PendingHTLC = new PendingHTLC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsRequest$Type extends MessageType<PendingChannelsRequest> {
    constructor() {
        super("lnrpc.PendingChannelsRequest", []);
    }
    create(value?: PartialMessage<PendingChannelsRequest>): PendingChannelsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsRequest): PendingChannelsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PendingChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsRequest
 */
export const PendingChannelsRequest = new PendingChannelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse$Type extends MessageType<PendingChannelsResponse> {
    constructor() {
        super("lnrpc.PendingChannelsResponse", [
            { no: 1, name: "total_limbo_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "pending_open_channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingChannelsResponse_PendingOpenChannel },
            { no: 3, name: "pending_closing_channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingChannelsResponse_ClosedChannel },
            { no: 4, name: "pending_force_closing_channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingChannelsResponse_ForceClosedChannel },
            { no: 5, name: "waiting_close_channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingChannelsResponse_WaitingCloseChannel }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse>): PendingChannelsResponse {
        const message = { totalLimboBalance: 0n, pendingOpenChannels: [], pendingClosingChannels: [], pendingForceClosingChannels: [], waitingCloseChannels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse): PendingChannelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 total_limbo_balance */ 1:
                    message.totalLimboBalance = reader.int64().toBigInt();
                    break;
                case /* repeated lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels */ 2:
                    message.pendingOpenChannels.push(PendingChannelsResponse_PendingOpenChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];*/ 3:
                    message.pendingClosingChannels.push(PendingChannelsResponse_ClosedChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels */ 4:
                    message.pendingForceClosingChannels.push(PendingChannelsResponse_ForceClosedChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels */ 5:
                    message.waitingCloseChannels.push(PendingChannelsResponse_WaitingCloseChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 total_limbo_balance = 1; */
        if (message.totalLimboBalance !== 0n)
            writer.tag(1, WireType.Varint).int64(message.totalLimboBalance);
        /* repeated lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2; */
        for (let i = 0; i < message.pendingOpenChannels.length; i++)
            PendingChannelsResponse_PendingOpenChannel.internalBinaryWrite(message.pendingOpenChannels[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true]; */
        for (let i = 0; i < message.pendingClosingChannels.length; i++)
            PendingChannelsResponse_ClosedChannel.internalBinaryWrite(message.pendingClosingChannels[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4; */
        for (let i = 0; i < message.pendingForceClosingChannels.length; i++)
            PendingChannelsResponse_ForceClosedChannel.internalBinaryWrite(message.pendingForceClosingChannels[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5; */
        for (let i = 0; i < message.waitingCloseChannels.length; i++)
            PendingChannelsResponse_WaitingCloseChannel.internalBinaryWrite(message.waitingCloseChannels[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse
 */
export const PendingChannelsResponse = new PendingChannelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse_PendingChannel$Type extends MessageType<PendingChannelsResponse_PendingChannel> {
    constructor() {
        super("lnrpc.PendingChannelsResponse.PendingChannel", [
            { no: 1, name: "remote_node_pub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "local_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "remote_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "local_chan_reserve_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "remote_chan_reserve_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "initiator", kind: "enum", T: () => ["lnrpc.Initiator", Initiator, "INITIATOR_"] },
            { no: 9, name: "commitment_type", kind: "enum", T: () => ["lnrpc.CommitmentType", CommitmentType] },
            { no: 10, name: "num_forwarding_packages", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "chan_status_flags", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "private", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse_PendingChannel>): PendingChannelsResponse_PendingChannel {
        const message = { remoteNodePub: "", channelPoint: "", capacity: 0n, localBalance: 0n, remoteBalance: 0n, localChanReserveSat: 0n, remoteChanReserveSat: 0n, initiator: 0, commitmentType: 0, numForwardingPackages: 0n, chanStatusFlags: "", private: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse_PendingChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_PendingChannel): PendingChannelsResponse_PendingChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_node_pub */ 1:
                    message.remoteNodePub = reader.string();
                    break;
                case /* string channel_point */ 2:
                    message.channelPoint = reader.string();
                    break;
                case /* int64 capacity */ 3:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* int64 local_balance */ 4:
                    message.localBalance = reader.int64().toBigInt();
                    break;
                case /* int64 remote_balance */ 5:
                    message.remoteBalance = reader.int64().toBigInt();
                    break;
                case /* int64 local_chan_reserve_sat */ 6:
                    message.localChanReserveSat = reader.int64().toBigInt();
                    break;
                case /* int64 remote_chan_reserve_sat */ 7:
                    message.remoteChanReserveSat = reader.int64().toBigInt();
                    break;
                case /* lnrpc.Initiator initiator */ 8:
                    message.initiator = reader.int32();
                    break;
                case /* lnrpc.CommitmentType commitment_type */ 9:
                    message.commitmentType = reader.int32();
                    break;
                case /* int64 num_forwarding_packages */ 10:
                    message.numForwardingPackages = reader.int64().toBigInt();
                    break;
                case /* string chan_status_flags */ 11:
                    message.chanStatusFlags = reader.string();
                    break;
                case /* bool private */ 12:
                    message.private = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse_PendingChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_node_pub = 1; */
        if (message.remoteNodePub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteNodePub);
        /* string channel_point = 2; */
        if (message.channelPoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelPoint);
        /* int64 capacity = 3; */
        if (message.capacity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.capacity);
        /* int64 local_balance = 4; */
        if (message.localBalance !== 0n)
            writer.tag(4, WireType.Varint).int64(message.localBalance);
        /* int64 remote_balance = 5; */
        if (message.remoteBalance !== 0n)
            writer.tag(5, WireType.Varint).int64(message.remoteBalance);
        /* int64 local_chan_reserve_sat = 6; */
        if (message.localChanReserveSat !== 0n)
            writer.tag(6, WireType.Varint).int64(message.localChanReserveSat);
        /* int64 remote_chan_reserve_sat = 7; */
        if (message.remoteChanReserveSat !== 0n)
            writer.tag(7, WireType.Varint).int64(message.remoteChanReserveSat);
        /* lnrpc.Initiator initiator = 8; */
        if (message.initiator !== 0)
            writer.tag(8, WireType.Varint).int32(message.initiator);
        /* lnrpc.CommitmentType commitment_type = 9; */
        if (message.commitmentType !== 0)
            writer.tag(9, WireType.Varint).int32(message.commitmentType);
        /* int64 num_forwarding_packages = 10; */
        if (message.numForwardingPackages !== 0n)
            writer.tag(10, WireType.Varint).int64(message.numForwardingPackages);
        /* string chan_status_flags = 11; */
        if (message.chanStatusFlags !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.chanStatusFlags);
        /* bool private = 12; */
        if (message.private !== false)
            writer.tag(12, WireType.Varint).bool(message.private);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.PendingChannel
 */
export const PendingChannelsResponse_PendingChannel = new PendingChannelsResponse_PendingChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse_PendingOpenChannel$Type extends MessageType<PendingChannelsResponse_PendingOpenChannel> {
    constructor() {
        super("lnrpc.PendingChannelsResponse.PendingOpenChannel", [
            { no: 1, name: "channel", kind: "message", T: () => PendingChannelsResponse_PendingChannel },
            { no: 4, name: "commit_fee", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "commit_weight", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "fee_per_kw", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse_PendingOpenChannel>): PendingChannelsResponse_PendingOpenChannel {
        const message = { commitFee: 0n, commitWeight: 0n, feePerKw: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse_PendingOpenChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_PendingOpenChannel): PendingChannelsResponse_PendingOpenChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.PendingChannelsResponse.PendingChannel channel */ 1:
                    message.channel = PendingChannelsResponse_PendingChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int64 commit_fee */ 4:
                    message.commitFee = reader.int64().toBigInt();
                    break;
                case /* int64 commit_weight */ 5:
                    message.commitWeight = reader.int64().toBigInt();
                    break;
                case /* int64 fee_per_kw */ 6:
                    message.feePerKw = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse_PendingOpenChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.PendingChannelsResponse.PendingChannel channel = 1; */
        if (message.channel)
            PendingChannelsResponse_PendingChannel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 commit_fee = 4; */
        if (message.commitFee !== 0n)
            writer.tag(4, WireType.Varint).int64(message.commitFee);
        /* int64 commit_weight = 5; */
        if (message.commitWeight !== 0n)
            writer.tag(5, WireType.Varint).int64(message.commitWeight);
        /* int64 fee_per_kw = 6; */
        if (message.feePerKw !== 0n)
            writer.tag(6, WireType.Varint).int64(message.feePerKw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.PendingOpenChannel
 */
export const PendingChannelsResponse_PendingOpenChannel = new PendingChannelsResponse_PendingOpenChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse_WaitingCloseChannel$Type extends MessageType<PendingChannelsResponse_WaitingCloseChannel> {
    constructor() {
        super("lnrpc.PendingChannelsResponse.WaitingCloseChannel", [
            { no: 1, name: "channel", kind: "message", T: () => PendingChannelsResponse_PendingChannel },
            { no: 2, name: "limbo_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "commitments", kind: "message", T: () => PendingChannelsResponse_Commitments },
            { no: 4, name: "closing_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse_WaitingCloseChannel>): PendingChannelsResponse_WaitingCloseChannel {
        const message = { limboBalance: 0n, closingTxid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse_WaitingCloseChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_WaitingCloseChannel): PendingChannelsResponse_WaitingCloseChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.PendingChannelsResponse.PendingChannel channel */ 1:
                    message.channel = PendingChannelsResponse_PendingChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int64 limbo_balance */ 2:
                    message.limboBalance = reader.int64().toBigInt();
                    break;
                case /* lnrpc.PendingChannelsResponse.Commitments commitments */ 3:
                    message.commitments = PendingChannelsResponse_Commitments.internalBinaryRead(reader, reader.uint32(), options, message.commitments);
                    break;
                case /* string closing_txid */ 4:
                    message.closingTxid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse_WaitingCloseChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.PendingChannelsResponse.PendingChannel channel = 1; */
        if (message.channel)
            PendingChannelsResponse_PendingChannel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 limbo_balance = 2; */
        if (message.limboBalance !== 0n)
            writer.tag(2, WireType.Varint).int64(message.limboBalance);
        /* lnrpc.PendingChannelsResponse.Commitments commitments = 3; */
        if (message.commitments)
            PendingChannelsResponse_Commitments.internalBinaryWrite(message.commitments, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string closing_txid = 4; */
        if (message.closingTxid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.closingTxid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.WaitingCloseChannel
 */
export const PendingChannelsResponse_WaitingCloseChannel = new PendingChannelsResponse_WaitingCloseChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse_Commitments$Type extends MessageType<PendingChannelsResponse_Commitments> {
    constructor() {
        super("lnrpc.PendingChannelsResponse.Commitments", [
            { no: 1, name: "local_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remote_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remote_pending_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "local_commit_fee_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "remote_commit_fee_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "remote_pending_commit_fee_sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse_Commitments>): PendingChannelsResponse_Commitments {
        const message = { localTxid: "", remoteTxid: "", remotePendingTxid: "", localCommitFeeSat: 0n, remoteCommitFeeSat: 0n, remotePendingCommitFeeSat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse_Commitments>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_Commitments): PendingChannelsResponse_Commitments {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string local_txid */ 1:
                    message.localTxid = reader.string();
                    break;
                case /* string remote_txid */ 2:
                    message.remoteTxid = reader.string();
                    break;
                case /* string remote_pending_txid */ 3:
                    message.remotePendingTxid = reader.string();
                    break;
                case /* uint64 local_commit_fee_sat */ 4:
                    message.localCommitFeeSat = reader.uint64().toBigInt();
                    break;
                case /* uint64 remote_commit_fee_sat */ 5:
                    message.remoteCommitFeeSat = reader.uint64().toBigInt();
                    break;
                case /* uint64 remote_pending_commit_fee_sat */ 6:
                    message.remotePendingCommitFeeSat = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse_Commitments, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string local_txid = 1; */
        if (message.localTxid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.localTxid);
        /* string remote_txid = 2; */
        if (message.remoteTxid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remoteTxid);
        /* string remote_pending_txid = 3; */
        if (message.remotePendingTxid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remotePendingTxid);
        /* uint64 local_commit_fee_sat = 4; */
        if (message.localCommitFeeSat !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.localCommitFeeSat);
        /* uint64 remote_commit_fee_sat = 5; */
        if (message.remoteCommitFeeSat !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.remoteCommitFeeSat);
        /* uint64 remote_pending_commit_fee_sat = 6; */
        if (message.remotePendingCommitFeeSat !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.remotePendingCommitFeeSat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.Commitments
 */
export const PendingChannelsResponse_Commitments = new PendingChannelsResponse_Commitments$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse_ClosedChannel$Type extends MessageType<PendingChannelsResponse_ClosedChannel> {
    constructor() {
        super("lnrpc.PendingChannelsResponse.ClosedChannel", [
            { no: 1, name: "channel", kind: "message", T: () => PendingChannelsResponse_PendingChannel },
            { no: 2, name: "closing_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse_ClosedChannel>): PendingChannelsResponse_ClosedChannel {
        const message = { closingTxid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse_ClosedChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_ClosedChannel): PendingChannelsResponse_ClosedChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.PendingChannelsResponse.PendingChannel channel */ 1:
                    message.channel = PendingChannelsResponse_PendingChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* string closing_txid */ 2:
                    message.closingTxid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse_ClosedChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.PendingChannelsResponse.PendingChannel channel = 1; */
        if (message.channel)
            PendingChannelsResponse_PendingChannel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string closing_txid = 2; */
        if (message.closingTxid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.closingTxid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.ClosedChannel
 */
export const PendingChannelsResponse_ClosedChannel = new PendingChannelsResponse_ClosedChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingChannelsResponse_ForceClosedChannel$Type extends MessageType<PendingChannelsResponse_ForceClosedChannel> {
    constructor() {
        super("lnrpc.PendingChannelsResponse.ForceClosedChannel", [
            { no: 1, name: "channel", kind: "message", T: () => PendingChannelsResponse_PendingChannel },
            { no: 2, name: "closing_txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limbo_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "maturity_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "blocks_til_maturity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "recovered_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "pending_htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PendingHTLC },
            { no: 9, name: "anchor", kind: "enum", T: () => ["lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState", PendingChannelsResponse_ForceClosedChannel_AnchorState] }
        ]);
    }
    create(value?: PartialMessage<PendingChannelsResponse_ForceClosedChannel>): PendingChannelsResponse_ForceClosedChannel {
        const message = { closingTxid: "", limboBalance: 0n, maturityHeight: 0, blocksTilMaturity: 0, recoveredBalance: 0n, pendingHtlcs: [], anchor: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingChannelsResponse_ForceClosedChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingChannelsResponse_ForceClosedChannel): PendingChannelsResponse_ForceClosedChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.PendingChannelsResponse.PendingChannel channel */ 1:
                    message.channel = PendingChannelsResponse_PendingChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* string closing_txid */ 2:
                    message.closingTxid = reader.string();
                    break;
                case /* int64 limbo_balance */ 3:
                    message.limboBalance = reader.int64().toBigInt();
                    break;
                case /* uint32 maturity_height */ 4:
                    message.maturityHeight = reader.uint32();
                    break;
                case /* int32 blocks_til_maturity */ 5:
                    message.blocksTilMaturity = reader.int32();
                    break;
                case /* int64 recovered_balance */ 6:
                    message.recoveredBalance = reader.int64().toBigInt();
                    break;
                case /* repeated lnrpc.PendingHTLC pending_htlcs */ 8:
                    message.pendingHtlcs.push(PendingHTLC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor */ 9:
                    message.anchor = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingChannelsResponse_ForceClosedChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.PendingChannelsResponse.PendingChannel channel = 1; */
        if (message.channel)
            PendingChannelsResponse_PendingChannel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string closing_txid = 2; */
        if (message.closingTxid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.closingTxid);
        /* int64 limbo_balance = 3; */
        if (message.limboBalance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.limboBalance);
        /* uint32 maturity_height = 4; */
        if (message.maturityHeight !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maturityHeight);
        /* int32 blocks_til_maturity = 5; */
        if (message.blocksTilMaturity !== 0)
            writer.tag(5, WireType.Varint).int32(message.blocksTilMaturity);
        /* int64 recovered_balance = 6; */
        if (message.recoveredBalance !== 0n)
            writer.tag(6, WireType.Varint).int64(message.recoveredBalance);
        /* repeated lnrpc.PendingHTLC pending_htlcs = 8; */
        for (let i = 0; i < message.pendingHtlcs.length; i++)
            PendingHTLC.internalBinaryWrite(message.pendingHtlcs[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9; */
        if (message.anchor !== 0)
            writer.tag(9, WireType.Varint).int32(message.anchor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PendingChannelsResponse.ForceClosedChannel
 */
export const PendingChannelsResponse_ForceClosedChannel = new PendingChannelsResponse_ForceClosedChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelEventSubscription$Type extends MessageType<ChannelEventSubscription> {
    constructor() {
        super("lnrpc.ChannelEventSubscription", []);
    }
    create(value?: PartialMessage<ChannelEventSubscription>): ChannelEventSubscription {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelEventSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEventSubscription): ChannelEventSubscription {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChannelEventSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEventSubscription
 */
export const ChannelEventSubscription = new ChannelEventSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelEventUpdate$Type extends MessageType<ChannelEventUpdate> {
    constructor() {
        super("lnrpc.ChannelEventUpdate", [
            { no: 1, name: "open_channel", kind: "message", oneof: "channel", T: () => Channel },
            { no: 2, name: "closed_channel", kind: "message", oneof: "channel", T: () => ChannelCloseSummary },
            { no: 3, name: "active_channel", kind: "message", oneof: "channel", T: () => ChannelPoint },
            { no: 4, name: "inactive_channel", kind: "message", oneof: "channel", T: () => ChannelPoint },
            { no: 6, name: "pending_open_channel", kind: "message", oneof: "channel", T: () => PendingUpdate },
            { no: 7, name: "fully_resolved_channel", kind: "message", oneof: "channel", T: () => ChannelPoint },
            { no: 5, name: "type", kind: "enum", T: () => ["lnrpc.ChannelEventUpdate.UpdateType", ChannelEventUpdate_UpdateType] }
        ]);
    }
    create(value?: PartialMessage<ChannelEventUpdate>): ChannelEventUpdate {
        const message = { channel: { oneofKind: undefined }, type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelEventUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEventUpdate): ChannelEventUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.Channel open_channel */ 1:
                    message.channel = {
                        oneofKind: "openChannel",
                        openChannel: Channel.internalBinaryRead(reader, reader.uint32(), options, (message.channel as any).openChannel)
                    };
                    break;
                case /* lnrpc.ChannelCloseSummary closed_channel */ 2:
                    message.channel = {
                        oneofKind: "closedChannel",
                        closedChannel: ChannelCloseSummary.internalBinaryRead(reader, reader.uint32(), options, (message.channel as any).closedChannel)
                    };
                    break;
                case /* lnrpc.ChannelPoint active_channel */ 3:
                    message.channel = {
                        oneofKind: "activeChannel",
                        activeChannel: ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, (message.channel as any).activeChannel)
                    };
                    break;
                case /* lnrpc.ChannelPoint inactive_channel */ 4:
                    message.channel = {
                        oneofKind: "inactiveChannel",
                        inactiveChannel: ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, (message.channel as any).inactiveChannel)
                    };
                    break;
                case /* lnrpc.PendingUpdate pending_open_channel */ 6:
                    message.channel = {
                        oneofKind: "pendingOpenChannel",
                        pendingOpenChannel: PendingUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.channel as any).pendingOpenChannel)
                    };
                    break;
                case /* lnrpc.ChannelPoint fully_resolved_channel */ 7:
                    message.channel = {
                        oneofKind: "fullyResolvedChannel",
                        fullyResolvedChannel: ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, (message.channel as any).fullyResolvedChannel)
                    };
                    break;
                case /* lnrpc.ChannelEventUpdate.UpdateType type */ 5:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelEventUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.Channel open_channel = 1; */
        if (message.channel.oneofKind === "openChannel")
            Channel.internalBinaryWrite(message.channel.openChannel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelCloseSummary closed_channel = 2; */
        if (message.channel.oneofKind === "closedChannel")
            ChannelCloseSummary.internalBinaryWrite(message.channel.closedChannel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelPoint active_channel = 3; */
        if (message.channel.oneofKind === "activeChannel")
            ChannelPoint.internalBinaryWrite(message.channel.activeChannel, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelPoint inactive_channel = 4; */
        if (message.channel.oneofKind === "inactiveChannel")
            ChannelPoint.internalBinaryWrite(message.channel.inactiveChannel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.PendingUpdate pending_open_channel = 6; */
        if (message.channel.oneofKind === "pendingOpenChannel")
            PendingUpdate.internalBinaryWrite(message.channel.pendingOpenChannel, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelPoint fully_resolved_channel = 7; */
        if (message.channel.oneofKind === "fullyResolvedChannel")
            ChannelPoint.internalBinaryWrite(message.channel.fullyResolvedChannel, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.ChannelEventUpdate.UpdateType type = 5; */
        if (message.type !== 0)
            writer.tag(5, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEventUpdate
 */
export const ChannelEventUpdate = new ChannelEventUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WalletAccountBalance$Type extends MessageType<WalletAccountBalance> {
    constructor() {
        super("lnrpc.WalletAccountBalance", [
            { no: 1, name: "confirmed_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "unconfirmed_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WalletAccountBalance>): WalletAccountBalance {
        const message = { confirmedBalance: 0n, unconfirmedBalance: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WalletAccountBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WalletAccountBalance): WalletAccountBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 confirmed_balance */ 1:
                    message.confirmedBalance = reader.int64().toBigInt();
                    break;
                case /* int64 unconfirmed_balance */ 2:
                    message.unconfirmedBalance = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WalletAccountBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 confirmed_balance = 1; */
        if (message.confirmedBalance !== 0n)
            writer.tag(1, WireType.Varint).int64(message.confirmedBalance);
        /* int64 unconfirmed_balance = 2; */
        if (message.unconfirmedBalance !== 0n)
            writer.tag(2, WireType.Varint).int64(message.unconfirmedBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.WalletAccountBalance
 */
export const WalletAccountBalance = new WalletAccountBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WalletBalanceRequest$Type extends MessageType<WalletBalanceRequest> {
    constructor() {
        super("lnrpc.WalletBalanceRequest", []);
    }
    create(value?: PartialMessage<WalletBalanceRequest>): WalletBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WalletBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WalletBalanceRequest): WalletBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: WalletBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.WalletBalanceRequest
 */
export const WalletBalanceRequest = new WalletBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WalletBalanceResponse$Type extends MessageType<WalletBalanceResponse> {
    constructor() {
        super("lnrpc.WalletBalanceResponse", [
            { no: 1, name: "total_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "confirmed_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "unconfirmed_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "locked_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "reserved_balance_anchor_chan", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "account_balance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => WalletAccountBalance } }
        ]);
    }
    create(value?: PartialMessage<WalletBalanceResponse>): WalletBalanceResponse {
        const message = { totalBalance: 0n, confirmedBalance: 0n, unconfirmedBalance: 0n, lockedBalance: 0n, reservedBalanceAnchorChan: 0n, accountBalance: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WalletBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WalletBalanceResponse): WalletBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 total_balance */ 1:
                    message.totalBalance = reader.int64().toBigInt();
                    break;
                case /* int64 confirmed_balance */ 2:
                    message.confirmedBalance = reader.int64().toBigInt();
                    break;
                case /* int64 unconfirmed_balance */ 3:
                    message.unconfirmedBalance = reader.int64().toBigInt();
                    break;
                case /* int64 locked_balance */ 5:
                    message.lockedBalance = reader.int64().toBigInt();
                    break;
                case /* int64 reserved_balance_anchor_chan */ 6:
                    message.reservedBalanceAnchorChan = reader.int64().toBigInt();
                    break;
                case /* map<string, lnrpc.WalletAccountBalance> account_balance */ 4:
                    this.binaryReadMap4(message.accountBalance, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: WalletBalanceResponse["accountBalance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WalletBalanceResponse["accountBalance"] | undefined, val: WalletBalanceResponse["accountBalance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = WalletAccountBalance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.WalletBalanceResponse.account_balance");
            }
        }
        map[key ?? ""] = val ?? WalletAccountBalance.create();
    }
    internalBinaryWrite(message: WalletBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 total_balance = 1; */
        if (message.totalBalance !== 0n)
            writer.tag(1, WireType.Varint).int64(message.totalBalance);
        /* int64 confirmed_balance = 2; */
        if (message.confirmedBalance !== 0n)
            writer.tag(2, WireType.Varint).int64(message.confirmedBalance);
        /* int64 unconfirmed_balance = 3; */
        if (message.unconfirmedBalance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.unconfirmedBalance);
        /* int64 locked_balance = 5; */
        if (message.lockedBalance !== 0n)
            writer.tag(5, WireType.Varint).int64(message.lockedBalance);
        /* int64 reserved_balance_anchor_chan = 6; */
        if (message.reservedBalanceAnchorChan !== 0n)
            writer.tag(6, WireType.Varint).int64(message.reservedBalanceAnchorChan);
        /* map<string, lnrpc.WalletAccountBalance> account_balance = 4; */
        for (let k of Object.keys(message.accountBalance)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            WalletAccountBalance.internalBinaryWrite(message.accountBalance[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.WalletBalanceResponse
 */
export const WalletBalanceResponse = new WalletBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Amount$Type extends MessageType<Amount> {
    constructor() {
        super("lnrpc.Amount", [
            { no: 1, name: "sat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Amount>): Amount {
        const message = { sat: 0n, msat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Amount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Amount): Amount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 sat */ 1:
                    message.sat = reader.uint64().toBigInt();
                    break;
                case /* uint64 msat */ 2:
                    message.msat = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Amount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 sat = 1; */
        if (message.sat !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.sat);
        /* uint64 msat = 2; */
        if (message.msat !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.msat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Amount
 */
export const Amount = new Amount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelBalanceRequest$Type extends MessageType<ChannelBalanceRequest> {
    constructor() {
        super("lnrpc.ChannelBalanceRequest", []);
    }
    create(value?: PartialMessage<ChannelBalanceRequest>): ChannelBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBalanceRequest): ChannelBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChannelBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBalanceRequest
 */
export const ChannelBalanceRequest = new ChannelBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelBalanceResponse$Type extends MessageType<ChannelBalanceResponse> {
    constructor() {
        super("lnrpc.ChannelBalanceResponse", [
            { no: 1, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "pending_open_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "local_balance", kind: "message", T: () => Amount },
            { no: 4, name: "remote_balance", kind: "message", T: () => Amount },
            { no: 5, name: "unsettled_local_balance", kind: "message", T: () => Amount },
            { no: 6, name: "unsettled_remote_balance", kind: "message", T: () => Amount },
            { no: 7, name: "pending_open_local_balance", kind: "message", T: () => Amount },
            { no: 8, name: "pending_open_remote_balance", kind: "message", T: () => Amount }
        ]);
    }
    create(value?: PartialMessage<ChannelBalanceResponse>): ChannelBalanceResponse {
        const message = { balance: 0n, pendingOpenBalance: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBalanceResponse): ChannelBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 balance = 1 [deprecated = true];*/ 1:
                    message.balance = reader.int64().toBigInt();
                    break;
                case /* int64 pending_open_balance = 2 [deprecated = true];*/ 2:
                    message.pendingOpenBalance = reader.int64().toBigInt();
                    break;
                case /* lnrpc.Amount local_balance */ 3:
                    message.localBalance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.localBalance);
                    break;
                case /* lnrpc.Amount remote_balance */ 4:
                    message.remoteBalance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.remoteBalance);
                    break;
                case /* lnrpc.Amount unsettled_local_balance */ 5:
                    message.unsettledLocalBalance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.unsettledLocalBalance);
                    break;
                case /* lnrpc.Amount unsettled_remote_balance */ 6:
                    message.unsettledRemoteBalance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.unsettledRemoteBalance);
                    break;
                case /* lnrpc.Amount pending_open_local_balance */ 7:
                    message.pendingOpenLocalBalance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.pendingOpenLocalBalance);
                    break;
                case /* lnrpc.Amount pending_open_remote_balance */ 8:
                    message.pendingOpenRemoteBalance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.pendingOpenRemoteBalance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 balance = 1 [deprecated = true]; */
        if (message.balance !== 0n)
            writer.tag(1, WireType.Varint).int64(message.balance);
        /* int64 pending_open_balance = 2 [deprecated = true]; */
        if (message.pendingOpenBalance !== 0n)
            writer.tag(2, WireType.Varint).int64(message.pendingOpenBalance);
        /* lnrpc.Amount local_balance = 3; */
        if (message.localBalance)
            Amount.internalBinaryWrite(message.localBalance, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Amount remote_balance = 4; */
        if (message.remoteBalance)
            Amount.internalBinaryWrite(message.remoteBalance, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Amount unsettled_local_balance = 5; */
        if (message.unsettledLocalBalance)
            Amount.internalBinaryWrite(message.unsettledLocalBalance, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Amount unsettled_remote_balance = 6; */
        if (message.unsettledRemoteBalance)
            Amount.internalBinaryWrite(message.unsettledRemoteBalance, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Amount pending_open_local_balance = 7; */
        if (message.pendingOpenLocalBalance)
            Amount.internalBinaryWrite(message.pendingOpenLocalBalance, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.Amount pending_open_remote_balance = 8; */
        if (message.pendingOpenRemoteBalance)
            Amount.internalBinaryWrite(message.pendingOpenRemoteBalance, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBalanceResponse
 */
export const ChannelBalanceResponse = new ChannelBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRoutesRequest$Type extends MessageType<QueryRoutesRequest> {
    constructor() {
        super("lnrpc.QueryRoutesRequest", [
            { no: 1, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "final_cltv_delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "fee_limit", kind: "message", T: () => FeeLimit },
            { no: 6, name: "ignored_nodes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "ignored_edges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EdgeLocator },
            { no: 8, name: "source_pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "use_mission_control", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "ignored_pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NodePair },
            { no: 11, name: "cltv_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "dest_custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 14, name: "outgoing_chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 15, name: "last_hop_pubkey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 16, name: "route_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteHint },
            { no: 17, name: "dest_features", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["lnrpc.FeatureBit", FeatureBit] },
            { no: 18, name: "time_pref", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRoutesRequest>): QueryRoutesRequest {
        const message = { pubKey: "", amt: 0n, amtMsat: 0n, finalCltvDelta: 0, ignoredNodes: [], ignoredEdges: [], sourcePubKey: "", useMissionControl: false, ignoredPairs: [], cltvLimit: 0, destCustomRecords: {}, outgoingChanId: "0", lastHopPubkey: new Uint8Array(0), routeHints: [], destFeatures: [], timePref: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryRoutesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRoutesRequest): QueryRoutesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pub_key */ 1:
                    message.pubKey = reader.string();
                    break;
                case /* int64 amt */ 2:
                    message.amt = reader.int64().toBigInt();
                    break;
                case /* int64 amt_msat */ 12:
                    message.amtMsat = reader.int64().toBigInt();
                    break;
                case /* int32 final_cltv_delta */ 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case /* lnrpc.FeeLimit fee_limit */ 5:
                    message.feeLimit = FeeLimit.internalBinaryRead(reader, reader.uint32(), options, message.feeLimit);
                    break;
                case /* repeated bytes ignored_nodes */ 6:
                    message.ignoredNodes.push(reader.bytes());
                    break;
                case /* repeated lnrpc.EdgeLocator ignored_edges = 7 [deprecated = true];*/ 7:
                    message.ignoredEdges.push(EdgeLocator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string source_pub_key */ 8:
                    message.sourcePubKey = reader.string();
                    break;
                case /* bool use_mission_control */ 9:
                    message.useMissionControl = reader.bool();
                    break;
                case /* repeated lnrpc.NodePair ignored_pairs */ 10:
                    message.ignoredPairs.push(NodePair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 cltv_limit */ 11:
                    message.cltvLimit = reader.uint32();
                    break;
                case /* map<uint64, bytes> dest_custom_records */ 13:
                    this.binaryReadMap13(message.destCustomRecords, reader, options);
                    break;
                case /* uint64 outgoing_chan_id = 14 [jstype = JS_STRING];*/ 14:
                    message.outgoingChanId = reader.uint64().toString();
                    break;
                case /* bytes last_hop_pubkey */ 15:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case /* repeated lnrpc.RouteHint route_hints */ 16:
                    message.routeHints.push(RouteHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.FeatureBit dest_features */ 17:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.destFeatures.push(reader.int32());
                    else
                        message.destFeatures.push(reader.int32());
                    break;
                case /* double time_pref */ 18:
                    message.timePref = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: QueryRoutesRequest["destCustomRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryRoutesRequest["destCustomRecords"] | undefined, val: QueryRoutesRequest["destCustomRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.QueryRoutesRequest.dest_custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: QueryRoutesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pub_key = 1; */
        if (message.pubKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubKey);
        /* int64 amt = 2; */
        if (message.amt !== 0n)
            writer.tag(2, WireType.Varint).int64(message.amt);
        /* int64 amt_msat = 12; */
        if (message.amtMsat !== 0n)
            writer.tag(12, WireType.Varint).int64(message.amtMsat);
        /* int32 final_cltv_delta = 4; */
        if (message.finalCltvDelta !== 0)
            writer.tag(4, WireType.Varint).int32(message.finalCltvDelta);
        /* lnrpc.FeeLimit fee_limit = 5; */
        if (message.feeLimit)
            FeeLimit.internalBinaryWrite(message.feeLimit, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes ignored_nodes = 6; */
        for (let i = 0; i < message.ignoredNodes.length; i++)
            writer.tag(6, WireType.LengthDelimited).bytes(message.ignoredNodes[i]);
        /* repeated lnrpc.EdgeLocator ignored_edges = 7 [deprecated = true]; */
        for (let i = 0; i < message.ignoredEdges.length; i++)
            EdgeLocator.internalBinaryWrite(message.ignoredEdges[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string source_pub_key = 8; */
        if (message.sourcePubKey !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.sourcePubKey);
        /* bool use_mission_control = 9; */
        if (message.useMissionControl !== false)
            writer.tag(9, WireType.Varint).bool(message.useMissionControl);
        /* repeated lnrpc.NodePair ignored_pairs = 10; */
        for (let i = 0; i < message.ignoredPairs.length; i++)
            NodePair.internalBinaryWrite(message.ignoredPairs[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* uint32 cltv_limit = 11; */
        if (message.cltvLimit !== 0)
            writer.tag(11, WireType.Varint).uint32(message.cltvLimit);
        /* map<uint64, bytes> dest_custom_records = 13; */
        for (let k of Object.keys(message.destCustomRecords))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.destCustomRecords[k]).join();
        /* uint64 outgoing_chan_id = 14 [jstype = JS_STRING]; */
        if (message.outgoingChanId !== "0")
            writer.tag(14, WireType.Varint).uint64(message.outgoingChanId);
        /* bytes last_hop_pubkey = 15; */
        if (message.lastHopPubkey.length)
            writer.tag(15, WireType.LengthDelimited).bytes(message.lastHopPubkey);
        /* repeated lnrpc.RouteHint route_hints = 16; */
        for (let i = 0; i < message.routeHints.length; i++)
            RouteHint.internalBinaryWrite(message.routeHints[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.FeatureBit dest_features = 17; */
        if (message.destFeatures.length) {
            writer.tag(17, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.destFeatures.length; i++)
                writer.int32(message.destFeatures[i]);
            writer.join();
        }
        /* double time_pref = 18; */
        if (message.timePref !== 0)
            writer.tag(18, WireType.Bit64).double(message.timePref);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.QueryRoutesRequest
 */
export const QueryRoutesRequest = new QueryRoutesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodePair$Type extends MessageType<NodePair> {
    constructor() {
        super("lnrpc.NodePair", [
            { no: 1, name: "from", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "to", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<NodePair>): NodePair {
        const message = { from: new Uint8Array(0), to: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodePair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodePair): NodePair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes from */ 1:
                    message.from = reader.bytes();
                    break;
                case /* bytes to */ 2:
                    message.to = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodePair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes from = 1; */
        if (message.from.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.from);
        /* bytes to = 2; */
        if (message.to.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.to);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodePair
 */
export const NodePair = new NodePair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EdgeLocator$Type extends MessageType<EdgeLocator> {
    constructor() {
        super("lnrpc.EdgeLocator", [
            { no: 1, name: "channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "direction_reverse", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EdgeLocator>): EdgeLocator {
        const message = { channelId: "0", directionReverse: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EdgeLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EdgeLocator): EdgeLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 channel_id = 1 [jstype = JS_STRING];*/ 1:
                    message.channelId = reader.uint64().toString();
                    break;
                case /* bool direction_reverse */ 2:
                    message.directionReverse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EdgeLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 channel_id = 1 [jstype = JS_STRING]; */
        if (message.channelId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.channelId);
        /* bool direction_reverse = 2; */
        if (message.directionReverse !== false)
            writer.tag(2, WireType.Varint).bool(message.directionReverse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.EdgeLocator
 */
export const EdgeLocator = new EdgeLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRoutesResponse$Type extends MessageType<QueryRoutesResponse> {
    constructor() {
        super("lnrpc.QueryRoutesResponse", [
            { no: 1, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Route },
            { no: 2, name: "success_prob", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRoutesResponse>): QueryRoutesResponse {
        const message = { routes: [], successProb: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryRoutesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRoutesResponse): QueryRoutesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Route routes */ 1:
                    message.routes.push(Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double success_prob */ 2:
                    message.successProb = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRoutesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Route routes = 1; */
        for (let i = 0; i < message.routes.length; i++)
            Route.internalBinaryWrite(message.routes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* double success_prob = 2; */
        if (message.successProb !== 0)
            writer.tag(2, WireType.Bit64).double(message.successProb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.QueryRoutesResponse
 */
export const QueryRoutesResponse = new QueryRoutesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Hop$Type extends MessageType<Hop> {
    constructor() {
        super("lnrpc.Hop", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "chan_capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "amt_to_forward", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fee", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "amt_to_forward_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "tlv_payload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "mpp_record", kind: "message", T: () => MPPRecord },
            { no: 12, name: "amp_record", kind: "message", T: () => AMPRecord },
            { no: 11, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 13, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Hop>): Hop {
        const message = { chanId: "0", chanCapacity: 0n, amtToForward: 0n, fee: 0n, expiry: 0, amtToForwardMsat: 0n, feeMsat: 0n, pubKey: "", tlvPayload: false, customRecords: {}, metadata: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Hop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Hop): Hop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id = 1 [jstype = JS_STRING];*/ 1:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* int64 chan_capacity = 2 [deprecated = true];*/ 2:
                    message.chanCapacity = reader.int64().toBigInt();
                    break;
                case /* int64 amt_to_forward = 3 [deprecated = true];*/ 3:
                    message.amtToForward = reader.int64().toBigInt();
                    break;
                case /* int64 fee = 4 [deprecated = true];*/ 4:
                    message.fee = reader.int64().toBigInt();
                    break;
                case /* uint32 expiry */ 5:
                    message.expiry = reader.uint32();
                    break;
                case /* int64 amt_to_forward_msat */ 6:
                    message.amtToForwardMsat = reader.int64().toBigInt();
                    break;
                case /* int64 fee_msat */ 7:
                    message.feeMsat = reader.int64().toBigInt();
                    break;
                case /* string pub_key */ 8:
                    message.pubKey = reader.string();
                    break;
                case /* bool tlv_payload = 9 [deprecated = true];*/ 9:
                    message.tlvPayload = reader.bool();
                    break;
                case /* lnrpc.MPPRecord mpp_record */ 10:
                    message.mppRecord = MPPRecord.internalBinaryRead(reader, reader.uint32(), options, message.mppRecord);
                    break;
                case /* lnrpc.AMPRecord amp_record */ 12:
                    message.ampRecord = AMPRecord.internalBinaryRead(reader, reader.uint32(), options, message.ampRecord);
                    break;
                case /* map<uint64, bytes> custom_records */ 11:
                    this.binaryReadMap11(message.customRecords, reader, options);
                    break;
                case /* bytes metadata */ 13:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: Hop["customRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Hop["customRecords"] | undefined, val: Hop["customRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.Hop.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: Hop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* int64 chan_capacity = 2 [deprecated = true]; */
        if (message.chanCapacity !== 0n)
            writer.tag(2, WireType.Varint).int64(message.chanCapacity);
        /* int64 amt_to_forward = 3 [deprecated = true]; */
        if (message.amtToForward !== 0n)
            writer.tag(3, WireType.Varint).int64(message.amtToForward);
        /* int64 fee = 4 [deprecated = true]; */
        if (message.fee !== 0n)
            writer.tag(4, WireType.Varint).int64(message.fee);
        /* uint32 expiry = 5; */
        if (message.expiry !== 0)
            writer.tag(5, WireType.Varint).uint32(message.expiry);
        /* int64 amt_to_forward_msat = 6; */
        if (message.amtToForwardMsat !== 0n)
            writer.tag(6, WireType.Varint).int64(message.amtToForwardMsat);
        /* int64 fee_msat = 7; */
        if (message.feeMsat !== 0n)
            writer.tag(7, WireType.Varint).int64(message.feeMsat);
        /* string pub_key = 8; */
        if (message.pubKey !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.pubKey);
        /* bool tlv_payload = 9 [deprecated = true]; */
        if (message.tlvPayload !== false)
            writer.tag(9, WireType.Varint).bool(message.tlvPayload);
        /* lnrpc.MPPRecord mpp_record = 10; */
        if (message.mppRecord)
            MPPRecord.internalBinaryWrite(message.mppRecord, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.AMPRecord amp_record = 12; */
        if (message.ampRecord)
            AMPRecord.internalBinaryWrite(message.ampRecord, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* map<uint64, bytes> custom_records = 11; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        /* bytes metadata = 13; */
        if (message.metadata.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Hop
 */
export const Hop = new Hop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MPPRecord$Type extends MessageType<MPPRecord> {
    constructor() {
        super("lnrpc.MPPRecord", [
            { no: 11, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "total_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MPPRecord>): MPPRecord {
        const message = { paymentAddr: new Uint8Array(0), totalAmtMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MPPRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MPPRecord): MPPRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_addr */ 11:
                    message.paymentAddr = reader.bytes();
                    break;
                case /* int64 total_amt_msat */ 10:
                    message.totalAmtMsat = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MPPRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payment_addr = 11; */
        if (message.paymentAddr.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.paymentAddr);
        /* int64 total_amt_msat = 10; */
        if (message.totalAmtMsat !== 0n)
            writer.tag(10, WireType.Varint).int64(message.totalAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.MPPRecord
 */
export const MPPRecord = new MPPRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AMPRecord$Type extends MessageType<AMPRecord> {
    constructor() {
        super("lnrpc.AMPRecord", [
            { no: 1, name: "root_share", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "set_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "child_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AMPRecord>): AMPRecord {
        const message = { rootShare: new Uint8Array(0), setId: new Uint8Array(0), childIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AMPRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AMPRecord): AMPRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes root_share */ 1:
                    message.rootShare = reader.bytes();
                    break;
                case /* bytes set_id */ 2:
                    message.setId = reader.bytes();
                    break;
                case /* uint32 child_index */ 3:
                    message.childIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AMPRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes root_share = 1; */
        if (message.rootShare.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rootShare);
        /* bytes set_id = 2; */
        if (message.setId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.setId);
        /* uint32 child_index = 3; */
        if (message.childIndex !== 0)
            writer.tag(3, WireType.Varint).uint32(message.childIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AMPRecord
 */
export const AMPRecord = new AMPRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Route$Type extends MessageType<Route> {
    constructor() {
        super("lnrpc.Route", [
            { no: 1, name: "total_time_lock", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "total_fees", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "total_amt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "hops", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Hop },
            { no: 5, name: "total_fees_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "total_amt_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Route>): Route {
        const message = { totalTimeLock: 0, totalFees: 0n, totalAmt: 0n, hops: [], totalFeesMsat: 0n, totalAmtMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Route): Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total_time_lock */ 1:
                    message.totalTimeLock = reader.uint32();
                    break;
                case /* int64 total_fees = 2 [deprecated = true];*/ 2:
                    message.totalFees = reader.int64().toBigInt();
                    break;
                case /* int64 total_amt = 3 [deprecated = true];*/ 3:
                    message.totalAmt = reader.int64().toBigInt();
                    break;
                case /* repeated lnrpc.Hop hops */ 4:
                    message.hops.push(Hop.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 total_fees_msat */ 5:
                    message.totalFeesMsat = reader.int64().toBigInt();
                    break;
                case /* int64 total_amt_msat */ 6:
                    message.totalAmtMsat = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total_time_lock = 1; */
        if (message.totalTimeLock !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalTimeLock);
        /* int64 total_fees = 2 [deprecated = true]; */
        if (message.totalFees !== 0n)
            writer.tag(2, WireType.Varint).int64(message.totalFees);
        /* int64 total_amt = 3 [deprecated = true]; */
        if (message.totalAmt !== 0n)
            writer.tag(3, WireType.Varint).int64(message.totalAmt);
        /* repeated lnrpc.Hop hops = 4; */
        for (let i = 0; i < message.hops.length; i++)
            Hop.internalBinaryWrite(message.hops[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_fees_msat = 5; */
        if (message.totalFeesMsat !== 0n)
            writer.tag(5, WireType.Varint).int64(message.totalFeesMsat);
        /* int64 total_amt_msat = 6; */
        if (message.totalAmtMsat !== 0n)
            writer.tag(6, WireType.Varint).int64(message.totalAmtMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Route
 */
export const Route = new Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeInfoRequest$Type extends MessageType<NodeInfoRequest> {
    constructor() {
        super("lnrpc.NodeInfoRequest", [
            { no: 1, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_channels", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<NodeInfoRequest>): NodeInfoRequest {
        const message = { pubKey: "", includeChannels: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeInfoRequest): NodeInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pub_key */ 1:
                    message.pubKey = reader.string();
                    break;
                case /* bool include_channels */ 2:
                    message.includeChannels = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pub_key = 1; */
        if (message.pubKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubKey);
        /* bool include_channels = 2; */
        if (message.includeChannels !== false)
            writer.tag(2, WireType.Varint).bool(message.includeChannels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeInfoRequest
 */
export const NodeInfoRequest = new NodeInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeInfo$Type extends MessageType<NodeInfo> {
    constructor() {
        super("lnrpc.NodeInfo", [
            { no: 1, name: "node", kind: "message", T: () => LightningNode },
            { no: 2, name: "num_channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "total_capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelEdge }
        ]);
    }
    create(value?: PartialMessage<NodeInfo>): NodeInfo {
        const message = { numChannels: 0, totalCapacity: 0n, channels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeInfo): NodeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.LightningNode node */ 1:
                    message.node = LightningNode.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* uint32 num_channels */ 2:
                    message.numChannels = reader.uint32();
                    break;
                case /* int64 total_capacity */ 3:
                    message.totalCapacity = reader.int64().toBigInt();
                    break;
                case /* repeated lnrpc.ChannelEdge channels */ 4:
                    message.channels.push(ChannelEdge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.LightningNode node = 1; */
        if (message.node)
            LightningNode.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 num_channels = 2; */
        if (message.numChannels !== 0)
            writer.tag(2, WireType.Varint).uint32(message.numChannels);
        /* int64 total_capacity = 3; */
        if (message.totalCapacity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.totalCapacity);
        /* repeated lnrpc.ChannelEdge channels = 4; */
        for (let i = 0; i < message.channels.length; i++)
            ChannelEdge.internalBinaryWrite(message.channels[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeInfo
 */
export const NodeInfo = new NodeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightningNode$Type extends MessageType<LightningNode> {
    constructor() {
        super("lnrpc.LightningNode", [
            { no: 1, name: "last_update", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "alias", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NodeAddress },
            { no: 5, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "features", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => Feature } },
            { no: 7, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } }
        ]);
    }
    create(value?: PartialMessage<LightningNode>): LightningNode {
        const message = { lastUpdate: 0, pubKey: "", alias: "", addresses: [], color: "", features: {}, customRecords: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LightningNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightningNode): LightningNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 last_update */ 1:
                    message.lastUpdate = reader.uint32();
                    break;
                case /* string pub_key */ 2:
                    message.pubKey = reader.string();
                    break;
                case /* string alias */ 3:
                    message.alias = reader.string();
                    break;
                case /* repeated lnrpc.NodeAddress addresses */ 4:
                    message.addresses.push(NodeAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string color */ 5:
                    message.color = reader.string();
                    break;
                case /* map<uint32, lnrpc.Feature> features */ 6:
                    this.binaryReadMap6(message.features, reader, options);
                    break;
                case /* map<uint64, bytes> custom_records */ 7:
                    this.binaryReadMap7(message.customRecords, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: LightningNode["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LightningNode["features"] | undefined, val: LightningNode["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = Feature.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.LightningNode.features");
            }
        }
        map[key ?? 0] = val ?? Feature.create();
    }
    private binaryReadMap7(map: LightningNode["customRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LightningNode["customRecords"] | undefined, val: LightningNode["customRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.LightningNode.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: LightningNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 last_update = 1; */
        if (message.lastUpdate !== 0)
            writer.tag(1, WireType.Varint).uint32(message.lastUpdate);
        /* string pub_key = 2; */
        if (message.pubKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pubKey);
        /* string alias = 3; */
        if (message.alias !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.alias);
        /* repeated lnrpc.NodeAddress addresses = 4; */
        for (let i = 0; i < message.addresses.length; i++)
            NodeAddress.internalBinaryWrite(message.addresses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string color = 5; */
        if (message.color !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.color);
        /* map<uint32, lnrpc.Feature> features = 6; */
        for (let k of Object.keys(message.features)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Feature.internalBinaryWrite(message.features[k as any], writer, options);
            writer.join().join();
        }
        /* map<uint64, bytes> custom_records = 7; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.LightningNode
 */
export const LightningNode = new LightningNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeAddress$Type extends MessageType<NodeAddress> {
    constructor() {
        super("lnrpc.NodeAddress", [
            { no: 1, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NodeAddress>): NodeAddress {
        const message = { network: "", addr: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeAddress): NodeAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string network */ 1:
                    message.network = reader.string();
                    break;
                case /* string addr */ 2:
                    message.addr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string network = 1; */
        if (message.network !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.network);
        /* string addr = 2; */
        if (message.addr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeAddress
 */
export const NodeAddress = new NodeAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutingPolicy$Type extends MessageType<RoutingPolicy> {
    constructor() {
        super("lnrpc.RoutingPolicy", [
            { no: 1, name: "time_lock_delta", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "min_htlc", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "fee_base_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fee_rate_milli_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "max_htlc_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "last_update", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } }
        ]);
    }
    create(value?: PartialMessage<RoutingPolicy>): RoutingPolicy {
        const message = { timeLockDelta: 0, minHtlc: 0n, feeBaseMsat: 0n, feeRateMilliMsat: 0n, disabled: false, maxHtlcMsat: 0n, lastUpdate: 0, customRecords: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoutingPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutingPolicy): RoutingPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 time_lock_delta */ 1:
                    message.timeLockDelta = reader.uint32();
                    break;
                case /* int64 min_htlc */ 2:
                    message.minHtlc = reader.int64().toBigInt();
                    break;
                case /* int64 fee_base_msat */ 3:
                    message.feeBaseMsat = reader.int64().toBigInt();
                    break;
                case /* int64 fee_rate_milli_msat */ 4:
                    message.feeRateMilliMsat = reader.int64().toBigInt();
                    break;
                case /* bool disabled */ 5:
                    message.disabled = reader.bool();
                    break;
                case /* uint64 max_htlc_msat */ 6:
                    message.maxHtlcMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 last_update */ 7:
                    message.lastUpdate = reader.uint32();
                    break;
                case /* map<uint64, bytes> custom_records */ 8:
                    this.binaryReadMap8(message.customRecords, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: RoutingPolicy["customRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RoutingPolicy["customRecords"] | undefined, val: RoutingPolicy["customRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.RoutingPolicy.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: RoutingPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 time_lock_delta = 1; */
        if (message.timeLockDelta !== 0)
            writer.tag(1, WireType.Varint).uint32(message.timeLockDelta);
        /* int64 min_htlc = 2; */
        if (message.minHtlc !== 0n)
            writer.tag(2, WireType.Varint).int64(message.minHtlc);
        /* int64 fee_base_msat = 3; */
        if (message.feeBaseMsat !== 0n)
            writer.tag(3, WireType.Varint).int64(message.feeBaseMsat);
        /* int64 fee_rate_milli_msat = 4; */
        if (message.feeRateMilliMsat !== 0n)
            writer.tag(4, WireType.Varint).int64(message.feeRateMilliMsat);
        /* bool disabled = 5; */
        if (message.disabled !== false)
            writer.tag(5, WireType.Varint).bool(message.disabled);
        /* uint64 max_htlc_msat = 6; */
        if (message.maxHtlcMsat !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.maxHtlcMsat);
        /* uint32 last_update = 7; */
        if (message.lastUpdate !== 0)
            writer.tag(7, WireType.Varint).uint32(message.lastUpdate);
        /* map<uint64, bytes> custom_records = 8; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RoutingPolicy
 */
export const RoutingPolicy = new RoutingPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelEdge$Type extends MessageType<ChannelEdge> {
    constructor() {
        super("lnrpc.ChannelEdge", [
            { no: 1, name: "channel_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "chan_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_update", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "node1_pub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "node2_pub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "node1_policy", kind: "message", T: () => RoutingPolicy },
            { no: 8, name: "node2_policy", kind: "message", T: () => RoutingPolicy },
            { no: 9, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } }
        ]);
    }
    create(value?: PartialMessage<ChannelEdge>): ChannelEdge {
        const message = { channelId: "0", chanPoint: "", lastUpdate: 0, node1Pub: "", node2Pub: "", capacity: 0n, customRecords: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelEdge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEdge): ChannelEdge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 channel_id = 1 [jstype = JS_STRING];*/ 1:
                    message.channelId = reader.uint64().toString();
                    break;
                case /* string chan_point */ 2:
                    message.chanPoint = reader.string();
                    break;
                case /* uint32 last_update = 3 [deprecated = true];*/ 3:
                    message.lastUpdate = reader.uint32();
                    break;
                case /* string node1_pub */ 4:
                    message.node1Pub = reader.string();
                    break;
                case /* string node2_pub */ 5:
                    message.node2Pub = reader.string();
                    break;
                case /* int64 capacity */ 6:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* lnrpc.RoutingPolicy node1_policy */ 7:
                    message.node1Policy = RoutingPolicy.internalBinaryRead(reader, reader.uint32(), options, message.node1Policy);
                    break;
                case /* lnrpc.RoutingPolicy node2_policy */ 8:
                    message.node2Policy = RoutingPolicy.internalBinaryRead(reader, reader.uint32(), options, message.node2Policy);
                    break;
                case /* map<uint64, bytes> custom_records */ 9:
                    this.binaryReadMap9(message.customRecords, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: ChannelEdge["customRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ChannelEdge["customRecords"] | undefined, val: ChannelEdge["customRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.ChannelEdge.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: ChannelEdge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 channel_id = 1 [jstype = JS_STRING]; */
        if (message.channelId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.channelId);
        /* string chan_point = 2; */
        if (message.chanPoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chanPoint);
        /* uint32 last_update = 3 [deprecated = true]; */
        if (message.lastUpdate !== 0)
            writer.tag(3, WireType.Varint).uint32(message.lastUpdate);
        /* string node1_pub = 4; */
        if (message.node1Pub !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.node1Pub);
        /* string node2_pub = 5; */
        if (message.node2Pub !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.node2Pub);
        /* int64 capacity = 6; */
        if (message.capacity !== 0n)
            writer.tag(6, WireType.Varint).int64(message.capacity);
        /* lnrpc.RoutingPolicy node1_policy = 7; */
        if (message.node1Policy)
            RoutingPolicy.internalBinaryWrite(message.node1Policy, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.RoutingPolicy node2_policy = 8; */
        if (message.node2Policy)
            RoutingPolicy.internalBinaryWrite(message.node2Policy, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* map<uint64, bytes> custom_records = 9; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEdge
 */
export const ChannelEdge = new ChannelEdge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelGraphRequest$Type extends MessageType<ChannelGraphRequest> {
    constructor() {
        super("lnrpc.ChannelGraphRequest", [
            { no: 1, name: "include_unannounced", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelGraphRequest>): ChannelGraphRequest {
        const message = { includeUnannounced: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelGraphRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelGraphRequest): ChannelGraphRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_unannounced */ 1:
                    message.includeUnannounced = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelGraphRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_unannounced = 1; */
        if (message.includeUnannounced !== false)
            writer.tag(1, WireType.Varint).bool(message.includeUnannounced);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelGraphRequest
 */
export const ChannelGraphRequest = new ChannelGraphRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelGraph$Type extends MessageType<ChannelGraph> {
    constructor() {
        super("lnrpc.ChannelGraph", [
            { no: 1, name: "nodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LightningNode },
            { no: 2, name: "edges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelEdge }
        ]);
    }
    create(value?: PartialMessage<ChannelGraph>): ChannelGraph {
        const message = { nodes: [], edges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelGraph>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelGraph): ChannelGraph {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.LightningNode nodes */ 1:
                    message.nodes.push(LightningNode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.ChannelEdge edges */ 2:
                    message.edges.push(ChannelEdge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelGraph, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.LightningNode nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            LightningNode.internalBinaryWrite(message.nodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.ChannelEdge edges = 2; */
        for (let i = 0; i < message.edges.length; i++)
            ChannelEdge.internalBinaryWrite(message.edges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelGraph
 */
export const ChannelGraph = new ChannelGraph$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeMetricsRequest$Type extends MessageType<NodeMetricsRequest> {
    constructor() {
        super("lnrpc.NodeMetricsRequest", [
            { no: 1, name: "types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["lnrpc.NodeMetricType", NodeMetricType] }
        ]);
    }
    create(value?: PartialMessage<NodeMetricsRequest>): NodeMetricsRequest {
        const message = { types: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeMetricsRequest): NodeMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.NodeMetricType types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.types.push(reader.int32());
                    else
                        message.types.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.NodeMetricType types = 1; */
        if (message.types.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.types.length; i++)
                writer.int32(message.types[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeMetricsRequest
 */
export const NodeMetricsRequest = new NodeMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeMetricsResponse$Type extends MessageType<NodeMetricsResponse> {
    constructor() {
        super("lnrpc.NodeMetricsResponse", [
            { no: 1, name: "betweenness_centrality", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => FloatMetric } }
        ]);
    }
    create(value?: PartialMessage<NodeMetricsResponse>): NodeMetricsResponse {
        const message = { betweennessCentrality: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeMetricsResponse): NodeMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, lnrpc.FloatMetric> betweenness_centrality */ 1:
                    this.binaryReadMap1(message.betweennessCentrality, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: NodeMetricsResponse["betweennessCentrality"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof NodeMetricsResponse["betweennessCentrality"] | undefined, val: NodeMetricsResponse["betweennessCentrality"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = FloatMetric.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.NodeMetricsResponse.betweenness_centrality");
            }
        }
        map[key ?? ""] = val ?? FloatMetric.create();
    }
    internalBinaryWrite(message: NodeMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, lnrpc.FloatMetric> betweenness_centrality = 1; */
        for (let k of Object.keys(message.betweennessCentrality)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FloatMetric.internalBinaryWrite(message.betweennessCentrality[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeMetricsResponse
 */
export const NodeMetricsResponse = new NodeMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FloatMetric$Type extends MessageType<FloatMetric> {
    constructor() {
        super("lnrpc.FloatMetric", [
            { no: 1, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "normalized_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<FloatMetric>): FloatMetric {
        const message = { value: 0, normalizedValue: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FloatMetric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FloatMetric): FloatMetric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double value */ 1:
                    message.value = reader.double();
                    break;
                case /* double normalized_value */ 2:
                    message.normalizedValue = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FloatMetric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Bit64).double(message.value);
        /* double normalized_value = 2; */
        if (message.normalizedValue !== 0)
            writer.tag(2, WireType.Bit64).double(message.normalizedValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FloatMetric
 */
export const FloatMetric = new FloatMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChanInfoRequest$Type extends MessageType<ChanInfoRequest> {
    constructor() {
        super("lnrpc.ChanInfoRequest", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<ChanInfoRequest>): ChanInfoRequest {
        const message = { chanId: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChanInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanInfoRequest): ChanInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id = 1 [jstype = JS_STRING];*/ 1:
                    message.chanId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChanInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanInfoRequest
 */
export const ChanInfoRequest = new ChanInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkInfoRequest$Type extends MessageType<NetworkInfoRequest> {
    constructor() {
        super("lnrpc.NetworkInfoRequest", []);
    }
    create(value?: PartialMessage<NetworkInfoRequest>): NetworkInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NetworkInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkInfoRequest): NetworkInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NetworkInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NetworkInfoRequest
 */
export const NetworkInfoRequest = new NetworkInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkInfo$Type extends MessageType<NetworkInfo> {
    constructor() {
        super("lnrpc.NetworkInfo", [
            { no: 1, name: "graph_diameter", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "avg_out_degree", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "max_out_degree", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "num_nodes", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "num_channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "total_network_capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "avg_channel_size", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "min_channel_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "max_channel_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "median_channel_size_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "num_zombie_chans", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<NetworkInfo>): NetworkInfo {
        const message = { graphDiameter: 0, avgOutDegree: 0, maxOutDegree: 0, numNodes: 0, numChannels: 0, totalNetworkCapacity: 0n, avgChannelSize: 0, minChannelSize: 0n, maxChannelSize: 0n, medianChannelSizeSat: 0n, numZombieChans: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NetworkInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkInfo): NetworkInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 graph_diameter */ 1:
                    message.graphDiameter = reader.uint32();
                    break;
                case /* double avg_out_degree */ 2:
                    message.avgOutDegree = reader.double();
                    break;
                case /* uint32 max_out_degree */ 3:
                    message.maxOutDegree = reader.uint32();
                    break;
                case /* uint32 num_nodes */ 4:
                    message.numNodes = reader.uint32();
                    break;
                case /* uint32 num_channels */ 5:
                    message.numChannels = reader.uint32();
                    break;
                case /* int64 total_network_capacity */ 6:
                    message.totalNetworkCapacity = reader.int64().toBigInt();
                    break;
                case /* double avg_channel_size */ 7:
                    message.avgChannelSize = reader.double();
                    break;
                case /* int64 min_channel_size */ 8:
                    message.minChannelSize = reader.int64().toBigInt();
                    break;
                case /* int64 max_channel_size */ 9:
                    message.maxChannelSize = reader.int64().toBigInt();
                    break;
                case /* int64 median_channel_size_sat */ 10:
                    message.medianChannelSizeSat = reader.int64().toBigInt();
                    break;
                case /* uint64 num_zombie_chans */ 11:
                    message.numZombieChans = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 graph_diameter = 1; */
        if (message.graphDiameter !== 0)
            writer.tag(1, WireType.Varint).uint32(message.graphDiameter);
        /* double avg_out_degree = 2; */
        if (message.avgOutDegree !== 0)
            writer.tag(2, WireType.Bit64).double(message.avgOutDegree);
        /* uint32 max_out_degree = 3; */
        if (message.maxOutDegree !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxOutDegree);
        /* uint32 num_nodes = 4; */
        if (message.numNodes !== 0)
            writer.tag(4, WireType.Varint).uint32(message.numNodes);
        /* uint32 num_channels = 5; */
        if (message.numChannels !== 0)
            writer.tag(5, WireType.Varint).uint32(message.numChannels);
        /* int64 total_network_capacity = 6; */
        if (message.totalNetworkCapacity !== 0n)
            writer.tag(6, WireType.Varint).int64(message.totalNetworkCapacity);
        /* double avg_channel_size = 7; */
        if (message.avgChannelSize !== 0)
            writer.tag(7, WireType.Bit64).double(message.avgChannelSize);
        /* int64 min_channel_size = 8; */
        if (message.minChannelSize !== 0n)
            writer.tag(8, WireType.Varint).int64(message.minChannelSize);
        /* int64 max_channel_size = 9; */
        if (message.maxChannelSize !== 0n)
            writer.tag(9, WireType.Varint).int64(message.maxChannelSize);
        /* int64 median_channel_size_sat = 10; */
        if (message.medianChannelSizeSat !== 0n)
            writer.tag(10, WireType.Varint).int64(message.medianChannelSizeSat);
        /* uint64 num_zombie_chans = 11; */
        if (message.numZombieChans !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.numZombieChans);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NetworkInfo
 */
export const NetworkInfo = new NetworkInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopRequest$Type extends MessageType<StopRequest> {
    constructor() {
        super("lnrpc.StopRequest", []);
    }
    create(value?: PartialMessage<StopRequest>): StopRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopRequest): StopRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.StopRequest
 */
export const StopRequest = new StopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopResponse$Type extends MessageType<StopResponse> {
    constructor() {
        super("lnrpc.StopResponse", []);
    }
    create(value?: PartialMessage<StopResponse>): StopResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopResponse): StopResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.StopResponse
 */
export const StopResponse = new StopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GraphTopologySubscription$Type extends MessageType<GraphTopologySubscription> {
    constructor() {
        super("lnrpc.GraphTopologySubscription", []);
    }
    create(value?: PartialMessage<GraphTopologySubscription>): GraphTopologySubscription {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GraphTopologySubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GraphTopologySubscription): GraphTopologySubscription {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GraphTopologySubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GraphTopologySubscription
 */
export const GraphTopologySubscription = new GraphTopologySubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GraphTopologyUpdate$Type extends MessageType<GraphTopologyUpdate> {
    constructor() {
        super("lnrpc.GraphTopologyUpdate", [
            { no: 1, name: "node_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NodeUpdate },
            { no: 2, name: "channel_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelEdgeUpdate },
            { no: 3, name: "closed_chans", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClosedChannelUpdate }
        ]);
    }
    create(value?: PartialMessage<GraphTopologyUpdate>): GraphTopologyUpdate {
        const message = { nodeUpdates: [], channelUpdates: [], closedChans: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GraphTopologyUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GraphTopologyUpdate): GraphTopologyUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.NodeUpdate node_updates */ 1:
                    message.nodeUpdates.push(NodeUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.ChannelEdgeUpdate channel_updates */ 2:
                    message.channelUpdates.push(ChannelEdgeUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated lnrpc.ClosedChannelUpdate closed_chans */ 3:
                    message.closedChans.push(ClosedChannelUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GraphTopologyUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.NodeUpdate node_updates = 1; */
        for (let i = 0; i < message.nodeUpdates.length; i++)
            NodeUpdate.internalBinaryWrite(message.nodeUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.ChannelEdgeUpdate channel_updates = 2; */
        for (let i = 0; i < message.channelUpdates.length; i++)
            ChannelEdgeUpdate.internalBinaryWrite(message.channelUpdates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated lnrpc.ClosedChannelUpdate closed_chans = 3; */
        for (let i = 0; i < message.closedChans.length; i++)
            ClosedChannelUpdate.internalBinaryWrite(message.closedChans[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.GraphTopologyUpdate
 */
export const GraphTopologyUpdate = new GraphTopologyUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeUpdate$Type extends MessageType<NodeUpdate> {
    constructor() {
        super("lnrpc.NodeUpdate", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "identity_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "global_features", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "alias", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "node_addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NodeAddress },
            { no: 6, name: "features", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => Feature } }
        ]);
    }
    create(value?: PartialMessage<NodeUpdate>): NodeUpdate {
        const message = { addresses: [], identityKey: "", globalFeatures: new Uint8Array(0), alias: "", color: "", nodeAddresses: [], features: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeUpdate): NodeUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses = 1 [deprecated = true];*/ 1:
                    message.addresses.push(reader.string());
                    break;
                case /* string identity_key */ 2:
                    message.identityKey = reader.string();
                    break;
                case /* bytes global_features = 3 [deprecated = true];*/ 3:
                    message.globalFeatures = reader.bytes();
                    break;
                case /* string alias */ 4:
                    message.alias = reader.string();
                    break;
                case /* string color */ 5:
                    message.color = reader.string();
                    break;
                case /* repeated lnrpc.NodeAddress node_addresses */ 7:
                    message.nodeAddresses.push(NodeAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint32, lnrpc.Feature> features */ 6:
                    this.binaryReadMap6(message.features, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: NodeUpdate["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof NodeUpdate["features"] | undefined, val: NodeUpdate["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = Feature.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.NodeUpdate.features");
            }
        }
        map[key ?? 0] = val ?? Feature.create();
    }
    internalBinaryWrite(message: NodeUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1 [deprecated = true]; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        /* string identity_key = 2; */
        if (message.identityKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.identityKey);
        /* bytes global_features = 3 [deprecated = true]; */
        if (message.globalFeatures.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.globalFeatures);
        /* string alias = 4; */
        if (message.alias !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.alias);
        /* string color = 5; */
        if (message.color !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.color);
        /* repeated lnrpc.NodeAddress node_addresses = 7; */
        for (let i = 0; i < message.nodeAddresses.length; i++)
            NodeAddress.internalBinaryWrite(message.nodeAddresses[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, lnrpc.Feature> features = 6; */
        for (let k of Object.keys(message.features)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Feature.internalBinaryWrite(message.features[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.NodeUpdate
 */
export const NodeUpdate = new NodeUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelEdgeUpdate$Type extends MessageType<ChannelEdgeUpdate> {
    constructor() {
        super("lnrpc.ChannelEdgeUpdate", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "chan_point", kind: "message", T: () => ChannelPoint },
            { no: 3, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "routing_policy", kind: "message", T: () => RoutingPolicy },
            { no: 5, name: "advertising_node", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "connecting_node", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelEdgeUpdate>): ChannelEdgeUpdate {
        const message = { chanId: "0", capacity: 0n, advertisingNode: "", connectingNode: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelEdgeUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelEdgeUpdate): ChannelEdgeUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id = 1 [jstype = JS_STRING];*/ 1:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* lnrpc.ChannelPoint chan_point */ 2:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* int64 capacity */ 3:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* lnrpc.RoutingPolicy routing_policy */ 4:
                    message.routingPolicy = RoutingPolicy.internalBinaryRead(reader, reader.uint32(), options, message.routingPolicy);
                    break;
                case /* string advertising_node */ 5:
                    message.advertisingNode = reader.string();
                    break;
                case /* string connecting_node */ 6:
                    message.connectingNode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelEdgeUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* lnrpc.ChannelPoint chan_point = 2; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 capacity = 3; */
        if (message.capacity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.capacity);
        /* lnrpc.RoutingPolicy routing_policy = 4; */
        if (message.routingPolicy)
            RoutingPolicy.internalBinaryWrite(message.routingPolicy, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string advertising_node = 5; */
        if (message.advertisingNode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.advertisingNode);
        /* string connecting_node = 6; */
        if (message.connectingNode !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.connectingNode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelEdgeUpdate
 */
export const ChannelEdgeUpdate = new ChannelEdgeUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClosedChannelUpdate$Type extends MessageType<ClosedChannelUpdate> {
    constructor() {
        super("lnrpc.ClosedChannelUpdate", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "closed_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "chan_point", kind: "message", T: () => ChannelPoint }
        ]);
    }
    create(value?: PartialMessage<ClosedChannelUpdate>): ClosedChannelUpdate {
        const message = { chanId: "0", capacity: 0n, closedHeight: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClosedChannelUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClosedChannelUpdate): ClosedChannelUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id = 1 [jstype = JS_STRING];*/ 1:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* int64 capacity */ 2:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* uint32 closed_height */ 3:
                    message.closedHeight = reader.uint32();
                    break;
                case /* lnrpc.ChannelPoint chan_point */ 4:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClosedChannelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* int64 capacity = 2; */
        if (message.capacity !== 0n)
            writer.tag(2, WireType.Varint).int64(message.capacity);
        /* uint32 closed_height = 3; */
        if (message.closedHeight !== 0)
            writer.tag(3, WireType.Varint).uint32(message.closedHeight);
        /* lnrpc.ChannelPoint chan_point = 4; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ClosedChannelUpdate
 */
export const ClosedChannelUpdate = new ClosedChannelUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HopHint$Type extends MessageType<HopHint> {
    constructor() {
        super("lnrpc.HopHint", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "fee_base_msat", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "fee_proportional_millionths", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "cltv_expiry_delta", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HopHint>): HopHint {
        const message = { nodeId: "", chanId: "0", feeBaseMsat: 0, feeProportionalMillionths: 0, cltvExpiryDelta: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HopHint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HopHint): HopHint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* uint64 chan_id = 2 [jstype = JS_STRING];*/ 2:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* uint32 fee_base_msat */ 3:
                    message.feeBaseMsat = reader.uint32();
                    break;
                case /* uint32 fee_proportional_millionths */ 4:
                    message.feeProportionalMillionths = reader.uint32();
                    break;
                case /* uint32 cltv_expiry_delta */ 5:
                    message.cltvExpiryDelta = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HopHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* uint64 chan_id = 2 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.chanId);
        /* uint32 fee_base_msat = 3; */
        if (message.feeBaseMsat !== 0)
            writer.tag(3, WireType.Varint).uint32(message.feeBaseMsat);
        /* uint32 fee_proportional_millionths = 4; */
        if (message.feeProportionalMillionths !== 0)
            writer.tag(4, WireType.Varint).uint32(message.feeProportionalMillionths);
        /* uint32 cltv_expiry_delta = 5; */
        if (message.cltvExpiryDelta !== 0)
            writer.tag(5, WireType.Varint).uint32(message.cltvExpiryDelta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.HopHint
 */
export const HopHint = new HopHint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetID$Type extends MessageType<SetID> {
    constructor() {
        super("lnrpc.SetID", [
            { no: 1, name: "set_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SetID>): SetID {
        const message = { setId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetID): SetID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes set_id */ 1:
                    message.setId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes set_id = 1; */
        if (message.setId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.setId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.SetID
 */
export const SetID = new SetID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteHint$Type extends MessageType<RouteHint> {
    constructor() {
        super("lnrpc.RouteHint", [
            { no: 1, name: "hop_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HopHint }
        ]);
    }
    create(value?: PartialMessage<RouteHint>): RouteHint {
        const message = { hopHints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RouteHint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteHint): RouteHint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.HopHint hop_hints */ 1:
                    message.hopHints.push(HopHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.HopHint hop_hints = 1; */
        for (let i = 0; i < message.hopHints.length; i++)
            HopHint.internalBinaryWrite(message.hopHints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RouteHint
 */
export const RouteHint = new RouteHint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AMPInvoiceState$Type extends MessageType<AMPInvoiceState> {
    constructor() {
        super("lnrpc.AMPInvoiceState", [
            { no: 1, name: "state", kind: "enum", T: () => ["lnrpc.InvoiceHTLCState", InvoiceHTLCState] },
            { no: 2, name: "settle_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "settle_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "amt_paid_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AMPInvoiceState>): AMPInvoiceState {
        const message = { state: 0, settleIndex: 0n, settleTime: 0n, amtPaidMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AMPInvoiceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AMPInvoiceState): AMPInvoiceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.InvoiceHTLCState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* uint64 settle_index */ 2:
                    message.settleIndex = reader.uint64().toBigInt();
                    break;
                case /* int64 settle_time */ 3:
                    message.settleTime = reader.int64().toBigInt();
                    break;
                case /* int64 amt_paid_msat */ 5:
                    message.amtPaidMsat = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AMPInvoiceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.InvoiceHTLCState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* uint64 settle_index = 2; */
        if (message.settleIndex !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.settleIndex);
        /* int64 settle_time = 3; */
        if (message.settleTime !== 0n)
            writer.tag(3, WireType.Varint).int64(message.settleTime);
        /* int64 amt_paid_msat = 5; */
        if (message.amtPaidMsat !== 0n)
            writer.tag(5, WireType.Varint).int64(message.amtPaidMsat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AMPInvoiceState
 */
export const AMPInvoiceState = new AMPInvoiceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Invoice$Type extends MessageType<Invoice> {
    constructor() {
        super("lnrpc.Invoice", [
            { no: 1, name: "memo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "r_preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "r_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 23, name: "value_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "settled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "creation_date", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "settle_date", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "description_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "expiry", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "fallback_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "cltv_expiry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "route_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteHint },
            { no: 15, name: "private", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "add_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "settle_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "amt_paid", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "amt_paid_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "amt_paid_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "state", kind: "enum", T: () => ["lnrpc.Invoice.InvoiceState", Invoice_InvoiceState] },
            { no: 22, name: "htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InvoiceHTLC },
            { no: 24, name: "features", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => Feature } },
            { no: 25, name: "is_keysend", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 27, name: "is_amp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "amp_invoice_state", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => AMPInvoiceState } }
        ]);
    }
    create(value?: PartialMessage<Invoice>): Invoice {
        const message = { memo: "", rPreimage: new Uint8Array(0), rHash: new Uint8Array(0), value: 0n, valueMsat: 0n, settled: false, creationDate: 0n, settleDate: 0n, paymentRequest: "", descriptionHash: new Uint8Array(0), expiry: 0n, fallbackAddr: "", cltvExpiry: 0n, routeHints: [], private: false, addIndex: 0n, settleIndex: 0n, amtPaid: 0n, amtPaidSat: 0n, amtPaidMsat: 0n, state: 0, htlcs: [], features: {}, isKeysend: false, paymentAddr: new Uint8Array(0), isAmp: false, ampInvoiceState: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Invoice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Invoice): Invoice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string memo */ 1:
                    message.memo = reader.string();
                    break;
                case /* bytes r_preimage */ 3:
                    message.rPreimage = reader.bytes();
                    break;
                case /* bytes r_hash */ 4:
                    message.rHash = reader.bytes();
                    break;
                case /* int64 value */ 5:
                    message.value = reader.int64().toBigInt();
                    break;
                case /* int64 value_msat */ 23:
                    message.valueMsat = reader.int64().toBigInt();
                    break;
                case /* bool settled = 6 [deprecated = true];*/ 6:
                    message.settled = reader.bool();
                    break;
                case /* int64 creation_date */ 7:
                    message.creationDate = reader.int64().toBigInt();
                    break;
                case /* int64 settle_date */ 8:
                    message.settleDate = reader.int64().toBigInt();
                    break;
                case /* string payment_request */ 9:
                    message.paymentRequest = reader.string();
                    break;
                case /* bytes description_hash */ 10:
                    message.descriptionHash = reader.bytes();
                    break;
                case /* int64 expiry */ 11:
                    message.expiry = reader.int64().toBigInt();
                    break;
                case /* string fallback_addr */ 12:
                    message.fallbackAddr = reader.string();
                    break;
                case /* uint64 cltv_expiry */ 13:
                    message.cltvExpiry = reader.uint64().toBigInt();
                    break;
                case /* repeated lnrpc.RouteHint route_hints */ 14:
                    message.routeHints.push(RouteHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool private */ 15:
                    message.private = reader.bool();
                    break;
                case /* uint64 add_index */ 16:
                    message.addIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 settle_index */ 17:
                    message.settleIndex = reader.uint64().toBigInt();
                    break;
                case /* int64 amt_paid = 18 [deprecated = true];*/ 18:
                    message.amtPaid = reader.int64().toBigInt();
                    break;
                case /* int64 amt_paid_sat */ 19:
                    message.amtPaidSat = reader.int64().toBigInt();
                    break;
                case /* int64 amt_paid_msat */ 20:
                    message.amtPaidMsat = reader.int64().toBigInt();
                    break;
                case /* lnrpc.Invoice.InvoiceState state */ 21:
                    message.state = reader.int32();
                    break;
                case /* repeated lnrpc.InvoiceHTLC htlcs */ 22:
                    message.htlcs.push(InvoiceHTLC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint32, lnrpc.Feature> features */ 24:
                    this.binaryReadMap24(message.features, reader, options);
                    break;
                case /* bool is_keysend */ 25:
                    message.isKeysend = reader.bool();
                    break;
                case /* bytes payment_addr */ 26:
                    message.paymentAddr = reader.bytes();
                    break;
                case /* bool is_amp */ 27:
                    message.isAmp = reader.bool();
                    break;
                case /* map<string, lnrpc.AMPInvoiceState> amp_invoice_state */ 28:
                    this.binaryReadMap28(message.ampInvoiceState, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap24(map: Invoice["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Invoice["features"] | undefined, val: Invoice["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = Feature.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.Invoice.features");
            }
        }
        map[key ?? 0] = val ?? Feature.create();
    }
    private binaryReadMap28(map: Invoice["ampInvoiceState"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Invoice["ampInvoiceState"] | undefined, val: Invoice["ampInvoiceState"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = AMPInvoiceState.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.Invoice.amp_invoice_state");
            }
        }
        map[key ?? ""] = val ?? AMPInvoiceState.create();
    }
    internalBinaryWrite(message: Invoice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string memo = 1; */
        if (message.memo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.memo);
        /* bytes r_preimage = 3; */
        if (message.rPreimage.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.rPreimage);
        /* bytes r_hash = 4; */
        if (message.rHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.rHash);
        /* int64 value = 5; */
        if (message.value !== 0n)
            writer.tag(5, WireType.Varint).int64(message.value);
        /* int64 value_msat = 23; */
        if (message.valueMsat !== 0n)
            writer.tag(23, WireType.Varint).int64(message.valueMsat);
        /* bool settled = 6 [deprecated = true]; */
        if (message.settled !== false)
            writer.tag(6, WireType.Varint).bool(message.settled);
        /* int64 creation_date = 7; */
        if (message.creationDate !== 0n)
            writer.tag(7, WireType.Varint).int64(message.creationDate);
        /* int64 settle_date = 8; */
        if (message.settleDate !== 0n)
            writer.tag(8, WireType.Varint).int64(message.settleDate);
        /* string payment_request = 9; */
        if (message.paymentRequest !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.paymentRequest);
        /* bytes description_hash = 10; */
        if (message.descriptionHash.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.descriptionHash);
        /* int64 expiry = 11; */
        if (message.expiry !== 0n)
            writer.tag(11, WireType.Varint).int64(message.expiry);
        /* string fallback_addr = 12; */
        if (message.fallbackAddr !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.fallbackAddr);
        /* uint64 cltv_expiry = 13; */
        if (message.cltvExpiry !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.cltvExpiry);
        /* repeated lnrpc.RouteHint route_hints = 14; */
        for (let i = 0; i < message.routeHints.length; i++)
            RouteHint.internalBinaryWrite(message.routeHints[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* bool private = 15; */
        if (message.private !== false)
            writer.tag(15, WireType.Varint).bool(message.private);
        /* uint64 add_index = 16; */
        if (message.addIndex !== 0n)
            writer.tag(16, WireType.Varint).uint64(message.addIndex);
        /* uint64 settle_index = 17; */
        if (message.settleIndex !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.settleIndex);
        /* int64 amt_paid = 18 [deprecated = true]; */
        if (message.amtPaid !== 0n)
            writer.tag(18, WireType.Varint).int64(message.amtPaid);
        /* int64 amt_paid_sat = 19; */
        if (message.amtPaidSat !== 0n)
            writer.tag(19, WireType.Varint).int64(message.amtPaidSat);
        /* int64 amt_paid_msat = 20; */
        if (message.amtPaidMsat !== 0n)
            writer.tag(20, WireType.Varint).int64(message.amtPaidMsat);
        /* lnrpc.Invoice.InvoiceState state = 21; */
        if (message.state !== 0)
            writer.tag(21, WireType.Varint).int32(message.state);
        /* repeated lnrpc.InvoiceHTLC htlcs = 22; */
        for (let i = 0; i < message.htlcs.length; i++)
            InvoiceHTLC.internalBinaryWrite(message.htlcs[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, lnrpc.Feature> features = 24; */
        for (let k of Object.keys(message.features)) {
            writer.tag(24, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Feature.internalBinaryWrite(message.features[k as any], writer, options);
            writer.join().join();
        }
        /* bool is_keysend = 25; */
        if (message.isKeysend !== false)
            writer.tag(25, WireType.Varint).bool(message.isKeysend);
        /* bytes payment_addr = 26; */
        if (message.paymentAddr.length)
            writer.tag(26, WireType.LengthDelimited).bytes(message.paymentAddr);
        /* bool is_amp = 27; */
        if (message.isAmp !== false)
            writer.tag(27, WireType.Varint).bool(message.isAmp);
        /* map<string, lnrpc.AMPInvoiceState> amp_invoice_state = 28; */
        for (let k of Object.keys(message.ampInvoiceState)) {
            writer.tag(28, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AMPInvoiceState.internalBinaryWrite(message.ampInvoiceState[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Invoice
 */
export const Invoice = new Invoice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvoiceHTLC$Type extends MessageType<InvoiceHTLC> {
    constructor() {
        super("lnrpc.InvoiceHTLC", [
            { no: 1, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "htlc_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "accept_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "accept_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "resolve_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "expiry_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "state", kind: "enum", T: () => ["lnrpc.InvoiceHTLCState", InvoiceHTLCState] },
            { no: 9, name: "custom_records", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 10, name: "mpp_total_amt_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "amp", kind: "message", T: () => AMP }
        ]);
    }
    create(value?: PartialMessage<InvoiceHTLC>): InvoiceHTLC {
        const message = { chanId: "0", htlcIndex: 0n, amtMsat: 0n, acceptHeight: 0, acceptTime: 0n, resolveTime: 0n, expiryHeight: 0, state: 0, customRecords: {}, mppTotalAmtMsat: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InvoiceHTLC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvoiceHTLC): InvoiceHTLC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id = 1 [jstype = JS_STRING];*/ 1:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* uint64 htlc_index */ 2:
                    message.htlcIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 amt_msat */ 3:
                    message.amtMsat = reader.uint64().toBigInt();
                    break;
                case /* int32 accept_height */ 4:
                    message.acceptHeight = reader.int32();
                    break;
                case /* int64 accept_time */ 5:
                    message.acceptTime = reader.int64().toBigInt();
                    break;
                case /* int64 resolve_time */ 6:
                    message.resolveTime = reader.int64().toBigInt();
                    break;
                case /* int32 expiry_height */ 7:
                    message.expiryHeight = reader.int32();
                    break;
                case /* lnrpc.InvoiceHTLCState state */ 8:
                    message.state = reader.int32();
                    break;
                case /* map<uint64, bytes> custom_records */ 9:
                    this.binaryReadMap9(message.customRecords, reader, options);
                    break;
                case /* uint64 mpp_total_amt_msat */ 10:
                    message.mppTotalAmtMsat = reader.uint64().toBigInt();
                    break;
                case /* lnrpc.AMP amp */ 11:
                    message.amp = AMP.internalBinaryRead(reader, reader.uint32(), options, message.amp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: InvoiceHTLC["customRecords"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InvoiceHTLC["customRecords"] | undefined, val: InvoiceHTLC["customRecords"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.InvoiceHTLC.custom_records");
            }
        }
        map[key ?? "0"] = val ?? new Uint8Array(0);
    }
    internalBinaryWrite(message: InvoiceHTLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 1 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.chanId);
        /* uint64 htlc_index = 2; */
        if (message.htlcIndex !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.htlcIndex);
        /* uint64 amt_msat = 3; */
        if (message.amtMsat !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.amtMsat);
        /* int32 accept_height = 4; */
        if (message.acceptHeight !== 0)
            writer.tag(4, WireType.Varint).int32(message.acceptHeight);
        /* int64 accept_time = 5; */
        if (message.acceptTime !== 0n)
            writer.tag(5, WireType.Varint).int64(message.acceptTime);
        /* int64 resolve_time = 6; */
        if (message.resolveTime !== 0n)
            writer.tag(6, WireType.Varint).int64(message.resolveTime);
        /* int32 expiry_height = 7; */
        if (message.expiryHeight !== 0)
            writer.tag(7, WireType.Varint).int32(message.expiryHeight);
        /* lnrpc.InvoiceHTLCState state = 8; */
        if (message.state !== 0)
            writer.tag(8, WireType.Varint).int32(message.state);
        /* map<uint64, bytes> custom_records = 9; */
        for (let k of Object.keys(message.customRecords))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.LengthDelimited).bytes(message.customRecords[k]).join();
        /* uint64 mpp_total_amt_msat = 10; */
        if (message.mppTotalAmtMsat !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.mppTotalAmtMsat);
        /* lnrpc.AMP amp = 11; */
        if (message.amp)
            AMP.internalBinaryWrite(message.amp, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.InvoiceHTLC
 */
export const InvoiceHTLC = new InvoiceHTLC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AMP$Type extends MessageType<AMP> {
    constructor() {
        super("lnrpc.AMP", [
            { no: 1, name: "root_share", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "set_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "child_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AMP>): AMP {
        const message = { rootShare: new Uint8Array(0), setId: new Uint8Array(0), childIndex: 0, hash: new Uint8Array(0), preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AMP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AMP): AMP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes root_share */ 1:
                    message.rootShare = reader.bytes();
                    break;
                case /* bytes set_id */ 2:
                    message.setId = reader.bytes();
                    break;
                case /* uint32 child_index */ 3:
                    message.childIndex = reader.uint32();
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* bytes preimage */ 5:
                    message.preimage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AMP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes root_share = 1; */
        if (message.rootShare.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rootShare);
        /* bytes set_id = 2; */
        if (message.setId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.setId);
        /* uint32 child_index = 3; */
        if (message.childIndex !== 0)
            writer.tag(3, WireType.Varint).uint32(message.childIndex);
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* bytes preimage = 5; */
        if (message.preimage.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.preimage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AMP
 */
export const AMP = new AMP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddInvoiceResponse$Type extends MessageType<AddInvoiceResponse> {
    constructor() {
        super("lnrpc.AddInvoiceResponse", [
            { no: 1, name: "r_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "add_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AddInvoiceResponse>): AddInvoiceResponse {
        const message = { rHash: new Uint8Array(0), paymentRequest: "", addIndex: 0n, paymentAddr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddInvoiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddInvoiceResponse): AddInvoiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes r_hash */ 1:
                    message.rHash = reader.bytes();
                    break;
                case /* string payment_request */ 2:
                    message.paymentRequest = reader.string();
                    break;
                case /* uint64 add_index */ 16:
                    message.addIndex = reader.uint64().toBigInt();
                    break;
                case /* bytes payment_addr */ 17:
                    message.paymentAddr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddInvoiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes r_hash = 1; */
        if (message.rHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rHash);
        /* string payment_request = 2; */
        if (message.paymentRequest !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paymentRequest);
        /* uint64 add_index = 16; */
        if (message.addIndex !== 0n)
            writer.tag(16, WireType.Varint).uint64(message.addIndex);
        /* bytes payment_addr = 17; */
        if (message.paymentAddr.length)
            writer.tag(17, WireType.LengthDelimited).bytes(message.paymentAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AddInvoiceResponse
 */
export const AddInvoiceResponse = new AddInvoiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaymentHash$Type extends MessageType<PaymentHash> {
    constructor() {
        super("lnrpc.PaymentHash", [
            { no: 1, name: "r_hash_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "r_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PaymentHash>): PaymentHash {
        const message = { rHashStr: "", rHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PaymentHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaymentHash): PaymentHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string r_hash_str = 1 [deprecated = true];*/ 1:
                    message.rHashStr = reader.string();
                    break;
                case /* bytes r_hash */ 2:
                    message.rHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaymentHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string r_hash_str = 1 [deprecated = true]; */
        if (message.rHashStr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rHashStr);
        /* bytes r_hash = 2; */
        if (message.rHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PaymentHash
 */
export const PaymentHash = new PaymentHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListInvoiceRequest$Type extends MessageType<ListInvoiceRequest> {
    constructor() {
        super("lnrpc.ListInvoiceRequest", [
            { no: 1, name: "pending_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "index_offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "num_max_invoices", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "reversed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListInvoiceRequest>): ListInvoiceRequest {
        const message = { pendingOnly: false, indexOffset: 0n, numMaxInvoices: 0n, reversed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListInvoiceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListInvoiceRequest): ListInvoiceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool pending_only */ 1:
                    message.pendingOnly = reader.bool();
                    break;
                case /* uint64 index_offset */ 4:
                    message.indexOffset = reader.uint64().toBigInt();
                    break;
                case /* uint64 num_max_invoices */ 5:
                    message.numMaxInvoices = reader.uint64().toBigInt();
                    break;
                case /* bool reversed */ 6:
                    message.reversed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListInvoiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool pending_only = 1; */
        if (message.pendingOnly !== false)
            writer.tag(1, WireType.Varint).bool(message.pendingOnly);
        /* uint64 index_offset = 4; */
        if (message.indexOffset !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.indexOffset);
        /* uint64 num_max_invoices = 5; */
        if (message.numMaxInvoices !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.numMaxInvoices);
        /* bool reversed = 6; */
        if (message.reversed !== false)
            writer.tag(6, WireType.Varint).bool(message.reversed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListInvoiceRequest
 */
export const ListInvoiceRequest = new ListInvoiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListInvoiceResponse$Type extends MessageType<ListInvoiceResponse> {
    constructor() {
        super("lnrpc.ListInvoiceResponse", [
            { no: 1, name: "invoices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Invoice },
            { no: 2, name: "last_index_offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "first_index_offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListInvoiceResponse>): ListInvoiceResponse {
        const message = { invoices: [], lastIndexOffset: 0n, firstIndexOffset: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListInvoiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListInvoiceResponse): ListInvoiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Invoice invoices */ 1:
                    message.invoices.push(Invoice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 last_index_offset */ 2:
                    message.lastIndexOffset = reader.uint64().toBigInt();
                    break;
                case /* uint64 first_index_offset */ 3:
                    message.firstIndexOffset = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListInvoiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Invoice invoices = 1; */
        for (let i = 0; i < message.invoices.length; i++)
            Invoice.internalBinaryWrite(message.invoices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 last_index_offset = 2; */
        if (message.lastIndexOffset !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.lastIndexOffset);
        /* uint64 first_index_offset = 3; */
        if (message.firstIndexOffset !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.firstIndexOffset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListInvoiceResponse
 */
export const ListInvoiceResponse = new ListInvoiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvoiceSubscription$Type extends MessageType<InvoiceSubscription> {
    constructor() {
        super("lnrpc.InvoiceSubscription", [
            { no: 1, name: "add_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "settle_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<InvoiceSubscription>): InvoiceSubscription {
        const message = { addIndex: 0n, settleIndex: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InvoiceSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvoiceSubscription): InvoiceSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 add_index */ 1:
                    message.addIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 settle_index */ 2:
                    message.settleIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvoiceSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 add_index = 1; */
        if (message.addIndex !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.addIndex);
        /* uint64 settle_index = 2; */
        if (message.settleIndex !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.settleIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.InvoiceSubscription
 */
export const InvoiceSubscription = new InvoiceSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payment$Type extends MessageType<Payment> {
    constructor() {
        super("lnrpc.Payment", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "creation_date", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "fee", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "payment_preimage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "value_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "value_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "payment_request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "status", kind: "enum", T: () => ["lnrpc.Payment.PaymentStatus", Payment_PaymentStatus] },
            { no: 11, name: "fee_sat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "creation_time_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "htlcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HTLCAttempt },
            { no: 15, name: "payment_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "failure_reason", kind: "enum", T: () => ["lnrpc.PaymentFailureReason", PaymentFailureReason] }
        ]);
    }
    create(value?: PartialMessage<Payment>): Payment {
        const message = { paymentHash: "", value: 0n, creationDate: 0n, fee: 0n, paymentPreimage: "", valueSat: 0n, valueMsat: 0n, paymentRequest: "", status: 0, feeSat: 0n, feeMsat: 0n, creationTimeNs: 0n, htlcs: [], paymentIndex: 0n, failureReason: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Payment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payment): Payment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_hash */ 1:
                    message.paymentHash = reader.string();
                    break;
                case /* int64 value = 2 [deprecated = true];*/ 2:
                    message.value = reader.int64().toBigInt();
                    break;
                case /* int64 creation_date = 3 [deprecated = true];*/ 3:
                    message.creationDate = reader.int64().toBigInt();
                    break;
                case /* int64 fee = 5 [deprecated = true];*/ 5:
                    message.fee = reader.int64().toBigInt();
                    break;
                case /* string payment_preimage */ 6:
                    message.paymentPreimage = reader.string();
                    break;
                case /* int64 value_sat */ 7:
                    message.valueSat = reader.int64().toBigInt();
                    break;
                case /* int64 value_msat */ 8:
                    message.valueMsat = reader.int64().toBigInt();
                    break;
                case /* string payment_request */ 9:
                    message.paymentRequest = reader.string();
                    break;
                case /* lnrpc.Payment.PaymentStatus status */ 10:
                    message.status = reader.int32();
                    break;
                case /* int64 fee_sat */ 11:
                    message.feeSat = reader.int64().toBigInt();
                    break;
                case /* int64 fee_msat */ 12:
                    message.feeMsat = reader.int64().toBigInt();
                    break;
                case /* int64 creation_time_ns */ 13:
                    message.creationTimeNs = reader.int64().toBigInt();
                    break;
                case /* repeated lnrpc.HTLCAttempt htlcs */ 14:
                    message.htlcs.push(HTLCAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 payment_index */ 15:
                    message.paymentIndex = reader.uint64().toBigInt();
                    break;
                case /* lnrpc.PaymentFailureReason failure_reason */ 16:
                    message.failureReason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Payment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_hash = 1; */
        if (message.paymentHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentHash);
        /* int64 value = 2 [deprecated = true]; */
        if (message.value !== 0n)
            writer.tag(2, WireType.Varint).int64(message.value);
        /* int64 creation_date = 3 [deprecated = true]; */
        if (message.creationDate !== 0n)
            writer.tag(3, WireType.Varint).int64(message.creationDate);
        /* int64 fee = 5 [deprecated = true]; */
        if (message.fee !== 0n)
            writer.tag(5, WireType.Varint).int64(message.fee);
        /* string payment_preimage = 6; */
        if (message.paymentPreimage !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.paymentPreimage);
        /* int64 value_sat = 7; */
        if (message.valueSat !== 0n)
            writer.tag(7, WireType.Varint).int64(message.valueSat);
        /* int64 value_msat = 8; */
        if (message.valueMsat !== 0n)
            writer.tag(8, WireType.Varint).int64(message.valueMsat);
        /* string payment_request = 9; */
        if (message.paymentRequest !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.paymentRequest);
        /* lnrpc.Payment.PaymentStatus status = 10; */
        if (message.status !== 0)
            writer.tag(10, WireType.Varint).int32(message.status);
        /* int64 fee_sat = 11; */
        if (message.feeSat !== 0n)
            writer.tag(11, WireType.Varint).int64(message.feeSat);
        /* int64 fee_msat = 12; */
        if (message.feeMsat !== 0n)
            writer.tag(12, WireType.Varint).int64(message.feeMsat);
        /* int64 creation_time_ns = 13; */
        if (message.creationTimeNs !== 0n)
            writer.tag(13, WireType.Varint).int64(message.creationTimeNs);
        /* repeated lnrpc.HTLCAttempt htlcs = 14; */
        for (let i = 0; i < message.htlcs.length; i++)
            HTLCAttempt.internalBinaryWrite(message.htlcs[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint64 payment_index = 15; */
        if (message.paymentIndex !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.paymentIndex);
        /* lnrpc.PaymentFailureReason failure_reason = 16; */
        if (message.failureReason !== 0)
            writer.tag(16, WireType.Varint).int32(message.failureReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Payment
 */
export const Payment = new Payment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTLCAttempt$Type extends MessageType<HTLCAttempt> {
    constructor() {
        super("lnrpc.HTLCAttempt", [
            { no: 7, name: "attempt_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1, name: "status", kind: "enum", T: () => ["lnrpc.HTLCAttempt.HTLCStatus", HTLCAttempt_HTLCStatus] },
            { no: 2, name: "route", kind: "message", T: () => Route },
            { no: 3, name: "attempt_time_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "resolve_time_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "failure", kind: "message", T: () => Failure },
            { no: 6, name: "preimage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HTLCAttempt>): HTLCAttempt {
        const message = { attemptId: 0n, status: 0, attemptTimeNs: 0n, resolveTimeNs: 0n, preimage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTLCAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTLCAttempt): HTLCAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 attempt_id */ 7:
                    message.attemptId = reader.uint64().toBigInt();
                    break;
                case /* lnrpc.HTLCAttempt.HTLCStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* lnrpc.Route route */ 2:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                case /* int64 attempt_time_ns */ 3:
                    message.attemptTimeNs = reader.int64().toBigInt();
                    break;
                case /* int64 resolve_time_ns */ 4:
                    message.resolveTimeNs = reader.int64().toBigInt();
                    break;
                case /* lnrpc.Failure failure */ 5:
                    message.failure = Failure.internalBinaryRead(reader, reader.uint32(), options, message.failure);
                    break;
                case /* bytes preimage */ 6:
                    message.preimage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTLCAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 attempt_id = 7; */
        if (message.attemptId !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.attemptId);
        /* lnrpc.HTLCAttempt.HTLCStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* lnrpc.Route route = 2; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 attempt_time_ns = 3; */
        if (message.attemptTimeNs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.attemptTimeNs);
        /* int64 resolve_time_ns = 4; */
        if (message.resolveTimeNs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.resolveTimeNs);
        /* lnrpc.Failure failure = 5; */
        if (message.failure)
            Failure.internalBinaryWrite(message.failure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bytes preimage = 6; */
        if (message.preimage.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.preimage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.HTLCAttempt
 */
export const HTLCAttempt = new HTLCAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPaymentsRequest$Type extends MessageType<ListPaymentsRequest> {
    constructor() {
        super("lnrpc.ListPaymentsRequest", [
            { no: 1, name: "include_incomplete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "index_offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_payments", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "reversed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "count_total_payments", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListPaymentsRequest>): ListPaymentsRequest {
        const message = { includeIncomplete: false, indexOffset: 0n, maxPayments: 0n, reversed: false, countTotalPayments: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPaymentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaymentsRequest): ListPaymentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_incomplete */ 1:
                    message.includeIncomplete = reader.bool();
                    break;
                case /* uint64 index_offset */ 2:
                    message.indexOffset = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_payments */ 3:
                    message.maxPayments = reader.uint64().toBigInt();
                    break;
                case /* bool reversed */ 4:
                    message.reversed = reader.bool();
                    break;
                case /* bool count_total_payments */ 5:
                    message.countTotalPayments = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_incomplete = 1; */
        if (message.includeIncomplete !== false)
            writer.tag(1, WireType.Varint).bool(message.includeIncomplete);
        /* uint64 index_offset = 2; */
        if (message.indexOffset !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.indexOffset);
        /* uint64 max_payments = 3; */
        if (message.maxPayments !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.maxPayments);
        /* bool reversed = 4; */
        if (message.reversed !== false)
            writer.tag(4, WireType.Varint).bool(message.reversed);
        /* bool count_total_payments = 5; */
        if (message.countTotalPayments !== false)
            writer.tag(5, WireType.Varint).bool(message.countTotalPayments);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPaymentsRequest
 */
export const ListPaymentsRequest = new ListPaymentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPaymentsResponse$Type extends MessageType<ListPaymentsResponse> {
    constructor() {
        super("lnrpc.ListPaymentsResponse", [
            { no: 1, name: "payments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Payment },
            { no: 2, name: "first_index_offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_index_offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_num_payments", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListPaymentsResponse>): ListPaymentsResponse {
        const message = { payments: [], firstIndexOffset: 0n, lastIndexOffset: 0n, totalNumPayments: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPaymentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaymentsResponse): ListPaymentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.Payment payments */ 1:
                    message.payments.push(Payment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 first_index_offset */ 2:
                    message.firstIndexOffset = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_index_offset */ 3:
                    message.lastIndexOffset = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_num_payments */ 4:
                    message.totalNumPayments = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPaymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.Payment payments = 1; */
        for (let i = 0; i < message.payments.length; i++)
            Payment.internalBinaryWrite(message.payments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 first_index_offset = 2; */
        if (message.firstIndexOffset !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.firstIndexOffset);
        /* uint64 last_index_offset = 3; */
        if (message.lastIndexOffset !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastIndexOffset);
        /* uint64 total_num_payments = 4; */
        if (message.totalNumPayments !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.totalNumPayments);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPaymentsResponse
 */
export const ListPaymentsResponse = new ListPaymentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaymentRequest$Type extends MessageType<DeletePaymentRequest> {
    constructor() {
        super("lnrpc.DeletePaymentRequest", [
            { no: 1, name: "payment_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "failed_htlcs_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePaymentRequest>): DeletePaymentRequest {
        const message = { paymentHash: new Uint8Array(0), failedHtlcsOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePaymentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaymentRequest): DeletePaymentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payment_hash */ 1:
                    message.paymentHash = reader.bytes();
                    break;
                case /* bool failed_htlcs_only */ 2:
                    message.failedHtlcsOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payment_hash = 1; */
        if (message.paymentHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paymentHash);
        /* bool failed_htlcs_only = 2; */
        if (message.failedHtlcsOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.failedHtlcsOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DeletePaymentRequest
 */
export const DeletePaymentRequest = new DeletePaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAllPaymentsRequest$Type extends MessageType<DeleteAllPaymentsRequest> {
    constructor() {
        super("lnrpc.DeleteAllPaymentsRequest", [
            { no: 1, name: "failed_payments_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "failed_htlcs_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAllPaymentsRequest>): DeleteAllPaymentsRequest {
        const message = { failedPaymentsOnly: false, failedHtlcsOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteAllPaymentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllPaymentsRequest): DeleteAllPaymentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool failed_payments_only */ 1:
                    message.failedPaymentsOnly = reader.bool();
                    break;
                case /* bool failed_htlcs_only */ 2:
                    message.failedHtlcsOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAllPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool failed_payments_only = 1; */
        if (message.failedPaymentsOnly !== false)
            writer.tag(1, WireType.Varint).bool(message.failedPaymentsOnly);
        /* bool failed_htlcs_only = 2; */
        if (message.failedHtlcsOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.failedHtlcsOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteAllPaymentsRequest
 */
export const DeleteAllPaymentsRequest = new DeleteAllPaymentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaymentResponse$Type extends MessageType<DeletePaymentResponse> {
    constructor() {
        super("lnrpc.DeletePaymentResponse", []);
    }
    create(value?: PartialMessage<DeletePaymentResponse>): DeletePaymentResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePaymentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaymentResponse): DeletePaymentResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeletePaymentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DeletePaymentResponse
 */
export const DeletePaymentResponse = new DeletePaymentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAllPaymentsResponse$Type extends MessageType<DeleteAllPaymentsResponse> {
    constructor() {
        super("lnrpc.DeleteAllPaymentsResponse", []);
    }
    create(value?: PartialMessage<DeleteAllPaymentsResponse>): DeleteAllPaymentsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteAllPaymentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllPaymentsResponse): DeleteAllPaymentsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteAllPaymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteAllPaymentsResponse
 */
export const DeleteAllPaymentsResponse = new DeleteAllPaymentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbandonChannelRequest$Type extends MessageType<AbandonChannelRequest> {
    constructor() {
        super("lnrpc.AbandonChannelRequest", [
            { no: 1, name: "channel_point", kind: "message", T: () => ChannelPoint },
            { no: 2, name: "pending_funding_shim_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "i_know_what_i_am_doing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AbandonChannelRequest>): AbandonChannelRequest {
        const message = { pendingFundingShimOnly: false, iKnowWhatIAmDoing: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbandonChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbandonChannelRequest): AbandonChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint channel_point */ 1:
                    message.channelPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.channelPoint);
                    break;
                case /* bool pending_funding_shim_only */ 2:
                    message.pendingFundingShimOnly = reader.bool();
                    break;
                case /* bool i_know_what_i_am_doing */ 3:
                    message.iKnowWhatIAmDoing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbandonChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint channel_point = 1; */
        if (message.channelPoint)
            ChannelPoint.internalBinaryWrite(message.channelPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool pending_funding_shim_only = 2; */
        if (message.pendingFundingShimOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.pendingFundingShimOnly);
        /* bool i_know_what_i_am_doing = 3; */
        if (message.iKnowWhatIAmDoing !== false)
            writer.tag(3, WireType.Varint).bool(message.iKnowWhatIAmDoing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AbandonChannelRequest
 */
export const AbandonChannelRequest = new AbandonChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbandonChannelResponse$Type extends MessageType<AbandonChannelResponse> {
    constructor() {
        super("lnrpc.AbandonChannelResponse", []);
    }
    create(value?: PartialMessage<AbandonChannelResponse>): AbandonChannelResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbandonChannelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbandonChannelResponse): AbandonChannelResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AbandonChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.AbandonChannelResponse
 */
export const AbandonChannelResponse = new AbandonChannelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DebugLevelRequest$Type extends MessageType<DebugLevelRequest> {
    constructor() {
        super("lnrpc.DebugLevelRequest", [
            { no: 1, name: "show", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "level_spec", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DebugLevelRequest>): DebugLevelRequest {
        const message = { show: false, levelSpec: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DebugLevelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DebugLevelRequest): DebugLevelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool show */ 1:
                    message.show = reader.bool();
                    break;
                case /* string level_spec */ 2:
                    message.levelSpec = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DebugLevelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool show = 1; */
        if (message.show !== false)
            writer.tag(1, WireType.Varint).bool(message.show);
        /* string level_spec = 2; */
        if (message.levelSpec !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.levelSpec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DebugLevelRequest
 */
export const DebugLevelRequest = new DebugLevelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DebugLevelResponse$Type extends MessageType<DebugLevelResponse> {
    constructor() {
        super("lnrpc.DebugLevelResponse", [
            { no: 1, name: "sub_systems", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DebugLevelResponse>): DebugLevelResponse {
        const message = { subSystems: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DebugLevelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DebugLevelResponse): DebugLevelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sub_systems */ 1:
                    message.subSystems = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DebugLevelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sub_systems = 1; */
        if (message.subSystems !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subSystems);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DebugLevelResponse
 */
export const DebugLevelResponse = new DebugLevelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PayReqString$Type extends MessageType<PayReqString> {
    constructor() {
        super("lnrpc.PayReqString", [
            { no: 1, name: "pay_req", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PayReqString>): PayReqString {
        const message = { payReq: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PayReqString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PayReqString): PayReqString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pay_req */ 1:
                    message.payReq = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PayReqString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pay_req = 1; */
        if (message.payReq !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.payReq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PayReqString
 */
export const PayReqString = new PayReqString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PayReq$Type extends MessageType<PayReq> {
    constructor() {
        super("lnrpc.PayReq", [
            { no: 1, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payment_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "num_satoshis", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "expiry", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "description_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "fallback_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "cltv_expiry", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "route_hints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteHint },
            { no: 11, name: "payment_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "num_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "features", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => Feature } }
        ]);
    }
    create(value?: PartialMessage<PayReq>): PayReq {
        const message = { destination: "", paymentHash: "", numSatoshis: 0n, timestamp: 0n, expiry: 0n, description: "", descriptionHash: "", fallbackAddr: "", cltvExpiry: 0n, routeHints: [], paymentAddr: new Uint8Array(0), numMsat: 0n, features: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PayReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PayReq): PayReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string destination */ 1:
                    message.destination = reader.string();
                    break;
                case /* string payment_hash */ 2:
                    message.paymentHash = reader.string();
                    break;
                case /* int64 num_satoshis */ 3:
                    message.numSatoshis = reader.int64().toBigInt();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* int64 expiry */ 5:
                    message.expiry = reader.int64().toBigInt();
                    break;
                case /* string description */ 6:
                    message.description = reader.string();
                    break;
                case /* string description_hash */ 7:
                    message.descriptionHash = reader.string();
                    break;
                case /* string fallback_addr */ 8:
                    message.fallbackAddr = reader.string();
                    break;
                case /* int64 cltv_expiry */ 9:
                    message.cltvExpiry = reader.int64().toBigInt();
                    break;
                case /* repeated lnrpc.RouteHint route_hints */ 10:
                    message.routeHints.push(RouteHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes payment_addr */ 11:
                    message.paymentAddr = reader.bytes();
                    break;
                case /* int64 num_msat */ 12:
                    message.numMsat = reader.int64().toBigInt();
                    break;
                case /* map<uint32, lnrpc.Feature> features */ 13:
                    this.binaryReadMap13(message.features, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: PayReq["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PayReq["features"] | undefined, val: PayReq["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = Feature.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.PayReq.features");
            }
        }
        map[key ?? 0] = val ?? Feature.create();
    }
    internalBinaryWrite(message: PayReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string destination = 1; */
        if (message.destination !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.destination);
        /* string payment_hash = 2; */
        if (message.paymentHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paymentHash);
        /* int64 num_satoshis = 3; */
        if (message.numSatoshis !== 0n)
            writer.tag(3, WireType.Varint).int64(message.numSatoshis);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        /* int64 expiry = 5; */
        if (message.expiry !== 0n)
            writer.tag(5, WireType.Varint).int64(message.expiry);
        /* string description = 6; */
        if (message.description !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* string description_hash = 7; */
        if (message.descriptionHash !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.descriptionHash);
        /* string fallback_addr = 8; */
        if (message.fallbackAddr !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.fallbackAddr);
        /* int64 cltv_expiry = 9; */
        if (message.cltvExpiry !== 0n)
            writer.tag(9, WireType.Varint).int64(message.cltvExpiry);
        /* repeated lnrpc.RouteHint route_hints = 10; */
        for (let i = 0; i < message.routeHints.length; i++)
            RouteHint.internalBinaryWrite(message.routeHints[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bytes payment_addr = 11; */
        if (message.paymentAddr.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.paymentAddr);
        /* int64 num_msat = 12; */
        if (message.numMsat !== 0n)
            writer.tag(12, WireType.Varint).int64(message.numMsat);
        /* map<uint32, lnrpc.Feature> features = 13; */
        for (let k of Object.keys(message.features)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Feature.internalBinaryWrite(message.features[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PayReq
 */
export const PayReq = new PayReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Feature$Type extends MessageType<Feature> {
    constructor() {
        super("lnrpc.Feature", [
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_known", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Feature>): Feature {
        const message = { name: "", isRequired: false, isKnown: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Feature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Feature): Feature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool is_required */ 3:
                    message.isRequired = reader.bool();
                    break;
                case /* bool is_known */ 4:
                    message.isKnown = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Feature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool is_required = 3; */
        if (message.isRequired !== false)
            writer.tag(3, WireType.Varint).bool(message.isRequired);
        /* bool is_known = 4; */
        if (message.isKnown !== false)
            writer.tag(4, WireType.Varint).bool(message.isKnown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Feature
 */
export const Feature = new Feature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeReportRequest$Type extends MessageType<FeeReportRequest> {
    constructor() {
        super("lnrpc.FeeReportRequest", []);
    }
    create(value?: PartialMessage<FeeReportRequest>): FeeReportRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeReportRequest): FeeReportRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FeeReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FeeReportRequest
 */
export const FeeReportRequest = new FeeReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelFeeReport$Type extends MessageType<ChannelFeeReport> {
    constructor() {
        super("lnrpc.ChannelFeeReport", [
            { no: 5, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 1, name: "channel_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base_fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "fee_per_mil", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fee_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelFeeReport>): ChannelFeeReport {
        const message = { chanId: "0", channelPoint: "", baseFeeMsat: 0n, feePerMil: 0n, feeRate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelFeeReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelFeeReport): ChannelFeeReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chan_id = 5 [jstype = JS_STRING];*/ 5:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* string channel_point */ 1:
                    message.channelPoint = reader.string();
                    break;
                case /* int64 base_fee_msat */ 2:
                    message.baseFeeMsat = reader.int64().toBigInt();
                    break;
                case /* int64 fee_per_mil */ 3:
                    message.feePerMil = reader.int64().toBigInt();
                    break;
                case /* double fee_rate */ 4:
                    message.feeRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelFeeReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chan_id = 5 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(5, WireType.Varint).uint64(message.chanId);
        /* string channel_point = 1; */
        if (message.channelPoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelPoint);
        /* int64 base_fee_msat = 2; */
        if (message.baseFeeMsat !== 0n)
            writer.tag(2, WireType.Varint).int64(message.baseFeeMsat);
        /* int64 fee_per_mil = 3; */
        if (message.feePerMil !== 0n)
            writer.tag(3, WireType.Varint).int64(message.feePerMil);
        /* double fee_rate = 4; */
        if (message.feeRate !== 0)
            writer.tag(4, WireType.Bit64).double(message.feeRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelFeeReport
 */
export const ChannelFeeReport = new ChannelFeeReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeReportResponse$Type extends MessageType<FeeReportResponse> {
    constructor() {
        super("lnrpc.FeeReportResponse", [
            { no: 1, name: "channel_fees", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelFeeReport },
            { no: 2, name: "day_fee_sum", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "week_fee_sum", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "month_fee_sum", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeeReportResponse>): FeeReportResponse {
        const message = { channelFees: [], dayFeeSum: 0n, weekFeeSum: 0n, monthFeeSum: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeReportResponse): FeeReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.ChannelFeeReport channel_fees */ 1:
                    message.channelFees.push(ChannelFeeReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 day_fee_sum */ 2:
                    message.dayFeeSum = reader.uint64().toBigInt();
                    break;
                case /* uint64 week_fee_sum */ 3:
                    message.weekFeeSum = reader.uint64().toBigInt();
                    break;
                case /* uint64 month_fee_sum */ 4:
                    message.monthFeeSum = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.ChannelFeeReport channel_fees = 1; */
        for (let i = 0; i < message.channelFees.length; i++)
            ChannelFeeReport.internalBinaryWrite(message.channelFees[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 day_fee_sum = 2; */
        if (message.dayFeeSum !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.dayFeeSum);
        /* uint64 week_fee_sum = 3; */
        if (message.weekFeeSum !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.weekFeeSum);
        /* uint64 month_fee_sum = 4; */
        if (message.monthFeeSum !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.monthFeeSum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FeeReportResponse
 */
export const FeeReportResponse = new FeeReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PolicyUpdateRequest$Type extends MessageType<PolicyUpdateRequest> {
    constructor() {
        super("lnrpc.PolicyUpdateRequest", [
            { no: 1, name: "global", kind: "scalar", oneof: "scope", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "chan_point", kind: "message", oneof: "scope", T: () => ChannelPoint },
            { no: 3, name: "base_fee_msat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fee_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "fee_rate_ppm", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "time_lock_delta", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "max_htlc_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "min_htlc_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "min_htlc_msat_specified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PolicyUpdateRequest>): PolicyUpdateRequest {
        const message = { scope: { oneofKind: undefined }, baseFeeMsat: 0n, feeRate: 0, feeRatePpm: 0, timeLockDelta: 0, maxHtlcMsat: 0n, minHtlcMsat: 0n, minHtlcMsatSpecified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PolicyUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyUpdateRequest): PolicyUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool global */ 1:
                    message.scope = {
                        oneofKind: "global",
                        global: reader.bool()
                    };
                    break;
                case /* lnrpc.ChannelPoint chan_point */ 2:
                    message.scope = {
                        oneofKind: "chanPoint",
                        chanPoint: ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, (message.scope as any).chanPoint)
                    };
                    break;
                case /* int64 base_fee_msat */ 3:
                    message.baseFeeMsat = reader.int64().toBigInt();
                    break;
                case /* double fee_rate */ 4:
                    message.feeRate = reader.double();
                    break;
                case /* uint32 fee_rate_ppm */ 9:
                    message.feeRatePpm = reader.uint32();
                    break;
                case /* uint32 time_lock_delta */ 5:
                    message.timeLockDelta = reader.uint32();
                    break;
                case /* uint64 max_htlc_msat */ 6:
                    message.maxHtlcMsat = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_htlc_msat */ 7:
                    message.minHtlcMsat = reader.uint64().toBigInt();
                    break;
                case /* bool min_htlc_msat_specified */ 8:
                    message.minHtlcMsatSpecified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PolicyUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool global = 1; */
        if (message.scope.oneofKind === "global")
            writer.tag(1, WireType.Varint).bool(message.scope.global);
        /* lnrpc.ChannelPoint chan_point = 2; */
        if (message.scope.oneofKind === "chanPoint")
            ChannelPoint.internalBinaryWrite(message.scope.chanPoint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 base_fee_msat = 3; */
        if (message.baseFeeMsat !== 0n)
            writer.tag(3, WireType.Varint).int64(message.baseFeeMsat);
        /* double fee_rate = 4; */
        if (message.feeRate !== 0)
            writer.tag(4, WireType.Bit64).double(message.feeRate);
        /* uint32 fee_rate_ppm = 9; */
        if (message.feeRatePpm !== 0)
            writer.tag(9, WireType.Varint).uint32(message.feeRatePpm);
        /* uint32 time_lock_delta = 5; */
        if (message.timeLockDelta !== 0)
            writer.tag(5, WireType.Varint).uint32(message.timeLockDelta);
        /* uint64 max_htlc_msat = 6; */
        if (message.maxHtlcMsat !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.maxHtlcMsat);
        /* uint64 min_htlc_msat = 7; */
        if (message.minHtlcMsat !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.minHtlcMsat);
        /* bool min_htlc_msat_specified = 8; */
        if (message.minHtlcMsatSpecified !== false)
            writer.tag(8, WireType.Varint).bool(message.minHtlcMsatSpecified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PolicyUpdateRequest
 */
export const PolicyUpdateRequest = new PolicyUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FailedUpdate$Type extends MessageType<FailedUpdate> {
    constructor() {
        super("lnrpc.FailedUpdate", [
            { no: 1, name: "outpoint", kind: "message", T: () => OutPoint },
            { no: 2, name: "reason", kind: "enum", T: () => ["lnrpc.UpdateFailure", UpdateFailure, "UPDATE_FAILURE_"] },
            { no: 3, name: "update_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FailedUpdate>): FailedUpdate {
        const message = { reason: 0, updateError: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FailedUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FailedUpdate): FailedUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.OutPoint outpoint */ 1:
                    message.outpoint = OutPoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* lnrpc.UpdateFailure reason */ 2:
                    message.reason = reader.int32();
                    break;
                case /* string update_error */ 3:
                    message.updateError = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FailedUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.OutPoint outpoint = 1; */
        if (message.outpoint)
            OutPoint.internalBinaryWrite(message.outpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.UpdateFailure reason = 2; */
        if (message.reason !== 0)
            writer.tag(2, WireType.Varint).int32(message.reason);
        /* string update_error = 3; */
        if (message.updateError !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updateError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.FailedUpdate
 */
export const FailedUpdate = new FailedUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PolicyUpdateResponse$Type extends MessageType<PolicyUpdateResponse> {
    constructor() {
        super("lnrpc.PolicyUpdateResponse", [
            { no: 1, name: "failed_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FailedUpdate }
        ]);
    }
    create(value?: PartialMessage<PolicyUpdateResponse>): PolicyUpdateResponse {
        const message = { failedUpdates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PolicyUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyUpdateResponse): PolicyUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.FailedUpdate failed_updates */ 1:
                    message.failedUpdates.push(FailedUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PolicyUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.FailedUpdate failed_updates = 1; */
        for (let i = 0; i < message.failedUpdates.length; i++)
            FailedUpdate.internalBinaryWrite(message.failedUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.PolicyUpdateResponse
 */
export const PolicyUpdateResponse = new PolicyUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardingHistoryRequest$Type extends MessageType<ForwardingHistoryRequest> {
    constructor() {
        super("lnrpc.ForwardingHistoryRequest", [
            { no: 1, name: "start_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "index_offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "num_max_events", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "peer_alias_lookup", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ForwardingHistoryRequest>): ForwardingHistoryRequest {
        const message = { startTime: 0n, endTime: 0n, indexOffset: 0, numMaxEvents: 0, peerAliasLookup: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardingHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardingHistoryRequest): ForwardingHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 start_time */ 1:
                    message.startTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 end_time */ 2:
                    message.endTime = reader.uint64().toBigInt();
                    break;
                case /* uint32 index_offset */ 3:
                    message.indexOffset = reader.uint32();
                    break;
                case /* uint32 num_max_events */ 4:
                    message.numMaxEvents = reader.uint32();
                    break;
                case /* bool peer_alias_lookup */ 5:
                    message.peerAliasLookup = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForwardingHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 start_time = 1; */
        if (message.startTime !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.startTime);
        /* uint64 end_time = 2; */
        if (message.endTime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.endTime);
        /* uint32 index_offset = 3; */
        if (message.indexOffset !== 0)
            writer.tag(3, WireType.Varint).uint32(message.indexOffset);
        /* uint32 num_max_events = 4; */
        if (message.numMaxEvents !== 0)
            writer.tag(4, WireType.Varint).uint32(message.numMaxEvents);
        /* bool peer_alias_lookup = 5; */
        if (message.peerAliasLookup !== false)
            writer.tag(5, WireType.Varint).bool(message.peerAliasLookup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ForwardingHistoryRequest
 */
export const ForwardingHistoryRequest = new ForwardingHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardingEvent$Type extends MessageType<ForwardingEvent> {
    constructor() {
        super("lnrpc.ForwardingEvent", [
            { no: 1, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chan_id_in", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "chan_id_out", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "amt_in", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "amt_out", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "fee", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "fee_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "amt_in_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "amt_out_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "peer_alias_in", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "peer_alias_out", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ForwardingEvent>): ForwardingEvent {
        const message = { timestamp: 0n, chanIdIn: "0", chanIdOut: "0", amtIn: 0n, amtOut: 0n, fee: 0n, feeMsat: 0n, amtInMsat: 0n, amtOutMsat: 0n, timestampNs: 0n, peerAliasIn: "", peerAliasOut: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardingEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardingEvent): ForwardingEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp = 1 [deprecated = true];*/ 1:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* uint64 chan_id_in = 2 [jstype = JS_STRING];*/ 2:
                    message.chanIdIn = reader.uint64().toString();
                    break;
                case /* uint64 chan_id_out = 4 [jstype = JS_STRING];*/ 4:
                    message.chanIdOut = reader.uint64().toString();
                    break;
                case /* uint64 amt_in */ 5:
                    message.amtIn = reader.uint64().toBigInt();
                    break;
                case /* uint64 amt_out */ 6:
                    message.amtOut = reader.uint64().toBigInt();
                    break;
                case /* uint64 fee */ 7:
                    message.fee = reader.uint64().toBigInt();
                    break;
                case /* uint64 fee_msat */ 8:
                    message.feeMsat = reader.uint64().toBigInt();
                    break;
                case /* uint64 amt_in_msat */ 9:
                    message.amtInMsat = reader.uint64().toBigInt();
                    break;
                case /* uint64 amt_out_msat */ 10:
                    message.amtOutMsat = reader.uint64().toBigInt();
                    break;
                case /* uint64 timestamp_ns */ 11:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                case /* string peer_alias_in */ 12:
                    message.peerAliasIn = reader.string();
                    break;
                case /* string peer_alias_out */ 13:
                    message.peerAliasOut = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForwardingEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp = 1 [deprecated = true]; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestamp);
        /* uint64 chan_id_in = 2 [jstype = JS_STRING]; */
        if (message.chanIdIn !== "0")
            writer.tag(2, WireType.Varint).uint64(message.chanIdIn);
        /* uint64 chan_id_out = 4 [jstype = JS_STRING]; */
        if (message.chanIdOut !== "0")
            writer.tag(4, WireType.Varint).uint64(message.chanIdOut);
        /* uint64 amt_in = 5; */
        if (message.amtIn !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.amtIn);
        /* uint64 amt_out = 6; */
        if (message.amtOut !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.amtOut);
        /* uint64 fee = 7; */
        if (message.fee !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.fee);
        /* uint64 fee_msat = 8; */
        if (message.feeMsat !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.feeMsat);
        /* uint64 amt_in_msat = 9; */
        if (message.amtInMsat !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.amtInMsat);
        /* uint64 amt_out_msat = 10; */
        if (message.amtOutMsat !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.amtOutMsat);
        /* uint64 timestamp_ns = 11; */
        if (message.timestampNs !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.timestampNs);
        /* string peer_alias_in = 12; */
        if (message.peerAliasIn !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.peerAliasIn);
        /* string peer_alias_out = 13; */
        if (message.peerAliasOut !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.peerAliasOut);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ForwardingEvent
 */
export const ForwardingEvent = new ForwardingEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardingHistoryResponse$Type extends MessageType<ForwardingHistoryResponse> {
    constructor() {
        super("lnrpc.ForwardingHistoryResponse", [
            { no: 1, name: "forwarding_events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ForwardingEvent },
            { no: 2, name: "last_offset_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForwardingHistoryResponse>): ForwardingHistoryResponse {
        const message = { forwardingEvents: [], lastOffsetIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForwardingHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardingHistoryResponse): ForwardingHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.ForwardingEvent forwarding_events */ 1:
                    message.forwardingEvents.push(ForwardingEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 last_offset_index */ 2:
                    message.lastOffsetIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForwardingHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.ForwardingEvent forwarding_events = 1; */
        for (let i = 0; i < message.forwardingEvents.length; i++)
            ForwardingEvent.internalBinaryWrite(message.forwardingEvents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 last_offset_index = 2; */
        if (message.lastOffsetIndex !== 0)
            writer.tag(2, WireType.Varint).uint32(message.lastOffsetIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ForwardingHistoryResponse
 */
export const ForwardingHistoryResponse = new ForwardingHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportChannelBackupRequest$Type extends MessageType<ExportChannelBackupRequest> {
    constructor() {
        super("lnrpc.ExportChannelBackupRequest", [
            { no: 1, name: "chan_point", kind: "message", T: () => ChannelPoint }
        ]);
    }
    create(value?: PartialMessage<ExportChannelBackupRequest>): ExportChannelBackupRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExportChannelBackupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExportChannelBackupRequest): ExportChannelBackupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint chan_point */ 1:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExportChannelBackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint chan_point = 1; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ExportChannelBackupRequest
 */
export const ExportChannelBackupRequest = new ExportChannelBackupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelBackup$Type extends MessageType<ChannelBackup> {
    constructor() {
        super("lnrpc.ChannelBackup", [
            { no: 1, name: "chan_point", kind: "message", T: () => ChannelPoint },
            { no: 2, name: "chan_backup", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelBackup>): ChannelBackup {
        const message = { chanBackup: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelBackup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBackup): ChannelBackup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelPoint chan_point */ 1:
                    message.chanPoint = ChannelPoint.internalBinaryRead(reader, reader.uint32(), options, message.chanPoint);
                    break;
                case /* bytes chan_backup */ 2:
                    message.chanBackup = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelBackup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelPoint chan_point = 1; */
        if (message.chanPoint)
            ChannelPoint.internalBinaryWrite(message.chanPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes chan_backup = 2; */
        if (message.chanBackup.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chanBackup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBackup
 */
export const ChannelBackup = new ChannelBackup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiChanBackup$Type extends MessageType<MultiChanBackup> {
    constructor() {
        super("lnrpc.MultiChanBackup", [
            { no: 1, name: "chan_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelPoint },
            { no: 2, name: "multi_chan_backup", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MultiChanBackup>): MultiChanBackup {
        const message = { chanPoints: [], multiChanBackup: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultiChanBackup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiChanBackup): MultiChanBackup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.ChannelPoint chan_points */ 1:
                    message.chanPoints.push(ChannelPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes multi_chan_backup */ 2:
                    message.multiChanBackup = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiChanBackup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.ChannelPoint chan_points = 1; */
        for (let i = 0; i < message.chanPoints.length; i++)
            ChannelPoint.internalBinaryWrite(message.chanPoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes multi_chan_backup = 2; */
        if (message.multiChanBackup.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.multiChanBackup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.MultiChanBackup
 */
export const MultiChanBackup = new MultiChanBackup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChanBackupExportRequest$Type extends MessageType<ChanBackupExportRequest> {
    constructor() {
        super("lnrpc.ChanBackupExportRequest", []);
    }
    create(value?: PartialMessage<ChanBackupExportRequest>): ChanBackupExportRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChanBackupExportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanBackupExportRequest): ChanBackupExportRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChanBackupExportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanBackupExportRequest
 */
export const ChanBackupExportRequest = new ChanBackupExportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChanBackupSnapshot$Type extends MessageType<ChanBackupSnapshot> {
    constructor() {
        super("lnrpc.ChanBackupSnapshot", [
            { no: 1, name: "single_chan_backups", kind: "message", T: () => ChannelBackups },
            { no: 2, name: "multi_chan_backup", kind: "message", T: () => MultiChanBackup }
        ]);
    }
    create(value?: PartialMessage<ChanBackupSnapshot>): ChanBackupSnapshot {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChanBackupSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChanBackupSnapshot): ChanBackupSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelBackups single_chan_backups */ 1:
                    message.singleChanBackups = ChannelBackups.internalBinaryRead(reader, reader.uint32(), options, message.singleChanBackups);
                    break;
                case /* lnrpc.MultiChanBackup multi_chan_backup */ 2:
                    message.multiChanBackup = MultiChanBackup.internalBinaryRead(reader, reader.uint32(), options, message.multiChanBackup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChanBackupSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelBackups single_chan_backups = 1; */
        if (message.singleChanBackups)
            ChannelBackups.internalBinaryWrite(message.singleChanBackups, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.MultiChanBackup multi_chan_backup = 2; */
        if (message.multiChanBackup)
            MultiChanBackup.internalBinaryWrite(message.multiChanBackup, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChanBackupSnapshot
 */
export const ChanBackupSnapshot = new ChanBackupSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelBackups$Type extends MessageType<ChannelBackups> {
    constructor() {
        super("lnrpc.ChannelBackups", [
            { no: 1, name: "chan_backups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelBackup }
        ]);
    }
    create(value?: PartialMessage<ChannelBackups>): ChannelBackups {
        const message = { chanBackups: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelBackups>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBackups): ChannelBackups {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.ChannelBackup chan_backups */ 1:
                    message.chanBackups.push(ChannelBackup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelBackups, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.ChannelBackup chan_backups = 1; */
        for (let i = 0; i < message.chanBackups.length; i++)
            ChannelBackup.internalBinaryWrite(message.chanBackups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBackups
 */
export const ChannelBackups = new ChannelBackups$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreChanBackupRequest$Type extends MessageType<RestoreChanBackupRequest> {
    constructor() {
        super("lnrpc.RestoreChanBackupRequest", [
            { no: 1, name: "chan_backups", kind: "message", oneof: "backup", T: () => ChannelBackups },
            { no: 2, name: "multi_chan_backup", kind: "scalar", oneof: "backup", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RestoreChanBackupRequest>): RestoreChanBackupRequest {
        const message = { backup: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RestoreChanBackupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreChanBackupRequest): RestoreChanBackupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.ChannelBackups chan_backups */ 1:
                    message.backup = {
                        oneofKind: "chanBackups",
                        chanBackups: ChannelBackups.internalBinaryRead(reader, reader.uint32(), options, (message.backup as any).chanBackups)
                    };
                    break;
                case /* bytes multi_chan_backup */ 2:
                    message.backup = {
                        oneofKind: "multiChanBackup",
                        multiChanBackup: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreChanBackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.ChannelBackups chan_backups = 1; */
        if (message.backup.oneofKind === "chanBackups")
            ChannelBackups.internalBinaryWrite(message.backup.chanBackups, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes multi_chan_backup = 2; */
        if (message.backup.oneofKind === "multiChanBackup")
            writer.tag(2, WireType.LengthDelimited).bytes(message.backup.multiChanBackup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RestoreChanBackupRequest
 */
export const RestoreChanBackupRequest = new RestoreChanBackupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreBackupResponse$Type extends MessageType<RestoreBackupResponse> {
    constructor() {
        super("lnrpc.RestoreBackupResponse", []);
    }
    create(value?: PartialMessage<RestoreBackupResponse>): RestoreBackupResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RestoreBackupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreBackupResponse): RestoreBackupResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RestoreBackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RestoreBackupResponse
 */
export const RestoreBackupResponse = new RestoreBackupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelBackupSubscription$Type extends MessageType<ChannelBackupSubscription> {
    constructor() {
        super("lnrpc.ChannelBackupSubscription", []);
    }
    create(value?: PartialMessage<ChannelBackupSubscription>): ChannelBackupSubscription {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelBackupSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelBackupSubscription): ChannelBackupSubscription {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChannelBackupSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelBackupSubscription
 */
export const ChannelBackupSubscription = new ChannelBackupSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyChanBackupResponse$Type extends MessageType<VerifyChanBackupResponse> {
    constructor() {
        super("lnrpc.VerifyChanBackupResponse", []);
    }
    create(value?: PartialMessage<VerifyChanBackupResponse>): VerifyChanBackupResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyChanBackupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyChanBackupResponse): VerifyChanBackupResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: VerifyChanBackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.VerifyChanBackupResponse
 */
export const VerifyChanBackupResponse = new VerifyChanBackupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MacaroonPermission$Type extends MessageType<MacaroonPermission> {
    constructor() {
        super("lnrpc.MacaroonPermission", [
            { no: 1, name: "entity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MacaroonPermission>): MacaroonPermission {
        const message = { entity: "", action: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MacaroonPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacaroonPermission): MacaroonPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity */ 1:
                    message.entity = reader.string();
                    break;
                case /* string action */ 2:
                    message.action = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MacaroonPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity = 1; */
        if (message.entity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entity);
        /* string action = 2; */
        if (message.action !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.MacaroonPermission
 */
export const MacaroonPermission = new MacaroonPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BakeMacaroonRequest$Type extends MessageType<BakeMacaroonRequest> {
    constructor() {
        super("lnrpc.BakeMacaroonRequest", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MacaroonPermission },
            { no: 2, name: "root_key_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "allow_external_permissions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BakeMacaroonRequest>): BakeMacaroonRequest {
        const message = { permissions: [], rootKeyId: 0n, allowExternalPermissions: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BakeMacaroonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BakeMacaroonRequest): BakeMacaroonRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.MacaroonPermission permissions */ 1:
                    message.permissions.push(MacaroonPermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 root_key_id */ 2:
                    message.rootKeyId = reader.uint64().toBigInt();
                    break;
                case /* bool allow_external_permissions */ 3:
                    message.allowExternalPermissions = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BakeMacaroonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.MacaroonPermission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            MacaroonPermission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 root_key_id = 2; */
        if (message.rootKeyId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.rootKeyId);
        /* bool allow_external_permissions = 3; */
        if (message.allowExternalPermissions !== false)
            writer.tag(3, WireType.Varint).bool(message.allowExternalPermissions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.BakeMacaroonRequest
 */
export const BakeMacaroonRequest = new BakeMacaroonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BakeMacaroonResponse$Type extends MessageType<BakeMacaroonResponse> {
    constructor() {
        super("lnrpc.BakeMacaroonResponse", [
            { no: 1, name: "macaroon", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BakeMacaroonResponse>): BakeMacaroonResponse {
        const message = { macaroon: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BakeMacaroonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BakeMacaroonResponse): BakeMacaroonResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string macaroon */ 1:
                    message.macaroon = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BakeMacaroonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string macaroon = 1; */
        if (message.macaroon !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.macaroon);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.BakeMacaroonResponse
 */
export const BakeMacaroonResponse = new BakeMacaroonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMacaroonIDsRequest$Type extends MessageType<ListMacaroonIDsRequest> {
    constructor() {
        super("lnrpc.ListMacaroonIDsRequest", []);
    }
    create(value?: PartialMessage<ListMacaroonIDsRequest>): ListMacaroonIDsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMacaroonIDsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMacaroonIDsRequest): ListMacaroonIDsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListMacaroonIDsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListMacaroonIDsRequest
 */
export const ListMacaroonIDsRequest = new ListMacaroonIDsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMacaroonIDsResponse$Type extends MessageType<ListMacaroonIDsResponse> {
    constructor() {
        super("lnrpc.ListMacaroonIDsResponse", [
            { no: 1, name: "root_key_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListMacaroonIDsResponse>): ListMacaroonIDsResponse {
        const message = { rootKeyIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMacaroonIDsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMacaroonIDsResponse): ListMacaroonIDsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 root_key_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rootKeyIds.push(reader.uint64().toBigInt());
                    else
                        message.rootKeyIds.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMacaroonIDsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 root_key_ids = 1; */
        if (message.rootKeyIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rootKeyIds.length; i++)
                writer.uint64(message.rootKeyIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListMacaroonIDsResponse
 */
export const ListMacaroonIDsResponse = new ListMacaroonIDsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMacaroonIDRequest$Type extends MessageType<DeleteMacaroonIDRequest> {
    constructor() {
        super("lnrpc.DeleteMacaroonIDRequest", [
            { no: 1, name: "root_key_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMacaroonIDRequest>): DeleteMacaroonIDRequest {
        const message = { rootKeyId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteMacaroonIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMacaroonIDRequest): DeleteMacaroonIDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 root_key_id */ 1:
                    message.rootKeyId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMacaroonIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 root_key_id = 1; */
        if (message.rootKeyId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rootKeyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteMacaroonIDRequest
 */
export const DeleteMacaroonIDRequest = new DeleteMacaroonIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMacaroonIDResponse$Type extends MessageType<DeleteMacaroonIDResponse> {
    constructor() {
        super("lnrpc.DeleteMacaroonIDResponse", [
            { no: 1, name: "deleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMacaroonIDResponse>): DeleteMacaroonIDResponse {
        const message = { deleted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteMacaroonIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMacaroonIDResponse): DeleteMacaroonIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool deleted */ 1:
                    message.deleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMacaroonIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool deleted = 1; */
        if (message.deleted !== false)
            writer.tag(1, WireType.Varint).bool(message.deleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.DeleteMacaroonIDResponse
 */
export const DeleteMacaroonIDResponse = new DeleteMacaroonIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MacaroonPermissionList$Type extends MessageType<MacaroonPermissionList> {
    constructor() {
        super("lnrpc.MacaroonPermissionList", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MacaroonPermission }
        ]);
    }
    create(value?: PartialMessage<MacaroonPermissionList>): MacaroonPermissionList {
        const message = { permissions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MacaroonPermissionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacaroonPermissionList): MacaroonPermissionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lnrpc.MacaroonPermission permissions */ 1:
                    message.permissions.push(MacaroonPermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MacaroonPermissionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lnrpc.MacaroonPermission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            MacaroonPermission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.MacaroonPermissionList
 */
export const MacaroonPermissionList = new MacaroonPermissionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPermissionsRequest$Type extends MessageType<ListPermissionsRequest> {
    constructor() {
        super("lnrpc.ListPermissionsRequest", []);
    }
    create(value?: PartialMessage<ListPermissionsRequest>): ListPermissionsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPermissionsRequest): ListPermissionsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPermissionsRequest
 */
export const ListPermissionsRequest = new ListPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPermissionsResponse$Type extends MessageType<ListPermissionsResponse> {
    constructor() {
        super("lnrpc.ListPermissionsResponse", [
            { no: 1, name: "method_permissions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MacaroonPermissionList } }
        ]);
    }
    create(value?: PartialMessage<ListPermissionsResponse>): ListPermissionsResponse {
        const message = { methodPermissions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPermissionsResponse): ListPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, lnrpc.MacaroonPermissionList> method_permissions */ 1:
                    this.binaryReadMap1(message.methodPermissions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ListPermissionsResponse["methodPermissions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ListPermissionsResponse["methodPermissions"] | undefined, val: ListPermissionsResponse["methodPermissions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MacaroonPermissionList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field lnrpc.ListPermissionsResponse.method_permissions");
            }
        }
        map[key ?? ""] = val ?? MacaroonPermissionList.create();
    }
    internalBinaryWrite(message: ListPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, lnrpc.MacaroonPermissionList> method_permissions = 1; */
        for (let k of Object.keys(message.methodPermissions)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MacaroonPermissionList.internalBinaryWrite(message.methodPermissions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ListPermissionsResponse
 */
export const ListPermissionsResponse = new ListPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Failure$Type extends MessageType<Failure> {
    constructor() {
        super("lnrpc.Failure", [
            { no: 1, name: "code", kind: "enum", T: () => ["lnrpc.Failure.FailureCode", Failure_FailureCode] },
            { no: 3, name: "channel_update", kind: "message", T: () => ChannelUpdate },
            { no: 4, name: "htlc_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "onion_sha_256", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "cltv_expiry", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "failure_source_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Failure>): Failure {
        const message = { code: 0, htlcMsat: 0n, onionSha256: new Uint8Array(0), cltvExpiry: 0, flags: 0, failureSourceIndex: 0, height: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Failure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Failure): Failure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lnrpc.Failure.FailureCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* lnrpc.ChannelUpdate channel_update */ 3:
                    message.channelUpdate = ChannelUpdate.internalBinaryRead(reader, reader.uint32(), options, message.channelUpdate);
                    break;
                case /* uint64 htlc_msat */ 4:
                    message.htlcMsat = reader.uint64().toBigInt();
                    break;
                case /* bytes onion_sha_256 */ 5:
                    message.onionSha256 = reader.bytes();
                    break;
                case /* uint32 cltv_expiry */ 6:
                    message.cltvExpiry = reader.uint32();
                    break;
                case /* uint32 flags */ 7:
                    message.flags = reader.uint32();
                    break;
                case /* uint32 failure_source_index */ 8:
                    message.failureSourceIndex = reader.uint32();
                    break;
                case /* uint32 height */ 9:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Failure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lnrpc.Failure.FailureCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* lnrpc.ChannelUpdate channel_update = 3; */
        if (message.channelUpdate)
            ChannelUpdate.internalBinaryWrite(message.channelUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 htlc_msat = 4; */
        if (message.htlcMsat !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.htlcMsat);
        /* bytes onion_sha_256 = 5; */
        if (message.onionSha256.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.onionSha256);
        /* uint32 cltv_expiry = 6; */
        if (message.cltvExpiry !== 0)
            writer.tag(6, WireType.Varint).uint32(message.cltvExpiry);
        /* uint32 flags = 7; */
        if (message.flags !== 0)
            writer.tag(7, WireType.Varint).uint32(message.flags);
        /* uint32 failure_source_index = 8; */
        if (message.failureSourceIndex !== 0)
            writer.tag(8, WireType.Varint).uint32(message.failureSourceIndex);
        /* uint32 height = 9; */
        if (message.height !== 0)
            writer.tag(9, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Failure
 */
export const Failure = new Failure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelUpdate$Type extends MessageType<ChannelUpdate> {
    constructor() {
        super("lnrpc.ChannelUpdate", [
            { no: 1, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "chain_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "chan_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "message_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "channel_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "time_lock_delta", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "htlc_minimum_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "base_fee", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "fee_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "htlc_maximum_msat", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "extra_opaque_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelUpdate>): ChannelUpdate {
        const message = { signature: new Uint8Array(0), chainHash: new Uint8Array(0), chanId: "0", timestamp: 0, messageFlags: 0, channelFlags: 0, timeLockDelta: 0, htlcMinimumMsat: 0n, baseFee: 0, feeRate: 0, htlcMaximumMsat: 0n, extraOpaqueData: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelUpdate): ChannelUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signature */ 1:
                    message.signature = reader.bytes();
                    break;
                case /* bytes chain_hash */ 2:
                    message.chainHash = reader.bytes();
                    break;
                case /* uint64 chan_id = 3 [jstype = JS_STRING];*/ 3:
                    message.chanId = reader.uint64().toString();
                    break;
                case /* uint32 timestamp */ 4:
                    message.timestamp = reader.uint32();
                    break;
                case /* uint32 message_flags */ 10:
                    message.messageFlags = reader.uint32();
                    break;
                case /* uint32 channel_flags */ 5:
                    message.channelFlags = reader.uint32();
                    break;
                case /* uint32 time_lock_delta */ 6:
                    message.timeLockDelta = reader.uint32();
                    break;
                case /* uint64 htlc_minimum_msat */ 7:
                    message.htlcMinimumMsat = reader.uint64().toBigInt();
                    break;
                case /* uint32 base_fee */ 8:
                    message.baseFee = reader.uint32();
                    break;
                case /* uint32 fee_rate */ 9:
                    message.feeRate = reader.uint32();
                    break;
                case /* uint64 htlc_maximum_msat */ 11:
                    message.htlcMaximumMsat = reader.uint64().toBigInt();
                    break;
                case /* bytes extra_opaque_data */ 12:
                    message.extraOpaqueData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signature = 1; */
        if (message.signature.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature);
        /* bytes chain_hash = 2; */
        if (message.chainHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chainHash);
        /* uint64 chan_id = 3 [jstype = JS_STRING]; */
        if (message.chanId !== "0")
            writer.tag(3, WireType.Varint).uint64(message.chanId);
        /* uint32 timestamp = 4; */
        if (message.timestamp !== 0)
            writer.tag(4, WireType.Varint).uint32(message.timestamp);
        /* uint32 message_flags = 10; */
        if (message.messageFlags !== 0)
            writer.tag(10, WireType.Varint).uint32(message.messageFlags);
        /* uint32 channel_flags = 5; */
        if (message.channelFlags !== 0)
            writer.tag(5, WireType.Varint).uint32(message.channelFlags);
        /* uint32 time_lock_delta = 6; */
        if (message.timeLockDelta !== 0)
            writer.tag(6, WireType.Varint).uint32(message.timeLockDelta);
        /* uint64 htlc_minimum_msat = 7; */
        if (message.htlcMinimumMsat !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.htlcMinimumMsat);
        /* uint32 base_fee = 8; */
        if (message.baseFee !== 0)
            writer.tag(8, WireType.Varint).uint32(message.baseFee);
        /* uint32 fee_rate = 9; */
        if (message.feeRate !== 0)
            writer.tag(9, WireType.Varint).uint32(message.feeRate);
        /* uint64 htlc_maximum_msat = 11; */
        if (message.htlcMaximumMsat !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.htlcMaximumMsat);
        /* bytes extra_opaque_data = 12; */
        if (message.extraOpaqueData.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.extraOpaqueData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.ChannelUpdate
 */
export const ChannelUpdate = new ChannelUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MacaroonId$Type extends MessageType<MacaroonId> {
    constructor() {
        super("lnrpc.MacaroonId", [
            { no: 1, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "storageId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "ops", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Op }
        ]);
    }
    create(value?: PartialMessage<MacaroonId>): MacaroonId {
        const message = { nonce: new Uint8Array(0), storageId: new Uint8Array(0), ops: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MacaroonId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacaroonId): MacaroonId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes nonce */ 1:
                    message.nonce = reader.bytes();
                    break;
                case /* bytes storageId */ 2:
                    message.storageId = reader.bytes();
                    break;
                case /* repeated lnrpc.Op ops */ 3:
                    message.ops.push(Op.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MacaroonId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes nonce = 1; */
        if (message.nonce.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nonce);
        /* bytes storageId = 2; */
        if (message.storageId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.storageId);
        /* repeated lnrpc.Op ops = 3; */
        for (let i = 0; i < message.ops.length; i++)
            Op.internalBinaryWrite(message.ops[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.MacaroonId
 */
export const MacaroonId = new MacaroonId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Op$Type extends MessageType<Op> {
    constructor() {
        super("lnrpc.Op", [
            { no: 1, name: "entity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "actions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Op>): Op {
        const message = { entity: "", actions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Op>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Op): Op {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity */ 1:
                    message.entity = reader.string();
                    break;
                case /* repeated string actions */ 2:
                    message.actions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Op, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity = 1; */
        if (message.entity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entity);
        /* repeated string actions = 2; */
        for (let i = 0; i < message.actions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.actions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.Op
 */
export const Op = new Op$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckMacPermRequest$Type extends MessageType<CheckMacPermRequest> {
    constructor() {
        super("lnrpc.CheckMacPermRequest", [
            { no: 1, name: "macaroon", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MacaroonPermission },
            { no: 3, name: "fullMethod", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckMacPermRequest>): CheckMacPermRequest {
        const message = { macaroon: new Uint8Array(0), permissions: [], fullMethod: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckMacPermRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckMacPermRequest): CheckMacPermRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes macaroon */ 1:
                    message.macaroon = reader.bytes();
                    break;
                case /* repeated lnrpc.MacaroonPermission permissions */ 2:
                    message.permissions.push(MacaroonPermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string fullMethod */ 3:
                    message.fullMethod = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckMacPermRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes macaroon = 1; */
        if (message.macaroon.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.macaroon);
        /* repeated lnrpc.MacaroonPermission permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            MacaroonPermission.internalBinaryWrite(message.permissions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string fullMethod = 3; */
        if (message.fullMethod !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fullMethod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.CheckMacPermRequest
 */
export const CheckMacPermRequest = new CheckMacPermRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckMacPermResponse$Type extends MessageType<CheckMacPermResponse> {
    constructor() {
        super("lnrpc.CheckMacPermResponse", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CheckMacPermResponse>): CheckMacPermResponse {
        const message = { valid: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckMacPermResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckMacPermResponse): CheckMacPermResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckMacPermResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.CheckMacPermResponse
 */
export const CheckMacPermResponse = new CheckMacPermResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RPCMiddlewareRequest$Type extends MessageType<RPCMiddlewareRequest> {
    constructor() {
        super("lnrpc.RPCMiddlewareRequest", [
            { no: 1, name: "request_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "raw_macaroon", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "custom_caveat_condition", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "stream_auth", kind: "message", oneof: "interceptType", T: () => StreamAuth },
            { no: 5, name: "request", kind: "message", oneof: "interceptType", T: () => RPCMessage },
            { no: 6, name: "response", kind: "message", oneof: "interceptType", T: () => RPCMessage },
            { no: 8, name: "reg_complete", kind: "scalar", oneof: "interceptType", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "msg_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RPCMiddlewareRequest>): RPCMiddlewareRequest {
        const message = { requestId: 0n, rawMacaroon: new Uint8Array(0), customCaveatCondition: "", interceptType: { oneofKind: undefined }, msgId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RPCMiddlewareRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPCMiddlewareRequest): RPCMiddlewareRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 request_id */ 1:
                    message.requestId = reader.uint64().toBigInt();
                    break;
                case /* bytes raw_macaroon */ 2:
                    message.rawMacaroon = reader.bytes();
                    break;
                case /* string custom_caveat_condition */ 3:
                    message.customCaveatCondition = reader.string();
                    break;
                case /* lnrpc.StreamAuth stream_auth */ 4:
                    message.interceptType = {
                        oneofKind: "streamAuth",
                        streamAuth: StreamAuth.internalBinaryRead(reader, reader.uint32(), options, (message.interceptType as any).streamAuth)
                    };
                    break;
                case /* lnrpc.RPCMessage request */ 5:
                    message.interceptType = {
                        oneofKind: "request",
                        request: RPCMessage.internalBinaryRead(reader, reader.uint32(), options, (message.interceptType as any).request)
                    };
                    break;
                case /* lnrpc.RPCMessage response */ 6:
                    message.interceptType = {
                        oneofKind: "response",
                        response: RPCMessage.internalBinaryRead(reader, reader.uint32(), options, (message.interceptType as any).response)
                    };
                    break;
                case /* bool reg_complete */ 8:
                    message.interceptType = {
                        oneofKind: "regComplete",
                        regComplete: reader.bool()
                    };
                    break;
                case /* uint64 msg_id */ 7:
                    message.msgId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RPCMiddlewareRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 request_id = 1; */
        if (message.requestId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.requestId);
        /* bytes raw_macaroon = 2; */
        if (message.rawMacaroon.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rawMacaroon);
        /* string custom_caveat_condition = 3; */
        if (message.customCaveatCondition !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.customCaveatCondition);
        /* lnrpc.StreamAuth stream_auth = 4; */
        if (message.interceptType.oneofKind === "streamAuth")
            StreamAuth.internalBinaryWrite(message.interceptType.streamAuth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.RPCMessage request = 5; */
        if (message.interceptType.oneofKind === "request")
            RPCMessage.internalBinaryWrite(message.interceptType.request, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.RPCMessage response = 6; */
        if (message.interceptType.oneofKind === "response")
            RPCMessage.internalBinaryWrite(message.interceptType.response, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool reg_complete = 8; */
        if (message.interceptType.oneofKind === "regComplete")
            writer.tag(8, WireType.Varint).bool(message.interceptType.regComplete);
        /* uint64 msg_id = 7; */
        if (message.msgId !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.msgId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RPCMiddlewareRequest
 */
export const RPCMiddlewareRequest = new RPCMiddlewareRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamAuth$Type extends MessageType<StreamAuth> {
    constructor() {
        super("lnrpc.StreamAuth", [
            { no: 1, name: "method_full_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamAuth>): StreamAuth {
        const message = { methodFullUri: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StreamAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAuth): StreamAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method_full_uri */ 1:
                    message.methodFullUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method_full_uri = 1; */
        if (message.methodFullUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.methodFullUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.StreamAuth
 */
export const StreamAuth = new StreamAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RPCMessage$Type extends MessageType<RPCMessage> {
    constructor() {
        super("lnrpc.RPCMessage", [
            { no: 1, name: "method_full_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "stream_rpc", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "type_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "serialized", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "is_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RPCMessage>): RPCMessage {
        const message = { methodFullUri: "", streamRpc: false, typeName: "", serialized: new Uint8Array(0), isError: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RPCMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPCMessage): RPCMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method_full_uri */ 1:
                    message.methodFullUri = reader.string();
                    break;
                case /* bool stream_rpc */ 2:
                    message.streamRpc = reader.bool();
                    break;
                case /* string type_name */ 3:
                    message.typeName = reader.string();
                    break;
                case /* bytes serialized */ 4:
                    message.serialized = reader.bytes();
                    break;
                case /* bool is_error */ 5:
                    message.isError = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RPCMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method_full_uri = 1; */
        if (message.methodFullUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.methodFullUri);
        /* bool stream_rpc = 2; */
        if (message.streamRpc !== false)
            writer.tag(2, WireType.Varint).bool(message.streamRpc);
        /* string type_name = 3; */
        if (message.typeName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.typeName);
        /* bytes serialized = 4; */
        if (message.serialized.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.serialized);
        /* bool is_error = 5; */
        if (message.isError !== false)
            writer.tag(5, WireType.Varint).bool(message.isError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RPCMessage
 */
export const RPCMessage = new RPCMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RPCMiddlewareResponse$Type extends MessageType<RPCMiddlewareResponse> {
    constructor() {
        super("lnrpc.RPCMiddlewareResponse", [
            { no: 1, name: "ref_msg_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "register", kind: "message", oneof: "middlewareMessage", T: () => MiddlewareRegistration },
            { no: 3, name: "feedback", kind: "message", oneof: "middlewareMessage", T: () => InterceptFeedback }
        ]);
    }
    create(value?: PartialMessage<RPCMiddlewareResponse>): RPCMiddlewareResponse {
        const message = { refMsgId: 0n, middlewareMessage: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RPCMiddlewareResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPCMiddlewareResponse): RPCMiddlewareResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 ref_msg_id */ 1:
                    message.refMsgId = reader.uint64().toBigInt();
                    break;
                case /* lnrpc.MiddlewareRegistration register */ 2:
                    message.middlewareMessage = {
                        oneofKind: "register",
                        register: MiddlewareRegistration.internalBinaryRead(reader, reader.uint32(), options, (message.middlewareMessage as any).register)
                    };
                    break;
                case /* lnrpc.InterceptFeedback feedback */ 3:
                    message.middlewareMessage = {
                        oneofKind: "feedback",
                        feedback: InterceptFeedback.internalBinaryRead(reader, reader.uint32(), options, (message.middlewareMessage as any).feedback)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RPCMiddlewareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 ref_msg_id = 1; */
        if (message.refMsgId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.refMsgId);
        /* lnrpc.MiddlewareRegistration register = 2; */
        if (message.middlewareMessage.oneofKind === "register")
            MiddlewareRegistration.internalBinaryWrite(message.middlewareMessage.register, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lnrpc.InterceptFeedback feedback = 3; */
        if (message.middlewareMessage.oneofKind === "feedback")
            InterceptFeedback.internalBinaryWrite(message.middlewareMessage.feedback, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.RPCMiddlewareResponse
 */
export const RPCMiddlewareResponse = new RPCMiddlewareResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MiddlewareRegistration$Type extends MessageType<MiddlewareRegistration> {
    constructor() {
        super("lnrpc.MiddlewareRegistration", [
            { no: 1, name: "middleware_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "custom_macaroon_caveat_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "read_only_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MiddlewareRegistration>): MiddlewareRegistration {
        const message = { middlewareName: "", customMacaroonCaveatName: "", readOnlyMode: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MiddlewareRegistration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MiddlewareRegistration): MiddlewareRegistration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string middleware_name */ 1:
                    message.middlewareName = reader.string();
                    break;
                case /* string custom_macaroon_caveat_name */ 2:
                    message.customMacaroonCaveatName = reader.string();
                    break;
                case /* bool read_only_mode */ 3:
                    message.readOnlyMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MiddlewareRegistration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string middleware_name = 1; */
        if (message.middlewareName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.middlewareName);
        /* string custom_macaroon_caveat_name = 2; */
        if (message.customMacaroonCaveatName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.customMacaroonCaveatName);
        /* bool read_only_mode = 3; */
        if (message.readOnlyMode !== false)
            writer.tag(3, WireType.Varint).bool(message.readOnlyMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.MiddlewareRegistration
 */
export const MiddlewareRegistration = new MiddlewareRegistration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterceptFeedback$Type extends MessageType<InterceptFeedback> {
    constructor() {
        super("lnrpc.InterceptFeedback", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "replace_response", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "replacement_serialized", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<InterceptFeedback>): InterceptFeedback {
        const message = { error: "", replaceResponse: false, replacementSerialized: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InterceptFeedback>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterceptFeedback): InterceptFeedback {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                case /* bool replace_response */ 2:
                    message.replaceResponse = reader.bool();
                    break;
                case /* bytes replacement_serialized */ 3:
                    message.replacementSerialized = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterceptFeedback, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        /* bool replace_response = 2; */
        if (message.replaceResponse !== false)
            writer.tag(2, WireType.Varint).bool(message.replaceResponse);
        /* bytes replacement_serialized = 3; */
        if (message.replacementSerialized.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.replacementSerialized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lnrpc.InterceptFeedback
 */
export const InterceptFeedback = new InterceptFeedback$Type();
/**
 * @generated ServiceType for protobuf service lnrpc.Lightning
 */
export const Lightning = new ServiceType("lnrpc.Lightning", [
    { name: "WalletBalance", options: {}, I: WalletBalanceRequest, O: WalletBalanceResponse },
    { name: "ChannelBalance", options: {}, I: ChannelBalanceRequest, O: ChannelBalanceResponse },
    { name: "GetTransactions", options: {}, I: GetTransactionsRequest, O: TransactionDetails },
    { name: "EstimateFee", options: {}, I: EstimateFeeRequest, O: EstimateFeeResponse },
    { name: "SendCoins", options: {}, I: SendCoinsRequest, O: SendCoinsResponse },
    { name: "ListUnspent", options: {}, I: ListUnspentRequest, O: ListUnspentResponse },
    { name: "SubscribeTransactions", serverStreaming: true, options: {}, I: GetTransactionsRequest, O: Transaction },
    { name: "SendMany", options: {}, I: SendManyRequest, O: SendManyResponse },
    { name: "NewAddress", options: {}, I: NewAddressRequest, O: NewAddressResponse },
    { name: "SignMessage", options: {}, I: SignMessageRequest, O: SignMessageResponse },
    { name: "VerifyMessage", options: {}, I: VerifyMessageRequest, O: VerifyMessageResponse },
    { name: "ConnectPeer", options: {}, I: ConnectPeerRequest, O: ConnectPeerResponse },
    { name: "DisconnectPeer", options: {}, I: DisconnectPeerRequest, O: DisconnectPeerResponse },
    { name: "ListPeers", options: {}, I: ListPeersRequest, O: ListPeersResponse },
    { name: "SubscribePeerEvents", serverStreaming: true, options: {}, I: PeerEventSubscription, O: PeerEvent },
    { name: "GetInfo", options: {}, I: GetInfoRequest, O: GetInfoResponse },
    { name: "GetRecoveryInfo", options: {}, I: GetRecoveryInfoRequest, O: GetRecoveryInfoResponse },
    { name: "PendingChannels", options: {}, I: PendingChannelsRequest, O: PendingChannelsResponse },
    { name: "ListChannels", options: {}, I: ListChannelsRequest, O: ListChannelsResponse },
    { name: "SubscribeChannelEvents", serverStreaming: true, options: {}, I: ChannelEventSubscription, O: ChannelEventUpdate },
    { name: "ClosedChannels", options: {}, I: ClosedChannelsRequest, O: ClosedChannelsResponse },
    { name: "OpenChannelSync", options: {}, I: OpenChannelRequest, O: ChannelPoint },
    { name: "OpenChannel", serverStreaming: true, options: {}, I: OpenChannelRequest, O: OpenStatusUpdate },
    { name: "BatchOpenChannel", options: {}, I: BatchOpenChannelRequest, O: BatchOpenChannelResponse },
    { name: "FundingStateStep", options: {}, I: FundingTransitionMsg, O: FundingStateStepResp },
    { name: "ChannelAcceptor", serverStreaming: true, clientStreaming: true, options: {}, I: ChannelAcceptResponse, O: ChannelAcceptRequest },
    { name: "CloseChannel", serverStreaming: true, options: {}, I: CloseChannelRequest, O: CloseStatusUpdate },
    { name: "AbandonChannel", options: {}, I: AbandonChannelRequest, O: AbandonChannelResponse },
    { name: "SendPayment", serverStreaming: true, clientStreaming: true, options: {}, I: SendRequest, O: SendResponse },
    { name: "SendPaymentSync", options: {}, I: SendRequest, O: SendResponse },
    { name: "SendToRoute", serverStreaming: true, clientStreaming: true, options: {}, I: SendToRouteRequest, O: SendResponse },
    { name: "SendToRouteSync", options: {}, I: SendToRouteRequest, O: SendResponse },
    { name: "AddInvoice", options: {}, I: Invoice, O: AddInvoiceResponse },
    { name: "ListInvoices", options: {}, I: ListInvoiceRequest, O: ListInvoiceResponse },
    { name: "LookupInvoice", options: {}, I: PaymentHash, O: Invoice },
    { name: "SubscribeInvoices", serverStreaming: true, options: {}, I: InvoiceSubscription, O: Invoice },
    { name: "DecodePayReq", options: {}, I: PayReqString, O: PayReq },
    { name: "ListPayments", options: {}, I: ListPaymentsRequest, O: ListPaymentsResponse },
    { name: "DeletePayment", options: {}, I: DeletePaymentRequest, O: DeletePaymentResponse },
    { name: "DeleteAllPayments", options: {}, I: DeleteAllPaymentsRequest, O: DeleteAllPaymentsResponse },
    { name: "DescribeGraph", options: {}, I: ChannelGraphRequest, O: ChannelGraph },
    { name: "GetNodeMetrics", options: {}, I: NodeMetricsRequest, O: NodeMetricsResponse },
    { name: "GetChanInfo", options: {}, I: ChanInfoRequest, O: ChannelEdge },
    { name: "GetNodeInfo", options: {}, I: NodeInfoRequest, O: NodeInfo },
    { name: "QueryRoutes", options: {}, I: QueryRoutesRequest, O: QueryRoutesResponse },
    { name: "GetNetworkInfo", options: {}, I: NetworkInfoRequest, O: NetworkInfo },
    { name: "StopDaemon", options: {}, I: StopRequest, O: StopResponse },
    { name: "SubscribeChannelGraph", serverStreaming: true, options: {}, I: GraphTopologySubscription, O: GraphTopologyUpdate },
    { name: "DebugLevel", options: {}, I: DebugLevelRequest, O: DebugLevelResponse },
    { name: "FeeReport", options: {}, I: FeeReportRequest, O: FeeReportResponse },
    { name: "UpdateChannelPolicy", options: {}, I: PolicyUpdateRequest, O: PolicyUpdateResponse },
    { name: "ForwardingHistory", options: {}, I: ForwardingHistoryRequest, O: ForwardingHistoryResponse },
    { name: "ExportChannelBackup", options: {}, I: ExportChannelBackupRequest, O: ChannelBackup },
    { name: "ExportAllChannelBackups", options: {}, I: ChanBackupExportRequest, O: ChanBackupSnapshot },
    { name: "VerifyChanBackup", options: {}, I: ChanBackupSnapshot, O: VerifyChanBackupResponse },
    { name: "RestoreChannelBackups", options: {}, I: RestoreChanBackupRequest, O: RestoreBackupResponse },
    { name: "SubscribeChannelBackups", serverStreaming: true, options: {}, I: ChannelBackupSubscription, O: ChanBackupSnapshot },
    { name: "BakeMacaroon", options: {}, I: BakeMacaroonRequest, O: BakeMacaroonResponse },
    { name: "ListMacaroonIDs", options: {}, I: ListMacaroonIDsRequest, O: ListMacaroonIDsResponse },
    { name: "DeleteMacaroonID", options: {}, I: DeleteMacaroonIDRequest, O: DeleteMacaroonIDResponse },
    { name: "ListPermissions", options: {}, I: ListPermissionsRequest, O: ListPermissionsResponse },
    { name: "CheckMacaroonPermissions", options: {}, I: CheckMacPermRequest, O: CheckMacPermResponse },
    { name: "RegisterRPCMiddleware", serverStreaming: true, clientStreaming: true, options: {}, I: RPCMiddlewareResponse, O: RPCMiddlewareRequest },
    { name: "SendCustomMessage", options: {}, I: SendCustomMessageRequest, O: SendCustomMessageResponse },
    { name: "SubscribeCustomMessages", serverStreaming: true, options: {}, I: SubscribeCustomMessagesRequest, O: CustomMessage },
    { name: "ListAliases", options: {}, I: ListAliasesRequest, O: ListAliasesResponse },
    { name: "LookupHtlc", options: {}, I: LookupHtlcRequest, O: LookupHtlcResponse }
]);
