// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "walletkit.proto" (package "walletrpc", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { WalletKit } from "./walletkit.js";
import type { FinalizePsbtResponse } from "./walletkit.js";
import type { FinalizePsbtRequest } from "./walletkit.js";
import type { SignPsbtResponse } from "./walletkit.js";
import type { SignPsbtRequest } from "./walletkit.js";
import type { FundPsbtResponse } from "./walletkit.js";
import type { FundPsbtRequest } from "./walletkit.js";
import type { LabelTransactionResponse } from "./walletkit.js";
import type { LabelTransactionRequest } from "./walletkit.js";
import type { ListSweepsResponse } from "./walletkit.js";
import type { ListSweepsRequest } from "./walletkit.js";
import type { BumpForceCloseFeeResponse } from "./walletkit.js";
import type { BumpForceCloseFeeRequest } from "./walletkit.js";
import type { BumpFeeResponse } from "./walletkit.js";
import type { BumpFeeRequest } from "./walletkit.js";
import type { PendingSweepsResponse } from "./walletkit.js";
import type { PendingSweepsRequest } from "./walletkit.js";
import type { EstimateFeeResponse } from "./walletkit.js";
import type { EstimateFeeRequest } from "./walletkit.js";
import type { SendOutputsResponse } from "./walletkit.js";
import type { SendOutputsRequest } from "./walletkit.js";
import type { RemoveTransactionResponse } from "./walletkit.js";
import type { PublishResponse } from "./walletkit.js";
import type { Transaction as Transaction$ } from "./walletkit.js";
import type { ImportTapscriptResponse } from "./walletkit.js";
import type { ImportTapscriptRequest } from "./walletkit.js";
import type { ImportPublicKeyResponse } from "./walletkit.js";
import type { ImportPublicKeyRequest } from "./walletkit.js";
import type { ImportAccountResponse } from "./walletkit.js";
import type { ImportAccountRequest } from "./walletkit.js";
import type { VerifyMessageWithAddrResponse } from "./walletkit.js";
import type { VerifyMessageWithAddrRequest } from "./walletkit.js";
import type { SignMessageWithAddrResponse } from "./walletkit.js";
import type { SignMessageWithAddrRequest } from "./walletkit.js";
import type { ListAddressesResponse } from "./walletkit.js";
import type { ListAddressesRequest } from "./walletkit.js";
import type { RequiredReserveResponse } from "./walletkit.js";
import type { RequiredReserveRequest } from "./walletkit.js";
import type { ListAccountsResponse } from "./walletkit.js";
import type { ListAccountsRequest } from "./walletkit.js";
import type { Transaction } from "./lightning";
import type { GetTransactionRequest } from "./walletkit.js";
import type { AddrResponse } from "./walletkit.js";
import type { AddrRequest } from "./walletkit.js";
import type { KeyLocator } from "./signer.js";
import type { KeyDescriptor } from "./signer.js";
import type { KeyReq } from "./walletkit.js";
import type { ListLeasesResponse } from "./walletkit.js";
import type { ListLeasesRequest } from "./walletkit.js";
import type { ReleaseOutputResponse } from "./walletkit.js";
import type { ReleaseOutputRequest } from "./walletkit.js";
import type { LeaseOutputResponse } from "./walletkit.js";
import type { LeaseOutputRequest } from "./walletkit.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ListUnspentResponse } from "./walletkit.js";
import type { ListUnspentRequest } from "./walletkit.js";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
// 
// Comments in this file will be directly parsed into the API
// Documentation as descriptions of the associated method, message, or field.
// These descriptions should go right above the definition of the object, and
// can be in either block or // comment format.
// 
// An RPC method can be matched to an lncli command by placing a line in the
// beginning of the description in exactly the following format:
// lncli: `methodname`
// 
// Failure to specify the exact name of the command will cause documentation
// generation to fail.
// 
// More information on how exactly the gRPC documentation is generated from
// this proto file can be found here:
// https://github.com/lightninglabs/lightning-api

/**
 * WalletKit is a service that gives access to the core functionalities of the
 * daemon's wallet.
 *
 * @generated from protobuf service walletrpc.WalletKit
 */
export interface IWalletKitClient {
    /**
     *
     * ListUnspent returns a list of all utxos spendable by the wallet with a
     * number of confirmations between the specified minimum and maximum. By
     * default, all utxos are listed. To list only the unconfirmed utxos, set
     * the unconfirmed_only to true.
     *
     * @generated from protobuf rpc: ListUnspent(walletrpc.ListUnspentRequest) returns (walletrpc.ListUnspentResponse);
     */
    listUnspent(input: ListUnspentRequest, options?: RpcOptions): UnaryCall<ListUnspentRequest, ListUnspentResponse>;
    /**
     * lncli: `wallet leaseoutput`
     * LeaseOutput locks an output to the given ID, preventing it from being
     * available for any future coin selection attempts. The absolute time of the
     * lock's expiration is returned. The expiration of the lock can be extended by
     * successive invocations of this RPC. Outputs can be unlocked before their
     * expiration through `ReleaseOutput`.
     *
     * @generated from protobuf rpc: LeaseOutput(walletrpc.LeaseOutputRequest) returns (walletrpc.LeaseOutputResponse);
     */
    leaseOutput(input: LeaseOutputRequest, options?: RpcOptions): UnaryCall<LeaseOutputRequest, LeaseOutputResponse>;
    /**
     * lncli: `wallet releaseoutput`
     * ReleaseOutput unlocks an output, allowing it to be available for coin
     * selection if it remains unspent. The ID should match the one used to
     * originally lock the output.
     *
     * @generated from protobuf rpc: ReleaseOutput(walletrpc.ReleaseOutputRequest) returns (walletrpc.ReleaseOutputResponse);
     */
    releaseOutput(input: ReleaseOutputRequest, options?: RpcOptions): UnaryCall<ReleaseOutputRequest, ReleaseOutputResponse>;
    /**
     * lncli: `wallet listleases`
     * ListLeases lists all currently locked utxos.
     *
     * @generated from protobuf rpc: ListLeases(walletrpc.ListLeasesRequest) returns (walletrpc.ListLeasesResponse);
     */
    listLeases(input: ListLeasesRequest, options?: RpcOptions): UnaryCall<ListLeasesRequest, ListLeasesResponse>;
    /**
     *
     * DeriveNextKey attempts to derive the *next* key within the key family
     * (account in BIP43) specified. This method should return the next external
     * child within this branch.
     *
     * @generated from protobuf rpc: DeriveNextKey(walletrpc.KeyReq) returns (signrpc.KeyDescriptor);
     */
    deriveNextKey(input: KeyReq, options?: RpcOptions): UnaryCall<KeyReq, KeyDescriptor>;
    /**
     *
     * DeriveKey attempts to derive an arbitrary key specified by the passed
     * KeyLocator.
     *
     * @generated from protobuf rpc: DeriveKey(signrpc.KeyLocator) returns (signrpc.KeyDescriptor);
     */
    deriveKey(input: KeyLocator, options?: RpcOptions): UnaryCall<KeyLocator, KeyDescriptor>;
    /**
     *
     * NextAddr returns the next unused address within the wallet.
     *
     * @generated from protobuf rpc: NextAddr(walletrpc.AddrRequest) returns (walletrpc.AddrResponse);
     */
    nextAddr(input: AddrRequest, options?: RpcOptions): UnaryCall<AddrRequest, AddrResponse>;
    /**
     * lncli: `wallet gettx`
     * GetTransaction returns details for a transaction found in the wallet.
     *
     * @generated from protobuf rpc: GetTransaction(walletrpc.GetTransactionRequest) returns (lnrpc.Transaction);
     */
    getTransaction(input: GetTransactionRequest, options?: RpcOptions): UnaryCall<GetTransactionRequest, Transaction>;
    /**
     * lncli: `wallet accounts list`
     * ListAccounts retrieves all accounts belonging to the wallet by default. A
     * name and key scope filter can be provided to filter through all of the
     * wallet accounts and return only those matching.
     *
     * @generated from protobuf rpc: ListAccounts(walletrpc.ListAccountsRequest) returns (walletrpc.ListAccountsResponse);
     */
    listAccounts(input: ListAccountsRequest, options?: RpcOptions): UnaryCall<ListAccountsRequest, ListAccountsResponse>;
    /**
     * lncli: `wallet requiredreserve`
     * RequiredReserve returns the minimum amount of satoshis that should be kept
     * in the wallet in order to fee bump anchor channels if necessary. The value
     * scales with the number of public anchor channels but is capped at a maximum.
     *
     * @generated from protobuf rpc: RequiredReserve(walletrpc.RequiredReserveRequest) returns (walletrpc.RequiredReserveResponse);
     */
    requiredReserve(input: RequiredReserveRequest, options?: RpcOptions): UnaryCall<RequiredReserveRequest, RequiredReserveResponse>;
    /**
     * lncli: `wallet addresses list`
     * ListAddresses retrieves all the addresses along with their balance. An
     * account name filter can be provided to filter through all of the
     * wallet accounts and return the addresses of only those matching.
     *
     * @generated from protobuf rpc: ListAddresses(walletrpc.ListAddressesRequest) returns (walletrpc.ListAddressesResponse);
     */
    listAddresses(input: ListAddressesRequest, options?: RpcOptions): UnaryCall<ListAddressesRequest, ListAddressesResponse>;
    /**
     * lncli: `wallet addresses signmessage`
     * SignMessageWithAddr returns the compact signature (base64 encoded) created
     * with the private key of the provided address. This requires the address
     * to be solely based on a public key lock (no scripts). Obviously the internal
     * lnd wallet has to possess the private key of the address otherwise
     * an error is returned.
     *
     * This method aims to provide full compatibility with the bitcoin-core and
     * btcd implementation. Bitcoin-core's algorithm is not specified in a
     * BIP and only applicable for legacy addresses. This method enhances the
     * signing for additional address types: P2WKH, NP2WKH, P2TR.
     * For P2TR addresses this represents a special case. ECDSA is used to create
     * a compact signature which makes the public key of the signature recoverable.
     *
     * @generated from protobuf rpc: SignMessageWithAddr(walletrpc.SignMessageWithAddrRequest) returns (walletrpc.SignMessageWithAddrResponse);
     */
    signMessageWithAddr(input: SignMessageWithAddrRequest, options?: RpcOptions): UnaryCall<SignMessageWithAddrRequest, SignMessageWithAddrResponse>;
    /**
     * lncli: `wallet addresses verifymessage`
     * VerifyMessageWithAddr returns the validity and the recovered public key of
     * the provided compact signature (base64 encoded). The verification is
     * twofold. First the validity of the signature itself is checked and then
     * it is verified that the recovered public key of the signature equals
     * the public key of the provided address. There is no dependence on the
     * private key of the address therefore also external addresses are allowed
     * to verify signatures.
     * Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.
     *
     * This method is the counterpart of the related signing method
     * (SignMessageWithAddr) and aims to provide full compatibility to
     * bitcoin-core's implementation. Although bitcoin-core/btcd only provide
     * this functionality for legacy addresses this function enhances it to
     * the address types: P2PKH, P2WKH, NP2WKH, P2TR.
     *
     * The verification for P2TR addresses is a special case and requires the
     * ECDSA compact signature to compare the reovered public key to the internal
     * taproot key. The compact ECDSA signature format was used because there
     * are still no known compact signature schemes for schnorr signatures.
     *
     * @generated from protobuf rpc: VerifyMessageWithAddr(walletrpc.VerifyMessageWithAddrRequest) returns (walletrpc.VerifyMessageWithAddrResponse);
     */
    verifyMessageWithAddr(input: VerifyMessageWithAddrRequest, options?: RpcOptions): UnaryCall<VerifyMessageWithAddrRequest, VerifyMessageWithAddrResponse>;
    /**
     * lncli: `wallet accounts import`
     * ImportAccount imports an account backed by an account extended public key.
     * The master key fingerprint denotes the fingerprint of the root key
     * corresponding to the account public key (also known as the key with
     * derivation path m/). This may be required by some hardware wallets for
     * proper identification and signing.
     *
     * The address type can usually be inferred from the key's version, but may be
     * required for certain keys to map them into the proper scope.
     *
     * For BIP-0044 keys, an address type must be specified as we intend to not
     * support importing BIP-0044 keys into the wallet using the legacy
     * pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force
     * the standard BIP-0049 derivation scheme, while a witness address type will
     * force the standard BIP-0084 derivation scheme.
     *
     * For BIP-0049 keys, an address type must also be specified to make a
     * distinction between the standard BIP-0049 address schema (nested witness
     * pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys
     * externally, witness pubkeys internally).
     *
     * NOTE: Events (deposits/spends) for keys derived from an account will only be
     * detected by lnd if they happen after the import. Rescans to detect past
     * events will be supported later on.
     *
     * @generated from protobuf rpc: ImportAccount(walletrpc.ImportAccountRequest) returns (walletrpc.ImportAccountResponse);
     */
    importAccount(input: ImportAccountRequest, options?: RpcOptions): UnaryCall<ImportAccountRequest, ImportAccountResponse>;
    /**
     * lncli: `wallet accounts import-pubkey`
     * ImportPublicKey imports a public key as watch-only into the wallet. The
     * public key is converted into a simple address of the given type and that
     * address script is watched on chain. For Taproot keys, this will only watch
     * the BIP-0086 style output script. Use ImportTapscript for more advanced key
     * spend or script spend outputs.
     *
     * NOTE: Events (deposits/spends) for a key will only be detected by lnd if
     * they happen after the import. Rescans to detect past events will be
     * supported later on.
     *
     * @generated from protobuf rpc: ImportPublicKey(walletrpc.ImportPublicKeyRequest) returns (walletrpc.ImportPublicKeyResponse);
     */
    importPublicKey(input: ImportPublicKeyRequest, options?: RpcOptions): UnaryCall<ImportPublicKeyRequest, ImportPublicKeyResponse>;
    /**
     *
     * ImportTapscript imports a Taproot script and internal key and adds the
     * resulting Taproot output key as a watch-only output script into the wallet.
     * For BIP-0086 style Taproot keys (no root hash commitment and no script spend
     * path) use ImportPublicKey.
     *
     * NOTE: Events (deposits/spends) for a key will only be detected by lnd if
     * they happen after the import. Rescans to detect past events will be
     * supported later on.
     *
     * NOTE: Taproot keys imported through this RPC currently _cannot_ be used for
     * funding PSBTs. Only tracking the balance and UTXOs is currently supported.
     *
     * @generated from protobuf rpc: ImportTapscript(walletrpc.ImportTapscriptRequest) returns (walletrpc.ImportTapscriptResponse);
     */
    importTapscript(input: ImportTapscriptRequest, options?: RpcOptions): UnaryCall<ImportTapscriptRequest, ImportTapscriptResponse>;
    /**
     * lncli: `wallet publishtx`
     * PublishTransaction attempts to publish the passed transaction to the
     * network. Once this returns without an error, the wallet will continually
     * attempt to re-broadcast the transaction on start up, until it enters the
     * chain.
     *
     * @generated from protobuf rpc: PublishTransaction(walletrpc.Transaction) returns (walletrpc.PublishResponse);
     */
    publishTransaction(input: Transaction$, options?: RpcOptions): UnaryCall<Transaction$, PublishResponse>;
    /**
     * lncli: `wallet removetx`
     * RemoveTransaction attempts to remove the provided transaction from the
     * internal transaction store of the wallet.
     *
     * @generated from protobuf rpc: RemoveTransaction(walletrpc.GetTransactionRequest) returns (walletrpc.RemoveTransactionResponse);
     */
    removeTransaction(input: GetTransactionRequest, options?: RpcOptions): UnaryCall<GetTransactionRequest, RemoveTransactionResponse>;
    /**
     *
     * SendOutputs is similar to the existing sendmany call in Bitcoind, and
     * allows the caller to create a transaction that sends to several outputs at
     * once. This is ideal when wanting to batch create a set of transactions.
     *
     * @generated from protobuf rpc: SendOutputs(walletrpc.SendOutputsRequest) returns (walletrpc.SendOutputsResponse);
     */
    sendOutputs(input: SendOutputsRequest, options?: RpcOptions): UnaryCall<SendOutputsRequest, SendOutputsResponse>;
    /**
     * lncli: `wallet estimatefeerate`
     * EstimateFee attempts to query the internal fee estimator of the wallet to
     * determine the fee (in sat/kw) to attach to a transaction in order to
     * achieve the confirmation target.
     *
     * @generated from protobuf rpc: EstimateFee(walletrpc.EstimateFeeRequest) returns (walletrpc.EstimateFeeResponse);
     */
    estimateFee(input: EstimateFeeRequest, options?: RpcOptions): UnaryCall<EstimateFeeRequest, EstimateFeeResponse>;
    /**
     * lncli: `wallet pendingsweeps`
     * PendingSweeps returns lists of on-chain outputs that lnd is currently
     * attempting to sweep within its central batching engine. Outputs with similar
     * fee rates are batched together in order to sweep them within a single
     * transaction.
     *
     * NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to
     * remain supported. This is an advanced API that depends on the internals of
     * the UtxoSweeper, so things may change.
     *
     * @generated from protobuf rpc: PendingSweeps(walletrpc.PendingSweepsRequest) returns (walletrpc.PendingSweepsResponse);
     */
    pendingSweeps(input: PendingSweepsRequest, options?: RpcOptions): UnaryCall<PendingSweepsRequest, PendingSweepsResponse>;
    /**
     * lncli: `wallet bumpfee`
     * BumpFee is an endpoint that allows users to interact with lnd's sweeper
     * directly. It takes an outpoint from an unconfirmed transaction and sends it
     * to the sweeper for potential fee bumping. Depending on whether the outpoint
     * has been registered in the sweeper (an existing input, e.g., an anchor
     * output) or not (a new input, e.g., an unconfirmed wallet utxo), this will
     * either be an RBF or CPFP attempt.
     *
     * When receiving an input, lnd’s sweeper needs to understand its time
     * sensitivity to make economical fee bumps - internally a fee function is
     * created using the deadline and budget to guide the process. When the
     * deadline is approaching, the fee function will increase the fee rate and
     * perform an RBF.
     *
     * When a force close happens, all the outputs from the force closing
     * transaction will be registered in the sweeper. The sweeper will then handle
     * the creation, publish, and fee bumping of the sweeping transactions.
     * Everytime a new block comes in, unless the sweeping transaction is
     * confirmed, an RBF is attempted. To interfere with this automatic process,
     * users can use BumpFee to specify customized fee rate, budget, deadline, and
     * whether the sweep should happen immediately. It's recommended to call
     * `ListSweeps` to understand the shape of the existing sweeping transaction
     * first - depending on the number of inputs in this transaction, the RBF
     * requirements can be quite different.
     *
     * This RPC also serves useful when wanting to perform a Child-Pays-For-Parent
     * (CPFP), where the child transaction pays for its parent's fee. This can be
     * done by specifying an outpoint within the low fee transaction that is under
     * the control of the wallet.
     *
     * @generated from protobuf rpc: BumpFee(walletrpc.BumpFeeRequest) returns (walletrpc.BumpFeeResponse);
     */
    bumpFee(input: BumpFeeRequest, options?: RpcOptions): UnaryCall<BumpFeeRequest, BumpFeeResponse>;
    /**
     * lncli: `wallet bumpforceclosefee`
     * BumpForceCloseFee is an endpoint that allows users to bump the fee of a
     * channel force close. This only works for channels with option_anchors.
     *
     * @generated from protobuf rpc: BumpForceCloseFee(walletrpc.BumpForceCloseFeeRequest) returns (walletrpc.BumpForceCloseFeeResponse);
     */
    bumpForceCloseFee(input: BumpForceCloseFeeRequest, options?: RpcOptions): UnaryCall<BumpForceCloseFeeRequest, BumpForceCloseFeeResponse>;
    /**
     * lncli: `wallet listsweeps`
     * ListSweeps returns a list of the sweep transactions our node has produced.
     * Note that these sweeps may not be confirmed yet, as we record sweeps on
     * broadcast, not confirmation.
     *
     * @generated from protobuf rpc: ListSweeps(walletrpc.ListSweepsRequest) returns (walletrpc.ListSweepsResponse);
     */
    listSweeps(input: ListSweepsRequest, options?: RpcOptions): UnaryCall<ListSweepsRequest, ListSweepsResponse>;
    /**
     * lncli: `wallet labeltx`
     * LabelTransaction adds a label to a transaction. If the transaction already
     * has a label the call will fail unless the overwrite bool is set. This will
     * overwrite the existing transaction label. Labels must not be empty, and
     * cannot exceed 500 characters.
     *
     * @generated from protobuf rpc: LabelTransaction(walletrpc.LabelTransactionRequest) returns (walletrpc.LabelTransactionResponse);
     */
    labelTransaction(input: LabelTransactionRequest, options?: RpcOptions): UnaryCall<LabelTransactionRequest, LabelTransactionResponse>;
    /**
     * lncli: `wallet psbt fund`
     * FundPsbt creates a fully populated PSBT that contains enough inputs to fund
     * the outputs specified in the template. There are three ways a user can
     * specify what we call the template (a list of inputs and outputs to use in
     * the PSBT): Either as a PSBT packet directly with no coin selection (using
     * the legacy "psbt" field), a PSBT with advanced coin selection support (using
     * the new "coin_select" field) or as a raw RPC message (using the "raw"
     * field).
     * The legacy "psbt" and "raw" modes, the following restrictions apply:
     * 1. If there are no inputs specified in the template, coin selection is
     * performed automatically.
     * 2. If the template does contain any inputs, it is assumed that full
     * coin selection happened externally and no additional inputs are added. If
     * the specified inputs aren't enough to fund the outputs with the given fee
     * rate, an error is returned.
     *
     * The new "coin_select" mode does not have these restrictions and allows the
     * user to specify a PSBT with inputs and outputs and still perform coin
     * selection on top of that.
     * For all modes this RPC requires any inputs that are specified to be locked
     * by the user (if they belong to this node in the first place).
     *
     * After either selecting or verifying the inputs, all input UTXOs are locked
     * with an internal app ID.
     *
     * NOTE: If this method returns without an error, it is the caller's
     * responsibility to either spend the locked UTXOs (by finalizing and then
     * publishing the transaction) or to unlock/release the locked UTXOs in case of
     * an error on the caller's side.
     *
     * @generated from protobuf rpc: FundPsbt(walletrpc.FundPsbtRequest) returns (walletrpc.FundPsbtResponse);
     */
    fundPsbt(input: FundPsbtRequest, options?: RpcOptions): UnaryCall<FundPsbtRequest, FundPsbtResponse>;
    /**
     *
     * SignPsbt expects a partial transaction with all inputs and outputs fully
     * declared and tries to sign all unsigned inputs that have all required fields
     * (UTXO information, BIP32 derivation information, witness or sig scripts)
     * set.
     * If no error is returned, the PSBT is ready to be given to the next signer or
     * to be finalized if lnd was the last signer.
     *
     * NOTE: This RPC only signs inputs (and only those it can sign), it does not
     * perform any other tasks (such as coin selection, UTXO locking or
     * input/output/fee value validation, PSBT finalization). Any input that is
     * incomplete will be skipped.
     *
     * @generated from protobuf rpc: SignPsbt(walletrpc.SignPsbtRequest) returns (walletrpc.SignPsbtResponse);
     */
    signPsbt(input: SignPsbtRequest, options?: RpcOptions): UnaryCall<SignPsbtRequest, SignPsbtResponse>;
    /**
     * lncli: `wallet psbt finalize`
     * FinalizePsbt expects a partial transaction with all inputs and outputs fully
     * declared and tries to sign all inputs that belong to the wallet. Lnd must be
     * the last signer of the transaction. That means, if there are any unsigned
     * non-witness inputs or inputs without UTXO information attached or inputs
     * without witness data that do not belong to lnd's wallet, this method will
     * fail. If no error is returned, the PSBT is ready to be extracted and the
     * final TX within to be broadcast.
     *
     * NOTE: This method does NOT publish the transaction once finalized. It is the
     * caller's responsibility to either publish the transaction on success or
     * unlock/release any locked UTXOs in case of an error in this method.
     *
     * @generated from protobuf rpc: FinalizePsbt(walletrpc.FinalizePsbtRequest) returns (walletrpc.FinalizePsbtResponse);
     */
    finalizePsbt(input: FinalizePsbtRequest, options?: RpcOptions): UnaryCall<FinalizePsbtRequest, FinalizePsbtResponse>;
}
// 
// Comments in this file will be directly parsed into the API
// Documentation as descriptions of the associated method, message, or field.
// These descriptions should go right above the definition of the object, and
// can be in either block or // comment format.
// 
// An RPC method can be matched to an lncli command by placing a line in the
// beginning of the description in exactly the following format:
// lncli: `methodname`
// 
// Failure to specify the exact name of the command will cause documentation
// generation to fail.
// 
// More information on how exactly the gRPC documentation is generated from
// this proto file can be found here:
// https://github.com/lightninglabs/lightning-api

/**
 * WalletKit is a service that gives access to the core functionalities of the
 * daemon's wallet.
 *
 * @generated from protobuf service walletrpc.WalletKit
 */
export class WalletKitClient implements IWalletKitClient, ServiceInfo {
    typeName = WalletKit.typeName;
    methods = WalletKit.methods;
    options = WalletKit.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     *
     * ListUnspent returns a list of all utxos spendable by the wallet with a
     * number of confirmations between the specified minimum and maximum. By
     * default, all utxos are listed. To list only the unconfirmed utxos, set
     * the unconfirmed_only to true.
     *
     * @generated from protobuf rpc: ListUnspent(walletrpc.ListUnspentRequest) returns (walletrpc.ListUnspentResponse);
     */
    listUnspent(input: ListUnspentRequest, options?: RpcOptions): UnaryCall<ListUnspentRequest, ListUnspentResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListUnspentRequest, ListUnspentResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet leaseoutput`
     * LeaseOutput locks an output to the given ID, preventing it from being
     * available for any future coin selection attempts. The absolute time of the
     * lock's expiration is returned. The expiration of the lock can be extended by
     * successive invocations of this RPC. Outputs can be unlocked before their
     * expiration through `ReleaseOutput`.
     *
     * @generated from protobuf rpc: LeaseOutput(walletrpc.LeaseOutputRequest) returns (walletrpc.LeaseOutputResponse);
     */
    leaseOutput(input: LeaseOutputRequest, options?: RpcOptions): UnaryCall<LeaseOutputRequest, LeaseOutputResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<LeaseOutputRequest, LeaseOutputResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet releaseoutput`
     * ReleaseOutput unlocks an output, allowing it to be available for coin
     * selection if it remains unspent. The ID should match the one used to
     * originally lock the output.
     *
     * @generated from protobuf rpc: ReleaseOutput(walletrpc.ReleaseOutputRequest) returns (walletrpc.ReleaseOutputResponse);
     */
    releaseOutput(input: ReleaseOutputRequest, options?: RpcOptions): UnaryCall<ReleaseOutputRequest, ReleaseOutputResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReleaseOutputRequest, ReleaseOutputResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet listleases`
     * ListLeases lists all currently locked utxos.
     *
     * @generated from protobuf rpc: ListLeases(walletrpc.ListLeasesRequest) returns (walletrpc.ListLeasesResponse);
     */
    listLeases(input: ListLeasesRequest, options?: RpcOptions): UnaryCall<ListLeasesRequest, ListLeasesResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListLeasesRequest, ListLeasesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * DeriveNextKey attempts to derive the *next* key within the key family
     * (account in BIP43) specified. This method should return the next external
     * child within this branch.
     *
     * @generated from protobuf rpc: DeriveNextKey(walletrpc.KeyReq) returns (signrpc.KeyDescriptor);
     */
    deriveNextKey(input: KeyReq, options?: RpcOptions): UnaryCall<KeyReq, KeyDescriptor> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<KeyReq, KeyDescriptor>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * DeriveKey attempts to derive an arbitrary key specified by the passed
     * KeyLocator.
     *
     * @generated from protobuf rpc: DeriveKey(signrpc.KeyLocator) returns (signrpc.KeyDescriptor);
     */
    deriveKey(input: KeyLocator, options?: RpcOptions): UnaryCall<KeyLocator, KeyDescriptor> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<KeyLocator, KeyDescriptor>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * NextAddr returns the next unused address within the wallet.
     *
     * @generated from protobuf rpc: NextAddr(walletrpc.AddrRequest) returns (walletrpc.AddrResponse);
     */
    nextAddr(input: AddrRequest, options?: RpcOptions): UnaryCall<AddrRequest, AddrResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<AddrRequest, AddrResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet gettx`
     * GetTransaction returns details for a transaction found in the wallet.
     *
     * @generated from protobuf rpc: GetTransaction(walletrpc.GetTransactionRequest) returns (lnrpc.Transaction);
     */
    getTransaction(input: GetTransactionRequest, options?: RpcOptions): UnaryCall<GetTransactionRequest, Transaction> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTransactionRequest, Transaction>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet accounts list`
     * ListAccounts retrieves all accounts belonging to the wallet by default. A
     * name and key scope filter can be provided to filter through all of the
     * wallet accounts and return only those matching.
     *
     * @generated from protobuf rpc: ListAccounts(walletrpc.ListAccountsRequest) returns (walletrpc.ListAccountsResponse);
     */
    listAccounts(input: ListAccountsRequest, options?: RpcOptions): UnaryCall<ListAccountsRequest, ListAccountsResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListAccountsRequest, ListAccountsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet requiredreserve`
     * RequiredReserve returns the minimum amount of satoshis that should be kept
     * in the wallet in order to fee bump anchor channels if necessary. The value
     * scales with the number of public anchor channels but is capped at a maximum.
     *
     * @generated from protobuf rpc: RequiredReserve(walletrpc.RequiredReserveRequest) returns (walletrpc.RequiredReserveResponse);
     */
    requiredReserve(input: RequiredReserveRequest, options?: RpcOptions): UnaryCall<RequiredReserveRequest, RequiredReserveResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<RequiredReserveRequest, RequiredReserveResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet addresses list`
     * ListAddresses retrieves all the addresses along with their balance. An
     * account name filter can be provided to filter through all of the
     * wallet accounts and return the addresses of only those matching.
     *
     * @generated from protobuf rpc: ListAddresses(walletrpc.ListAddressesRequest) returns (walletrpc.ListAddressesResponse);
     */
    listAddresses(input: ListAddressesRequest, options?: RpcOptions): UnaryCall<ListAddressesRequest, ListAddressesResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListAddressesRequest, ListAddressesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet addresses signmessage`
     * SignMessageWithAddr returns the compact signature (base64 encoded) created
     * with the private key of the provided address. This requires the address
     * to be solely based on a public key lock (no scripts). Obviously the internal
     * lnd wallet has to possess the private key of the address otherwise
     * an error is returned.
     *
     * This method aims to provide full compatibility with the bitcoin-core and
     * btcd implementation. Bitcoin-core's algorithm is not specified in a
     * BIP and only applicable for legacy addresses. This method enhances the
     * signing for additional address types: P2WKH, NP2WKH, P2TR.
     * For P2TR addresses this represents a special case. ECDSA is used to create
     * a compact signature which makes the public key of the signature recoverable.
     *
     * @generated from protobuf rpc: SignMessageWithAddr(walletrpc.SignMessageWithAddrRequest) returns (walletrpc.SignMessageWithAddrResponse);
     */
    signMessageWithAddr(input: SignMessageWithAddrRequest, options?: RpcOptions): UnaryCall<SignMessageWithAddrRequest, SignMessageWithAddrResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<SignMessageWithAddrRequest, SignMessageWithAddrResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet addresses verifymessage`
     * VerifyMessageWithAddr returns the validity and the recovered public key of
     * the provided compact signature (base64 encoded). The verification is
     * twofold. First the validity of the signature itself is checked and then
     * it is verified that the recovered public key of the signature equals
     * the public key of the provided address. There is no dependence on the
     * private key of the address therefore also external addresses are allowed
     * to verify signatures.
     * Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.
     *
     * This method is the counterpart of the related signing method
     * (SignMessageWithAddr) and aims to provide full compatibility to
     * bitcoin-core's implementation. Although bitcoin-core/btcd only provide
     * this functionality for legacy addresses this function enhances it to
     * the address types: P2PKH, P2WKH, NP2WKH, P2TR.
     *
     * The verification for P2TR addresses is a special case and requires the
     * ECDSA compact signature to compare the reovered public key to the internal
     * taproot key. The compact ECDSA signature format was used because there
     * are still no known compact signature schemes for schnorr signatures.
     *
     * @generated from protobuf rpc: VerifyMessageWithAddr(walletrpc.VerifyMessageWithAddrRequest) returns (walletrpc.VerifyMessageWithAddrResponse);
     */
    verifyMessageWithAddr(input: VerifyMessageWithAddrRequest, options?: RpcOptions): UnaryCall<VerifyMessageWithAddrRequest, VerifyMessageWithAddrResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<VerifyMessageWithAddrRequest, VerifyMessageWithAddrResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet accounts import`
     * ImportAccount imports an account backed by an account extended public key.
     * The master key fingerprint denotes the fingerprint of the root key
     * corresponding to the account public key (also known as the key with
     * derivation path m/). This may be required by some hardware wallets for
     * proper identification and signing.
     *
     * The address type can usually be inferred from the key's version, but may be
     * required for certain keys to map them into the proper scope.
     *
     * For BIP-0044 keys, an address type must be specified as we intend to not
     * support importing BIP-0044 keys into the wallet using the legacy
     * pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force
     * the standard BIP-0049 derivation scheme, while a witness address type will
     * force the standard BIP-0084 derivation scheme.
     *
     * For BIP-0049 keys, an address type must also be specified to make a
     * distinction between the standard BIP-0049 address schema (nested witness
     * pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys
     * externally, witness pubkeys internally).
     *
     * NOTE: Events (deposits/spends) for keys derived from an account will only be
     * detected by lnd if they happen after the import. Rescans to detect past
     * events will be supported later on.
     *
     * @generated from protobuf rpc: ImportAccount(walletrpc.ImportAccountRequest) returns (walletrpc.ImportAccountResponse);
     */
    importAccount(input: ImportAccountRequest, options?: RpcOptions): UnaryCall<ImportAccountRequest, ImportAccountResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<ImportAccountRequest, ImportAccountResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet accounts import-pubkey`
     * ImportPublicKey imports a public key as watch-only into the wallet. The
     * public key is converted into a simple address of the given type and that
     * address script is watched on chain. For Taproot keys, this will only watch
     * the BIP-0086 style output script. Use ImportTapscript for more advanced key
     * spend or script spend outputs.
     *
     * NOTE: Events (deposits/spends) for a key will only be detected by lnd if
     * they happen after the import. Rescans to detect past events will be
     * supported later on.
     *
     * @generated from protobuf rpc: ImportPublicKey(walletrpc.ImportPublicKeyRequest) returns (walletrpc.ImportPublicKeyResponse);
     */
    importPublicKey(input: ImportPublicKeyRequest, options?: RpcOptions): UnaryCall<ImportPublicKeyRequest, ImportPublicKeyResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<ImportPublicKeyRequest, ImportPublicKeyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * ImportTapscript imports a Taproot script and internal key and adds the
     * resulting Taproot output key as a watch-only output script into the wallet.
     * For BIP-0086 style Taproot keys (no root hash commitment and no script spend
     * path) use ImportPublicKey.
     *
     * NOTE: Events (deposits/spends) for a key will only be detected by lnd if
     * they happen after the import. Rescans to detect past events will be
     * supported later on.
     *
     * NOTE: Taproot keys imported through this RPC currently _cannot_ be used for
     * funding PSBTs. Only tracking the balance and UTXOs is currently supported.
     *
     * @generated from protobuf rpc: ImportTapscript(walletrpc.ImportTapscriptRequest) returns (walletrpc.ImportTapscriptResponse);
     */
    importTapscript(input: ImportTapscriptRequest, options?: RpcOptions): UnaryCall<ImportTapscriptRequest, ImportTapscriptResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<ImportTapscriptRequest, ImportTapscriptResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet publishtx`
     * PublishTransaction attempts to publish the passed transaction to the
     * network. Once this returns without an error, the wallet will continually
     * attempt to re-broadcast the transaction on start up, until it enters the
     * chain.
     *
     * @generated from protobuf rpc: PublishTransaction(walletrpc.Transaction) returns (walletrpc.PublishResponse);
     */
    publishTransaction(input: Transaction$, options?: RpcOptions): UnaryCall<Transaction$, PublishResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<Transaction$, PublishResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet removetx`
     * RemoveTransaction attempts to remove the provided transaction from the
     * internal transaction store of the wallet.
     *
     * @generated from protobuf rpc: RemoveTransaction(walletrpc.GetTransactionRequest) returns (walletrpc.RemoveTransactionResponse);
     */
    removeTransaction(input: GetTransactionRequest, options?: RpcOptions): UnaryCall<GetTransactionRequest, RemoveTransactionResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTransactionRequest, RemoveTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * SendOutputs is similar to the existing sendmany call in Bitcoind, and
     * allows the caller to create a transaction that sends to several outputs at
     * once. This is ideal when wanting to batch create a set of transactions.
     *
     * @generated from protobuf rpc: SendOutputs(walletrpc.SendOutputsRequest) returns (walletrpc.SendOutputsResponse);
     */
    sendOutputs(input: SendOutputsRequest, options?: RpcOptions): UnaryCall<SendOutputsRequest, SendOutputsResponse> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<SendOutputsRequest, SendOutputsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet estimatefeerate`
     * EstimateFee attempts to query the internal fee estimator of the wallet to
     * determine the fee (in sat/kw) to attach to a transaction in order to
     * achieve the confirmation target.
     *
     * @generated from protobuf rpc: EstimateFee(walletrpc.EstimateFeeRequest) returns (walletrpc.EstimateFeeResponse);
     */
    estimateFee(input: EstimateFeeRequest, options?: RpcOptions): UnaryCall<EstimateFeeRequest, EstimateFeeResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<EstimateFeeRequest, EstimateFeeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet pendingsweeps`
     * PendingSweeps returns lists of on-chain outputs that lnd is currently
     * attempting to sweep within its central batching engine. Outputs with similar
     * fee rates are batched together in order to sweep them within a single
     * transaction.
     *
     * NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to
     * remain supported. This is an advanced API that depends on the internals of
     * the UtxoSweeper, so things may change.
     *
     * @generated from protobuf rpc: PendingSweeps(walletrpc.PendingSweepsRequest) returns (walletrpc.PendingSweepsResponse);
     */
    pendingSweeps(input: PendingSweepsRequest, options?: RpcOptions): UnaryCall<PendingSweepsRequest, PendingSweepsResponse> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<PendingSweepsRequest, PendingSweepsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet bumpfee`
     * BumpFee is an endpoint that allows users to interact with lnd's sweeper
     * directly. It takes an outpoint from an unconfirmed transaction and sends it
     * to the sweeper for potential fee bumping. Depending on whether the outpoint
     * has been registered in the sweeper (an existing input, e.g., an anchor
     * output) or not (a new input, e.g., an unconfirmed wallet utxo), this will
     * either be an RBF or CPFP attempt.
     *
     * When receiving an input, lnd’s sweeper needs to understand its time
     * sensitivity to make economical fee bumps - internally a fee function is
     * created using the deadline and budget to guide the process. When the
     * deadline is approaching, the fee function will increase the fee rate and
     * perform an RBF.
     *
     * When a force close happens, all the outputs from the force closing
     * transaction will be registered in the sweeper. The sweeper will then handle
     * the creation, publish, and fee bumping of the sweeping transactions.
     * Everytime a new block comes in, unless the sweeping transaction is
     * confirmed, an RBF is attempted. To interfere with this automatic process,
     * users can use BumpFee to specify customized fee rate, budget, deadline, and
     * whether the sweep should happen immediately. It's recommended to call
     * `ListSweeps` to understand the shape of the existing sweeping transaction
     * first - depending on the number of inputs in this transaction, the RBF
     * requirements can be quite different.
     *
     * This RPC also serves useful when wanting to perform a Child-Pays-For-Parent
     * (CPFP), where the child transaction pays for its parent's fee. This can be
     * done by specifying an outpoint within the low fee transaction that is under
     * the control of the wallet.
     *
     * @generated from protobuf rpc: BumpFee(walletrpc.BumpFeeRequest) returns (walletrpc.BumpFeeResponse);
     */
    bumpFee(input: BumpFeeRequest, options?: RpcOptions): UnaryCall<BumpFeeRequest, BumpFeeResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<BumpFeeRequest, BumpFeeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet bumpforceclosefee`
     * BumpForceCloseFee is an endpoint that allows users to bump the fee of a
     * channel force close. This only works for channels with option_anchors.
     *
     * @generated from protobuf rpc: BumpForceCloseFee(walletrpc.BumpForceCloseFeeRequest) returns (walletrpc.BumpForceCloseFeeResponse);
     */
    bumpForceCloseFee(input: BumpForceCloseFeeRequest, options?: RpcOptions): UnaryCall<BumpForceCloseFeeRequest, BumpForceCloseFeeResponse> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<BumpForceCloseFeeRequest, BumpForceCloseFeeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet listsweeps`
     * ListSweeps returns a list of the sweep transactions our node has produced.
     * Note that these sweeps may not be confirmed yet, as we record sweeps on
     * broadcast, not confirmation.
     *
     * @generated from protobuf rpc: ListSweeps(walletrpc.ListSweepsRequest) returns (walletrpc.ListSweepsResponse);
     */
    listSweeps(input: ListSweepsRequest, options?: RpcOptions): UnaryCall<ListSweepsRequest, ListSweepsResponse> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListSweepsRequest, ListSweepsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet labeltx`
     * LabelTransaction adds a label to a transaction. If the transaction already
     * has a label the call will fail unless the overwrite bool is set. This will
     * overwrite the existing transaction label. Labels must not be empty, and
     * cannot exceed 500 characters.
     *
     * @generated from protobuf rpc: LabelTransaction(walletrpc.LabelTransactionRequest) returns (walletrpc.LabelTransactionResponse);
     */
    labelTransaction(input: LabelTransactionRequest, options?: RpcOptions): UnaryCall<LabelTransactionRequest, LabelTransactionResponse> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<LabelTransactionRequest, LabelTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet psbt fund`
     * FundPsbt creates a fully populated PSBT that contains enough inputs to fund
     * the outputs specified in the template. There are three ways a user can
     * specify what we call the template (a list of inputs and outputs to use in
     * the PSBT): Either as a PSBT packet directly with no coin selection (using
     * the legacy "psbt" field), a PSBT with advanced coin selection support (using
     * the new "coin_select" field) or as a raw RPC message (using the "raw"
     * field).
     * The legacy "psbt" and "raw" modes, the following restrictions apply:
     * 1. If there are no inputs specified in the template, coin selection is
     * performed automatically.
     * 2. If the template does contain any inputs, it is assumed that full
     * coin selection happened externally and no additional inputs are added. If
     * the specified inputs aren't enough to fund the outputs with the given fee
     * rate, an error is returned.
     *
     * The new "coin_select" mode does not have these restrictions and allows the
     * user to specify a PSBT with inputs and outputs and still perform coin
     * selection on top of that.
     * For all modes this RPC requires any inputs that are specified to be locked
     * by the user (if they belong to this node in the first place).
     *
     * After either selecting or verifying the inputs, all input UTXOs are locked
     * with an internal app ID.
     *
     * NOTE: If this method returns without an error, it is the caller's
     * responsibility to either spend the locked UTXOs (by finalizing and then
     * publishing the transaction) or to unlock/release the locked UTXOs in case of
     * an error on the caller's side.
     *
     * @generated from protobuf rpc: FundPsbt(walletrpc.FundPsbtRequest) returns (walletrpc.FundPsbtResponse);
     */
    fundPsbt(input: FundPsbtRequest, options?: RpcOptions): UnaryCall<FundPsbtRequest, FundPsbtResponse> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<FundPsbtRequest, FundPsbtResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * SignPsbt expects a partial transaction with all inputs and outputs fully
     * declared and tries to sign all unsigned inputs that have all required fields
     * (UTXO information, BIP32 derivation information, witness or sig scripts)
     * set.
     * If no error is returned, the PSBT is ready to be given to the next signer or
     * to be finalized if lnd was the last signer.
     *
     * NOTE: This RPC only signs inputs (and only those it can sign), it does not
     * perform any other tasks (such as coin selection, UTXO locking or
     * input/output/fee value validation, PSBT finalization). Any input that is
     * incomplete will be skipped.
     *
     * @generated from protobuf rpc: SignPsbt(walletrpc.SignPsbtRequest) returns (walletrpc.SignPsbtResponse);
     */
    signPsbt(input: SignPsbtRequest, options?: RpcOptions): UnaryCall<SignPsbtRequest, SignPsbtResponse> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept<SignPsbtRequest, SignPsbtResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * lncli: `wallet psbt finalize`
     * FinalizePsbt expects a partial transaction with all inputs and outputs fully
     * declared and tries to sign all inputs that belong to the wallet. Lnd must be
     * the last signer of the transaction. That means, if there are any unsigned
     * non-witness inputs or inputs without UTXO information attached or inputs
     * without witness data that do not belong to lnd's wallet, this method will
     * fail. If no error is returned, the PSBT is ready to be extracted and the
     * final TX within to be broadcast.
     *
     * NOTE: This method does NOT publish the transaction once finalized. It is the
     * caller's responsibility to either publish the transaction on success or
     * unlock/release any locked UTXOs in case of an error in this method.
     *
     * @generated from protobuf rpc: FinalizePsbt(walletrpc.FinalizePsbtRequest) returns (walletrpc.FinalizePsbtResponse);
     */
    finalizePsbt(input: FinalizePsbtRequest, options?: RpcOptions): UnaryCall<FinalizePsbtRequest, FinalizePsbtResponse> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept<FinalizePsbtRequest, FinalizePsbtResponse>("unary", this._transport, method, opt, input);
    }
}
