// This file was autogenerated from a .proto file, DO NOT EDIT!

export type ResultError = { status: 'ERROR', reason: string }
export type RequestInfo = { rpcName: string, batch: boolean, nostr: boolean, batchSize: number }
export type RequestStats = { startMs:number, start:bigint, parse: bigint, guard: bigint, validate: bigint, handle: bigint }
export type RequestMetric = AuthContext & RequestInfo & RequestStats & { error?: string }
export type GuestContext = {
}
export type GuestMethodInputs = GetAdminConnectInfo_Input | GetServiceState_Input | WizardConfig_Input | WizardState_Input
export type GuestMethodOutputs = GetAdminConnectInfo_Output | GetServiceState_Output | WizardConfig_Output | WizardState_Output
export type AuthContext = GuestContext

export type GetAdminConnectInfo_Input = {rpcName:'GetAdminConnectInfo'}
export type GetAdminConnectInfo_Output = ResultError | ({ status: 'OK' } & AdminConnectInfoResponse)

export type GetServiceState_Input = {rpcName:'GetServiceState'}
export type GetServiceState_Output = ResultError | ({ status: 'OK' } & ServiceStateResponse)

export type WizardConfig_Input = {rpcName:'WizardConfig', req: ConfigRequest}
export type WizardConfig_Output = ResultError | { status: 'OK' }

export type WizardState_Input = {rpcName:'WizardState'}
export type WizardState_Output = ResultError | ({ status: 'OK' } & StateResponse)

export type ServerMethods = {
    GetAdminConnectInfo?: (req: GetAdminConnectInfo_Input & {ctx: GuestContext }) => Promise<AdminConnectInfoResponse>
    GetServiceState?: (req: GetServiceState_Input & {ctx: GuestContext }) => Promise<ServiceStateResponse>
    WizardConfig?: (req: WizardConfig_Input & {ctx: GuestContext }) => Promise<void>
    WizardState?: (req: WizardState_Input & {ctx: GuestContext }) => Promise<StateResponse>
}

export enum LndState {
    OFFLINE = 'OFFLINE',
    ONLINE = 'ONLINE',
    SYNCING = 'SYNCING',
}
export const enumCheckLndState = (e?: LndState): boolean => {
    for (const v in LndState) if (e === v) return true
    return false
}

export type OptionsBaseMessage = {
    allOptionalsAreSet?: true
}

export type AdminConnectInfoResponse = {
    connect_info: AdminConnectInfoResponse_connect_info
    nprofile: string
}
export const AdminConnectInfoResponseOptionalFields: [] = []
export type AdminConnectInfoResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    connect_info_Options?: AdminConnectInfoResponse_connect_infoOptions
    nprofile_CustomCheck?: (v: string) => boolean
}
export const AdminConnectInfoResponseValidate = (o?: AdminConnectInfoResponse, opts: AdminConnectInfoResponseOptions = {}, path: string = 'AdminConnectInfoResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    const connect_infoErr = AdminConnectInfoResponse_connect_infoValidate(o.connect_info, opts.connect_info_Options, `${path}.connect_info`)
    if (connect_infoErr !== null) return connect_infoErr
    

    if (typeof o.nprofile !== 'string') return new Error(`${path}.nprofile: is not a string`)
    if (opts.nprofile_CustomCheck && !opts.nprofile_CustomCheck(o.nprofile)) return new Error(`${path}.nprofile: custom check failed`)

    return null
}

export type ConfigRequest = {
    automate_liquidity: boolean
    push_backups_to_nostr: boolean
    relay_url: string
    source_name: string
}
export const ConfigRequestOptionalFields: [] = []
export type ConfigRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    automate_liquidity_CustomCheck?: (v: boolean) => boolean
    push_backups_to_nostr_CustomCheck?: (v: boolean) => boolean
    relay_url_CustomCheck?: (v: string) => boolean
    source_name_CustomCheck?: (v: string) => boolean
}
export const ConfigRequestValidate = (o?: ConfigRequest, opts: ConfigRequestOptions = {}, path: string = 'ConfigRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.automate_liquidity !== 'boolean') return new Error(`${path}.automate_liquidity: is not a boolean`)
    if (opts.automate_liquidity_CustomCheck && !opts.automate_liquidity_CustomCheck(o.automate_liquidity)) return new Error(`${path}.automate_liquidity: custom check failed`)

    if (typeof o.push_backups_to_nostr !== 'boolean') return new Error(`${path}.push_backups_to_nostr: is not a boolean`)
    if (opts.push_backups_to_nostr_CustomCheck && !opts.push_backups_to_nostr_CustomCheck(o.push_backups_to_nostr)) return new Error(`${path}.push_backups_to_nostr: custom check failed`)

    if (typeof o.relay_url !== 'string') return new Error(`${path}.relay_url: is not a string`)
    if (opts.relay_url_CustomCheck && !opts.relay_url_CustomCheck(o.relay_url)) return new Error(`${path}.relay_url: custom check failed`)

    if (typeof o.source_name !== 'string') return new Error(`${path}.source_name: is not a string`)
    if (opts.source_name_CustomCheck && !opts.source_name_CustomCheck(o.source_name)) return new Error(`${path}.source_name: custom check failed`)

    return null
}

export type Empty = {
}
export const EmptyOptionalFields: [] = []
export type EmptyOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
}
export const EmptyValidate = (o?: Empty, opts: EmptyOptions = {}, path: string = 'Empty::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    return null
}

export type ServiceStateResponse = {
    admin_npub: string
    automate_liquidity: boolean
    http_url: string
    lnd_state: LndState
    nprofile: string
    provider_name: string
    push_backups_to_nostr: boolean
    relay_connected: boolean
    relay_url: string
    relays: string[]
    source_name: string
    watchdog_ok: boolean
}
export const ServiceStateResponseOptionalFields: [] = []
export type ServiceStateResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    admin_npub_CustomCheck?: (v: string) => boolean
    automate_liquidity_CustomCheck?: (v: boolean) => boolean
    http_url_CustomCheck?: (v: string) => boolean
    lnd_state_CustomCheck?: (v: LndState) => boolean
    nprofile_CustomCheck?: (v: string) => boolean
    provider_name_CustomCheck?: (v: string) => boolean
    push_backups_to_nostr_CustomCheck?: (v: boolean) => boolean
    relay_connected_CustomCheck?: (v: boolean) => boolean
    relay_url_CustomCheck?: (v: string) => boolean
    relays_CustomCheck?: (v: string[]) => boolean
    source_name_CustomCheck?: (v: string) => boolean
    watchdog_ok_CustomCheck?: (v: boolean) => boolean
}
export const ServiceStateResponseValidate = (o?: ServiceStateResponse, opts: ServiceStateResponseOptions = {}, path: string = 'ServiceStateResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.admin_npub !== 'string') return new Error(`${path}.admin_npub: is not a string`)
    if (opts.admin_npub_CustomCheck && !opts.admin_npub_CustomCheck(o.admin_npub)) return new Error(`${path}.admin_npub: custom check failed`)

    if (typeof o.automate_liquidity !== 'boolean') return new Error(`${path}.automate_liquidity: is not a boolean`)
    if (opts.automate_liquidity_CustomCheck && !opts.automate_liquidity_CustomCheck(o.automate_liquidity)) return new Error(`${path}.automate_liquidity: custom check failed`)

    if (typeof o.http_url !== 'string') return new Error(`${path}.http_url: is not a string`)
    if (opts.http_url_CustomCheck && !opts.http_url_CustomCheck(o.http_url)) return new Error(`${path}.http_url: custom check failed`)

    if (!enumCheckLndState(o.lnd_state)) return new Error(`${path}.lnd_state: is not a valid LndState`)
    if (opts.lnd_state_CustomCheck && !opts.lnd_state_CustomCheck(o.lnd_state)) return new Error(`${path}.lnd_state: custom check failed`)

    if (typeof o.nprofile !== 'string') return new Error(`${path}.nprofile: is not a string`)
    if (opts.nprofile_CustomCheck && !opts.nprofile_CustomCheck(o.nprofile)) return new Error(`${path}.nprofile: custom check failed`)

    if (typeof o.provider_name !== 'string') return new Error(`${path}.provider_name: is not a string`)
    if (opts.provider_name_CustomCheck && !opts.provider_name_CustomCheck(o.provider_name)) return new Error(`${path}.provider_name: custom check failed`)

    if (typeof o.push_backups_to_nostr !== 'boolean') return new Error(`${path}.push_backups_to_nostr: is not a boolean`)
    if (opts.push_backups_to_nostr_CustomCheck && !opts.push_backups_to_nostr_CustomCheck(o.push_backups_to_nostr)) return new Error(`${path}.push_backups_to_nostr: custom check failed`)

    if (typeof o.relay_connected !== 'boolean') return new Error(`${path}.relay_connected: is not a boolean`)
    if (opts.relay_connected_CustomCheck && !opts.relay_connected_CustomCheck(o.relay_connected)) return new Error(`${path}.relay_connected: custom check failed`)

    if (typeof o.relay_url !== 'string') return new Error(`${path}.relay_url: is not a string`)
    if (opts.relay_url_CustomCheck && !opts.relay_url_CustomCheck(o.relay_url)) return new Error(`${path}.relay_url: custom check failed`)

    if (!Array.isArray(o.relays)) return new Error(`${path}.relays: is not an array`)
    for (let index = 0; index < o.relays.length; index++) {
        if (typeof o.relays[index] !== 'string') return new Error(`${path}.relays[${index}]: is not a string`)
    }
    if (opts.relays_CustomCheck && !opts.relays_CustomCheck(o.relays)) return new Error(`${path}.relays: custom check failed`)

    if (typeof o.source_name !== 'string') return new Error(`${path}.source_name: is not a string`)
    if (opts.source_name_CustomCheck && !opts.source_name_CustomCheck(o.source_name)) return new Error(`${path}.source_name: custom check failed`)

    if (typeof o.watchdog_ok !== 'boolean') return new Error(`${path}.watchdog_ok: is not a boolean`)
    if (opts.watchdog_ok_CustomCheck && !opts.watchdog_ok_CustomCheck(o.watchdog_ok)) return new Error(`${path}.watchdog_ok: custom check failed`)

    return null
}

export type StateResponse = {
    admin_linked: boolean
    config_sent: boolean
}
export const StateResponseOptionalFields: [] = []
export type StateResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    admin_linked_CustomCheck?: (v: boolean) => boolean
    config_sent_CustomCheck?: (v: boolean) => boolean
}
export const StateResponseValidate = (o?: StateResponse, opts: StateResponseOptions = {}, path: string = 'StateResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.admin_linked !== 'boolean') return new Error(`${path}.admin_linked: is not a boolean`)
    if (opts.admin_linked_CustomCheck && !opts.admin_linked_CustomCheck(o.admin_linked)) return new Error(`${path}.admin_linked: custom check failed`)

    if (typeof o.config_sent !== 'boolean') return new Error(`${path}.config_sent: is not a boolean`)
    if (opts.config_sent_CustomCheck && !opts.config_sent_CustomCheck(o.config_sent)) return new Error(`${path}.config_sent: custom check failed`)

    return null
}

export enum AdminConnectInfoResponse_connect_info_type {
    ADMIN_TOKEN = 'admin_token',
    ENROLLED_NPUB = 'enrolled_npub',
}
export const enumCheckAdminConnectInfoResponse_connect_info_type = (e?: AdminConnectInfoResponse_connect_info_type): boolean => {
    for (const v in AdminConnectInfoResponse_connect_info_type) if (e === v) return true
    return false
}
export type AdminConnectInfoResponse_connect_info = 
    {type:AdminConnectInfoResponse_connect_info_type.ADMIN_TOKEN, admin_token:string}|
    {type:AdminConnectInfoResponse_connect_info_type.ENROLLED_NPUB, enrolled_npub:string}

export type AdminConnectInfoResponse_connect_infoOptions = {
    admin_token_CustomCheck?: (v: string) => boolean
    enrolled_npub_CustomCheck?: (v: string) => boolean
}
export const AdminConnectInfoResponse_connect_infoValidate = (o?: AdminConnectInfoResponse_connect_info, opts:AdminConnectInfoResponse_connect_infoOptions = {}, path: string = 'AdminConnectInfoResponse_connect_info::root.'): Error | null => {
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')
    const stringType: string = o.type
    switch (o.type) {
        case AdminConnectInfoResponse_connect_info_type.ADMIN_TOKEN:
        if (typeof o.admin_token !== 'string') return new Error(`${path}.admin_token: is not a string`)
        if (opts.admin_token_CustomCheck && !opts.admin_token_CustomCheck(o.admin_token)) return new Error(`${path}.admin_token: custom check failed`)

        break
        case AdminConnectInfoResponse_connect_info_type.ENROLLED_NPUB:
        if (typeof o.enrolled_npub !== 'string') return new Error(`${path}.enrolled_npub: is not a string`)
        if (opts.enrolled_npub_CustomCheck && !opts.enrolled_npub_CustomCheck(o.enrolled_npub)) return new Error(`${path}.enrolled_npub: custom check failed`)

        break
        default:
            return new Error(path + ': unknown type '+ stringType)
    }
    return null
}
