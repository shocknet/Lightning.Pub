// This file was autogenerated from a .proto file, DO NOT EDIT!

export type GuestContext = {
}
export type UserContext = {
    user_id: string
}
export type AdminContext = {
    admin_id: string
}
export type AppContext = {
    app_id: string
}
export type AuthContext = GuestContext | UserContext | AdminContext | AppContext

export type Health_Query = {
}
export type Health_RouteParams = {
}
export type Health_Context = Health_Query & Health_RouteParams & GuestContext
export type EncryptionExchange_Query = {
}
export type EncryptionExchange_RouteParams = {
}
export type EncryptionExchange_Context = EncryptionExchange_Query & EncryptionExchange_RouteParams & GuestContext
export type LndGetInfo_Query = {
}
export type LndGetInfo_RouteParams = {
}
export type LndGetInfo_Context = LndGetInfo_Query & LndGetInfo_RouteParams & AdminContext
export type SetMockInvoiceAsPaid_Query = {
}
export type SetMockInvoiceAsPaid_RouteParams = {
}
export type SetMockInvoiceAsPaid_Context = SetMockInvoiceAsPaid_Query & SetMockInvoiceAsPaid_RouteParams & GuestContext
export type AddApp_Query = {
}
export type AddApp_RouteParams = {
}
export type AddApp_Context = AddApp_Query & AddApp_RouteParams & AdminContext
export type GetApp_Query = {
}
export type GetApp_RouteParams = {
}
export type GetApp_Context = GetApp_Query & GetApp_RouteParams & AppContext
export type AddAppUser_Query = {
}
export type AddAppUser_RouteParams = {
}
export type AddAppUser_Context = AddAppUser_Query & AddAppUser_RouteParams & AppContext
export type AddAppInvoice_Query = {
}
export type AddAppInvoice_RouteParams = {
}
export type AddAppInvoice_Context = AddAppInvoice_Query & AddAppInvoice_RouteParams & AppContext
export type AddAppUserInvoice_Query = {
}
export type AddAppUserInvoice_RouteParams = {
}
export type AddAppUserInvoice_Context = AddAppUserInvoice_Query & AddAppUserInvoice_RouteParams & AppContext
export type GetAppUser_Query = {
}
export type GetAppUser_RouteParams = {
}
export type GetAppUser_Context = GetAppUser_Query & GetAppUser_RouteParams & AppContext
export type PayAppUserInvoice_Query = {
}
export type PayAppUserInvoice_RouteParams = {
}
export type PayAppUserInvoice_Context = PayAppUserInvoice_Query & PayAppUserInvoice_RouteParams & AppContext
export type SendAppUserToAppUserPayment_Query = {
}
export type SendAppUserToAppUserPayment_RouteParams = {
}
export type SendAppUserToAppUserPayment_Context = SendAppUserToAppUserPayment_Query & SendAppUserToAppUserPayment_RouteParams & AppContext
export type SendAppUserToAppPayment_Query = {
}
export type SendAppUserToAppPayment_RouteParams = {
}
export type SendAppUserToAppPayment_Context = SendAppUserToAppPayment_Query & SendAppUserToAppPayment_RouteParams & AppContext
export type GetAppUserLNURLInfo_Query = {
}
export type GetAppUserLNURLInfo_RouteParams = {
}
export type GetAppUserLNURLInfo_Context = GetAppUserLNURLInfo_Query & GetAppUserLNURLInfo_RouteParams & AppContext
export type SetMockAppUserBalance_Query = {
}
export type SetMockAppUserBalance_RouteParams = {
}
export type SetMockAppUserBalance_Context = SetMockAppUserBalance_Query & SetMockAppUserBalance_RouteParams & AppContext
export type SetMockAppBalance_Query = {
}
export type SetMockAppBalance_RouteParams = {
}
export type SetMockAppBalance_Context = SetMockAppBalance_Query & SetMockAppBalance_RouteParams & AppContext
export type AddUser_Query = {
}
export type AddUser_RouteParams = {
}
export type AddUser_Context = AddUser_Query & AddUser_RouteParams & GuestContext
export type AuthUser_Query = {
}
export type AuthUser_RouteParams = {
}
export type AuthUser_Context = AuthUser_Query & AuthUser_RouteParams & GuestContext
export type GetUserInfo_Query = {
}
export type GetUserInfo_RouteParams = {
}
export type GetUserInfo_Context = GetUserInfo_Query & GetUserInfo_RouteParams & UserContext
export type AddProduct_Query = {
}
export type AddProduct_RouteParams = {
}
export type AddProduct_Context = AddProduct_Query & AddProduct_RouteParams & UserContext
export type NewProductInvoice_Query = {
    id?: string
}
export type NewProductInvoice_RouteParams = {
}
export type NewProductInvoice_Context = NewProductInvoice_Query & NewProductInvoice_RouteParams & UserContext
export type GetUserOperations_Query = {
}
export type GetUserOperations_RouteParams = {
}
export type GetUserOperations_Context = GetUserOperations_Query & GetUserOperations_RouteParams & UserContext
export type NewAddress_Query = {
}
export type NewAddress_RouteParams = {
}
export type NewAddress_Context = NewAddress_Query & NewAddress_RouteParams & UserContext
export type PayAddress_Query = {
}
export type PayAddress_RouteParams = {
}
export type PayAddress_Context = PayAddress_Query & PayAddress_RouteParams & UserContext
export type NewInvoice_Query = {
}
export type NewInvoice_RouteParams = {
}
export type NewInvoice_Context = NewInvoice_Query & NewInvoice_RouteParams & UserContext
export type DecodeInvoice_Query = {
}
export type DecodeInvoice_RouteParams = {
}
export type DecodeInvoice_Context = DecodeInvoice_Query & DecodeInvoice_RouteParams & UserContext
export type PayInvoice_Query = {
}
export type PayInvoice_RouteParams = {
}
export type PayInvoice_Context = PayInvoice_Query & PayInvoice_RouteParams & UserContext
export type OpenChannel_Query = {
}
export type OpenChannel_RouteParams = {
}
export type OpenChannel_Context = OpenChannel_Query & OpenChannel_RouteParams & UserContext
export type GetLnurlWithdrawLink_Query = {
}
export type GetLnurlWithdrawLink_RouteParams = {
}
export type GetLnurlWithdrawLink_Context = GetLnurlWithdrawLink_Query & GetLnurlWithdrawLink_RouteParams & UserContext
export type GetLnurlWithdrawInfo_Query = {
    k1?: string
}
export type GetLnurlWithdrawInfo_RouteParams = {
}
export type GetLnurlWithdrawInfo_Context = GetLnurlWithdrawInfo_Query & GetLnurlWithdrawInfo_RouteParams & GuestContext
export type HandleLnurlWithdraw_Query = {
    k1?: string
    pr?: string
}
export type HandleLnurlWithdraw_RouteParams = {
}
export type HandleLnurlWithdraw_Context = HandleLnurlWithdraw_Query & HandleLnurlWithdraw_RouteParams & GuestContext
export type GetLnurlPayInfo_Query = {
    k1?: string
}
export type GetLnurlPayInfo_RouteParams = {
}
export type GetLnurlPayInfo_Context = GetLnurlPayInfo_Query & GetLnurlPayInfo_RouteParams & GuestContext
export type HandleLnurlPay_Query = {
    k1?: string
    amount?: string
}
export type HandleLnurlPay_RouteParams = {
}
export type HandleLnurlPay_Context = HandleLnurlPay_Query & HandleLnurlPay_RouteParams & GuestContext
export type GetLNURLChannelLink_Query = {
}
export type GetLNURLChannelLink_RouteParams = {
}
export type GetLNURLChannelLink_Context = GetLNURLChannelLink_Query & GetLNURLChannelLink_RouteParams & UserContext
export type ServerMethods = {
    Health?: (ctx: Health_Context) => Promise<void>
    EncryptionExchange?: (ctx: EncryptionExchange_Context, req: EncryptionExchangeRequest) => Promise<void>
    LndGetInfo?: (ctx: LndGetInfo_Context, req: LndGetInfoRequest) => Promise<LndGetInfoResponse>
    SetMockInvoiceAsPaid?: (ctx: SetMockInvoiceAsPaid_Context, req: SetMockInvoiceAsPaidRequest) => Promise<void>
    AddApp?: (ctx: AddApp_Context, req: AddAppRequest) => Promise<AddAppResponse>
    GetApp?: (ctx: GetApp_Context) => Promise<Application>
    AddAppUser?: (ctx: AddAppUser_Context, req: AddAppUserRequest) => Promise<AppUser>
    AddAppInvoice?: (ctx: AddAppInvoice_Context, req: AddAppInvoiceRequest) => Promise<NewInvoiceResponse>
    AddAppUserInvoice?: (ctx: AddAppUserInvoice_Context, req: AddAppUserInvoiceRequest) => Promise<NewInvoiceResponse>
    GetAppUser?: (ctx: GetAppUser_Context, req: GetAppUserRequest) => Promise<AppUser>
    PayAppUserInvoice?: (ctx: PayAppUserInvoice_Context, req: PayAppUserInvoiceRequest) => Promise<PayAppUserInvoiceResponse>
    SendAppUserToAppUserPayment?: (ctx: SendAppUserToAppUserPayment_Context, req: SendAppUserToAppUserPaymentRequest) => Promise<void>
    SendAppUserToAppPayment?: (ctx: SendAppUserToAppPayment_Context, req: SendAppUserToAppPaymentRequest) => Promise<void>
    GetAppUserLNURLInfo?: (ctx: GetAppUserLNURLInfo_Context, req: GetAppUserLNURLInfoRequest) => Promise<LnurlPayInfoResponse>
    SetMockAppUserBalance?: (ctx: SetMockAppUserBalance_Context, req: SetMockAppUserBalanceRequest) => Promise<void>
    SetMockAppBalance?: (ctx: SetMockAppBalance_Context, req: SetMockAppBalanceRequest) => Promise<void>
    AddUser?: (ctx: AddUser_Context, req: AddUserRequest) => Promise<AddUserResponse>
    AuthUser?: (ctx: AuthUser_Context, req: AuthUserRequest) => Promise<AuthUserResponse>
    GetUserInfo?: (ctx: GetUserInfo_Context) => Promise<UserInfo>
    AddProduct?: (ctx: AddProduct_Context, req: AddProductRequest) => Promise<Product>
    NewProductInvoice?: (ctx: NewProductInvoice_Context) => Promise<NewInvoiceResponse>
    GetUserOperations?: (ctx: GetUserOperations_Context, req: GetUserOperationsRequest) => Promise<GetUserOperationsResponse>
    NewAddress?: (ctx: NewAddress_Context, req: NewAddressRequest) => Promise<NewAddressResponse>
    PayAddress?: (ctx: PayAddress_Context, req: PayAddressRequest) => Promise<PayAddressResponse>
    NewInvoice?: (ctx: NewInvoice_Context, req: NewInvoiceRequest) => Promise<NewInvoiceResponse>
    DecodeInvoice?: (ctx: DecodeInvoice_Context, req: DecodeInvoiceRequest) => Promise<DecodeInvoiceResponse>
    PayInvoice?: (ctx: PayInvoice_Context, req: PayInvoiceRequest) => Promise<PayInvoiceResponse>
    OpenChannel?: (ctx: OpenChannel_Context, req: OpenChannelRequest) => Promise<OpenChannelResponse>
    GetLnurlWithdrawLink?: (ctx: GetLnurlWithdrawLink_Context) => Promise<LnurlLinkResponse>
    GetLnurlWithdrawInfo?: (ctx: GetLnurlWithdrawInfo_Context) => Promise<LnurlWithdrawInfoResponse>
    HandleLnurlWithdraw?: (ctx: HandleLnurlWithdraw_Context) => Promise<void>
    GetLnurlPayInfo?: (ctx: GetLnurlPayInfo_Context) => Promise<LnurlPayInfoResponse>
    HandleLnurlPay?: (ctx: HandleLnurlPay_Context) => Promise<HandleLnurlPayResponse>
    GetLNURLChannelLink?: (ctx: GetLNURLChannelLink_Context) => Promise<LnurlLinkResponse>
}

export enum AddressType {
    WITNESS_PUBKEY_HASH = 'WITNESS_PUBKEY_HASH',
    NESTED_PUBKEY_HASH = 'NESTED_PUBKEY_HASH',
    TAPROOT_PUBKEY = 'TAPROOT_PUBKEY',
}
const enumCheckAddressType = (e?: AddressType): boolean => {
    for (const v in AddressType) if (e === v) return true
    return false
}
export enum UserOperationType {
    INCOMING_TX = 'INCOMING_TX',
    OUTGOING_TX = 'OUTGOING_TX',
    INCOMING_INVOICE = 'INCOMING_INVOICE',
    OUTGOING_INVOICE = 'OUTGOING_INVOICE',
    OUTGOING_USER_TO_USER = 'OUTGOING_USER_TO_USER',
    INCOMING_USER_TO_USER = 'INCOMING_USER_TO_USER',
}
const enumCheckUserOperationType = (e?: UserOperationType): boolean => {
    for (const v in UserOperationType) if (e === v) return true
    return false
}

export type OptionsBaseMessage = {
    allOptionalsAreSet?: true
}

export type Application = {
    name: string
    id: string
    balance: number
}
export const ApplicationOptionalFields: [] = []
export type ApplicationOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    name_CustomCheck?: (v: string) => boolean
    id_CustomCheck?: (v: string) => boolean
    balance_CustomCheck?: (v: number) => boolean
}
export const ApplicationValidate = (o?: Application, opts: ApplicationOptions = {}, path: string = 'Application::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.name !== 'string') return new Error(`${path}.name: is not a string`)
    if (opts.name_CustomCheck && !opts.name_CustomCheck(o.name)) return new Error(`${path}.name: custom check failed`)

    if (typeof o.id !== 'string') return new Error(`${path}.id: is not a string`)
    if (opts.id_CustomCheck && !opts.id_CustomCheck(o.id)) return new Error(`${path}.id: custom check failed`)

    if (typeof o.balance !== 'number') return new Error(`${path}.balance: is not a number`)
    if (opts.balance_CustomCheck && !opts.balance_CustomCheck(o.balance)) return new Error(`${path}.balance: custom check failed`)

    return null
}

export type AddAppInvoiceRequest = {
    payer_identifier: string
    http_callback_url: string
    invoice_req: NewInvoiceRequest
}
export const AddAppInvoiceRequestOptionalFields: [] = []
export type AddAppInvoiceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    payer_identifier_CustomCheck?: (v: string) => boolean
    http_callback_url_CustomCheck?: (v: string) => boolean
    invoice_req_Options?: NewInvoiceRequestOptions
}
export const AddAppInvoiceRequestValidate = (o?: AddAppInvoiceRequest, opts: AddAppInvoiceRequestOptions = {}, path: string = 'AddAppInvoiceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.payer_identifier !== 'string') return new Error(`${path}.payer_identifier: is not a string`)
    if (opts.payer_identifier_CustomCheck && !opts.payer_identifier_CustomCheck(o.payer_identifier)) return new Error(`${path}.payer_identifier: custom check failed`)

    if (typeof o.http_callback_url !== 'string') return new Error(`${path}.http_callback_url: is not a string`)
    if (opts.http_callback_url_CustomCheck && !opts.http_callback_url_CustomCheck(o.http_callback_url)) return new Error(`${path}.http_callback_url: custom check failed`)

    const invoice_reqErr = NewInvoiceRequestValidate(o.invoice_req, opts.invoice_req_Options, `${path}.invoice_req`)
    if (invoice_reqErr !== null) return invoice_reqErr
    

    return null
}

export type PayAppUserInvoiceResponse = {
    preimage: string
    amount_paid: number
}
export const PayAppUserInvoiceResponseOptionalFields: [] = []
export type PayAppUserInvoiceResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    preimage_CustomCheck?: (v: string) => boolean
    amount_paid_CustomCheck?: (v: number) => boolean
}
export const PayAppUserInvoiceResponseValidate = (o?: PayAppUserInvoiceResponse, opts: PayAppUserInvoiceResponseOptions = {}, path: string = 'PayAppUserInvoiceResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.preimage !== 'string') return new Error(`${path}.preimage: is not a string`)
    if (opts.preimage_CustomCheck && !opts.preimage_CustomCheck(o.preimage)) return new Error(`${path}.preimage: custom check failed`)

    if (typeof o.amount_paid !== 'number') return new Error(`${path}.amount_paid: is not a number`)
    if (opts.amount_paid_CustomCheck && !opts.amount_paid_CustomCheck(o.amount_paid)) return new Error(`${path}.amount_paid: custom check failed`)

    return null
}

export type SetMockAppBalanceRequest = {
    amount: number
}
export const SetMockAppBalanceRequestOptionalFields: [] = []
export type SetMockAppBalanceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    amount_CustomCheck?: (v: number) => boolean
}
export const SetMockAppBalanceRequestValidate = (o?: SetMockAppBalanceRequest, opts: SetMockAppBalanceRequestOptions = {}, path: string = 'SetMockAppBalanceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type DecodeInvoiceRequest = {
    invoice: string
}
export const DecodeInvoiceRequestOptionalFields: [] = []
export type DecodeInvoiceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    invoice_CustomCheck?: (v: string) => boolean
}
export const DecodeInvoiceRequestValidate = (o?: DecodeInvoiceRequest, opts: DecodeInvoiceRequestOptions = {}, path: string = 'DecodeInvoiceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.invoice !== 'string') return new Error(`${path}.invoice: is not a string`)
    if (opts.invoice_CustomCheck && !opts.invoice_CustomCheck(o.invoice)) return new Error(`${path}.invoice: custom check failed`)

    return null
}

export type GetUserOperationsResponse = {
    latestOutgoingInvoiceOperations: UserOperations
    latestIncomingInvoiceOperations: UserOperations
    latestOutgoingTxOperations: UserOperations
    latestIncomingTxOperations: UserOperations
    latestOutgoingUserToUserPayemnts: UserOperations
    latestIncomingUserToUserPayemnts: UserOperations
}
export const GetUserOperationsResponseOptionalFields: [] = []
export type GetUserOperationsResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    latestOutgoingInvoiceOperations_Options?: UserOperationsOptions
    latestIncomingInvoiceOperations_Options?: UserOperationsOptions
    latestOutgoingTxOperations_Options?: UserOperationsOptions
    latestIncomingTxOperations_Options?: UserOperationsOptions
    latestOutgoingUserToUserPayemnts_Options?: UserOperationsOptions
    latestIncomingUserToUserPayemnts_Options?: UserOperationsOptions
}
export const GetUserOperationsResponseValidate = (o?: GetUserOperationsResponse, opts: GetUserOperationsResponseOptions = {}, path: string = 'GetUserOperationsResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    const latestOutgoingInvoiceOperationsErr = UserOperationsValidate(o.latestOutgoingInvoiceOperations, opts.latestOutgoingInvoiceOperations_Options, `${path}.latestOutgoingInvoiceOperations`)
    if (latestOutgoingInvoiceOperationsErr !== null) return latestOutgoingInvoiceOperationsErr
    

    const latestIncomingInvoiceOperationsErr = UserOperationsValidate(o.latestIncomingInvoiceOperations, opts.latestIncomingInvoiceOperations_Options, `${path}.latestIncomingInvoiceOperations`)
    if (latestIncomingInvoiceOperationsErr !== null) return latestIncomingInvoiceOperationsErr
    

    const latestOutgoingTxOperationsErr = UserOperationsValidate(o.latestOutgoingTxOperations, opts.latestOutgoingTxOperations_Options, `${path}.latestOutgoingTxOperations`)
    if (latestOutgoingTxOperationsErr !== null) return latestOutgoingTxOperationsErr
    

    const latestIncomingTxOperationsErr = UserOperationsValidate(o.latestIncomingTxOperations, opts.latestIncomingTxOperations_Options, `${path}.latestIncomingTxOperations`)
    if (latestIncomingTxOperationsErr !== null) return latestIncomingTxOperationsErr
    

    const latestOutgoingUserToUserPayemntsErr = UserOperationsValidate(o.latestOutgoingUserToUserPayemnts, opts.latestOutgoingUserToUserPayemnts_Options, `${path}.latestOutgoingUserToUserPayemnts`)
    if (latestOutgoingUserToUserPayemntsErr !== null) return latestOutgoingUserToUserPayemntsErr
    

    const latestIncomingUserToUserPayemntsErr = UserOperationsValidate(o.latestIncomingUserToUserPayemnts, opts.latestIncomingUserToUserPayemnts_Options, `${path}.latestIncomingUserToUserPayemnts`)
    if (latestIncomingUserToUserPayemntsErr !== null) return latestIncomingUserToUserPayemntsErr
    

    return null
}

export type SendAppUserToAppUserPaymentRequest = {
    from_user_identifier: string
    to_user_identifier: string
    amount: number
}
export const SendAppUserToAppUserPaymentRequestOptionalFields: [] = []
export type SendAppUserToAppUserPaymentRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    from_user_identifier_CustomCheck?: (v: string) => boolean
    to_user_identifier_CustomCheck?: (v: string) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const SendAppUserToAppUserPaymentRequestValidate = (o?: SendAppUserToAppUserPaymentRequest, opts: SendAppUserToAppUserPaymentRequestOptions = {}, path: string = 'SendAppUserToAppUserPaymentRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.from_user_identifier !== 'string') return new Error(`${path}.from_user_identifier: is not a string`)
    if (opts.from_user_identifier_CustomCheck && !opts.from_user_identifier_CustomCheck(o.from_user_identifier)) return new Error(`${path}.from_user_identifier: custom check failed`)

    if (typeof o.to_user_identifier !== 'string') return new Error(`${path}.to_user_identifier: is not a string`)
    if (opts.to_user_identifier_CustomCheck && !opts.to_user_identifier_CustomCheck(o.to_user_identifier)) return new Error(`${path}.to_user_identifier: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type DecodeInvoiceResponse = {
    amount: number
}
export const DecodeInvoiceResponseOptionalFields: [] = []
export type DecodeInvoiceResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    amount_CustomCheck?: (v: number) => boolean
}
export const DecodeInvoiceResponseValidate = (o?: DecodeInvoiceResponse, opts: DecodeInvoiceResponseOptions = {}, path: string = 'DecodeInvoiceResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type OpenChannelResponse = {
    channelId: string
}
export const OpenChannelResponseOptionalFields: [] = []
export type OpenChannelResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    channelId_CustomCheck?: (v: string) => boolean
}
export const OpenChannelResponseValidate = (o?: OpenChannelResponse, opts: OpenChannelResponseOptions = {}, path: string = 'OpenChannelResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.channelId !== 'string') return new Error(`${path}.channelId: is not a string`)
    if (opts.channelId_CustomCheck && !opts.channelId_CustomCheck(o.channelId)) return new Error(`${path}.channelId: custom check failed`)

    return null
}

export type LnurlPayInfoResponse = {
    tag: string
    callback: string
    maxSendable: number
    minSendable: number
    metadata: string
}
export const LnurlPayInfoResponseOptionalFields: [] = []
export type LnurlPayInfoResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    tag_CustomCheck?: (v: string) => boolean
    callback_CustomCheck?: (v: string) => boolean
    maxSendable_CustomCheck?: (v: number) => boolean
    minSendable_CustomCheck?: (v: number) => boolean
    metadata_CustomCheck?: (v: string) => boolean
}
export const LnurlPayInfoResponseValidate = (o?: LnurlPayInfoResponse, opts: LnurlPayInfoResponseOptions = {}, path: string = 'LnurlPayInfoResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.tag !== 'string') return new Error(`${path}.tag: is not a string`)
    if (opts.tag_CustomCheck && !opts.tag_CustomCheck(o.tag)) return new Error(`${path}.tag: custom check failed`)

    if (typeof o.callback !== 'string') return new Error(`${path}.callback: is not a string`)
    if (opts.callback_CustomCheck && !opts.callback_CustomCheck(o.callback)) return new Error(`${path}.callback: custom check failed`)

    if (typeof o.maxSendable !== 'number') return new Error(`${path}.maxSendable: is not a number`)
    if (opts.maxSendable_CustomCheck && !opts.maxSendable_CustomCheck(o.maxSendable)) return new Error(`${path}.maxSendable: custom check failed`)

    if (typeof o.minSendable !== 'number') return new Error(`${path}.minSendable: is not a number`)
    if (opts.minSendable_CustomCheck && !opts.minSendable_CustomCheck(o.minSendable)) return new Error(`${path}.minSendable: custom check failed`)

    if (typeof o.metadata !== 'string') return new Error(`${path}.metadata: is not a string`)
    if (opts.metadata_CustomCheck && !opts.metadata_CustomCheck(o.metadata)) return new Error(`${path}.metadata: custom check failed`)

    return null
}

export type HandleLnurlPayResponse = {
    pr: string
    routes: Empty[]
}
export const HandleLnurlPayResponseOptionalFields: [] = []
export type HandleLnurlPayResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    pr_CustomCheck?: (v: string) => boolean
    routes_ItemOptions?: EmptyOptions
    routes_CustomCheck?: (v: Empty[]) => boolean
}
export const HandleLnurlPayResponseValidate = (o?: HandleLnurlPayResponse, opts: HandleLnurlPayResponseOptions = {}, path: string = 'HandleLnurlPayResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.pr !== 'string') return new Error(`${path}.pr: is not a string`)
    if (opts.pr_CustomCheck && !opts.pr_CustomCheck(o.pr)) return new Error(`${path}.pr: custom check failed`)

    if (!Array.isArray(o.routes)) return new Error(`${path}.routes: is not an array`)
    for (let index = 0; index < o.routes.length; index++) {
        const routesErr = EmptyValidate(o.routes[index], opts.routes_ItemOptions, `${path}.routes[${index}]`)
        if (routesErr !== null) return routesErr
    }
    if (opts.routes_CustomCheck && !opts.routes_CustomCheck(o.routes)) return new Error(`${path}.routes: custom check failed`)

    return null
}

export type AddUserRequest = {
    callbackUrl: string
    name: string
    secret: string
}
export const AddUserRequestOptionalFields: [] = []
export type AddUserRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    callbackUrl_CustomCheck?: (v: string) => boolean
    name_CustomCheck?: (v: string) => boolean
    secret_CustomCheck?: (v: string) => boolean
}
export const AddUserRequestValidate = (o?: AddUserRequest, opts: AddUserRequestOptions = {}, path: string = 'AddUserRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.callbackUrl !== 'string') return new Error(`${path}.callbackUrl: is not a string`)
    if (opts.callbackUrl_CustomCheck && !opts.callbackUrl_CustomCheck(o.callbackUrl)) return new Error(`${path}.callbackUrl: custom check failed`)

    if (typeof o.name !== 'string') return new Error(`${path}.name: is not a string`)
    if (opts.name_CustomCheck && !opts.name_CustomCheck(o.name)) return new Error(`${path}.name: custom check failed`)

    if (typeof o.secret !== 'string') return new Error(`${path}.secret: is not a string`)
    if (opts.secret_CustomCheck && !opts.secret_CustomCheck(o.secret)) return new Error(`${path}.secret: custom check failed`)

    return null
}

export type LndGetInfoResponse = {
    alias: string
}
export const LndGetInfoResponseOptionalFields: [] = []
export type LndGetInfoResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    alias_CustomCheck?: (v: string) => boolean
}
export const LndGetInfoResponseValidate = (o?: LndGetInfoResponse, opts: LndGetInfoResponseOptions = {}, path: string = 'LndGetInfoResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.alias !== 'string') return new Error(`${path}.alias: is not a string`)
    if (opts.alias_CustomCheck && !opts.alias_CustomCheck(o.alias)) return new Error(`${path}.alias: custom check failed`)

    return null
}

export type AddAppUserRequest = {
    identifier: string
    fail_if_exists: boolean
    balance: number
}
export const AddAppUserRequestOptionalFields: [] = []
export type AddAppUserRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    identifier_CustomCheck?: (v: string) => boolean
    fail_if_exists_CustomCheck?: (v: boolean) => boolean
    balance_CustomCheck?: (v: number) => boolean
}
export const AddAppUserRequestValidate = (o?: AddAppUserRequest, opts: AddAppUserRequestOptions = {}, path: string = 'AddAppUserRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.identifier !== 'string') return new Error(`${path}.identifier: is not a string`)
    if (opts.identifier_CustomCheck && !opts.identifier_CustomCheck(o.identifier)) return new Error(`${path}.identifier: custom check failed`)

    if (typeof o.fail_if_exists !== 'boolean') return new Error(`${path}.fail_if_exists: is not a boolean`)
    if (opts.fail_if_exists_CustomCheck && !opts.fail_if_exists_CustomCheck(o.fail_if_exists)) return new Error(`${path}.fail_if_exists: custom check failed`)

    if (typeof o.balance !== 'number') return new Error(`${path}.balance: is not a number`)
    if (opts.balance_CustomCheck && !opts.balance_CustomCheck(o.balance)) return new Error(`${path}.balance: custom check failed`)

    return null
}

export type AppUser = {
    identifier: string
    info: UserInfo
    max_withdrawable: number
}
export const AppUserOptionalFields: [] = []
export type AppUserOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    identifier_CustomCheck?: (v: string) => boolean
    info_Options?: UserInfoOptions
    max_withdrawable_CustomCheck?: (v: number) => boolean
}
export const AppUserValidate = (o?: AppUser, opts: AppUserOptions = {}, path: string = 'AppUser::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.identifier !== 'string') return new Error(`${path}.identifier: is not a string`)
    if (opts.identifier_CustomCheck && !opts.identifier_CustomCheck(o.identifier)) return new Error(`${path}.identifier: custom check failed`)

    const infoErr = UserInfoValidate(o.info, opts.info_Options, `${path}.info`)
    if (infoErr !== null) return infoErr
    

    if (typeof o.max_withdrawable !== 'number') return new Error(`${path}.max_withdrawable: is not a number`)
    if (opts.max_withdrawable_CustomCheck && !opts.max_withdrawable_CustomCheck(o.max_withdrawable)) return new Error(`${path}.max_withdrawable: custom check failed`)

    return null
}

export type PayAddressRequest = {
    address: string
    amoutSats: number
    targetConf: number
}
export const PayAddressRequestOptionalFields: [] = []
export type PayAddressRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    address_CustomCheck?: (v: string) => boolean
    amoutSats_CustomCheck?: (v: number) => boolean
    targetConf_CustomCheck?: (v: number) => boolean
}
export const PayAddressRequestValidate = (o?: PayAddressRequest, opts: PayAddressRequestOptions = {}, path: string = 'PayAddressRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.address !== 'string') return new Error(`${path}.address: is not a string`)
    if (opts.address_CustomCheck && !opts.address_CustomCheck(o.address)) return new Error(`${path}.address: custom check failed`)

    if (typeof o.amoutSats !== 'number') return new Error(`${path}.amoutSats: is not a number`)
    if (opts.amoutSats_CustomCheck && !opts.amoutSats_CustomCheck(o.amoutSats)) return new Error(`${path}.amoutSats: custom check failed`)

    if (typeof o.targetConf !== 'number') return new Error(`${path}.targetConf: is not a number`)
    if (opts.targetConf_CustomCheck && !opts.targetConf_CustomCheck(o.targetConf)) return new Error(`${path}.targetConf: custom check failed`)

    return null
}

export type LnurlLinkResponse = {
    lnurl: string
    k1: string
}
export const LnurlLinkResponseOptionalFields: [] = []
export type LnurlLinkResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    lnurl_CustomCheck?: (v: string) => boolean
    k1_CustomCheck?: (v: string) => boolean
}
export const LnurlLinkResponseValidate = (o?: LnurlLinkResponse, opts: LnurlLinkResponseOptions = {}, path: string = 'LnurlLinkResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.lnurl !== 'string') return new Error(`${path}.lnurl: is not a string`)
    if (opts.lnurl_CustomCheck && !opts.lnurl_CustomCheck(o.lnurl)) return new Error(`${path}.lnurl: custom check failed`)

    if (typeof o.k1 !== 'string') return new Error(`${path}.k1: is not a string`)
    if (opts.k1_CustomCheck && !opts.k1_CustomCheck(o.k1)) return new Error(`${path}.k1: custom check failed`)

    return null
}

export type AddUserResponse = {
    userId: string
    authToken: string
}
export const AddUserResponseOptionalFields: [] = []
export type AddUserResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    userId_CustomCheck?: (v: string) => boolean
    authToken_CustomCheck?: (v: string) => boolean
}
export const AddUserResponseValidate = (o?: AddUserResponse, opts: AddUserResponseOptions = {}, path: string = 'AddUserResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.userId !== 'string') return new Error(`${path}.userId: is not a string`)
    if (opts.userId_CustomCheck && !opts.userId_CustomCheck(o.userId)) return new Error(`${path}.userId: custom check failed`)

    if (typeof o.authToken !== 'string') return new Error(`${path}.authToken: is not a string`)
    if (opts.authToken_CustomCheck && !opts.authToken_CustomCheck(o.authToken)) return new Error(`${path}.authToken: custom check failed`)

    return null
}

export type Product = {
    id: string
    name: string
    price_sats: number
}
export const ProductOptionalFields: [] = []
export type ProductOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    id_CustomCheck?: (v: string) => boolean
    name_CustomCheck?: (v: string) => boolean
    price_sats_CustomCheck?: (v: number) => boolean
}
export const ProductValidate = (o?: Product, opts: ProductOptions = {}, path: string = 'Product::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.id !== 'string') return new Error(`${path}.id: is not a string`)
    if (opts.id_CustomCheck && !opts.id_CustomCheck(o.id)) return new Error(`${path}.id: custom check failed`)

    if (typeof o.name !== 'string') return new Error(`${path}.name: is not a string`)
    if (opts.name_CustomCheck && !opts.name_CustomCheck(o.name)) return new Error(`${path}.name: custom check failed`)

    if (typeof o.price_sats !== 'number') return new Error(`${path}.price_sats: is not a number`)
    if (opts.price_sats_CustomCheck && !opts.price_sats_CustomCheck(o.price_sats)) return new Error(`${path}.price_sats: custom check failed`)

    return null
}

export type AuthUserResponse = {
    userId: string
    authToken: string
}
export const AuthUserResponseOptionalFields: [] = []
export type AuthUserResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    userId_CustomCheck?: (v: string) => boolean
    authToken_CustomCheck?: (v: string) => boolean
}
export const AuthUserResponseValidate = (o?: AuthUserResponse, opts: AuthUserResponseOptions = {}, path: string = 'AuthUserResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.userId !== 'string') return new Error(`${path}.userId: is not a string`)
    if (opts.userId_CustomCheck && !opts.userId_CustomCheck(o.userId)) return new Error(`${path}.userId: custom check failed`)

    if (typeof o.authToken !== 'string') return new Error(`${path}.authToken: is not a string`)
    if (opts.authToken_CustomCheck && !opts.authToken_CustomCheck(o.authToken)) return new Error(`${path}.authToken: custom check failed`)

    return null
}

export type SetMockInvoiceAsPaidRequest = {
    invoice: string
    amount: number
}
export const SetMockInvoiceAsPaidRequestOptionalFields: [] = []
export type SetMockInvoiceAsPaidRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    invoice_CustomCheck?: (v: string) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const SetMockInvoiceAsPaidRequestValidate = (o?: SetMockInvoiceAsPaidRequest, opts: SetMockInvoiceAsPaidRequestOptions = {}, path: string = 'SetMockInvoiceAsPaidRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.invoice !== 'string') return new Error(`${path}.invoice: is not a string`)
    if (opts.invoice_CustomCheck && !opts.invoice_CustomCheck(o.invoice)) return new Error(`${path}.invoice: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type AddAppRequest = {
    name: string
}
export const AddAppRequestOptionalFields: [] = []
export type AddAppRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    name_CustomCheck?: (v: string) => boolean
}
export const AddAppRequestValidate = (o?: AddAppRequest, opts: AddAppRequestOptions = {}, path: string = 'AddAppRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.name !== 'string') return new Error(`${path}.name: is not a string`)
    if (opts.name_CustomCheck && !opts.name_CustomCheck(o.name)) return new Error(`${path}.name: custom check failed`)

    return null
}

export type PayAppUserInvoiceRequest = {
    user_identifier: string
    invoice: string
    amount: number
}
export const PayAppUserInvoiceRequestOptionalFields: [] = []
export type PayAppUserInvoiceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    user_identifier_CustomCheck?: (v: string) => boolean
    invoice_CustomCheck?: (v: string) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const PayAppUserInvoiceRequestValidate = (o?: PayAppUserInvoiceRequest, opts: PayAppUserInvoiceRequestOptions = {}, path: string = 'PayAppUserInvoiceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.user_identifier !== 'string') return new Error(`${path}.user_identifier: is not a string`)
    if (opts.user_identifier_CustomCheck && !opts.user_identifier_CustomCheck(o.user_identifier)) return new Error(`${path}.user_identifier: custom check failed`)

    if (typeof o.invoice !== 'string') return new Error(`${path}.invoice: is not a string`)
    if (opts.invoice_CustomCheck && !opts.invoice_CustomCheck(o.invoice)) return new Error(`${path}.invoice: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type SendAppUserToAppPaymentRequest = {
    from_user_identifier: string
    amount: number
}
export const SendAppUserToAppPaymentRequestOptionalFields: [] = []
export type SendAppUserToAppPaymentRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    from_user_identifier_CustomCheck?: (v: string) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const SendAppUserToAppPaymentRequestValidate = (o?: SendAppUserToAppPaymentRequest, opts: SendAppUserToAppPaymentRequestOptions = {}, path: string = 'SendAppUserToAppPaymentRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.from_user_identifier !== 'string') return new Error(`${path}.from_user_identifier: is not a string`)
    if (opts.from_user_identifier_CustomCheck && !opts.from_user_identifier_CustomCheck(o.from_user_identifier)) return new Error(`${path}.from_user_identifier: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type PayAddressResponse = {
    txId: string
}
export const PayAddressResponseOptionalFields: [] = []
export type PayAddressResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    txId_CustomCheck?: (v: string) => boolean
}
export const PayAddressResponseValidate = (o?: PayAddressResponse, opts: PayAddressResponseOptions = {}, path: string = 'PayAddressResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.txId !== 'string') return new Error(`${path}.txId: is not a string`)
    if (opts.txId_CustomCheck && !opts.txId_CustomCheck(o.txId)) return new Error(`${path}.txId: custom check failed`)

    return null
}

export type PayInvoiceResponse = {
    preimage: string
    amount_paid: number
}
export const PayInvoiceResponseOptionalFields: [] = []
export type PayInvoiceResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    preimage_CustomCheck?: (v: string) => boolean
    amount_paid_CustomCheck?: (v: number) => boolean
}
export const PayInvoiceResponseValidate = (o?: PayInvoiceResponse, opts: PayInvoiceResponseOptions = {}, path: string = 'PayInvoiceResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.preimage !== 'string') return new Error(`${path}.preimage: is not a string`)
    if (opts.preimage_CustomCheck && !opts.preimage_CustomCheck(o.preimage)) return new Error(`${path}.preimage: custom check failed`)

    if (typeof o.amount_paid !== 'number') return new Error(`${path}.amount_paid: is not a number`)
    if (opts.amount_paid_CustomCheck && !opts.amount_paid_CustomCheck(o.amount_paid)) return new Error(`${path}.amount_paid: custom check failed`)

    return null
}

export type AuthUserRequest = {
    name: string
    secret: string
}
export const AuthUserRequestOptionalFields: [] = []
export type AuthUserRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    name_CustomCheck?: (v: string) => boolean
    secret_CustomCheck?: (v: string) => boolean
}
export const AuthUserRequestValidate = (o?: AuthUserRequest, opts: AuthUserRequestOptions = {}, path: string = 'AuthUserRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.name !== 'string') return new Error(`${path}.name: is not a string`)
    if (opts.name_CustomCheck && !opts.name_CustomCheck(o.name)) return new Error(`${path}.name: custom check failed`)

    if (typeof o.secret !== 'string') return new Error(`${path}.secret: is not a string`)
    if (opts.secret_CustomCheck && !opts.secret_CustomCheck(o.secret)) return new Error(`${path}.secret: custom check failed`)

    return null
}

export type GetAppUserRequest = {
    user_identifier: string
}
export const GetAppUserRequestOptionalFields: [] = []
export type GetAppUserRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    user_identifier_CustomCheck?: (v: string) => boolean
}
export const GetAppUserRequestValidate = (o?: GetAppUserRequest, opts: GetAppUserRequestOptions = {}, path: string = 'GetAppUserRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.user_identifier !== 'string') return new Error(`${path}.user_identifier: is not a string`)
    if (opts.user_identifier_CustomCheck && !opts.user_identifier_CustomCheck(o.user_identifier)) return new Error(`${path}.user_identifier: custom check failed`)

    return null
}

export type NewInvoiceRequest = {
    amountSats: number
    memo: string
}
export const NewInvoiceRequestOptionalFields: [] = []
export type NewInvoiceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    amountSats_CustomCheck?: (v: number) => boolean
    memo_CustomCheck?: (v: string) => boolean
}
export const NewInvoiceRequestValidate = (o?: NewInvoiceRequest, opts: NewInvoiceRequestOptions = {}, path: string = 'NewInvoiceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.amountSats !== 'number') return new Error(`${path}.amountSats: is not a number`)
    if (opts.amountSats_CustomCheck && !opts.amountSats_CustomCheck(o.amountSats)) return new Error(`${path}.amountSats: custom check failed`)

    if (typeof o.memo !== 'string') return new Error(`${path}.memo: is not a string`)
    if (opts.memo_CustomCheck && !opts.memo_CustomCheck(o.memo)) return new Error(`${path}.memo: custom check failed`)

    return null
}

export type Empty = {
}
export const EmptyOptionalFields: [] = []
export type EmptyOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
}
export const EmptyValidate = (o?: Empty, opts: EmptyOptions = {}, path: string = 'Empty::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    return null
}

export type GetAppUserLNURLInfoRequest = {
    user_identifier: string
}
export const GetAppUserLNURLInfoRequestOptionalFields: [] = []
export type GetAppUserLNURLInfoRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    user_identifier_CustomCheck?: (v: string) => boolean
}
export const GetAppUserLNURLInfoRequestValidate = (o?: GetAppUserLNURLInfoRequest, opts: GetAppUserLNURLInfoRequestOptions = {}, path: string = 'GetAppUserLNURLInfoRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.user_identifier !== 'string') return new Error(`${path}.user_identifier: is not a string`)
    if (opts.user_identifier_CustomCheck && !opts.user_identifier_CustomCheck(o.user_identifier)) return new Error(`${path}.user_identifier: custom check failed`)

    return null
}

export type SetMockAppUserBalanceRequest = {
    user_identifier: string
    amount: number
}
export const SetMockAppUserBalanceRequestOptionalFields: [] = []
export type SetMockAppUserBalanceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    user_identifier_CustomCheck?: (v: string) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const SetMockAppUserBalanceRequestValidate = (o?: SetMockAppUserBalanceRequest, opts: SetMockAppUserBalanceRequestOptions = {}, path: string = 'SetMockAppUserBalanceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.user_identifier !== 'string') return new Error(`${path}.user_identifier: is not a string`)
    if (opts.user_identifier_CustomCheck && !opts.user_identifier_CustomCheck(o.user_identifier)) return new Error(`${path}.user_identifier: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type LnurlWithdrawInfoResponse = {
    tag: string
    callback: string
    k1: string
    defaultDescription: string
    minWithdrawable: number
    maxWithdrawable: number
    balanceCheck: string
    payLink: string
}
export const LnurlWithdrawInfoResponseOptionalFields: [] = []
export type LnurlWithdrawInfoResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    tag_CustomCheck?: (v: string) => boolean
    callback_CustomCheck?: (v: string) => boolean
    k1_CustomCheck?: (v: string) => boolean
    defaultDescription_CustomCheck?: (v: string) => boolean
    minWithdrawable_CustomCheck?: (v: number) => boolean
    maxWithdrawable_CustomCheck?: (v: number) => boolean
    balanceCheck_CustomCheck?: (v: string) => boolean
    payLink_CustomCheck?: (v: string) => boolean
}
export const LnurlWithdrawInfoResponseValidate = (o?: LnurlWithdrawInfoResponse, opts: LnurlWithdrawInfoResponseOptions = {}, path: string = 'LnurlWithdrawInfoResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.tag !== 'string') return new Error(`${path}.tag: is not a string`)
    if (opts.tag_CustomCheck && !opts.tag_CustomCheck(o.tag)) return new Error(`${path}.tag: custom check failed`)

    if (typeof o.callback !== 'string') return new Error(`${path}.callback: is not a string`)
    if (opts.callback_CustomCheck && !opts.callback_CustomCheck(o.callback)) return new Error(`${path}.callback: custom check failed`)

    if (typeof o.k1 !== 'string') return new Error(`${path}.k1: is not a string`)
    if (opts.k1_CustomCheck && !opts.k1_CustomCheck(o.k1)) return new Error(`${path}.k1: custom check failed`)

    if (typeof o.defaultDescription !== 'string') return new Error(`${path}.defaultDescription: is not a string`)
    if (opts.defaultDescription_CustomCheck && !opts.defaultDescription_CustomCheck(o.defaultDescription)) return new Error(`${path}.defaultDescription: custom check failed`)

    if (typeof o.minWithdrawable !== 'number') return new Error(`${path}.minWithdrawable: is not a number`)
    if (opts.minWithdrawable_CustomCheck && !opts.minWithdrawable_CustomCheck(o.minWithdrawable)) return new Error(`${path}.minWithdrawable: custom check failed`)

    if (typeof o.maxWithdrawable !== 'number') return new Error(`${path}.maxWithdrawable: is not a number`)
    if (opts.maxWithdrawable_CustomCheck && !opts.maxWithdrawable_CustomCheck(o.maxWithdrawable)) return new Error(`${path}.maxWithdrawable: custom check failed`)

    if (typeof o.balanceCheck !== 'string') return new Error(`${path}.balanceCheck: is not a string`)
    if (opts.balanceCheck_CustomCheck && !opts.balanceCheck_CustomCheck(o.balanceCheck)) return new Error(`${path}.balanceCheck: custom check failed`)

    if (typeof o.payLink !== 'string') return new Error(`${path}.payLink: is not a string`)
    if (opts.payLink_CustomCheck && !opts.payLink_CustomCheck(o.payLink)) return new Error(`${path}.payLink: custom check failed`)

    return null
}

export type GetUserOperationsRequest = {
    latestIncomingInvoice: number
    latestOutgoingInvoice: number
    latestIncomingTx: number
    latestOutgoingTx: number
    latestIncomingUserToUserPayment: number
    latestOutgoingUserToUserPayment: number
}
export const GetUserOperationsRequestOptionalFields: [] = []
export type GetUserOperationsRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    latestIncomingInvoice_CustomCheck?: (v: number) => boolean
    latestOutgoingInvoice_CustomCheck?: (v: number) => boolean
    latestIncomingTx_CustomCheck?: (v: number) => boolean
    latestOutgoingTx_CustomCheck?: (v: number) => boolean
    latestIncomingUserToUserPayment_CustomCheck?: (v: number) => boolean
    latestOutgoingUserToUserPayment_CustomCheck?: (v: number) => boolean
}
export const GetUserOperationsRequestValidate = (o?: GetUserOperationsRequest, opts: GetUserOperationsRequestOptions = {}, path: string = 'GetUserOperationsRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.latestIncomingInvoice !== 'number') return new Error(`${path}.latestIncomingInvoice: is not a number`)
    if (opts.latestIncomingInvoice_CustomCheck && !opts.latestIncomingInvoice_CustomCheck(o.latestIncomingInvoice)) return new Error(`${path}.latestIncomingInvoice: custom check failed`)

    if (typeof o.latestOutgoingInvoice !== 'number') return new Error(`${path}.latestOutgoingInvoice: is not a number`)
    if (opts.latestOutgoingInvoice_CustomCheck && !opts.latestOutgoingInvoice_CustomCheck(o.latestOutgoingInvoice)) return new Error(`${path}.latestOutgoingInvoice: custom check failed`)

    if (typeof o.latestIncomingTx !== 'number') return new Error(`${path}.latestIncomingTx: is not a number`)
    if (opts.latestIncomingTx_CustomCheck && !opts.latestIncomingTx_CustomCheck(o.latestIncomingTx)) return new Error(`${path}.latestIncomingTx: custom check failed`)

    if (typeof o.latestOutgoingTx !== 'number') return new Error(`${path}.latestOutgoingTx: is not a number`)
    if (opts.latestOutgoingTx_CustomCheck && !opts.latestOutgoingTx_CustomCheck(o.latestOutgoingTx)) return new Error(`${path}.latestOutgoingTx: custom check failed`)

    if (typeof o.latestIncomingUserToUserPayment !== 'number') return new Error(`${path}.latestIncomingUserToUserPayment: is not a number`)
    if (opts.latestIncomingUserToUserPayment_CustomCheck && !opts.latestIncomingUserToUserPayment_CustomCheck(o.latestIncomingUserToUserPayment)) return new Error(`${path}.latestIncomingUserToUserPayment: custom check failed`)

    if (typeof o.latestOutgoingUserToUserPayment !== 'number') return new Error(`${path}.latestOutgoingUserToUserPayment: is not a number`)
    if (opts.latestOutgoingUserToUserPayment_CustomCheck && !opts.latestOutgoingUserToUserPayment_CustomCheck(o.latestOutgoingUserToUserPayment)) return new Error(`${path}.latestOutgoingUserToUserPayment: custom check failed`)

    return null
}

export type UserOperation = {
    paidAtUnix: number
    type: UserOperationType
    inbound: boolean
    amount: number
}
export const UserOperationOptionalFields: [] = []
export type UserOperationOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    paidAtUnix_CustomCheck?: (v: number) => boolean
    type_CustomCheck?: (v: UserOperationType) => boolean
    inbound_CustomCheck?: (v: boolean) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const UserOperationValidate = (o?: UserOperation, opts: UserOperationOptions = {}, path: string = 'UserOperation::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.paidAtUnix !== 'number') return new Error(`${path}.paidAtUnix: is not a number`)
    if (opts.paidAtUnix_CustomCheck && !opts.paidAtUnix_CustomCheck(o.paidAtUnix)) return new Error(`${path}.paidAtUnix: custom check failed`)

    if (!enumCheckUserOperationType(o.type)) return new Error(`${path}.type: is not a valid UserOperationType`)
    if (opts.type_CustomCheck && !opts.type_CustomCheck(o.type)) return new Error(`${path}.type: custom check failed`)

    if (typeof o.inbound !== 'boolean') return new Error(`${path}.inbound: is not a boolean`)
    if (opts.inbound_CustomCheck && !opts.inbound_CustomCheck(o.inbound)) return new Error(`${path}.inbound: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type AddProductRequest = {
    name: string
    price_sats: number
}
export const AddProductRequestOptionalFields: [] = []
export type AddProductRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    name_CustomCheck?: (v: string) => boolean
    price_sats_CustomCheck?: (v: number) => boolean
}
export const AddProductRequestValidate = (o?: AddProductRequest, opts: AddProductRequestOptions = {}, path: string = 'AddProductRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.name !== 'string') return new Error(`${path}.name: is not a string`)
    if (opts.name_CustomCheck && !opts.name_CustomCheck(o.name)) return new Error(`${path}.name: custom check failed`)

    if (typeof o.price_sats !== 'number') return new Error(`${path}.price_sats: is not a number`)
    if (opts.price_sats_CustomCheck && !opts.price_sats_CustomCheck(o.price_sats)) return new Error(`${path}.price_sats: custom check failed`)

    return null
}

export type EncryptionExchangeRequest = {
    publicKey: string
    deviceId: string
}
export const EncryptionExchangeRequestOptionalFields: [] = []
export type EncryptionExchangeRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    publicKey_CustomCheck?: (v: string) => boolean
    deviceId_CustomCheck?: (v: string) => boolean
}
export const EncryptionExchangeRequestValidate = (o?: EncryptionExchangeRequest, opts: EncryptionExchangeRequestOptions = {}, path: string = 'EncryptionExchangeRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.publicKey !== 'string') return new Error(`${path}.publicKey: is not a string`)
    if (opts.publicKey_CustomCheck && !opts.publicKey_CustomCheck(o.publicKey)) return new Error(`${path}.publicKey: custom check failed`)

    if (typeof o.deviceId !== 'string') return new Error(`${path}.deviceId: is not a string`)
    if (opts.deviceId_CustomCheck && !opts.deviceId_CustomCheck(o.deviceId)) return new Error(`${path}.deviceId: custom check failed`)

    return null
}

export type LndGetInfoRequest = {
    nodeId: number
}
export const LndGetInfoRequestOptionalFields: [] = []
export type LndGetInfoRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    nodeId_CustomCheck?: (v: number) => boolean
}
export const LndGetInfoRequestValidate = (o?: LndGetInfoRequest, opts: LndGetInfoRequestOptions = {}, path: string = 'LndGetInfoRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.nodeId !== 'number') return new Error(`${path}.nodeId: is not a number`)
    if (opts.nodeId_CustomCheck && !opts.nodeId_CustomCheck(o.nodeId)) return new Error(`${path}.nodeId: custom check failed`)

    return null
}

export type NewAddressResponse = {
    address: string
}
export const NewAddressResponseOptionalFields: [] = []
export type NewAddressResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    address_CustomCheck?: (v: string) => boolean
}
export const NewAddressResponseValidate = (o?: NewAddressResponse, opts: NewAddressResponseOptions = {}, path: string = 'NewAddressResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.address !== 'string') return new Error(`${path}.address: is not a string`)
    if (opts.address_CustomCheck && !opts.address_CustomCheck(o.address)) return new Error(`${path}.address: custom check failed`)

    return null
}

export type PayInvoiceRequest = {
    invoice: string
    amount: number
}
export const PayInvoiceRequestOptionalFields: [] = []
export type PayInvoiceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    invoice_CustomCheck?: (v: string) => boolean
    amount_CustomCheck?: (v: number) => boolean
}
export const PayInvoiceRequestValidate = (o?: PayInvoiceRequest, opts: PayInvoiceRequestOptions = {}, path: string = 'PayInvoiceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.invoice !== 'string') return new Error(`${path}.invoice: is not a string`)
    if (opts.invoice_CustomCheck && !opts.invoice_CustomCheck(o.invoice)) return new Error(`${path}.invoice: custom check failed`)

    if (typeof o.amount !== 'number') return new Error(`${path}.amount: is not a number`)
    if (opts.amount_CustomCheck && !opts.amount_CustomCheck(o.amount)) return new Error(`${path}.amount: custom check failed`)

    return null
}

export type GetProductBuyLinkResponse = {
    link: string
}
export const GetProductBuyLinkResponseOptionalFields: [] = []
export type GetProductBuyLinkResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    link_CustomCheck?: (v: string) => boolean
}
export const GetProductBuyLinkResponseValidate = (o?: GetProductBuyLinkResponse, opts: GetProductBuyLinkResponseOptions = {}, path: string = 'GetProductBuyLinkResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.link !== 'string') return new Error(`${path}.link: is not a string`)
    if (opts.link_CustomCheck && !opts.link_CustomCheck(o.link)) return new Error(`${path}.link: custom check failed`)

    return null
}

export type AddAppResponse = {
    app: Application
    auth_token: string
}
export const AddAppResponseOptionalFields: [] = []
export type AddAppResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    app_Options?: ApplicationOptions
    auth_token_CustomCheck?: (v: string) => boolean
}
export const AddAppResponseValidate = (o?: AddAppResponse, opts: AddAppResponseOptions = {}, path: string = 'AddAppResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    const appErr = ApplicationValidate(o.app, opts.app_Options, `${path}.app`)
    if (appErr !== null) return appErr
    

    if (typeof o.auth_token !== 'string') return new Error(`${path}.auth_token: is not a string`)
    if (opts.auth_token_CustomCheck && !opts.auth_token_CustomCheck(o.auth_token)) return new Error(`${path}.auth_token: custom check failed`)

    return null
}

export type AddAppUserInvoiceRequest = {
    receiver_identifier: string
    payer_identifier: string
    http_callback_url: string
    invoice_req: NewInvoiceRequest
}
export const AddAppUserInvoiceRequestOptionalFields: [] = []
export type AddAppUserInvoiceRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    receiver_identifier_CustomCheck?: (v: string) => boolean
    payer_identifier_CustomCheck?: (v: string) => boolean
    http_callback_url_CustomCheck?: (v: string) => boolean
    invoice_req_Options?: NewInvoiceRequestOptions
}
export const AddAppUserInvoiceRequestValidate = (o?: AddAppUserInvoiceRequest, opts: AddAppUserInvoiceRequestOptions = {}, path: string = 'AddAppUserInvoiceRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.receiver_identifier !== 'string') return new Error(`${path}.receiver_identifier: is not a string`)
    if (opts.receiver_identifier_CustomCheck && !opts.receiver_identifier_CustomCheck(o.receiver_identifier)) return new Error(`${path}.receiver_identifier: custom check failed`)

    if (typeof o.payer_identifier !== 'string') return new Error(`${path}.payer_identifier: is not a string`)
    if (opts.payer_identifier_CustomCheck && !opts.payer_identifier_CustomCheck(o.payer_identifier)) return new Error(`${path}.payer_identifier: custom check failed`)

    if (typeof o.http_callback_url !== 'string') return new Error(`${path}.http_callback_url: is not a string`)
    if (opts.http_callback_url_CustomCheck && !opts.http_callback_url_CustomCheck(o.http_callback_url)) return new Error(`${path}.http_callback_url: custom check failed`)

    const invoice_reqErr = NewInvoiceRequestValidate(o.invoice_req, opts.invoice_req_Options, `${path}.invoice_req`)
    if (invoice_reqErr !== null) return invoice_reqErr
    

    return null
}

export type NewAddressRequest = {
    addressType: AddressType
}
export const NewAddressRequestOptionalFields: [] = []
export type NewAddressRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    addressType_CustomCheck?: (v: AddressType) => boolean
}
export const NewAddressRequestValidate = (o?: NewAddressRequest, opts: NewAddressRequestOptions = {}, path: string = 'NewAddressRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (!enumCheckAddressType(o.addressType)) return new Error(`${path}.addressType: is not a valid AddressType`)
    if (opts.addressType_CustomCheck && !opts.addressType_CustomCheck(o.addressType)) return new Error(`${path}.addressType: custom check failed`)

    return null
}

export type NewInvoiceResponse = {
    invoice: string
}
export const NewInvoiceResponseOptionalFields: [] = []
export type NewInvoiceResponseOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    invoice_CustomCheck?: (v: string) => boolean
}
export const NewInvoiceResponseValidate = (o?: NewInvoiceResponse, opts: NewInvoiceResponseOptions = {}, path: string = 'NewInvoiceResponse::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.invoice !== 'string') return new Error(`${path}.invoice: is not a string`)
    if (opts.invoice_CustomCheck && !opts.invoice_CustomCheck(o.invoice)) return new Error(`${path}.invoice: custom check failed`)

    return null
}

export type OpenChannelRequest = {
    destination: string
    fundingAmount: number
    pushAmount: number
    closeAddress: string
}
export const OpenChannelRequestOptionalFields: [] = []
export type OpenChannelRequestOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    destination_CustomCheck?: (v: string) => boolean
    fundingAmount_CustomCheck?: (v: number) => boolean
    pushAmount_CustomCheck?: (v: number) => boolean
    closeAddress_CustomCheck?: (v: string) => boolean
}
export const OpenChannelRequestValidate = (o?: OpenChannelRequest, opts: OpenChannelRequestOptions = {}, path: string = 'OpenChannelRequest::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.destination !== 'string') return new Error(`${path}.destination: is not a string`)
    if (opts.destination_CustomCheck && !opts.destination_CustomCheck(o.destination)) return new Error(`${path}.destination: custom check failed`)

    if (typeof o.fundingAmount !== 'number') return new Error(`${path}.fundingAmount: is not a number`)
    if (opts.fundingAmount_CustomCheck && !opts.fundingAmount_CustomCheck(o.fundingAmount)) return new Error(`${path}.fundingAmount: custom check failed`)

    if (typeof o.pushAmount !== 'number') return new Error(`${path}.pushAmount: is not a number`)
    if (opts.pushAmount_CustomCheck && !opts.pushAmount_CustomCheck(o.pushAmount)) return new Error(`${path}.pushAmount: custom check failed`)

    if (typeof o.closeAddress !== 'string') return new Error(`${path}.closeAddress: is not a string`)
    if (opts.closeAddress_CustomCheck && !opts.closeAddress_CustomCheck(o.closeAddress)) return new Error(`${path}.closeAddress: custom check failed`)

    return null
}

export type UserInfo = {
    userId: string
    balance: number
}
export const UserInfoOptionalFields: [] = []
export type UserInfoOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    userId_CustomCheck?: (v: string) => boolean
    balance_CustomCheck?: (v: number) => boolean
}
export const UserInfoValidate = (o?: UserInfo, opts: UserInfoOptions = {}, path: string = 'UserInfo::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.userId !== 'string') return new Error(`${path}.userId: is not a string`)
    if (opts.userId_CustomCheck && !opts.userId_CustomCheck(o.userId)) return new Error(`${path}.userId: custom check failed`)

    if (typeof o.balance !== 'number') return new Error(`${path}.balance: is not a number`)
    if (opts.balance_CustomCheck && !opts.balance_CustomCheck(o.balance)) return new Error(`${path}.balance: custom check failed`)

    return null
}

export type UserOperations = {
    fromIndex: number
    toIndex: number
    operations: UserOperation[]
}
export const UserOperationsOptionalFields: [] = []
export type UserOperationsOptions = OptionsBaseMessage & {
    checkOptionalsAreSet?: []
    fromIndex_CustomCheck?: (v: number) => boolean
    toIndex_CustomCheck?: (v: number) => boolean
    operations_ItemOptions?: UserOperationOptions
    operations_CustomCheck?: (v: UserOperation[]) => boolean
}
export const UserOperationsValidate = (o?: UserOperations, opts: UserOperationsOptions = {}, path: string = 'UserOperations::root.'): Error | null => {
    if (opts.checkOptionalsAreSet && opts.allOptionalsAreSet) return new Error(path + ': only one of checkOptionalsAreSet or allOptionalNonDefault can be set for each message')
    if (typeof o !== 'object' || o === null) return new Error(path + ': object is not an instance of an object or is null')

    if (typeof o.fromIndex !== 'number') return new Error(`${path}.fromIndex: is not a number`)
    if (opts.fromIndex_CustomCheck && !opts.fromIndex_CustomCheck(o.fromIndex)) return new Error(`${path}.fromIndex: custom check failed`)

    if (typeof o.toIndex !== 'number') return new Error(`${path}.toIndex: is not a number`)
    if (opts.toIndex_CustomCheck && !opts.toIndex_CustomCheck(o.toIndex)) return new Error(`${path}.toIndex: custom check failed`)

    if (!Array.isArray(o.operations)) return new Error(`${path}.operations: is not an array`)
    for (let index = 0; index < o.operations.length; index++) {
        const operationsErr = UserOperationValidate(o.operations[index], opts.operations_ItemOptions, `${path}.operations[${index}]`)
        if (operationsErr !== null) return operationsErr
    }
    if (opts.operations_CustomCheck && !opts.operations_CustomCheck(o.operations)) return new Error(`${path}.operations: custom check failed`)

    return null
}

