// This file was autogenerated from a .proto file, DO NOT EDIT!

import express, { Response } from 'express'
import * as Types from './types'
export type Logger = { log: (v: any) => void, error: (v: any) => void }
export type ServerOptions = {
    allowNotImplementedMethods?: number
    logger?: Logger
    throwErrors?: true
    NoAuthAuthGuard: (authorizationHeader?: string) => Promise<Types.NoAuthContext>
    GuestAuthGuard: (authorizationHeader?: string) => Promise<Types.GuestContext>
    AdminAuthGuard: (authorizationHeader?: string) => Promise<Types.AdminContext>
    encryptionCallback: (ctx: Types.AuthContext, body: any) => Promise<string>
}
const logErrorAndReturnResponse = (error: Error, response: string, res: Response, logger: Logger) => { logger.error(error.message || error); res.json({ status: 'ERROR', reason: response }) }
export default (methods: Types.ServerMethods, opts: ServerOptions) => {
    const logger = opts.logger || { log: console.log, error: console.error }
    const app = express()
    if (!opts.allowNotImplementedMethods && !methods.Health) throw new Error('method: Health is not implemented')
    app.get('/health', async (req, res) => {
        try {
            if (!methods.Health) throw new Error('method: Health is not implemented')
            const authContext = await opts.NoAuthAuthGuard(req.headers['authorization'])
            const query = req.query
            const params = req.params
            await methods.Health({ ...authContext, ...query, ...params })
            res.json({ status: 'OK' })
        } catch (ex) { const e = ex as any; logErrorAndReturnResponse(e, e.message || e, res, logger); if (opts.throwErrors) throw e }
    })
    if (!opts.allowNotImplementedMethods && !methods.EncryptionExchange) throw new Error('method: EncryptionExchange is not implemented')
    app.post('/api/encryption/exchange', async (req, res) => {
        try {
            if (!methods.EncryptionExchange) throw new Error('method: EncryptionExchange is not implemented')
            const authContext = await opts.NoAuthAuthGuard(req.headers['authorization'])
            const request = req.body
            const error = Types.EncryptionExchangeRequestValidate(request)
            if (error !== null) return logErrorAndReturnResponse(error, 'invalid request body', res, logger)
            const query = req.query
            const params = req.params
            await methods.EncryptionExchange({ ...authContext, ...query, ...params }, request)
            res.json({ status: 'OK' })
        } catch (ex) { const e = ex as any; logErrorAndReturnResponse(e, e.message || e, res, logger); if (opts.throwErrors) throw e }
    })
    if (!opts.allowNotImplementedMethods && !methods.LndGetInfo) throw new Error('method: LndGetInfo is not implemented')
    app.get('/api/lnd/getinfo', async (req, res) => {
        try {
            if (!methods.LndGetInfo) throw new Error('method: LndGetInfo is not implemented')
            const authContext = await opts.NoAuthAuthGuard(req.headers['authorization'])
            const query = req.query
            const params = req.params
            const response = await methods.LndGetInfo({ ...authContext, ...query, ...params })
            res.json({ status: 'OK', result: response })
        } catch (ex) { const e = ex as any; logErrorAndReturnResponse(e, e.message || e, res, logger); if (opts.throwErrors) throw e }
    })
    var server: { close: () => void } | undefined
    return {
        Close: () => { if (!server) { throw new Error('tried closing server before starting') } else server.close() },
        Listen: (port: number) => { server = app.listen(port, () => logger.log('Example app listening on port ' + port)) }
    }
}
