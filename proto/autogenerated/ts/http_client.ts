// This file was autogenerated from a .proto file, DO NOT EDIT!
import axios from 'axios'
import * as Types from './types'
export type ResultError = { status: 'ERROR', reason: string }

export type ClientParams = {
    baseUrl: string
    retrieveGuestAuth: () => Promise<string | null>
    retrieveUserAuth: () => Promise<string | null>
    retrieveAdminAuth: () => Promise<string | null>
    encryptCallback: (plain: any) => Promise<any>
    decryptCallback: (encrypted: any) => Promise<any>
    deviceId: string
}
export default (params: ClientParams) => ({
    Health: async (): Promise<ResultError | { status: 'OK' }> => {
        const auth = await params.retrieveGuestAuth()
        if (auth === null) throw new Error('retrieveGuestAuth() returned null')
        let finalRoute = '/api/health'
        const { data } = await axios.get(params.baseUrl + finalRoute, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            return data
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    EncryptionExchange: async (request: Types.EncryptionExchangeRequest): Promise<ResultError | { status: 'OK' }> => {
        const auth = await params.retrieveGuestAuth()
        if (auth === null) throw new Error('retrieveGuestAuth() returned null')
        let finalRoute = '/api/encryption/exchange'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            return data
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    LndGetInfo: async (request: Types.LndGetInfoRequest): Promise<ResultError | { status: 'OK', result: Types.LndGetInfoResponse }> => {
        const auth = await params.retrieveAdminAuth()
        if (auth === null) throw new Error('retrieveAdminAuth() returned null')
        let finalRoute = '/api/lnd/getinfo'
        const { data } = await axios.post(params.baseUrl + finalRoute, await params.encryptCallback(request), { headers: { 'authorization': auth, 'x-e2ee-device-id-x': params.deviceId  } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = await params.decryptCallback(data.result)
            const error = Types.LndGetInfoResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    AddUser: async (request: Types.AddUserRequest): Promise<ResultError | { status: 'OK', result: Types.AddUserResponse }> => {
        const auth = await params.retrieveGuestAuth()
        if (auth === null) throw new Error('retrieveGuestAuth() returned null')
        let finalRoute = '/api/user/add'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.AddUserResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    AuthUser: async (request: Types.AuthUserRequest): Promise<ResultError | { status: 'OK', result: Types.AuthUserResponse }> => {
        const auth = await params.retrieveGuestAuth()
        if (auth === null) throw new Error('retrieveGuestAuth() returned null')
        let finalRoute = '/api/user/auth'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.AuthUserResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    NewAddress: async (): Promise<ResultError | { status: 'OK', result: Types.NewAddressResponse }> => {
        const auth = await params.retrieveUserAuth()
        if (auth === null) throw new Error('retrieveUserAuth() returned null')
        let finalRoute = '/api/user/chain/new'
        const { data } = await axios.post(params.baseUrl + finalRoute, {}, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.NewAddressResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    PayAddress: async (request: Types.PayAddressRequest): Promise<ResultError | { status: 'OK', result: Types.PayAddressResponse }> => {
        const auth = await params.retrieveUserAuth()
        if (auth === null) throw new Error('retrieveUserAuth() returned null')
        let finalRoute = '/api/user/chain/pay'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.PayAddressResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    NewInvoice: async (request: Types.NewInvoiceRequest): Promise<ResultError | { status: 'OK', result: Types.NewInvoiceResponse }> => {
        const auth = await params.retrieveUserAuth()
        if (auth === null) throw new Error('retrieveUserAuth() returned null')
        let finalRoute = '/api/user/invoice/new'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.NewInvoiceResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    PayInvoice: async (request: Types.PayInvoiceRequest): Promise<ResultError | { status: 'OK', result: Types.PayInvoiceResponse }> => {
        const auth = await params.retrieveUserAuth()
        if (auth === null) throw new Error('retrieveUserAuth() returned null')
        let finalRoute = '/api/user/invoice/pay'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.PayInvoiceResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    OpenChannel: async (request: Types.OpenChannelRequest): Promise<ResultError | { status: 'OK', result: Types.OpenChannelResponse }> => {
        const auth = await params.retrieveUserAuth()
        if (auth === null) throw new Error('retrieveUserAuth() returned null')
        let finalRoute = '/api/user/open/channel'
        const { data } = await axios.post(params.baseUrl + finalRoute, request, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.OpenChannelResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
    GetOpenChannelLNURL: async (): Promise<ResultError | { status: 'OK', result: Types.GetOpenChannelLNURLResponse }> => {
        const auth = await params.retrieveUserAuth()
        if (auth === null) throw new Error('retrieveUserAuth() returned null')
        let finalRoute = '/api/user/lnurl_channel'
        const { data } = await axios.post(params.baseUrl + finalRoute, {}, { headers: { 'authorization': auth } })
        if (data.status === 'ERROR' && typeof data.reason === 'string') return data
        if (data.status === 'OK') { 
            const result = data.result
            const error = Types.GetOpenChannelLNURLResponseValidate(result)
            if (error === null) { return { status: 'OK', result: result } } else return { status: 'ERROR', reason: error.message }
        }
        return { status: 'ERROR', reason: 'invalid response' }
    },
})
